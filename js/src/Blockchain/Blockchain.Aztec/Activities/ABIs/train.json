{
  "file_map": {
    "100": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::utils::get_params_len_quote;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it's possible to have collisions. With the following check, we ensure it doesn't happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f\"Public function selector collision detected between functions '{fn_name}' and '{existing_fn}'\",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let params_len_quote = get_params_len_quote(parameters);\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $params_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $params_len_quote);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[external(\"public\")]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "104": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "//! Stubs are auto-generated wrapper functions that provide an ergonomic interface for cross-contract calls.\n//! Instead of manually serializing arguments and creating call interfaces, stubs allow natural syntax, e.g. for\n//! enqueuing calls to public functions:\n//!\n//!   ExternalContract.at(address).some_method(arg1, arg2).enqueue()\n\nuse crate::macros::utils::{AsStrQuote, compute_fn_selector, is_fn_view};\nuse super::stub_registry;\nuse protocol_types::meta::utils::derive_serialization_quotes;\nuse std::meta::unquote;\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\npub comptime fn register_private_fn_stub(f: FunctionDefinition) {\n    let stub = if is_fn_view(f) {\n        create_private_static_stub(f)\n    } else {\n        create_private_stub(f)\n    };\n    stub_registry::register(f.module(), stub);\n}\n\npub comptime fn register_public_fn_stub(f: FunctionDefinition) {\n    let stub = if is_fn_view(f) {\n        create_public_static_stub(f)\n    } else {\n        create_public_stub(f)\n    };\n    stub_registry::register(f.module(), stub);\n}\n\npub comptime fn register_utility_fn_stub(f: FunctionDefinition) {\n    let stub = create_utility_stub(f);\n    stub_registry::register(f.module(), stub);\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    // Dear privacy adventurer,\n    // Chances are, you've command+clicked on the name of an external function\n    // call -- seeking to view that function -- only to end up here.\n    // Here's an explanation:\n    // The external contract that you're calling was likely annotated with the `#[aztec]`\n    // annotation -- as all good aztec contracts are. This triggers a macro which generates\n    // a \"contract interface\" for that contract, which is effectively a pretty interface\n    // that gives natural contract calling semantics:\n    //\n    // `MyImportedContract.at(some_address).my_method(arg1, arg2).enqueue();\n    //\n    // Unfortunately, the usage of macros makes it a bit of a black box.\n    // To actually view the target function, you could instead command+click on\n    // `MyImportedContract`, or you can just manually search it.\n    // If you want to view the noir code that gets generated by this macro, you can\n    // use `nargo expand` on your contract.\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    let (serialized_args_array_construction, _, serialized_args_array_name) =\n        derive_serialization_quotes(fn_parameters, false);\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name,\n        fn_name_str, fn_name_len, fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n\ncomptime fn create_utility_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, serialized_args_array_name, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::UtilityCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $serialized_args_array_name,\n            )\n        }\n    }\n}\n"
    },
    "105": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "108": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{\n        auth_registry::AUTHORIZE_ONCE_REGISTRY,\n        call_interface_stubs::{\n            register_private_fn_stub, register_public_fn_stub, register_utility_fn_stub,\n        },\n    },\n    notes::NOTES,\n    utils::{\n        fn_has_authorize_once, fn_has_noinitcheck, is_fn_contract_library_method, is_fn_external,\n        is_fn_initializer, is_fn_internal, is_fn_test, is_fn_view, modify_fn_body,\n        module_has_initializer, module_has_storage,\n    },\n};\nuse dep::protocol_types::meta::utils::derive_serialization_quotes;\nuse std::meta::{ctstring::AsCtString, type_of};\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) {\n    register_private_fn_stub(f);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    let (args_serialization, _, serialized_args_name) =\n        derive_serialization_quotes(original_params, false);\n\n    let context_creation = quote {\n        $args_serialization\n        let args_hash = dep::aztec::hash::hash_args_array($serialized_args_name);\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, args_hash);\n    };\n\n    let function_name = f.name();\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        let assertion_message = f\"Function {function_name} can only be called internally\";\n        quote { assert(context.msg_sender().unwrap() == context.this_address(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let assertion_message =\n            f\"Function {function_name} can only be called statically\".as_ctstring().as_quoted_str();\n        quote { assert(context.inputs.call_context.is_static_call, $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_private(context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_private(&mut context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_private(&mut context); }\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any. Note that the message\n    // discovery call syncs private events as well. We do not sync those here if there are no notes because we don't\n    // have an API that would access events from private functions.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, true)\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is serialized and hashed before being passed to the context.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n\n        let (return_serialization, _, serialized_return_name) =\n            derive_serialization_quotes([(return_value_var_name, return_value_type)], false);\n\n        body = body_without_return;\n\n        quote {\n            $return_value_assignment\n            $return_serialization\n            context.set_return_hash($serialized_return_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) {\n    register_public_fn_stub(f);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n\n    let args_len_quote = if original_params.len() == 0 {\n        // If the function has no parameters, we set the args_len to 0.\n        quote { 0 }\n    } else {\n        // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n        original_params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n            <$param_type as $crate::protocol_types::traits::Serialize>::N\n        }\n            })\n            .join(quote {+})\n    };\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $args_len_quote);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    let name = f.name();\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        let assertion_message = f\"Function {name} can only be called internally\";\n        quote { assert(context.msg_sender().unwrap() == context.this_address(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let name = f.name();\n        let assertion_message =\n            f\"Function {name} can only be called statically\".as_ctstring().as_quoted_str();\n        quote { assert(context.is_static_call(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_public(context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_public(&mut context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_public(&mut context); }\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, false)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    register_utility_fn_stub(f);\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage(f.module()) {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process or they may be used to sync private events from TypeScript\n    // (`sync_private_state` function gets invoked by PXE::getPrivateEvents function).\n    let message_discovery_call = create_message_discovery_call();\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Injects an authwit verification check of the form:\n/// ```\n///   if (!from.eq(context.msg_sender().unwrap())) {\n///         assert_current_call_valid_authwit::<N>(&mut context, from);\n///     } else {\n///         assert(authwit_nonce, \"Invalid authwit nonce. When 'from' and 'msg_sender' are the same, authwit_nonce must be zero\");\n///     }\n/// ```\n/// where `from` and `authwit_nonce` are the names of the parameters that are expected to be present in the function definition.\n/// This check is injected by the `#[authorize_once(\"from_arg_name\", \"nonce_arg_name\")]`, which allows the user to define\n/// which parameters to use.\n///\n/// # Arguments\n/// * `f` - The function definition to inject the authwit verification check into. The function must have parameters\n///         matching the names specified in the `#[authorize_once]` attribute.\n/// * `is_private` - Whether the function is a private function (`true`) or a public function (`false`). This determines\n///                  which authwit verification method to use: `assert_current_call_valid_authwit` for private functions\n///                  or `assert_current_call_valid_authwit_public` for public functions.\npub(crate) comptime fn create_authorize_once_check(\n    f: FunctionDefinition,\n    is_private: bool,\n) -> Quoted {\n    let maybe_authorize_once_args = AUTHORIZE_ONCE_REGISTRY.get(f);\n    let authorize_once_args = if maybe_authorize_once_args.is_some() {\n        maybe_authorize_once_args.unwrap()\n    } else {\n        // We need to for authorize_once to have already executed so that we can retrieve its params - this depends on\n        // the order in which the attributes are applied.\n        panic(\n            f\"Functions marked with #[authorize_once] must have the #[external(\\\"private\\\")] or #[external(\\\"public\\\")] attribute placed last\",\n        )\n    };\n\n    let (from_arg_name, nonce_arg_name) = authorize_once_args;\n    let name: Quoted = f.name();\n\n    let from_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{from_arg_name}\".quoted_contents());\n    let (from_arg_name_quoted, from_arg_type) = if from_arg_candidates.len() == 1 {\n        from_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {from_arg_name} parameter. Please specify which one to use in #[authorize_once(\\\"...\\\", \\\"authwit_nonce\\\")]\",\n        )\n    };\n    if from_arg_type\n        != quote { dep::protocol_types::address::aztec_address::AztecAddress }.as_type() {\n        panic(\n            f\"Argument {from_arg_name_quoted} in function {name} must be of type AztecAddress, but is of type {from_arg_type}\",\n        )\n    }\n\n    let nonce_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{nonce_arg_name}\".quoted_contents());\n    let (nonce_arg_name_quoted, nonce_arg_type) = if nonce_arg_candidates.len() == 1 {\n        nonce_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {nonce_arg_name}. Please specify which one to use in #[authorize_once(\\\"from\\\", \\\"...\\\")]\",\n        )\n    };\n    if nonce_arg_type != quote { Field }.as_type() {\n        panic(\n            f\"Argument {nonce_arg_name_quoted} in function {name} must be of type Field, but is of type {nonce_arg_type}\",\n        );\n    }\n\n    let nonce_check_quote = f\"{nonce_arg_name_quoted} == 0\".quoted_contents();\n\n    let fn_call = if is_private {\n        // At this point, the original args of the fn have already been altered by the macro\n        // to include PrivateContextInputs, so we need to adjust the args_len accordingly.\n        let args_len = f.parameters().len() - 1;\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit::<$args_len> }\n    } else {\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit_public }\n    };\n    let invalid_nonce_message = f\"Invalid authwit nonce. When '{from_arg_name}' and 'msg_sender' are the same, '{nonce_arg_name}' must be zero\"\n        .as_ctstring()\n        .as_quoted_str();\n    quote {         \n        if (!$from_arg_name_quoted.eq(context.msg_sender().unwrap())) {\n            $fn_call(&mut context, $from_arg_name_quoted);\n        } else {\n            assert($nonce_check_quote, $invalid_nonce_message);\n        }\n    }\n}\n\n/// Checks if each function in the module is marked with either #[external(...)], #[contract_library_method], or #[test].\n/// Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_external(f) & !is_fn_contract_library_method(f) & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[external(...)], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "110": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::note::note_getter_options::PropertySelector;\nuse std::{collections::bounded_vec::BoundedVec, meta::{ctstring::AsCtString, type_of}};\n\n/// Maximum number of note types within 1 contract.\ncomptime global MAX_NOTE_TYPES: u32 = 128;\n\n/// A BoundedVec containing all the note types within this contract.\npub comptime mut global NOTES: BoundedVec<Type, MAX_NOTE_TYPES> = BoundedVec::new();\n\ncomptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < MAX_NOTE_TYPES,\n        f\"A contract can contain at most {MAX_NOTE_TYPES} different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_type_impl(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n    let typ = s.as_type();\n    let note_type_name: str<_> = f\"{name}\".as_ctstring().as_quoted_str!();\n    let max_note_packed_len = crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                // This static assertion ensures the note's packed length doesn't exceed the maximum allowed size.\n                // While this check would ideally live in the Packable trait implementation, we place it here since\n                // this function is always generated by our macros and the Packable trait implementation is not.\n                // Note: We set the note type name and max packed length as local variables because injecting them\n                // directly into the error message doesn't work.\n                let note_type_name = $note_type_name;\n                let max_note_packed_len: u32 = $max_note_packed_len; // Casting to u32 to avoid the value to be printed in hex.\n                let note_packed_len = <$typ as Packable>::N;\n                std::static_assert(note_packed_len <= $max_note_packed_len, f\"{note_type_name} has a packed length of {note_packed_len} fields, which exceeds the maximum allowed length of {max_note_packed_len} fields\");\n\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullification: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullification: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::traits::Packable::pack(self).concat( [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::context::PrivateContext,\n                note_hash_for_nullification: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullification, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullification: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullification, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _, _)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates the core note functionality for a struct:\n///\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - NoteHash trait implementation: Handles note hash and nullifier computation\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Have an `owner` field\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Generated Code\n///\n/// For detailed documentation on the generated implementations, see:\n/// - `generate_note_properties()`\n/// - `generate_note_type_impl()`\n/// - `generate_note_hash_trait_impl()`\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n\n    quote {\n        $note_properties\n        $note_type_impl\n        $note_hash_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// Unlike the `#[note]` macro, there is no requirement for an `owner` field.\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_type_id = get_next_note_type_id();\n    let note_properties = generate_note_properties(s);\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_type_impl\n    }\n}\n\n/// Asserts that the given note implements the `Packable` trait.\n///\n/// We require that notes have the `Packable` trait implemented because it is used when emitting a note in a log or as\n/// an offchain message.\ncomptime fn assert_has_packable(note: TypeDefinition) {\n    let packable_constraint =\n        quote { crate::protocol_types::traits::Packable }.as_trait_constraint();\n    let note_name = note.name();\n\n    assert(\n        note.as_type().implements(packable_constraint),\n        f\"{note_name} does not implement Packable trait. Either implement it manually or place #[derive(Packable)] on the note struct before #[note] macro invocation.\",\n    );\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    let note_name = note.name();\n\n    assert(\n        has_owner,\n        f\"{note_name} does not have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "111": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract should have this macro (or `storage_no_init`) applied to it, and the\n/// struct has to be called 'Storage'.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    let struct_name = s.name();\n    if struct_name != quote { Storage } {\n        panic(\n            f\"The #[storage] macro can only be applied to a struct with name 'Storage', got '{struct_name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage_no_init\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ, _) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot });\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields = storage_layout_fields.push_back(\n            quote { pub $name: dep::aztec::state_vars::storage::Storable },\n        );\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::state_vars::storage::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract can have this macro (or storage_no_init) applied to it, and the struct\n/// has to be called 'Storage'.\npub comptime fn storage_no_init(s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n\n    // We do need to make sure that the type is called Storage, since we'll do `Storage::init` later on.\n\n    if s.name() != quote { Storage } {\n        let name = s.name();\n        panic(\n            f\"The #[storage_no_init] macro can only be applied to a struct with name 'Storage', got '{name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(typ: Type, slot: Quoted) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    let constructor = if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot });\n\n        quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }\n    } else {\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        quote { $struct_name::new(context, $slot)}\n    };\n\n    (constructor, get_storage_size(typ))\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "113": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{\n            private_notes::MAX_NOTE_PACKED_LEN, process_message::process_message_ciphertext,\n        },\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, note_nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullification);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\npub type ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private logs are downloaded and inspected to find new private\n/// notes, partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Note that the state is synchronized up to the latest block synchronized by PXE. That should be close to the chain\n/// tip as block synchronization is performed before contract function simulation is done.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        process_message_ciphertext(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n"
    },
    "114": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullification,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullification = compute_note_hash_for_nullification(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullification);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(\n            compute_note_hash_for_nullification(retrieved_note, STORAGE_SLOT),\n        );\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "115": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "116": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/messages/discovery/private_events.nr",
      "source": "use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator_bounded_vec, traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n"
    },
    "117": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            storage_slot,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "118": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/messages/discovery/process_message.nr",
      "source": "use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::{decode_message, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN},\n    encryption::{aes128::AES128, message_encryption::MessageEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn process_message_ciphertext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    process_message_plaintext(\n        contract_address,\n        compute_note_hash_and_nullifier,\n        AES128::decrypt(message_ciphertext, message_context.recipient),\n        message_context,\n    );\n}\n\npub unconstrained fn process_message_plaintext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_plaintext: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "119": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::utils::array;\nuse protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// We reassign to the constant here to communicate the distinction between a log and a message. In Aztec.nr, unlike in\n// protocol circuits, we have a concept of a message that can be emitted either as a private log or as an offchain\n// message. Message is a piece of data that is to be eventually delivered to a contract via the `process_message(...)`\n// utility function function that is injected by the #[aztec] macro.\npub global MESSAGE_CIPHERTEXT_LEN: u32 = PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// TODO(#12750): The global variables below should not be here as they are AES128 specific.\n// ciphertext_length (2) + 14 bytes pkcs#7 AES padding.\npub(crate) global HEADER_CIPHERTEXT_SIZE_IN_BYTES: u32 = 16;\n\npub global EPH_PK_X_SIZE_IN_FIELDS: u32 = 1;\npub global EPH_PK_SIGN_BYTE_SIZE_IN_BYTES: u32 = 1;\n\n// (17 - 1) * 31 - 16 - 1 = 479\nglobal MESSAGE_PLAINTEXT_SIZE_IN_BYTES: u32 = (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS)\n    * 31\n    - HEADER_CIPHERTEXT_SIZE_IN_BYTES\n    - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES;\n// Each field of the original note log was serialized to 32 bytes. Below we convert the bytes back to fields.\n// 479 / 32 = 15\npub global MESSAGE_PLAINTEXT_LEN: u32 = MESSAGE_PLAINTEXT_SIZE_IN_BYTES / 32;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MESSAGE_PLAINTEXT_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u16 {\n    fn from(value: u8) -> u16 {\n        value as u16\n    }\n}\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u16> for u32 {\n    fn from(value: u16) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u16> for u64 {\n    fn from(value: u16) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u16> for u128 {\n    fn from(value: u16) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u16> for Field {\n    fn from(value: u16) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i16 {\n    fn from(value: i8) -> i16 {\n        value as i16\n    }\n}\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i16> for i32 {\n    fn from(value: i16) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i16> for i64 {\n    fn from(value: i16) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u16 {\n    fn from(value: bool) -> u16 {\n        value as u16\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for u128 {\n    fn from(value: bool) -> u128 {\n        value as u128\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i16 {\n    fn from(value: bool) -> i16 {\n        value as i16\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            let body = if type1 == type2 {\n                quote { self }\n            } else if type1 == quote { bool } {\n                quote { self != 0 }\n            } else {\n                quote { self as $type1 }\n            };\n\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n            );\n        }\n    }\n\n    let u_types =\n        [quote { bool }, quote { u8 }, quote { u16 }, quote { u32 }, quote { u64 }, quote { u128 }];\n\n    for type2 in u_types {\n        let body = quote { self as Field };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<Field> for $type2 {\n                    fn as_(self) -> Field {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    for type1 in u_types {\n        let body = if type1 == quote { bool } {\n            quote { self != 0 }\n        } else {\n            quote { self as $type1 }\n        };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<$type1> for Field {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    impls.join(quote {})\n}\n"
    },
    "120": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encoding::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN,\n        },\n        encryption::message_encryption::MessageEncryption,\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__message_bytes__from_PT,\n            get_arr_of_size__message_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\n/**\n * Computes N close-to-uniformly-random 256 bits from a given ECDH shared_secret.\n *\n * NEVER re-use the same iv and sym_key.\n * DO NOT call this function more than once with the same shared_secret.\n *\n * This function is only known to be safe if shared_secret is computed by combining a \n * random ephemeral key with an address point. See big comment within the body of the function.\n * See big comment within the body of the function.\n */\nfn extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [[u8; 32]; N] {\n    /*\n     * Unsafe because of https://eprint.iacr.org/2010/264.pdf Page 13, Lemma 2 (and the * two paragraphs below it).\n     *\n     * If you call this function, you need to be careful and aware of how the arg\n     * `shared_secret` has been derived.\n     *\n     * The paper says that the way you derive aes keys and IVs should be fine with poseidon2\n     * (modelled as a RO), as long as you _don't_ use Poseidon2 as a PRG to generate the * two exponents x & y which multiply to the shared secret S:\n     *\n     * S = [x*y]*G.\n     *\n     * (Otherwise, you would have to \"key\" poseidon2, i.e. generate a uniformly string K\n     * which can be public and compute Hash(x) as poseidon(K,x)).\n     * In that lemma, k would be 2*254=508, and m would be the number of points on the * grumpkin curve (which is close to r according to the Hasse bound).\n     *\n     * Our shared secret S is [esk * address_sk] * G, and the question is: * Can we compute hash(S) using poseidon2 instead of sha256?\n     *\n     * Well, esk is random and not generated with poseidon2, so that's good.\n     * What about address_sk?\n     * Well, address_sk = poseidon2(stuff) + ivsk, so there was some\n     * discussion about whether address_sk is independent of poseidon2.\n     * Given that ivsk is random and independent of poseidon2, the address_sk is also\n     * independent of poseidon2.\n     *\n     * Tl;dr: we believe it's safe to hash S = [esk * address_sk] * G using poseidon2,\n     * in order to derive a symmetric key.\n     *\n     * If you're calling this function for a differently-derived `shared_secret`, be\n     * careful.\n     *\n     */\n\n    /* The output of this function needs to be 32 random bytes.\n     * A single field won't give us 32 bytes of entropy.\n     * So we compute two \"random\" fields, by poseidon-hashing with two different\n     * generators.\n     * We then extract the last 16 (big endian) bytes of each \"random\" field.\n     * Note: we use to_be_bytes because it's slightly more efficient. But we have to\n     * be careful not to take bytes from the \"big end\", because the \"big\" byte is\n     * not uniformly random over the byte: it only has < 6 bits of randomness, because\n     * it's the big end of a 254-bit field element.\n     */\n\n    let mut all_bytes: [[u8; 32]; N] = std::mem::zeroed();\n    // We restrict N to be < 2^8, because of how we compute the domain separator\n    // from k below (where k <= N must be 8 bits). In practice, it's extremely\n    // unlikely that an app will want to compute >= 256 ciphertexts.\n    std::static_assert(N < 256, \"N too large\");\n    for k in 0..N {\n        // We augment the domain separator with the loop index, so that we can\n        // generate N lots of randomness.\n        let k_shift = (k as u16 << 8);\n        let separator_1 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY as u16;\n        let separator_2 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY_2 as u16;\n\n        let rand1: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_1);\n        let rand2: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_2);\n\n        let rand1_bytes: [u8; 32] = rand1.to_be_bytes();\n        let rand2_bytes: [u8; 32] = rand2.to_be_bytes();\n\n        let mut bytes: [u8; 32] = [0; 32];\n        for i in 0..16 {\n            // We take bytes from the \"little end\" of the be-bytes arrays:\n            let j = 32 - i - 1;\n            bytes[i] = rand1_bytes[j];\n            bytes[16 + i] = rand2_bytes[j];\n        }\n\n        all_bytes[k] = bytes;\n    }\n\n    all_bytes\n}\n\nfn derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits<let N: u32>(\n    many_random_256_bits: [[u8; 32]; N],\n) -> [([u8; 16], [u8; 16]); N] {\n    // Many (sym_key, iv) pairs:\n    let mut many_pairs: [([u8; 16], [u8; 16]); N] = std::mem::zeroed();\n    for k in 0..N {\n        let random_256_bits = many_random_256_bits[k];\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n        for i in 0..16 {\n            sym_key[i] = random_256_bits[i];\n            iv[i] = random_256_bits[i + 16];\n        }\n        many_pairs[k] = (sym_key, iv);\n    }\n\n    many_pairs\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [([u8; 16], [u8; 16]); N] {\n    let many_random_256_bits: [[u8; 32]; N] = extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe(\n        shared_secret,\n    );\n\n    derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits(many_random_256_bits)\n}\n\npub struct AES128 {}\n\nimpl MessageEncryption for AES128 {\n    fn encrypt<let PlaintextLen: u32>(\n        plaintext: [Field; PlaintextLen],\n        recipient: AztecAddress,\n    ) -> [Field; MESSAGE_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the message in `do_process_message`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        // TODO (#17158): Currently we unwrap the Option returned by derive_ecdh_shared_secret_using_aztec_address.\n        // We need to handle the case where the ephemeral public key is invalid to prevent potential DoS vectors.\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient).unwrap();\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        // It is safe to call the `unsafe` function here, because we know the `shared_secret`\n        // was derived using an AztecAddress (the recipient). See the block comment\n        // at the start of this unsafe target function for more info.\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, body_iv, body_sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        std::static_assert(\n            ciphertext_bytes.len() == 16 * (1 + (PlaintextLen * 32) / 16),\n            \"unexpected ciphertext length\",\n        );\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, header_iv, header_sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        std::static_assert(\n            header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES,\n            \"unexpected ciphertext header length\",\n        );\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut message_bytes_padding_to_mult_31 =\n            get_arr_of_size__message_bytes_padding__from_PT::<PlaintextLen * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        message_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut message_bytes = get_arr_of_size__message_bytes__from_PT::<PlaintextLen * 32>();\n\n        std::static_assert(\n            message_bytes.len() % 31 == 0,\n            \"Unexpected error: message_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        message_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            message_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            message_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..message_bytes_padding_to_mult_31.len() {\n            message_bytes[offset + i] = message_bytes_padding_to_mult_31[i];\n        }\n        offset += message_bytes_padding_to_mult_31.len();\n\n        // Ideally we would be able to have a static assert where we check that the offset would be such that we've\n        // written to the entire log_bytes array, but we cannot since Noir does not treat the offset as a comptime\n        // value (despite the values that it goes through being known at each stage). We instead check that the\n        // computation used to obtain the offset computes the expected value (which we _can_ do in a static check), and\n        // then add a cheap runtime check to also validate that the offset matches this.\n        std::static_assert(\n            1\n                + header_ciphertext_bytes.len()\n                + ciphertext_bytes.len()\n                + message_bytes_padding_to_mult_31.len()\n                == message_bytes.len(),\n            \"unexpected message length\",\n        );\n        assert(offset == message_bytes.len(), \"unexpected encrypted message length\");\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make messages produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let message_bytes_as_fields = bytes_to_fields(message_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final message\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; MESSAGE_CIPHERTEXT_LEN] = [0; MESSAGE_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..message_bytes_as_fields.len() {\n            ciphertext[offset + i] = message_bytes_as_fields[i];\n        }\n        offset += message_bytes_as_fields.len();\n\n        for i in offset..MESSAGE_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the message\n            // (all the \"real\" message fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the message to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt(\n        ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, MESSAGE_PLAINTEXT_LEN> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, MESSAGE_CIPHERTEXT_LEN, MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret\n        // TODO(#17158): handle invalid ephemeral keys when decrypting to prevent DoS vectors\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk.unwrap());\n\n        // Derive symmetric keys:\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with messages with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext =\n            aes128_decrypt_oracle(header_ciphertext_bvec, header_iv, header_sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, body_iv, body_sym_key);\n\n        // Each field of the original note message was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::{\n            encoding::MESSAGE_PLAINTEXT_LEN, encryption::message_encryption::MessageEncryption,\n        },\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{address::AztecAddress, traits::FromField};\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt() {\n        let env = TestEnvironment::new();\n\n        // Message decryption requires oracles that are only available during private execution\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n\n            let recipient = AztecAddress::from_field(\n                0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n            );\n\n            // Mock random values for deterministic test\n            let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(eph_sk).times(1);\n\n            let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(randomness).times(1000000);\n\n            let _ = OracleMock::mock(\"privateGetNextAppTagAsSender\").returns(42);\n\n            // Encrypt the message\n            let encrypted_message = BoundedVec::from_array(AES128::encrypt(plaintext, recipient));\n\n            // Mock shared secret for deterministic test\n            let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n                EmbeddedCurveScalar::from_field(eph_sk),\n                recipient,\n            );\n\n            let _ = OracleMock::mock(\"utilityGetSharedSecret\").returns(shared_secret.unwrap());\n\n            // Decrypt the message\n            let decrypted = AES128::decrypt(encrypted_message, recipient);\n\n            // The decryption function spits out a BoundedVec because it's designed to work with messages with unknown length\n            // at compile time. For this reason we need to convert the original input to a BoundedVec.\n            let plaintext_bvec = BoundedVec::<Field, MESSAGE_PLAINTEXT_LEN>::from_array(plaintext);\n\n            // Verify decryption matches original plaintext\n            assert_eq(\n                decrypted,\n                plaintext_bvec,\n                \"Decrypted bytes should match original plaintext\",\n            );\n\n            // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n            // static methods of the struct).\n            let _ = AES128 {};\n        });\n    }\n}\n"
    },
    "128": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/messages/logs/utils.nr",
      "source": "use crate::oracle::notes::{get_next_app_tag_as_sender, get_sender_for_tags};\nuse dep::protocol_types::address::AztecAddress;\n\n// TODO(#14565): Add constrained tagging\npub(crate) fn prefix_with_tag<let L: u32>(\n    log_without_tag: [Field; L],\n    recipient: AztecAddress,\n) -> [Field; L + 1] {\n    // Safety: we assume that the sender wants for the recipient to find the tagged note, and therefore that they will\n    // cooperate and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the\n    // note automatically.\n    let tag = unsafe {\n        let sender = get_sender_for_tags().expect(\n            f\"Sender for tags is not set when emitting a private log. Set it by calling `set_sender_for_tags(...)`.\",\n        );\n        get_next_app_tag_as_sender(sender, recipient)\n    };\n\n    let mut log_with_tag = [0; L + 1];\n\n    log_with_tag[0] = tag;\n    for i in 0..log_without_tag.len() {\n        log_with_tag[i + 1] = log_without_tag[i];\n    }\n\n    log_with_tag\n}\n\nmod test {\n    use super::prefix_with_tag;\n    use protocol_types::{address::AztecAddress, traits::FromField};\n    use std::test::OracleMock;\n\n    #[test(should_fail)]\n    unconstrained fn no_tag_sender() {\n        let recipient = AztecAddress::from_field(2);\n\n        let expected_tag = 42;\n\n        // Mock the tagging oracles - note privateGetSenderForTags returns none\n        let _ = OracleMock::mock(\"privateGetSenderForTags\").returns(Option::<AztecAddress>::none());\n        let _ = OracleMock::mock(\"privateGetNextAppTagAsSender\").returns(expected_tag);\n\n        let log_without_tag = [1, 2, 3];\n        let _ = prefix_with_tag(log_without_tag, recipient);\n    }\n\n    #[test]\n    unconstrained fn prefixing_with_tag() {\n        let sender = AztecAddress::from_field(1);\n        let recipient = AztecAddress::from_field(2);\n\n        let expected_tag = 42;\n\n        // Mock the tagging oracles\n        let _ = OracleMock::mock(\"privateGetSenderForTags\").returns(Option::some(sender));\n        let _ = OracleMock::mock(\"privateGetNextAppTagAsSender\").returns(expected_tag);\n\n        let log_without_tag = [1, 2, 3];\n        let log_with_tag = prefix_with_tag(log_without_tag, recipient);\n\n        let expected_result = [expected_tag, 1, 2, 3];\n\n        // Check tag was prefixed correctly\n        assert_eq(log_with_tag, expected_result, \"Tag was not prefixed correctly\");\n    }\n}\n"
    },
    "137": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/messages/processing/mod.nr",
      "source": "pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            storage_slot,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n"
    },
    "142": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_interface::{NoteHash, NoteType},\n    retrieved_note::RetrievedNote,\n    utils::{\n        compute_note_hash_for_nullification_from_read_request, compute_note_hash_for_read_request,\n    },\n};\nuse crate::oracle::notes::notify_created_note;\nuse protocol_types::traits::Packable;\n\npub fn create_note<Note>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteType + NoteHash + Packable,\n{\n    let note_hash_counter = context.side_effect_counter;\n\n    let note_hash = note.compute_note_hash(storage_slot);\n\n    let packed_note = Note::pack(note);\n    notify_created_note(\n        storage_slot,\n        Note::get_id(),\n        packed_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(note, storage_slot, note_hash_counter, context)\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n\n    destroy_note_unsafe(context, retrieved_note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullification = compute_note_hash_for_nullification_from_read_request(\n        retrieved_note,\n        note_hash_for_read_request,\n    );\n    let nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullification);\n\n    let note_hash = if retrieved_note.metadata.is_settled() {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifying so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullification\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, note_hash)\n}\n"
    },
    "144": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    messages::{\n        encryption::{aes128::AES128, message_encryption::MessageEncryption},\n        logs::{note::private_note_to_message_plaintext, utils::prefix_with_tag},\n        message_delivery::MessageDelivery,\n        offchain_messages::emit_offchain_message,\n    },\n    note::note_interface::NoteType,\n    utils::remove_constraints::remove_constraints_if,\n};\nuse protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct NoteEmissionContent<Note> {\n    // The struct fields are exposed only because of tests.\n    pub note: Note,\n    pub storage_slot: Field,\n    pub note_hash_counter: u32, // a note_hash_counter of 0 means settled\n}\n\n/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub content: NoteEmissionContent<Note>,\n\n    // NoteEmission is expected to be constructed when a note is created, which means that the `context` object will be\n    // in scope. By storing a reference to it inside this object we remove the need for its methods to receive it,\n    // resulting in a cleaner end-user API.\n    context: &mut PrivateContext,\n}\n\nimpl<Note> NoteEmission<Note>\nwhere\n    Note: NoteType + Packable,\n{\n    pub fn new(\n        note: Note,\n        storage_slot: Field,\n        note_hash_counter: u32,\n        context: &mut PrivateContext,\n    ) -> Self {\n        Self { content: NoteEmissionContent { note, storage_slot, note_hash_counter }, context }\n    }\n\n    /// Emits a note that can be delivered either via private logs or offchain messages, with configurable encryption and\n    /// tagging constraints.\n    ///\n    /// # Arguments\n    /// * `self` - The note emission to emit\n    /// * `recipient` - The address that should receive this note\n    /// * `delivery_mode` - Controls encryption, tagging, and delivery constraints. Must be a compile-time constant.\n    ///   See `MessageDeliveryEnum` for details on the available modes.\n    pub fn emit(self, recipient: AztecAddress, delivery_mode: u8) {\n        // This function relies on `delivery_mode` being a constant in order to reduce circuit constraints when unconstrained\n        // usage is requested. If `delivery_mode` were a runtime value then performance would suffer.\n        assert_constant(delivery_mode);\n\n        // The following maps out the 3 dimensions across which we configure message delivery.\n        let constrained_encryption = delivery_mode == MessageDelivery.CONSTRAINED_ONCHAIN;\n        let emit_as_offchain_message = delivery_mode == MessageDelivery.UNCONSTRAINED_OFFCHAIN;\n        // TODO(#14565): Add constrained tagging\n        let _constrained_tagging = delivery_mode == MessageDelivery.CONSTRAINED_ONCHAIN;\n\n        let ciphertext = remove_constraints_if(\n            !constrained_encryption,\n            || AES128::encrypt(\n                private_note_to_message_plaintext(self.content.note, self.content.storage_slot),\n                recipient,\n            ),\n        );\n\n        if emit_as_offchain_message {\n            emit_offchain_message(ciphertext, recipient);\n        } else {\n            // Safety: Currently unsafe. See description of CONSTRAINED_ONCHAIN in MessageDeliveryEnum.\n            // TODO(#14565): Implement proper constrained tag prefixing to make this truly CONSTRAINED_ONCHAIN\n            let log_content = prefix_with_tag(ciphertext, recipient);\n\n            // Regardless of the original note size `N`, the log is padded with random bytes up to\n            // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n            let length = log_content.len();\n            self.context.emit_raw_note_log(log_content, length, self.content.note_hash_counter);\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    pub content_option: Option<NoteEmissionContent<Note>>,\n\n    // OuterNoteEmission is expected to be constructed when a note is created, which means that the `context` object\n    // will be in scope. By storing a reference to it inside this object we remove the need for its methods to receive\n    // it, resulting in a cleaner end-user API.\n    context: &mut PrivateContext,\n}\n\nimpl<Note> OuterNoteEmission<Note>\nwhere\n    Note: NoteType + Packable,\n{\n    pub fn new(\n        content_option: Option<NoteEmissionContent<Note>>,\n        context: &mut PrivateContext,\n    ) -> Self {\n        Self { content_option, context }\n    }\n\n    pub fn emit(self, recipient: AztecAddress, delivery_mode: u8) {\n        if self.content_option.is_some() {\n            NoteEmission { content: self.content_option.unwrap_unchecked(), context: self.context }\n                .emit(recipient, delivery_mode);\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "146": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/note/note_getter.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{\n        note_getter_options::{\n            NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder,\n        },\n        note_interface::{NoteHash, NoteType},\n        note_viewer_options::NoteViewerOptions,\n        retrieved_note::RetrievedNote,\n        utils::compute_note_hash_for_read_request,\n    },\n    oracle,\n    utils::{array, comparison::compare},\n};\n\nuse protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, traits::{Packable, ToField}};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    packed_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the packed note.\n    // This allows easier packing and custom (un)packing schemas. A note property is located\n    // inside the packed note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = packed_note[selector.index as u32].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[(31 + offset - i) as u32] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_packed_note<let N: u32>(packed_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(packed_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (RetrievedNote<Note>, Field)\nwhere\n    Note: NoteType + NoteHash + Packable,\n{\n    // Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\n    // is check that the metadata is correct, and that the note exists.\n    let retrieved_note = unsafe { view_note::<Note>(storage_slot) };\n\n    // For settled notes, the contract address is implicitly checked since the hash returned from\n    // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n    // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the contract\n    // address returned from the oracle matches. Since branching in circuits is expensive, we perform this check on all\n    // note types.\n    assert(\n        retrieved_note.contract_address.eq(context.this_address()),\n        \"Note contract address mismatch.\",\n    );\n\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (retrieved_note, note_hash_for_read_request)\n}\n\n/// Returns a BoundedVec of notes that have been proven to have been created by this contract, either in the current or\n/// past transactions (i.e. pending or settled notes). A second BoundedVec contains the note hashes used for the read\n/// requests, which can save constraints when computing the note's nullifiers.\n///\n/// WARNING: recall that notes are never destroyed! Note existence therefore does not imply that the note is _current_\n/// or _valid_ - this typically requires also emitting the note's nullifier to prove that it had not been emitted\n/// before. Because of this, calling this function directly from end-user applications should be discouraged, and safe\n/// abstractions such as aztec-nr's state variables should be used instead.\npub fn get_notes<Note, let M: u32, PreprocessorArgs, FilterArgs>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, M, PreprocessorArgs, FilterArgs>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N = M>,\n{\n    // Safety: The notes are constrained below.\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PreprocessorArgs>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PreprocessorArgs) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PreprocessorArgs,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let M: u32, PreprocessorArgs, FilterArgs>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, M, PreprocessorArgs, FilterArgs>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N = M>,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the notes (as opposed to simply removing some), the private\n    // kernel will later validate that these note actually exist, so transformations would cause for that check\n    // to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = array::collapse(filtered_notes);\n    let mut note_hashes = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_packed_note = [0; M];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let retrieved_note = notes.get_unchecked(i);\n\n            // For settled notes, the contract address is implicitly checked since the hash returned from\n            // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n            // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the\n            // contract address returned from the oracle matches. Since branching in circuits is expensive, we perform\n            // this check on all note types.\n            assert(\n                retrieved_note.contract_address.eq(context.this_address()),\n                \"Note contract address mismatch.\",\n            );\n\n            let packed_note = retrieved_note.note.pack();\n            check_packed_note(packed_note, options.selects);\n            if i != 0 {\n                check_notes_order(prev_packed_note, packed_note, options.sorts);\n            }\n            prev_packed_note = packed_note;\n\n            let note_hash_for_read_request =\n                compute_note_hash_for_read_request(retrieved_note, storage_slot);\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\npub unconstrained fn view_note<Note>(storage_slot: Field) -> RetrievedNote<Note>\nwhere\n    Note: NoteType + Packable,\n{\n    let opt_notes: [_; 1] = oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n    );\n\n    opt_notes[0].expect(f\"Failed to get a note\")\n}\n\nunconstrained fn get_notes_internal<Note, let M: u32, PreprocessorArgs, FilterArgs>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, M, PreprocessorArgs, FilterArgs>,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteType + Packable<N = M>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\n/// Unconstrained variant of `get_notes`, meant to be used in unconstrained execution contexts. Notably only the note\n/// content is returned, and not any of the information used when proving its existence (e.g. note nonce, note hash,\n/// etc.).\npub unconstrained fn view_notes<Note, let M: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, M>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteType + Packable<N = M> + Eq,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n\n    // We fetch the notes from the same oracle we use in the constrained case, except we don't bother inspecting the\n    // metadata in order to prove existence.\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n    );\n\n    // Even though we don't expect for the opt_notes array to be sparse, collapse is still useful in this case to\n    // convert it into a BoundedVec.\n    array::collapse(opt_notes).map(\n        // view_notes just returns the actual note, so we drop the metadata\n        |retrieved_note| retrieved_note.note,\n    )\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects as u32] = select.unwrap_unchecked().value;\n            select_comparators[num_selects as u32] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "149": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::{Deserialize, Packable, Serialize};\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, note_nonce: Field },\n//   Settled{ note_nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Deserialize, Eq, Serialize, Packable)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_note_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_note_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_note_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_note_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_note_nonce }\n            }\n        } else if maybe_note_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_note_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_note_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_note_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.note_nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.note_nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    note_nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    note_nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n"
    },
    "152": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().note_nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullification<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullification_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullification`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullification_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let note_nonce = retrieved_note.metadata.to_pending_previous_phase().note_nonce();\n\n        compute_unique_note_hash(note_nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullification =\n        compute_note_hash_for_nullification(retrieved_note, storage_slot);\n    let inner_nullifier =\n        retrieved_note.note.compute_nullifier(context, note_hash_for_nullification);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "156": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(privateCallPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "157": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize,\n{\n    let serialized_option = load_oracle(contract_address, slot, <T as Deserialize>::N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(utilityStoreCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(utilityLoadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(utilityDeleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(utilityCopyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            let new_value = MockStruct::new(7, 8);\n            store(contract_address, SLOT, new_value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n        });\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n            delete(contract_address, SLOT);\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            delete(contract_address, SLOT);\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 5;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 10;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 1;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 2;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n            assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n            assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 2;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 1;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n            assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n            assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n        });\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            copy(contract_address, SLOT, SLOT, 1);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let value = MockStruct::new(5, 6);\n            store(other_contract_address, SLOT, value);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let _: Option<MockStruct> = load(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            delete(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            copy(other_contract_address, SLOT, SLOT, 0);\n        });\n    }\n}\n"
    },
    "158": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(privateNotifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(privateNotifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(privateNotifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "159": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use crate::context::utility_context::UtilityContext;\n\n#[oracle(utilityGetUtilityContext)]\nunconstrained fn get_utility_context_oracle() -> UtilityContext {}\n\n/// Returns a utility context built from the global variables of anchor block and the contract address of the function\n/// being executed.\npub unconstrained fn get_utility_context() -> UtilityContext {\n    get_utility_context_oracle()\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars, true)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n    predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        let mut result = if double_predicate {\n            // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n            embedded_curve_add_unsafe(point1, point1)\n        } else {\n            let point1_1 = EmbeddedCurvePoint {\n                x: point1.x + (x_coordinates_match as Field),\n                y: point1.y,\n                is_infinite: false,\n            };\n            let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n            // point1_1 is guaranteed to have a different abscissa than point2:\n            // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n            // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n            // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n            // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n            // therefore we only want to do this if we need the result, otherwise it needs to be eliminated as a dead instruction, lest we want the circuit to fail.\n            embedded_curve_add_unsafe(point1_1, point2_1)\n        };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n    _predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    // Ensure is_infinite is comptime\n    let point1_1 = EmbeddedCurvePoint { x: point1.x, y: point1.y, is_infinite: false };\n    let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n    embedded_curve_add_unsafe(point1_1, point2_1)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2, true)[0]\n}\n"
    },
    "160": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(privateStoreInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(privateLoadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "161": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(utilityGetContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "165": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\nuse protocol_types::traits::{Deserialize, Serialize};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(utilityGetPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "166": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(utilityGetKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "167": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(utilityGetPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] != 0 } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] != 0 } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] != 0 } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] != 0 } },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "169": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/message_processing.nr",
      "source": "use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(utilityFetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(utilityValidateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(utilityBulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n"
    },
    "171": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{note_interface::NoteType, retrieved_note::RetrievedNote};\n\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(privateNotifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(privateNotifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(privateNotifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(utilityGetNotes)]\nunconstrained fn get_notes_oracle<Note, let M: u32, let MaxNotes: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; M],\n    _select_by_offsets: [u8; M],\n    _select_by_lengths: [u8; M],\n    _select_values: [Field; M],\n    _select_comparators: [u8; M],\n    _sort_by_indexes: [u8; M],\n    _sort_by_offsets: [u8; M],\n    _sort_by_lengths: [u8; M],\n    _sort_order: [u8; M],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec\n    _max_notes: u32,\n    // This is always set to <RetrievedNote<Note> as Packable>::N. We need to pass it to TS in order to be able to\n    // correctly construct the BoundedVec there.\n    _packed_retrieved_note_length: u32,\n) -> BoundedVec<[Field; <RetrievedNote<Note> as Packable>::N], MaxNotes>\nwhere\n    // TODO(https://github.com/noir-lang/noir/issues/9399): `Note: Packable` should work here.\n    RetrievedNote<Note>: Packable,\n{}\n\npub unconstrained fn get_notes<Note, let M: u32, let MaxNotes: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Option<RetrievedNote<Note>>; MaxNotes]\nwhere\n    Note: NoteType + Packable,\n{\n    let packed_retrieved_notes: BoundedVec<[Field; <RetrievedNote<Note> as Packable>::N], MaxNotes>\n         = get_notes_oracle::<Note, M, MaxNotes>(\n            storage_slot,\n            num_selects,\n            select_by_indexes,\n            select_by_offsets,\n            select_by_lengths,\n            select_values,\n            select_comparators,\n            sort_by_indexes,\n            sort_by_offsets,\n            sort_by_lengths,\n            sort_order,\n            limit,\n            offset,\n            status,\n            MaxNotes,\n            <RetrievedNote<Note> as Packable>::N,\n        );\n\n    let mut notes = BoundedVec::<_, MaxNotes>::new();\n    for i in 0..packed_retrieved_notes.len() {\n        let retrieved_note = RetrievedNote::unpack(packed_retrieved_notes.get(i));\n        notes.push(retrieved_note);\n    }\n\n    // At last we convert the bounded vector to an array of options. We do this because that is what the filter\n    // function needs to have on the output and we've decided to have the same type on the input and output of\n    // the filter and preprocessor functions.\n    //\n    // We have decided to have the same type on the input and output of the filter and preprocessor functions because\n    // it allows us to chain multiple filters and preprocessors together.\n    //\n    // So why do we want the array of options on the output of the filter function?\n    //\n    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options\n    // allows setting values at known indices in the output array which is much more efficient than pushing to a\n    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted\n    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic\n    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor\n    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in\n    // an unconstrained context. We, however, use the same return value type to be able to use the same function as\n    // both a preprocessor and a filter.\n    let mut notes_array = [Option::none(); MaxNotes];\n    for i in 0..notes.len() {\n        if i < notes.len() {\n            notes_array[i] = Option::some(notes.get_unchecked(i));\n        }\n    }\n\n    notes_array\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(utilityCheckNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n// TODO: Oracles below are generic private log oracles and are not specific to notes. Move them somewhere else.\n\n/// Returns the next app tag for a given sender and recipient pair.\n///\n/// This also notifies the simulator that a tag has been used in a note, and to therefore increment the\n/// associated index so that future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub unconstrained fn get_next_app_tag_as_sender(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> Field {\n    get_next_app_tag_as_sender_oracle(sender, recipient)\n}\n\n#[oracle(privateGetNextAppTagAsSender)]\nunconstrained fn get_next_app_tag_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> Field {}\n\n/// Gets the sender for tags.\n///\n/// This unconstrained value is used as the sender when computing an unconstrained shared secret\n/// for a tag in order to emit a log. Constrained tagging should not use this as there is no\n/// guarantee that the recipient knows about the sender, and hence about the shared secret.\n///\n/// The value persists through nested calls, meaning all calls down the stack will use the same\n/// 'senderForTags' value (unless it is replaced).\npub unconstrained fn get_sender_for_tags() -> Option<AztecAddress> {\n    get_sender_for_tags_oracle()\n}\n\n#[oracle(privateGetSenderForTags)]\nunconstrained fn get_sender_for_tags_oracle() -> Option<AztecAddress> {}\n\n/// Sets the sender for tags.\n///\n/// This unconstrained value is used as the sender when computing an unconstrained shared secret\n/// for a tag in order to emit a log. Constrained tagging should not use this as there is no\n/// guarantee that the recipient knows about the sender, and hence about the shared secret.\n///\n/// Account contracts typically set this value before calling other contracts. The value persists\n/// through nested calls, meaning all calls down the stack will use the same 'senderForTags'\n/// value (unless it is replaced by another call to this setter).\npub unconstrained fn set_sender_for_tags(sender_for_tags: AztecAddress) {\n    set_sender_for_tags_oracle(sender_for_tags);\n}\n\n#[oracle(privateSetSenderForTags)]\nunconstrained fn set_sender_for_tags_oracle(_sender_for_tags: AztecAddress) {}\n"
    },
    "173": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(utilityGetRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "174": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(utilityGetSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "175": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(utilityStorageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: u32,\n    length: u32,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(address.to_field(), storage_slot, block_number, N)\n}\n\npub unconstrained fn storage_read<T>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"utilityStorageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"utilityStorageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "176": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/oracle/version.nr",
      "source": "/// The ORACLE_VERSION constant is used to check that the oracle interface is in sync between PXE and Aztec.nr. We need\n/// to version the oracle interface to ensure that developers get a reasonable error message if they use incompatible\n/// versions of Aztec.nr and PXE. The TypeScript counterpart is in `oracle_version.ts`.\n///\n/// @dev Whenever a contract function or Noir test is run, the `utilityAssertCompatibleOracleVersion` oracle is called and\n/// if the oracle version is incompatible an error is thrown.\npub global ORACLE_VERSION: Field = 3;\n\n/// Asserts that the version of the oracle is compatible with the version expected by the contract.\npub fn assert_compatible_oracle_version() {\n    // Safety: This oracle call returns nothing: we only call it to check Aztec.nr and Oracle interface versions are\n    // compatible. It is therefore always safe to call.\n    unsafe {\n        assert_compatible_oracle_version_wrapper();\n    }\n}\n\nunconstrained fn assert_compatible_oracle_version_wrapper() {\n    assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n}\n\n#[oracle(utilityAssertCompatibleOracleVersion)]\nunconstrained fn assert_compatible_oracle_version_oracle(version: Field) {}\n\nmod test {\n    use super::{assert_compatible_oracle_version_oracle, ORACLE_VERSION};\n\n    #[test]\n    unconstrained fn compatible_oracle_version() {\n        assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n    }\n\n    #[test(should_fail_with = \"Incompatible oracle version. TXE is using version '3', but got a request for '318183437'.\")]\n    unconstrained fn incompatible_oracle_version() {\n        let arbitrary_incorrect_version = 318183437;\n        assert_compatible_oracle_version_oracle(arbitrary_incorrect_version);\n    }\n}\n"
    },
    "179": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/state_vars/delayed_public_mutable.nr",
      "source": "use dep::protocol_types::{\n    delayed_public_mutable::{\n        delayed_public_mutable_values::{unpack_delay_change, unpack_value_change},\n        DelayedPublicMutableValues,\n        ScheduledDelayChange,\n        ScheduledValueChange,\n    },\n    traits::Packable,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::HasStorageSlot,\n    utils::with_hash::WithHash,\n};\n\nmod test;\n\npub struct DelayedPublicMutable<T, let InitialDelay: u64, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// This will make the Aztec macros require that T implements the Packable and Eq traits, and allocate `M + 1` storage\n// slots to this state variable.\nimpl<T, let InitialDelay: u64, Context, let M: u32> HasStorageSlot<M + 1> for DelayedPublicMutable<T, InitialDelay, Context>\nwhere\n    DelayedPublicMutableValues<T, InitialDelay>: Packable<N = M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\n// DelayedPublicMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. DelayedPublicMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in seconds. Reads in private are only valid as long as they are included in a block with a timestamp not\n// too far into the future, so that they can guarantee the value will not have possibly changed by then (because of the\n// delay). The delay for changing a value is initially equal to InitialDelay, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, let InitialDelay: u64, Context> DelayedPublicMutable<T, InitialDelay, Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T, let InitialDelay: u64> DelayedPublicMutable<T, InitialDelay, &mut PublicContext>\nwhere\n    T: Eq,\n{\n\n    pub fn schedule_value_change(self, new_value: T)\n    where\n        T: Packable,\n    {\n        let _value_change = self.schedule_and_return_value_change(new_value);\n    }\n\n    pub fn schedule_and_return_value_change(self, new_value: T) -> ScheduledValueChange<T>\n    where\n        T: Packable,\n    {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let current_timestamp = self.context.timestamp();\n        let current_delay = delay_change.get_current(current_timestamp);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let timestamp_of_change = current_timestamp + current_delay;\n        value_change.schedule_change(\n            new_value,\n            current_timestamp,\n            current_delay,\n            timestamp_of_change,\n        );\n\n        self.write(value_change, delay_change);\n\n        value_change\n    }\n\n    pub fn schedule_delay_change(self, new_delay: u64)\n    where\n        T: Packable,\n    {\n        let mut delay_change = self.read_delay_change();\n\n        let current_timestamp = self.context.timestamp();\n\n        delay_change.schedule_change(new_delay, current_timestamp);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value(self) -> T\n    where\n        T: Packable,\n    {\n        let current_timestamp = self.context.timestamp();\n        let value_change = self.read_value_change();\n\n        value_change.get_current_at(current_timestamp)\n    }\n\n    pub fn get_current_delay(self) -> u64\n    where\n        T: Packable,\n    {\n        let current_timestamp = self.context.timestamp();\n        self.read_delay_change().get_current(current_timestamp)\n    }\n\n    pub fn get_scheduled_value(self) -> (T, u64)\n    where\n        T: Packable,\n    {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay(self) -> (u64, u64)\n    where\n        T: Packable,\n    {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change(self) -> ScheduledValueChange<T>\n    where\n        T: Packable,\n    {\n        // We don't read ScheduledValueChange directly by having it implement Packable because ScheduledValueChange\n        // and ScheduledDelayChange are packed together (sdc and svc.timestamp_of_change are stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_value_change::<T, <T as Packable>::N>(packed)\n    }\n\n    fn read_delay_change(self) -> ScheduledDelayChange<InitialDelay>\n    where\n        T: Packable,\n    {\n        // Since all ScheduledDelayChange member are packed into a single field, we can read a single storage slot\n        // here and skip the ones that correspond to ScheduledValueChange members. We are abusing the fact that\n        // the field containing the ScheduledDelayChange data is the first one in the storage layout - otherwise we'd\n        // need to offset the storage slot to get the position where it'd land.\n        // We don't read ScheduledDelayChange directly by having it implement Packable because ScheduledValueChange\n        // and ScheduledDelayChange are packed together (sdc and svc.timestamp_of_change are stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_delay_change::<InitialDelay>(packed)\n    }\n\n    fn write(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<InitialDelay>,\n    )\n    where\n        T: Packable,\n    {\n        // Whenever we write to public storage, we write both the value change and delay change to storage at once.\n        // We do so by wrapping them in a single struct (`DelayedPublicMutableValues`). Then we wrap the resulting struct in\n        // `WithHash`.\n        // Wrapping in `WithHash` makes for more costly writes but it also makes private proofs much simpler because\n        // they only need to produce a historical proof for the hash, which results in a single inclusion proof (as\n        // opposed to 4 in the best case scenario in which T is a single field). Private delayed public mutable reads are\n        // assumed to be much more frequent than public writes, so this tradeoff makes sense.\n        let values = WithHash::new(DelayedPublicMutableValues::new(value_change, delay_change));\n\n        self.context.storage_write(self.storage_slot, values);\n    }\n}\n\nimpl<T, let InitialDelay: u64> DelayedPublicMutable<T, InitialDelay, &mut PrivateContext>\nwhere\n    T: Eq,\n{\n    pub fn get_current_value(self) -> T\n    where\n        T: Packable,\n    {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction timestamp as this proof\n        // will only be valid for the time we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n        let (value_change, delay_change, anchor_timestamp) = self.anchor_read_from_public_storage();\n\n        // We use the effective minimum delay as opposed to the current delay at the anchor block's timestamp as this\n        // one also takes into consideration any scheduled delay changes.\n        // For example, consider a scenario in which at timestamp `x` the current delay was 86400 seconds (1 day). We\n        // may naively think that the earliest we could change the value would be at timestamp `x + 86400` by\n        // scheduling immediately after the anchor block's timestamp, i.e. at timestamp `x + 1`. But if there was\n        // a delay change scheduled for timestamp `y` to reduce the delay to 43200 seconds (12 hours), then if a value\n        // change was scheduled at timestamp `y` it would go into effect at timestamp `y + 43200`, which is earlier\n        // than what we'd expect if we only considered the current delay.\n        let effective_minimum_delay = delay_change.get_effective_minimum_delay_at(anchor_timestamp);\n        let time_horizon = value_change.get_time_horizon(anchor_timestamp, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any timestamp after the time horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_include_by_timestamp(time_horizon);\n\n        value_change.get_current_at(anchor_timestamp)\n    }\n\n    fn anchor_read_from_public_storage(\n        self,\n    ) -> (ScheduledValueChange<T>, ScheduledDelayChange<InitialDelay>, u64)\n    where\n        T: Packable,\n    {\n        let header = self.context.get_anchor_block_header();\n        let address = self.context.this_address();\n\n        let anchor_timestamp = header.global_variables.timestamp;\n\n        let values: DelayedPublicMutableValues<T, InitialDelay> =\n            WithHash::historical_public_storage_read(header, address, self.storage_slot);\n\n        (values.svc, values.sdc, anchor_timestamp)\n    }\n}\n\nimpl<T, let InitialDelay: u64> DelayedPublicMutable<T, InitialDelay, UtilityContext>\nwhere\n    T: Eq,\n{\n    pub unconstrained fn get_current_value(self) -> T\n    where\n        T: Packable,\n    {\n        let dpmv: DelayedPublicMutableValues<T, InitialDelay> =\n            WithHash::utility_public_storage_read(self.context, self.storage_slot);\n\n        let current_timestamp = self.context.timestamp();\n        dpmv.svc.get_current_at(current_timestamp)\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n"
    },
    "180": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::HasStorageSlot;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n/// Map\n///\n/// A key-value storage container that maps keys to state variables, similar\n/// to Solidity mappings.\n///\n/// `Map` enables you to associate keys (like addresses or other identifiers)\n/// with state variables in your Aztec smart contract. This is conceptually\n/// similar to Solidity's `mapping(K => V)` syntax, where you can store and\n/// retrieve values by their associated keys.\n///\n/// You can declare a state variable contained within a Map in your contract's\n/// #[storage] struct.\n///\n/// For example, you might use\n/// `Map<AztecAddress, PrivateMutable<ValueNote, Context>, Context>` to track\n/// token balances for different users, similar to how you'd use\n/// `mapping(address => uint256)` in Solidity.\n///\n/// > Aside: the verbose `Context` in the declaration is a consequence of\n/// > leveraging Noir's regular syntax for generics to ensure that certain\n/// > state variable methods can only be called in some contexts (private,\n/// > public, utility).\n///\n/// The methods of Map are:\n/// - `at` (access state variable for a given key)\n/// (see the method's own doc comments for more info).\n///\n/// ## Generic Parameters\n/// - `K`: The key type (must implement `ToField` trait for hashing)\n/// - `V`: The value type:\n///   - any Aztec state variable:\n///     - `PublicMutable`\n///     - `PublicImmutable`\n///     - `PrivateMutable`\n///     - `PrivateImmutable`\n///     - `PrivateSet`\n///     - `DelayedPublicMutable`\n///     - `Map`\n/// - `Context`: The execution context (handles private/public function\n///   contexts)\n///\n/// ## Usage\n/// Maps are typically declared in your contract's #[storage] struct and\n/// accessed\n/// using the `at(key)` method to get the state variable for a specific key.\n/// The resulting state variable can then be read from or written to using its\n/// own methods.\n///\n/// ## Advanced\n/// Internally, `Map` uses a single base storage slot to represent the\n/// mapping\n/// itself, similar to Solidity's approach. Individual key-value pairs are\n/// stored at derived storage slots computed by hashing the base storage\n/// slot\n/// with the key using Poseidon2. This ensures:\n/// - No storage slot collisions between different keys\n/// - Uniform distribution of storage slots across the storage space\n/// - Compatibility with Aztec's storage tree structure\n/// - Gas-efficient storage access patterns similar to Solidity mappings\n///\n/// The storage slot derivation uses `derive_storage_slot_in_map(base_slot,\n/// key)` which computes `poseidon2_hash([base_slot, key.to_field()])`,\n/// ensuring cryptographically secure slot separation.\n///\n/// docs:start:map\npub struct Map<K, V, Context> {\n    pub context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n\n// Map reserves a single storage slot regardless of what it stores because\n// nothing is stored at said slot: it is only used to derive the storage slots\n// of nested state variables, which is expected to never result in collisions\n// or slots being close to one another due to these being hashes. This mirrors\n// the strategy adopted by Solidity mappings.\nimpl<K, T, Context> HasStorageSlot<1> for Map<K, T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    /// Initializes a new Map state variable.\n    ///\n    /// This function is usually automatically called within the #[storage]\n    /// macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PrivateContext`/`PublicContext`/`UtilityContext`.\n    ///               The Context determines which methods of this struct will\n    ///               be made available to the calling smart contract function.\n    /// * `storage_slot` - A unique identifier for this Map within the contract.\n    ///                    Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart\n    ///                    contract dev shouldn't have to worry about this, as\n    ///                    it's managed behind the scenes.\n    /// * `state_var_constructor` - A function that creates the value type (V)\n    ///                             given a context and storage slot. This is\n    ///                             typically the constructor of the state\n    ///                             variable type being stored in the Map.\n    ///\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n\n    /// Returns the state variable associated with the given key.\n    ///\n    /// This is equivalent to accessing `mapping[key]` in Solidity. It returns\n    /// the state variable instance for the specified key, which can then be\n    /// used to read or write the value at that key.\n    ///\n    /// Unlike Solidity mappings which return the value directly, this returns\n    /// the state variable wrapper (like PrivateMutable, PublicMutable, etc.)\n    /// that you then call methods on to interact with the actual value.\n    ///\n    /// # Arguments\n    ///\n    /// * `key` - The key to look up in the map. Must implement the ToField\n    ///           trait (which most basic Noir & Aztec types do).\n    ///\n    /// # Returns\n    ///\n    /// * `V` - The state variable instance for this key. You can then call\n    ///         methods like `.read()`, `.write()`, `.get_note()`, etc. on this\n    ///         depending on the specific state variable type.\n    ///\n    /// # Example\n    ///\n    /// ```noir\n    /// // Get a user's balance (assuming PrivateMutable<ValueNote>)\n    /// let user_balance = storage.balances.at(user_address);\n    /// let current_note = user_balance.get_note();\n    ///\n    /// // Update the balance\n    /// user_balance.replace(new_note);\n    /// ```\n    ///\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n}\n"
    },
    "182": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/state_vars/private_immutable.nr",
      "source": "use dep::protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\nuse crate::context::{PrivateContext, UtilityContext};\nuse crate::note::{\n    lifecycle::create_note,\n    note_emission::NoteEmission,\n    note_getter::{get_note, view_notes},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::HasStorageSlot;\n\n/// PrivateImmutable\n///\n/// PrivateImmutable is a private state variable type for values that are set once\n/// and remain permanently unchanged.\n///\n/// You can declare a state variable of type PrivateImmutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PrivateImmutable<YourNote, Context>`\n///\n/// The value is represented as a single note that persists for the lifetime of\n/// the state variable. Once initialized, this note is never nullified or replaced\n/// through the state variable interface - it can only be read.\n///\n/// The PrivateImmutable type facilitates: inserting the permanent note during\n/// initialization, and reading that note.\n///\n/// The methods of PrivateImmutable are:\n/// - `initialize`\n/// - `get_note`\n/// (see the methods' own doc comments for more info).\n///\n/// ## Example.\n///\n/// A contract's configuration parameters can be represented as a PrivateImmutable.\n/// Once set during contract deployment or initial setup, these parameters remain\n/// constant for the lifetime of the contract.\n///\n/// ## Privacy\n///\n/// PrivateImmutable has the same privacy properties as PrivateMutable (see\n/// PrivateMutable documentation), including the same privacy considerations\n/// regarding the initialization nullifier potentially leaking information about\n/// which storage slot was initialized.\n///\n/// # Generic Parameters:\n///\n/// * `Note` - A single note of this type will represent the PrivateImmutable's\n///            value at the given storage_slot.\n/// * `Context` - The execution context (PrivateContext or UtilityContext).\n///\n/// docs:start:struct\npub struct PrivateImmutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// Private storage slots are not really 'slots' but rather a value in the note hash preimage, so there is no notion of a\n// value spilling over multiple slots. For this reason PrivateImmutable (and all other private state variables) needs\n// just one slot to be reserved, regardless of what it stores.\nimpl<T, Context> HasStorageSlot<1> for PrivateImmutable<T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateImmutable<Note, Context> {\n    /// Initializes a new PrivateImmutable state variable.\n    ///\n    /// This function is usually automatically called within the #[storage] macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PrivateContext`/`PublicContext`/`UtilityContext`. The\n    ///               Context determines which methods of this struct will be made\n    ///               available to the calling smart contract function.\n    /// * `storage_slot` - A unique identifier for this state variable within the\n    ///                    contract. The permanent note for this PrivateImmutable\n    ///                    state variable will have this `storage_slot`.\n    ///                    Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart contract\n    ///                    dev shouldn't have to worry about this, as it's managed\n    ///                    behind the scenes.\n    ///\n    /// docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n\n    /// Computes the nullifier that will be created when this PrivateImmutable is\n    /// initialized.\n    ///\n    /// This function is primarily used internally by the `initialize` method, but\n    /// may also be useful for contracts that need to check if a PrivateImmutable\n    /// has been initialized.\n    ///\n    /// **IMPORTANT PRIVACY CONSIDERATION:**\n    /// This computation has the same privacy implications as PrivateMutable's\n    /// initialization nullifier (see PrivateMutable documentation for detailed\n    /// explanation). The initialization nullifier can leak information about which\n    /// storage slot was initialized.\n    ///\n    /// See https://github.com/AztecProtocol/aztec-packages/issues/15568 for ideas to\n    /// improve this privacy footgun in future.\n    ///\n    /// # Returns\n    ///\n    /// * `Field` - The nullifier that will be emitted when this PrivateImmutable is\n    ///             initialized.\n    ///\n    /// # Advanced\n    ///\n    /// The computation uses the Poseidon2 hash function with a specific generator\n    /// index to hash the storage slot, creating a deterministic nullifier based on\n    /// the storage location.\n    ///\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<Note> PrivateImmutable<Note, &mut PrivateContext> {\n    /// Initializes a PrivateImmutable state variable instance with a permanent note.\n    ///\n    /// This function inserts the single, permanent note for this state variable. It can\n    /// only be called once per PrivateImmutable. Subsequent calls will fail because\n    /// the initialization nullifier will already exist.\n    ///\n    /// Unlike PrivateMutable, this note will never be nullified or replaced through\n    /// the state variable interface - it persists for the lifetime of the state variable.\n    ///\n    /// # Arguments\n    ///\n    /// * `note` - The permanent note to store in this PrivateImmutable. This note\n    ///            contains the unchanging value of the state variable.\n    ///\n    /// # Returns\n    ///\n    /// * `NoteEmission<Note>` - A type-safe wrapper that requires you to decide\n    ///                          whether to encrypt and send the note to someone.\n    ///                          You can call `.emit()` on it to encrypt and log\n    ///                          the note, or `.discard()` to skip emission.\n    ///                          See NoteEmission for more details.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Creates and emits an initialization nullifier to mark this storage slot\n    ///   as initialized. This prevents double-initialization.\n    /// - Inserts the provided note into the protocol's Note Hash Tree.\n    /// - Returns a NoteEmission type that allows the caller to decide how to encrypt\n    ///   and deliver the note to its intended recipient.\n    ///\n    /// The initialization nullifier is deterministically computed from the storage\n    /// slot and can leak privacy information (see `compute_initialization_nullifier`\n    /// documentation).\n    ///\n    /// docs:start:initialize\n    pub fn initialize(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: NoteType + NoteHash + Packable,\n    {\n        // We emit an initialization nullifier to indicate that the struct is initialized. This also prevents\n        // the value from being initialized again as a nullifier can be included only once.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n\n    /// Reads the permanent note of a PrivateImmutable state variable instance.\n    ///\n    /// If this PrivateImmutable state variable has not yet been initialized,\n    /// no note will exist: the call will fail and the transaction will not\n    /// be provable.\n    ///\n    /// # Returns\n    ///\n    /// * `Note` - The permanent note stored in this PrivateImmutable.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Retrieves the note from the PXE via an oracle call\n    /// - Validates that the note exists and belongs to this contract address and\n    ///   storage slot by pushing a read request to the context\n    /// - Returns the note content directly without nullification\n    ///\n    /// Since the note is immutable, there's no risk of reading stale data or\n    /// race conditions - the note never changes after initialization.\n    ///\n    /// docs:start:get_note\n    pub fn get_note(self) -> Note\n    where\n        Note: NoteType + NoteHash + Packable,\n    {\n        let storage_slot = self.storage_slot;\n        let retrieved_note = get_note(self.context, storage_slot).0;\n\n        // Because the notes obtained from PrivateImmutable are not meant to be nullified and get_note(...) function\n        // has already constrained the note (by pushing a read request to the context), we can return just the note\n        // and skip the additional data in RetrievedNote.\n        retrieved_note.note\n    }\n}\n\nimpl<Note> PrivateImmutable<Note, UtilityContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    /// Checks whether this PrivateImmutable has been initialized.\n    ///\n    /// # Returns\n    ///\n    /// * `bool` - `true` if the PrivateImmutable has been initialized (the initialization\n    ///            nullifier exists), `false` otherwise.\n    ///\n    /// docs:start:is_initialized\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n\n    /// Returns the permanent note in this PrivateImmutable without consuming it.\n    ///\n    /// This function is only available in a UtilityContext (unconstrained environment)\n    /// and is typically used for offchain queries, view functions, or testing.\n    ///\n    /// Unlike the constrained `get_note()`, this function does not push read requests\n    /// or perform validation. It simply reads the note from the PXE's database.\n    ///\n    /// # Returns\n    ///\n    /// * `Note` - The permanent note stored in this PrivateImmutable.\n    ///\n    /// docs:start:view_note\n    pub unconstrained fn view_note(self) -> Note\n    where\n        Note: Packable,\n    {\n        let mut options = NoteViewerOptions::<Note, <Note as Packable>::N>::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n}\n"
    },
    "19": {
      "path": "std/hash/mod.nr",
      "source": "// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "210": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends the elements of the second `BoundedVec` to the end of the first one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let ALen: u32, let BLen: u32, let DstLen: u32>(\n    a: BoundedVec<T, ALen>,\n    b: BoundedVec<T, BLen>,\n) -> BoundedVec<T, DstLen> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "213": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DstLen` elements from a source array, starting at `offset`. `DstLen` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SrcLen: u32, let DstLen: u32>(src: [T; SrcLen], offset: u32) -> [T; DstLen] {\n    assert(offset + DstLen <= SrcLen, \"DstLen too large for offset\");\n\n    let mut dst: [T; DstLen] = std::mem::zeroed();\n    for i in 0..DstLen {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DstLen to be 0, so we always get back an empty array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "214": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DstMaxLen` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DstLen` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DstLen` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SrcMaxLen: u32, let DstMaxLen: u32>(\n    bvec: BoundedVec<T, SrcMaxLen>,\n    offset: u32,\n) -> BoundedVec<T, DstMaxLen> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "216": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "217": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "220": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use protocol_types::{point::Point, utils::field::sqrt};\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\npub fn point_from_x_coord(x: Field) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    sqrt(rhs).map(|y| Point { x, y, is_infinite: false })\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate and sign for the y coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\n///\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n\n    sqrt(rhs).map(|y| {\n        // If there is a square root, we need to ensure it has the correct \"sign\"\n        let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n        let final_y = if y_is_positive == sign { y } else { -y };\n        Point { x, y: final_y, is_infinite: false }\n    })\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord, point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n    use dep::protocol_types::utils::field::pow;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign).unwrap();\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2).unwrap();\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_valid() {\n        // x = 8 is a known quadratic residue - should give a valid point\n        let result = point_from_x_coord(Field::from(8));\n        assert(result.is_some());\n\n        let point = result.unwrap();\n        assert_eq(point.x, Field::from(8));\n        // Check curve equation y^2 = x^3 - 17\n        assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_invalid() {\n        // x = 3 is a non-residue for this curve - should give None\n        let x = Field::from(3);\n        let maybe_point = point_from_x_coord(x);\n        assert(maybe_point.is_none());\n    }\n\n}\n"
    },
    "221": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/utils/random.nr",
      "source": "use crate::oracle::random::random;\n\n/// Returns as many random bytes as specified through N.\npub unconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n"
    },
    "222": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/utils/remove_constraints.nr",
      "source": "/// Calls a function and returns its return value, but removes any constraints associated with calling the function,\n/// behaving as if the function was unconstrained.\npub unconstrained fn remove_constraints<Env, T>(f: fn[Env]() -> T) -> T {\n    f()\n}\n\n/// Calls a function and returns its return value, removing any constraints associated with calling the function if\n/// `condition` is true, behaving as if the function was unconstrained.\n///\n/// Requires `condition` to be a compile time constant.\npub fn remove_constraints_if<Env, T>(condition: bool, f: fn[Env]() -> T) -> T {\n    // If `condition` is not a compile-time constant, then the compiler won't optimize away the branch not taken in the\n    // if statement below, and we may end up with constraints for `f` regardless of the runtime value of `condition`.\n    assert_constant(condition);\n\n    if condition {\n        // Safety: the purpose of this function is to execute `f` with no constraints when `condition` is true.\n        unsafe {\n            remove_constraints(f)\n        }\n    } else {\n        f()\n    }\n}\n\nmod test {\n    use super::remove_constraints;\n\n    fn return_unit() -> () {\n        ()\n    }\n\n    fn return_field() -> Field {\n        5\n    }\n\n    #[test]\n    fn returns_unit() {\n        let expected = return_unit();\n        // Safety: this is a test\n        let actual = unsafe { remove_constraints(|| return_unit()) };\n        assert_eq(actual, expected);\n    }\n\n    #[test]\n    fn returns_original_value() {\n        let expected = return_field();\n        // Safety: this is a test\n        let actual = unsafe { remove_constraints(|| return_field()) };\n        assert_eq(actual, expected);\n    }\n\n    #[test]\n    unconstrained fn returns_unit_unconstrained() {\n        let expected = return_unit();\n        let actual = remove_constraints(|| return_unit());\n        assert_eq(actual, expected);\n    }\n\n    #[test]\n    unconstrained fn returns_original_value_unconstrained() {\n        let expected = return_field();\n        let actual = remove_constraints(|| return_field());\n        assert_eq(actual, expected);\n    }\n}\n"
    },
    "224": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    abis::block_header::BlockHeader, address::AztecAddress, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `M` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `M`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let M: u32> {\n    value: T,\n    packed: [Field; M],\n    hash: Field,\n}\n\nimpl<T, let M: u32> WithHash<T, M>\nwhere\n    T: Packable<N = M> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + M as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\n// Note: I don't derive Packable on `WithHash` because `derive_serialize` function does not support setting \"N = M\"\n// as I do here 3 lines below. This could be worked around by placing the \"where\" clause directly on the `WithHash`\n// struct, but Jake mentioned that the syntax is not expected to be supported at least until Noir 1.0.\n// Relevant discussion on Slack:\n// https://aztecprotocol.slack.com/archives/C04QF64EDNV/p1752593876160699?thread_ts=1752589887.955379&cid=C04QF64EDNV\nimpl<T, let M: u32> Packable for WithHash<T, M>\nwhere\n    T: Packable<N = M>,\n{\n    let N: u32 = M + 1;\n\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            result[i] = self.packed[i];\n        }\n        result[M] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        let mut value_packed = [0; M];\n        for i in 0..M {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[M];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::test::OracleMock;\n\n    global STORAGE_SLOT: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let env = TestEnvironment::new();\n\n        env.private_context(|context| {\n            let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.anchor_block_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n\n            assert_eq(result, std::mem::zeroed());\n        });\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        env.public_context(|context| { context.storage_write(STORAGE_SLOT, value_with_hash); });\n\n        env.private_context(|context| {\n            let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.anchor_block_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n            assert_eq(result, value);\n        });\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn bad_hint_uninitialized_value() {\n        let env = TestEnvironment::new();\n\n        env.private_context(|context| {\n            let block_header = context.anchor_block_header;\n            let address = context.this_address();\n\n            // Mock the oracle to return a non-zero hint/packed value\n            let value_packed = MockStruct { a: 1, b: 1 }.pack();\n            let _ = OracleMock::mock(\"utilityStorageRead\")\n                .with_params((\n                    address.to_field(), STORAGE_SLOT, block_header.global_variables.block_number,\n                    value_packed.len(),\n                ))\n                .returns(value_packed)\n                .times(1);\n\n            // This should fail because the hint value is non-zero and the hash is zero (default value of storage)\n            let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n                block_header,\n                address,\n                STORAGE_SLOT,\n            );\n        });\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn bad_hint_initialized_value() {\n        let env = TestEnvironment::new();\n\n        env.public_context(|context| {\n            // Write the value and hash separately so that the hash is wrong\n            let value = MockStruct { a: 5, b: 3 };\n            context.storage_write(STORAGE_SLOT, value);\n\n            let incorrect_hash = 13;\n            let hash_storage_slot = STORAGE_SLOT + (value.pack().len() as Field);\n            context.storage_write(hash_storage_slot, [incorrect_hash]);\n        });\n\n        env.private_context(|context| {\n            let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.anchor_block_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n        });\n    }\n}\n"
    },
    "231": {
      "path": "/home/nerses/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "253": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\nuse std::meta::derive;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct FunctionSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    pub inner: u32,\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "294": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\nuse std::meta::derive;\n\n// Aztec address\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    /// Returns an address's `AddressPoint`, which can be used to create shared secrets with the owner\n    /// of the address. If the address is invalid (i.e. it is not a properly derived Aztec address), then this\n    /// returns `Option::none()`, and no shared secrets can be created.\n    pub fn to_address_point(self) -> Option<AddressPoint> {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // An invalid AztecAddress is one for which no y coordinate satisfies the curve equation, which we'll\n        // identify by proving that the square root of y_squared does not exist.\n        let mut y_opt = sqrt(y_squared);\n        if y_opt.is_none() {\n            Option::none()\n        } else {\n            let mut y = y_opt.unwrap();\n\n            // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n            // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n            // note: The field modulus is MAX_FIELD_VALUE + 1\n            if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n                y = (MAX_FIELD_VALUE + 1) - y;\n            }\n\n            Option::some(\n                AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } },\n            )\n        }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    // We use the AZTEC_ADDRESS_LENGTH constant to ensure that there is a match between the derived trait\n    // implementation and the constant.\n    let serialized: [Field; AZTEC_ADDRESS_LENGTH] = address.serialize();\n    let deserialized = AztecAddress::deserialize(serialized);\n    assert_eq(address, deserialized);\n}\n\n#[test]\nfn to_address_point_valid() {\n    // x = 8 where x^3 - 17 = 512 - 17 = 495, which is a residue in this field\n    let address = AztecAddress { inner: 8 };\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_some());\n\n    let point = maybe_point.unwrap().inner;\n    // check that x is preserved\n    assert_eq(point.x, Field::from(8));\n\n    // check that the curve equation holds: y^2 == x^3 - 17\n    assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n}\n\n#[test]\nunconstrained fn to_address_point_invalid() {\n    // x = 3 where x^3 - 17 = 27 - 17 = 10, which is a non-residue in this field\n    let address = AztecAddress { inner: 3 }; //\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_none());\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "307": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Deserialize, Empty, Hash, Serialize},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: Field,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: Field) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "309": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "// TODO: Expose other wrapped functions than debug (info, warn)\n// ['silent', 'fatal', 'error', 'warn', 'info', 'verbose', 'debug', 'trace']\n\npub global SILENT_LOG_LEVEL: u8 = 0;\npub global FATAL_LOG_LEVEL: u8 = 1;\npub global ERROR_LOG_LEVEL: u8 = 2;\npub global WARN_LOG_LEVEL: u8 = 3;\npub global INFO_LOG_LEVEL: u8 = 4;\npub global VERBOSE_LOG_LEVEL: u8 = 5;\npub global DEBUG_LOG_LEVEL: u8 = 6;\npub global TRACE_LOG_LEVEL: u8 = 7;\n\n/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Same as debug_log, but allows to customize the log level.\n/// Consider changing just to 'log'\npub fn debug_log_with_level<let N: u32>(log_level: u8, msg: str<N>) {\n    debug_log_format_with_level(log_level, msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(DEBUG_LOG_LEVEL, msg, args) };\n}\n\n/// Same as debug_log_format, but allows to customize the log level.\n/// Consider changing just to 'log_format'\npub fn debug_log_format_with_level<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(log_level, msg, args) };\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` slice.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole slice: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format_slice<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_slice_oracle_wrapper(log_level, msg, args) };\n}\n\n// We provide two versions of the debug log oracle: one that takes args as a slice and another one that takes args as an array.\n// We do this since conversion from array to slice generates overhead in public functions, since opcodes need to be emitted for the conversion.\n// By exposing the two flavors, we avoid conversions since the AVM is able to handle both arrays an slices in this oracle.\n\nunconstrained fn debug_log_slice_oracle_wrapper<let M: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field],\n) {\n    debug_log_slice_oracle(log_level, msg, args);\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_slice_oracle<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {}\n\nunconstrained fn debug_log_array_oracle_wrapper<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_array_oracle(log_level, msg, N, args);\n}\n\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_array_oracle<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    length: u32,\n    args: [Field; N],\n) {}\n"
    },
    "311": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/delayed_public_mutable/delayed_public_mutable_values.nr",
      "source": "use crate::{\n    delayed_public_mutable::{\n        scheduled_delay_change::ScheduledDelayChange, scheduled_value_change::ScheduledValueChange,\n    },\n    hash::poseidon2_hash,\n    traits::{Hash, Packable},\n    utils::arrays,\n};\nuse std::meta::derive;\n\nmod test;\n\n/// DelayedPublicMutableValues is just a wrapper around ScheduledValueChange and ScheduledDelayChange that then allows us\n/// to wrap both of these values in WithHash. WithHash allows for efficient read of values in private.\n///\n/// Note that the WithHash optimization does not work in public (due to there being no unconstrained). But we also want\n/// to be able to read the values efficiently in public and we want to be able to read each value separately. Reading\n/// the values separately is tricky because ScheduledValueChange and ScheduledDelayChange are packed together (sdc and\n/// svc.timestamp_of_change are stored in the same slot). For that reason we expose `unpack_value_change` and\n/// `unpack_delay_change` functions that can be used to extract the values from the packed representation. This\n/// is \"hacky\" but there is no way around it.\n#[derive(Eq)]\npub struct DelayedPublicMutableValues<T, let INITIAL_DELAY: u64> {\n    pub svc: ScheduledValueChange<T>,\n    pub sdc: ScheduledDelayChange<INITIAL_DELAY>,\n}\n\nimpl<T, let INITIAL_DELAY: u64> DelayedPublicMutableValues<T, INITIAL_DELAY> {\n    pub fn new(svc: ScheduledValueChange<T>, sdc: ScheduledDelayChange<INITIAL_DELAY>) -> Self {\n        DelayedPublicMutableValues { svc, sdc }\n    }\n}\n\npub fn unpack_value_change<T, let M: u32>(packed: [Field; 2 * M + 1]) -> ScheduledValueChange<T>\nwhere\n    T: Packable<N = M>,\n{\n    let svc_pre_packed = arrays::subarray(packed, 1);\n    let svc_post_packed = arrays::subarray(packed, M + 1);\n\n    // We first cast to u32 as the timestamp_of_change is packed into the same field as the delay change and it\n    // occupies the first 32 bits of the field.\n    let timestamp_of_change = (packed[0] as u32) as u64;\n    ScheduledValueChange::new(\n        T::unpack(svc_pre_packed),\n        T::unpack(svc_post_packed),\n        timestamp_of_change,\n    )\n}\n\npub fn unpack_delay_change<let INITIAL_DELAY: u64>(\n    packed: Field,\n) -> ScheduledDelayChange<INITIAL_DELAY> {\n    // This function expects to be called with just the first field of the packed representation, which contains sdc\n    // and svc timestamp_of_change. We'll discard the svc component.\n    let svc_timestamp_of_change = packed as u32;\n\n    let mut tmp = (packed - svc_timestamp_of_change as Field) / TWO_POW_32;\n    let sdc_timestamp_of_change = tmp as u32;\n\n    tmp = (tmp - sdc_timestamp_of_change as Field) / TWO_POW_32;\n    let sdc_post_is_some = (tmp as u1) != 0;\n\n    tmp = (tmp - sdc_post_is_some as Field) / TWO_POW_8;\n    let sdc_post_inner = tmp as u32;\n\n    tmp = (tmp - sdc_post_inner as Field) / TWO_POW_32;\n    let sdc_pre_is_some = (tmp as u1) != 0;\n\n    tmp = (tmp - sdc_pre_is_some as Field) / TWO_POW_8;\n    let sdc_pre_inner = tmp as u32;\n\n    // Note that below we cast the values to u64 as that is the default type of timestamp in the system. Us packing\n    // the values as u32 is a tech debt that is not worth tackling.\n    ScheduledDelayChange {\n        pre: if sdc_pre_is_some {\n            Option::some(sdc_pre_inner as u64)\n        } else {\n            Option::none()\n        },\n        post: if sdc_post_is_some {\n            Option::some(sdc_post_inner as u64)\n        } else {\n            Option::none()\n        },\n        timestamp_of_change: sdc_timestamp_of_change as u64,\n    }\n}\n\nglobal TWO_POW_32: Field = 2.pow_32(32);\nglobal TWO_POW_8: Field = 2.pow_32(8);\n\n// We pack to `2 * N + 1` fields because ScheduledValueChange contains T twice (hence `2 * N`) and we need one extra\n// field to store ScheduledDelayChange and the timestamp_of_change of ScheduledValueChange.\nimpl<T, let INITIAL_DELAY: u64> Packable for DelayedPublicMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable,\n{\n    let N: u32 = 2 * <T as Packable>::N + 1;\n\n    fn pack(self) -> [Field; Self::N] {\n        let mut result = [0; Self::N];\n\n        // We pack sdc.pre, sdc.post, sdc.timestamp_of_change and svc.timestamp_of_change into a single field as follows:\n        // [ sdc.pre_inner: u32 | sdc.pre_is_some: u8 | sdc.post_inner: u32 | sdc.post_is_some: u8 | sdc.timestamp_of_change: u32 | svc.timestamp_of_change: u32 ]\n        // Note that the code below no longer works after 2106 as by that time the timestamp will overflow u32. This is a tech debt that is not worth tackling.\n        result[0] = self.svc.timestamp_of_change as Field\n            + ((self.sdc.timestamp_of_change as Field) * 2.pow_32(32))\n            + ((self.sdc.post.is_some() as Field) * 2.pow_32(64))\n            + ((self.sdc.post.unwrap_unchecked() as Field) * 2.pow_32(72))\n            + ((self.sdc.pre.is_some() as Field) * 2.pow_32(104))\n            + ((self.sdc.pre.unwrap_unchecked() as Field) * 2.pow_32(112));\n\n        // Pack the pre and post values from ScheduledValueChange\n        let svc_pre_packed = self.svc.pre.pack();\n        let svc_post_packed = self.svc.post.pack();\n        for i in 0..<T as Packable>::N {\n            result[i + 1] = svc_pre_packed[i];\n            result[i + 1 + <T as Packable>::N] = svc_post_packed[i];\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        let svc = unpack_value_change::<T, _>(fields);\n        let sdc = unpack_delay_change::<INITIAL_DELAY>(fields[0]);\n        Self::new(svc, sdc)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u64> Hash for DelayedPublicMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable,\n{\n    fn hash(self) -> Field {\n        poseidon2_hash(self.pack())\n    }\n}\n"
    },
    "314": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/delayed_public_mutable/scheduled_delay_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by DelayedPublicMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initially equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation\n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the\n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a\n// reduced delay, invalidating prior private reads.\npub struct ScheduledDelayChange<let INITIAL_DELAY: u64> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option,\n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pub(crate) pre: Option<u64>,\n    pub(crate) post: Option<u64>,\n    // Timestamp at which `post` value is used instead of `pre`\n    pub(crate) timestamp_of_change: u64,\n}\n\nimpl<let INITIAL_DELAY: u64> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u64>, post: Option<u64>, timestamp_of_change: u64) -> Self {\n        Self { pre, post, timestamp_of_change }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current timestamp - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_timestamp: u64) -> u64 {\n        // The post value becomes the current one at the timestamp of change, so any transaction that is included at or after\n        // the timestamp of change will use the post value.\n        if current_timestamp < self.timestamp_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the timestamp at which it will become the current\n    /// delay. Note that this timestamp may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u64, u64) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.timestamp_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current timestamp. This function is only meaningful\n    /// when called in public with the current timestamp.\n    /// The timestamp at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u64, current_timestamp: u64) {\n        let current = self.get_current(current_timestamp);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let time_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior constraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value timestamp of change\n            //      timestamp             timestamp of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   time until change               new delay              |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.timestamp_of_change = current_timestamp + time_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical timestamp. It only returns a meaningful value when called in private with historical timestamps.\n    /// This function can be used alongside `ScheduledValueChange.get_time_horizon` to properly constrain\n    /// the `include_by_timestamp` transaction property when reading delayed mutable state.\n    /// This value typically equals the current delay at the timestamp following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is\n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_timestamp: u64) -> u64 {\n        if self.timestamp_of_change <= historical_timestamp {\n            // If no delay changes were scheduled, then the delay value at the historical timestamp (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // timestamp of change the current delay will be the scheduled one, with an overall delay from the historical\n            // timestamp equal to the time until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //        timestamp                delay                  actual earliest value\n            //           v              timestamp of change           timestamp of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest timestamp in        |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |          time                  new delay                       |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest timestamp in\n            //                             which to scheduled value change\n            let time_until_change = self.timestamp_of_change - (historical_timestamp + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                time_until_change + self.post.unwrap_or(INITIAL_DELAY),\n            )\n        }\n    }\n}\n\nimpl<let INITIAL_DELAY: u64> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.timestamp_of_change == other.timestamp_of_change)\n    }\n}\n\nimpl<let INITIAL_DELAY: u64> Empty for ScheduledDelayChange<INITIAL_DELAY> {\n    fn empty() -> Self {\n        Self { pre: Option::none(), post: Option::none(), timestamp_of_change: 0 }\n    }\n}\n"
    },
    "316": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/delayed_public_mutable/scheduled_value_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by DelayedPublicMutable to represent a value that changes from `pre` to `post` at some timestamp\n// called the `timestamp_of_change`. The value can only be made to change by scheduling a change event at some future\n// timestamp after some minimum delay measured in seconds has elapsed. This means that at any given timestamp we know\n// both the current value and the smallest timestamp at which the value might change - this is called the\n// 'time horizon'.\npub struct ScheduledValueChange<T> {\n    pub(crate) pre: T,\n    pub(crate) post: T,\n    // Timestamp at which `post` value is used instead of `pre`\n    pub(crate) timestamp_of_change: u64,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, timestamp_of_change: u64) -> Self {\n        Self { pre, post, timestamp_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given timestamp. This function can be called both in public\n    /// (where `timestamp` is simply the current timestamp, i.e. the timestamp at which the current transaction will be\n    /// included) and in private (where `timestamp` is the anchor block's timestamp). Reading in private is only safe\n    /// if the transaction's `include_by_timestamp` property is set to a value lower or equal to the time horizon (see\n    /// `get_time_horizon()`).\n    pub fn get_current_at(self, timestamp: u64) -> T {\n        // The post value becomes the current one at the timestamp of change. This means different things in each realm:\n        // - in public, any transaction that is included at the timestamp of change will use the post value\n        // - in private, any transaction that includes the timestamp of change as part of the historical state will use\n        //   the post value (barring any follow-up changes)\n        if timestamp < self.timestamp_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the timestamp at which it will become the current\n    /// value. Note that this timestamp may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u64) {\n        (self.post, self.timestamp_of_change)\n    }\n\n    // Returns the previous value. This is the value that is current up until the timestamp of change. Note that this\n    // value might not be the current anymore since timestamp of change might have already passed.\n    pub fn get_previous(self) -> (T, u64) {\n        (self.pre, self.timestamp_of_change)\n    }\n\n    /// Returns the largest timestamp at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private where the proof is constructed against an anchor block, since\n    /// due to its asynchronous nature private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum time in seconds that needs to\n    /// elapse from the next block's timestamp until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a anchor block's timestamp is only safe to use\n    /// if the transaction's `include_by_timestamp` property is set to a value lower or equal to the time horizon\n    /// computed using the same anchor timestamp.\n    pub fn get_time_horizon(self, anchor_timestamp: u64, minimum_delay: u64) -> u64 {\n        // The time horizon is the very last timestamp in which the current value is known. Any timestamp past the\n        // horizon (i.e. with a timestamp larger than the time horizon) may have a different current value.\n        // Reading the current value in private typically requires constraining the maximum valid timestamp to be equal\n        // to the time horizon.\n        if anchor_timestamp >= self.timestamp_of_change {\n            // Once the timestamp of change has passed (block with timestamp >= timestamp_of_change was mined),\n            // the current value (post) will not change unless a new value change is scheduled. This did not happen at\n            // the anchor timestamp (or else it would not be greater or equal to the timestamp of change), and\n            // therefore could only happen after the anchor timestamp. The earliest would be the immediate next\n            // timestamp, and so the smallest possible next timestamp of change equals `anchor_timestamp + 1 +\n            // minimum_delay`. Our time horizon is simply the previous timestamp to that one.\n            //\n            //   timestamp of    anchor\n            //      change       timestamp          time horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n            anchor_timestamp + minimum_delay\n        } else {\n            // If the timestamp of change has not yet been reached however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the time horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the timestamp of change is in the past: the time horizon is\n            //      the timestamp prior to the earliest one in which a new timestamp of change might land.\n            //\n            //         anchor\n            //         timestamp                      time horizon    timestamp of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` seconds away from the anchor timestamp, in which case\n            //      the timestamp of change would become the limiting factor for the time horizon, which would equal\n            //      the timestamp right before the timestamp of change (since by definition the value changes at the\n            //      timestamp of change).\n            //\n            //           anchor                         time horizon\n            //           timestamp   timestamp of change    if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the timestamp of change to an\n            // arbitrary value, and therefore scenario a) is not currently possible. However implementing #5501 would\n            // allow for this to happen.\n            // Because anchor_timestamp < self.timestamp_of_change, then timestamp_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.timestamp_of_change - 1,\n                anchor_timestamp + minimum_delay,\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current timestamp. This function is only meaningful when\n    /// called in public with the current timestamp.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_timestamp: u64,\n        minimum_delay: u64,\n        timestamp_of_change: u64,\n    ) {\n        assert(timestamp_of_change >= current_timestamp + minimum_delay);\n\n        self.pre = self.get_current_at(current_timestamp);\n        self.post = new_value;\n        self.timestamp_of_change = timestamp_of_change;\n    }\n}\n\nimpl<T> Eq for ScheduledValueChange<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.timestamp_of_change == other.timestamp_of_change)\n    }\n}\n\nimpl<T> Empty for ScheduledValueChange<T>\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        Self { pre: T::empty(), post: T::empty(), timestamp_of_change: 0 }\n    }\n}\n"
    },
    "319": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "mod poseidon2_chunks;\n\nuse crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_log::{PrivateLog, PrivateLogData},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    side_effect::{Counted, Scoped},\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\n\npub use poseidon2_chunks::poseidon2_absorb_in_chunks_existing_sponge;\nuse poseidon2_chunks::poseidon2_absorb_in_chunks;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: Scoped<Counted<NoteHash>>) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.innermost())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: Scoped<Counted<Nullifier>>) -> Field {\n    let value = nullifier.innermost().value;\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        value // Return `value` instead of 0 because an already-siloed nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, value)\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<Counted<PrivateLogData>>) -> PrivateLog {\n    let log = private_log.innermost().log;\n    if private_log.contract_address.is_zero() {\n        log\n    } else {\n        let mut fields = log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n/// Computes a Poseidon2 hash over a dynamic-length subarray of the given input.\n/// Only the first `in_len` fields of `input` are absorbed; any remaining fields are ignored.\n/// The caller is responsible for ensuring that the input is padded with zeros if required.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n"
    },
    "328": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_tree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n/// These values are precomputed and we run tests to ensure that they are correct.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_tree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_tree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_tree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_tree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_tree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_tree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_tree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_tree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_tree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_tree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_tree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_tree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "332": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use utils::derive_serialization_quotes;\n\npub mod utils;\n\n/// Generates the generic parameter declarations for a struct's trait implementation.\n///\n/// This function takes a struct type definition and generates the generic parameter declarations\n/// that go after the `impl` keyword. For example, given a struct with generics `N: u32` and `T`,\n/// it generates `<let N: u32, T>`.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate generic declarations for\n///\n/// # Returns\n/// A quoted code block containing the generic parameter declarations, or an empty quote if the struct\n/// has no generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// This function generates:\n/// ```\n/// <let N: u32, T>\n/// ```\ncomptime fn get_generics_declarations(s: TypeDefinition) -> Quoted {\n    let generics = s.generics();\n\n    if generics.len() > 0 {\n        let generics_declarations_items = generics\n            .map(|(name, maybe_integer_typ)| {\n                // The second item in the generics tuple is an Option of an integer type that is Some only if\n                // the generic is numeric.\n                if maybe_integer_typ.is_some() {\n                    // The generic is numeric, so we return a quote defined as e.g. \"let N: u32\"\n                    let integer_type = maybe_integer_typ.unwrap();\n                    quote {let $name: $integer_type}\n                } else {\n                    // The generic is not numeric, so we return a quote containing the name of the generic (e.g. \"T\")\n                    quote {$name}\n                }\n            })\n            .join(quote {,});\n        quote {<$generics_declarations_items>}\n    } else {\n        // The struct doesn't have any generics defined, so we just return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates the `where` clause for a trait implementation that constrains non-numeric generic type parameters.\n///\n/// This function takes a struct type definition and a trait name, and generates a `where` clause that\n/// requires all non-numeric generic type parameters to implement the specified trait.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the where clause for\n/// - `trait_name`: The name of the trait that non-numeric generic parameters must implement\n///\n/// # Returns\n/// A quoted code block containing the where clause, or an empty quote if the struct has no non-numeric\n/// generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// And trait name \"Serialize\", this function generates:\n/// ```\n/// where T: Serialize\n/// ```\ncomptime fn get_where_trait_clause(s: TypeDefinition, trait_name: Quoted) -> Quoted {\n    let generics = s.generics();\n\n    // The second item in the generics tuple is an Option of an integer type that is Some only if the generic is\n    // numeric.\n    let non_numeric_generics =\n        generics.filter(|(_, maybe_integer_typ)| maybe_integer_typ.is_none());\n\n    if non_numeric_generics.len() > 0 {\n        let non_numeric_generics_declarations =\n            non_numeric_generics.map(|(name, _)| quote {$name: $trait_name}).join(quote {,});\n        quote {where $non_numeric_generics_declarations}\n    } else {\n        // There are no non-numeric generics, so we return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates a `Serialize` trait implementation for a struct type.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A quoted code block containing the trait implementation\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Log<N> {\n///     fields: [Field; N],\n///     length: u32\n/// }\n/// ```\n///\n/// This function generates code equivalent to:\n/// ```\n/// impl<let N: u32> Serialize for Log<N> {\n///     let N: u32 = <[Field; N] as Serialize>::N + <u32 as Serialize>::N;\n///\n///     #[inline_always]\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut serialized_params = [0; _];\n///         let mut offset = 0;\n///\n///         let serialized_member = Serialize::serialize(self.fields);\n///         let serialized_member_len = <[Field; N] as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         let serialized_member = Serialize::serialize(self.length);\n///         let serialized_member_len = <u32 as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         serialized_params\n///     }\n/// }\n/// ```\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n\n    // We care only about the name and type so we drop the last item of the tuple\n    let params = nested_struct.0.fields(nested_struct.1).map(|(name, typ, _)| (name, typ));\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Serialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_serialize_clause = get_where_trait_clause(s, quote {Serialize});\n\n    let (function_body, params_len_quote, serialized_params_name) =\n        derive_serialization_quotes(params, true);\n\n    quote {\n        impl$generics_declarations $crate::traits::Serialize for $typ\n            $where_serialize_clause\n        {\n            let N: u32 = $params_len_quote;\n\n            #[inline_always]\n            fn serialize(self) -> [Field; Self::N] {\n                $function_body\n\n                $serialized_params_name\n            }\n        }\n    }\n}\n\n/// Generates a `Deserialize` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Deserialize` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Deserialize for MyStruct {\n///     let N: u32 = <AztecAddress as Deserialize>::N + <Field as Deserialize>::N;\n///\n///     fn deserialize(serialized: [Field; Self::N]) -> Self {\n///         let mut offset = 0;\n///         let mut member_fields = [0; <AztecAddress as Deserialize>::N];\n///         for i in 0..<AztecAddress as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let x = <AztecAddress as Deserialize>::deserialize(member_fields);\n///         offset += <AztecAddress as Deserialize>::N;\n///\n///         let mut member_fields = [0; <Field as Deserialize>::N];\n///         for i in 0..<Field as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let y = <Field as Deserialize>::deserialize(member_fields);\n///         offset += <Field as Deserialize>::N;\n///\n///         Self { x, y }\n///     }\n/// }\n/// ```\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Deserialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_deserialize_clause = get_where_trait_clause(s, quote {Deserialize});\n\n    // The following will give us <type_of_struct_member_1 as Deserialize>::N + <type_of_struct_member_2 as Deserialize>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Deserialize>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly deserializing the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // This generates deserialization code for each struct member and concatenates them together.\n        let deserialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as Deserialize>::N];\n                    for i in 0..<$param_type as Deserialize>::N {\n                        member_fields[i] = serialized[i + offset];\n                    }\n                    let $param_name = <$param_type as Deserialize>::deserialize(member_fields);\n                    offset += <$param_type as Deserialize>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        // This will give us e.g. `a, b, c` for a struct with three fields named `a`, `b`, and `c`.\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n\n            $deserialization_of_struct_members\n\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Deserialize::deserialize(serialized) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Deserialize for $typ\n            $where_deserialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn deserialize(serialized: [Field; Self::N]) -> Self {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Packable` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Packable` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Packable for MyStruct {\n///     let N: u32 = 2;\n///\n///     fn pack(self) -> [Field; 2] {\n///         let mut result: [Field; 2] = [0_Field; 2];\n///         let mut offset: u32 = 0_u32;\n///         let packed_member: [Field; 1] = self.x.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         let packed_member: [Field; 1] = self.y.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         result\n///     }\n///\n///     fn unpack(packed: [Field; 2]) -> Self {\n///         let mut offset: u32 = 0_u32;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<AztecAddress as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let x: AztecAddress = <AztecAddress as Packable>::unpack(member_fields);\n///         offset = offset + <AztecAddress as Packable>::N;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<Field as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let y: Field = <Field as Packable>::unpack(member_fields);\n///         offset = offset + <Field as Packable>::N;\n///         Self { x: x, y: y }\n///     }\n/// }\n/// ```\npub comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Packable` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_packable_clause = get_where_trait_clause(s, quote {Packable});\n\n    // The following will give us <type_of_struct_member_1 as Packable>::N + <type_of_struct_member_2 as Packable>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Packable>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly returning the packed member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let pack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate packing code that:\n        // 1. Packs each member\n        // 2. Copies the packed fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let packing_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let packed_member = $crate::traits::Packable::pack(self.$param_name);\n                    let packed_member_len = <$param_type as $crate::traits::Packable>::N;\n                    for i in 0..packed_member_len {\n                        result[i + offset] = packed_member[i];\n                    }\n                    offset += packed_member_len;\n                }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; Self::N];\n            let mut offset = 0;\n\n            $packing_of_struct_members\n\n            result\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Packable::pack(self.$param_name)\n        }\n    };\n\n    // For structs containing a single member, we can enhance performance by directly unpacking the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let unpack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate unpacking code that:\n        // 1. Unpacks each member\n        // 2. Copies packed fields into member array at correct offset\n        // 3. Updates offset for next member\n        let unpacking_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as $crate::traits::Packable>::N];\n                    for i in 0..<$param_type as $crate::traits::Packable>::N {\n                        member_fields[i] = packed[i + offset];\n                    }\n                    let $param_name = <$param_type as $crate::traits::Packable>::unpack(member_fields);\n                    offset += <$param_type as $crate::traits::Packable>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n            $unpacking_of_struct_members\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Packable::unpack(packed) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Packable for $typ\n            $where_packable_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn pack(self) -> [Field; Self::N] {\n                $pack_function_body\n            }\n\n            #[inline_always]\n            fn unpack(packed: [Field; Self::N]) -> Self {\n                $unpack_function_body\n            }\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Packable, Serialize};\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Smol {\n        a: Field,\n        b: Field,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct HasArray {\n        a: [Field; 2],\n        b: bool,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct Fancier {\n        a: Smol,\n        b: [Field; 2],\n        c: [u8; 3],\n        d: str<16>,\n    }\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct HasArrayWithGenerics<T, let N: u32> {\n        pub fields: [T; N],\n        pub length: u32,\n    }\n\n    #[test]\n    fn serde_on_smol() {\n        let smol = Smol { a: 1, b: 2 };\n        let serialized = smol.serialize();\n        assert(serialized == [1, 2], serialized);\n        let deserialized = Smol::deserialize(serialized);\n        assert(deserialized == smol);\n\n        // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n        let packed = smol.pack();\n        assert_eq(packed, serialized, \"Packed does not match serialized\");\n    }\n\n    #[test]\n    fn serde_on_has_array() {\n        let has_array = HasArray { a: [1, 2], b: true };\n        let serialized = has_array.serialize();\n        assert(serialized == [1, 2, 1], serialized);\n        let deserialized = HasArray::deserialize(serialized);\n        assert(deserialized == has_array);\n    }\n\n    #[test]\n    fn serde_on_fancier() {\n        let fancier =\n            Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n        let serialized = fancier.serialize();\n        assert(\n            serialized\n                == [\n                    1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                    0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n                ],\n            serialized,\n        );\n        let deserialized = Fancier::deserialize(serialized);\n        assert(deserialized == fancier);\n    }\n\n    #[test]\n    fn serde_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let serialized = struct_with_array_of_generics.serialize();\n        assert(serialized == [1, 2, 3, 3], serialized);\n        let deserialized = HasArrayWithGenerics::deserialize(serialized);\n        assert(deserialized == struct_with_array_of_generics);\n    }\n\n    #[test]\n    fn packable_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let packed = struct_with_array_of_generics.pack();\n        assert(packed == [1, 2, 3, 3], packed);\n\n        let unpacked = HasArrayWithGenerics::unpack(packed);\n        assert(unpacked == struct_with_array_of_generics);\n    }\n\n}\n"
    },
    "333": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/meta/utils.nr",
      "source": "/// Generates serialization code for a list of parameters and the total length of the serialized array\n///\n/// # Parameters\n/// - `params`: A list of (name, type) tuples to serialize\n/// - `use_self_prefix`: If true, parameters are accessed as `self.$param_name` (for struct members).\n///                      If false, parameters are accessed directly as `$param_name` (for function parameters).\n///\n/// # Returns\n/// A tuple containing:\n/// - Quoted code that serializes the parameters into an array named `serialized_params`\n/// - Quoted code that evaluates to the total length of the serialized array\n/// - Quoted code containing the name of the serialized array\npub comptime fn derive_serialization_quotes(\n    params: [(Quoted, Type)],\n    use_self_prefix: bool,\n) -> (Quoted, Quoted, Quoted) {\n    let prefix_quote = if use_self_prefix {\n        quote { self. }\n    } else {\n        quote {}\n    };\n\n    let params_len_quote = get_params_len_quote(params);\n    let serialized_params_name = quote { serialized_params };\n\n    let body = if params.len() == 0 {\n        quote {\n            let $serialized_params_name: [Field; 0] = [];\n        }\n    } else if params.len() == 1 {\n        // When we have only a single parameter on the input, we can enhance performance by directly returning\n        // the serialized member, bypassing the need for loop-based array construction. While this optimization yields\n        // significant benefits in Brillig where the loops are expected to not be optimized, it is not relevant in ACIR\n        // where the loops are expected to be optimized away.\n\n        let param_name = params[0].0;\n        quote {\n            let $serialized_params_name = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n        }\n    } else {\n        // For multiple struct members, generate serialization code that:\n        // 1. Serializes each member\n        // 2. Copies the serialized fields into the serialize array at the correct offset\n        // 3. Updates the offset for the next member\n        let serialization_of_struct_members = params\n            .map(|(param_name, param_type): (Quoted, Type)| {\n                quote {\n                let serialized_member = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n                let serialized_member_len = <$param_type as $crate::traits::Serialize>::N;\n                for i in 0..serialized_member_len {\n                    $serialized_params_name[i + offset] = serialized_member[i];\n                }\n                offset += serialized_member_len;\n            }\n            })\n            .join(quote {});\n\n        quote {\n            let mut $serialized_params_name = [0; $params_len_quote];\n            let mut offset = 0;\n\n            $serialization_of_struct_members\n        }\n    };\n\n    (body, params_len_quote, serialized_params_name)\n}\n\n/// Generates a quoted expression that computes the total serialized length of function parameters.\n///\n/// # Parameters\n/// * `params` - An array of tuples where each tuple contains a quoted parameter name and its Type. The type needs\n///              to implement the Serialize trait.\n///\n/// # Returns\n/// A quoted expression that evaluates to:\n/// * `0` if there are no parameters\n/// * `(<type1 as Serialize>::N + <type2 as Serialize>::N + ...)` for one or more parameters\npub comptime fn get_params_len_quote(params: [(Quoted, Type)]) -> Quoted {\n    if params.len() == 0 {\n        quote { 0 }\n    } else {\n        let params_quote_without_parentheses = params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n                    <$param_type as $crate::traits::Serialize>::N\n                }\n            })\n            .join(quote {+});\n        quote { ($params_quote_without_parentheses) }\n    }\n}\n"
    },
    "334": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl Serialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn serialize(self: Self) -> [Field; Self::N] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn deserialize(serialized: [Field; Self::N]) -> Self {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] != 0 }\n    }\n}\n\n// TODO(#11356): use compact representation here.\nimpl Packable for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn pack(self) -> [Field; Self::N] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "335": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\nuse crate::traits::{Deserialize, Serialize};\nuse std::meta::derive;\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "342": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::{default::Default, meta::derive};\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nmod test {\n    use crate::{\n        point::POINT_LENGTH,\n        public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n        traits::{Deserialize, Serialize},\n    };\n    use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\n    #[test]\n    unconstrained fn compute_public_keys_hash() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        let actual = keys.hash();\n        let expected_public_keys_hash =\n            0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n        assert(actual.to_field() == expected_public_keys_hash);\n    }\n\n    #[test]\n    unconstrained fn compute_default_hash() {\n        let keys = PublicKeys::default();\n\n        let actual = keys.hash();\n        let test_data_default_hash =\n            0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n        assert(actual.to_field() == test_data_default_hash);\n    }\n\n    #[test]\n    unconstrained fn serde() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        // We use the PUBLIC_KEYS_LENGTH constant to ensure that there is a match between the derived trait\n        let serialized: [Field; POINT_LENGTH * 4] = keys.serialize();\n        let deserialized = PublicKeys::deserialize(serialized);\n\n        assert_eq(keys, deserialized);\n    }\n}\n"
    },
    "347": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "363": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty: Eq {\n    fn empty() -> Self;\n\n    fn is_empty(self) -> bool {\n        self.eq(Self::empty())\n    }\n\n    // Requires this Noir fix: https://github.com/noir-lang/noir/issues/9002\n    // fn assert_not_empty<let U: u32>(self, msg: str<U>) { // This msg version was failing with weird compiler errors.\n    //     // We provide a default impl but it's likely inefficient.\n    //     // The reason we include this function is because there's a lot of\n    //     // opportunity for optimisation on a per-struct basis.\n    //     // You only need to show one element is not empty to know that the whole thing\n    //     // is not empty.\n    //     // If you know an element of your struct which should always be nonempty,\n    //     // you can write an impl that solely checks that that element is nonempty.\n    //     assert(!self.is_empty(), msg);\n    // }\n\n    // This default impl is overwritten by types like arrays, because there's a much\n    // more efficient approach.\n    fn assert_empty<let S: u32>(self, msg: str<S>) {\n        assert(self.is_empty(), msg);\n    }\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u16 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\n\nimpl<T> Empty for [T]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty()]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\nimpl<A, B> Empty for (A, B)\nwhere\n    A: Empty,\n    B: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        (A::empty(), B::empty())\n    }\n}\n\nimpl<T> Empty for Option<T>\nwhere\n    T: Eq,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\n// pub fn is_empty<T>(item: T) -> bool\n// where\n//     T: Empty,\n// {\n//     item.eq(T::empty())\n// }\n\n// pub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\n// where\n//     T: Empty,\n// {\n//     array.all(|elem| is_empty(elem))\n// }\n\n// pub fn assert_empty<T>(item: T) -> ()\n// where\n//     T: Empty,\n// {\n//     assert(item.eq(T::empty()))\n// }\n\n// pub fn assert_empty_array<T, let N: u32>(array: [T; N]) -> ()\n// where\n//     T: Empty,\n// {\n//     // A cheaper option than `is_empty_array` for if you don't need to gracefully\n//     // handle a bool result.\n//     // Avoids the `&` operator of `is_empty_array`'s `.all()` call.\n//     for i in 0..N {\n//         assert(is_empty(array[i]));\n//     }\n// }\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u16 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u16 {\n    fn from_field(value: Field) -> Self {\n        value as u16\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Associated Constants\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize for str<N> {\n///     let N: u32 = N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; Self::N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize {\n    let N: u32;\n\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let M: u32> Serialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; Self::N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n/// Implementation of Deserialize for BoundedVec.\n///\n/// This implementation deserializes a BoundedVec from an array of Fields. The array contains:\n/// 1. The serialized items, each taking up T::N Fields\n/// 2. The length of the BoundedVec as the last Field\n///\n/// # Type Parameters\n/// * `T` - The type of items stored in the BoundedVec, must implement Deserialize\n/// * `M` - The maximum length of the BoundedVec\n///\n/// # Fields Array Layout\n/// [item1_field1, item1_field2, ..., item2_field1, item2_field2, ..., length]\n/// Where:\n/// - itemN_fieldM: The M-th Field of the N-th item (T::N Fields per item)\n/// - length: The number of items in the BoundedVec (1 Field)\n///\n/// Total length N = T::N * M + 1, where:\n/// - T::N is the number of Fields needed to deserialize one item\n/// - M is the maximum length of the BoundedVec\n/// - +1 is for storing the length\n///\n/// # Note\n/// Not deriving this because it's not supported to call derive_deserialize on a \"remote\" struct (and it will never\n/// be supported).\nimpl<T, let M: u32> Deserialize for BoundedVec<T, M>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[<T as Deserialize>::N * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; <T as Deserialize>::N];\n            for j in 0..<T as Deserialize>::N {\n                nested_fields[j] = fields[i * <T as Deserialize>::N + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl Deserialize for () {\n    let N: u32 = 0;\n\n    fn deserialize(_fields: [Field; Self::N]) -> Self {\n        ()\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Serialize for BoundedVec<T, M>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M + 1; // +1 for the length of the BoundedVec\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut fields = [0; Self::N];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..<T as Serialize>::N {\n                fields[i * <T as Serialize>::N + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[<T as Serialize>::N * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Associated Constants\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let M: u32> Deserialize for str<M> {\n///     let N: u32 = M;\n///\n///     #[inline_always]\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         str::<Self::N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize {\n    let N: u32;\n\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let M: u32> Deserialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        str::<Self::N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Associated Constants\n/// * `N` - The length of the Field array, known at compile time\n#[derive_via(derive_packable)]\npub trait Packable {\n    let N: u32;\n\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n"
    },
    "365": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable for bool {\n    let N: u32 = BOOL_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable for u8 {\n    let N: u32 = U8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable for u16 {\n    let N: u32 = U16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable for u32 {\n    let N: u32 = U32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable for u64 {\n    let N: u32 = U64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable for u128 {\n    let N: u32 = U128_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable for Field {\n    let N: u32 = FIELD_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable for i8 {\n    let N: u32 = I8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable for i16 {\n    let N: u32 = I16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable for i32 {\n    let N: u32 = I32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable for i64 {\n    let N: u32 = I64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Packable for [T; M]\nwhere\n    T: Packable,\n{\n    let N: u32 = M * <T as Packable>::N;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized = self[i].pack();\n            for j in 0..<T as Packable>::N {\n                result[i * <T as Packable>::N + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Packable>::N, M>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "366": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal U1_SERIALIZED_LEN: u32 = 1;\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u1\n    }\n}\n\nimpl Serialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self]\n    }\n}\n\nimpl Deserialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Serialize for [T; M]\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; _] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized_t = self[i].serialize();\n            for j in 0..<T as Serialize>::N {\n                result[i * <T as Serialize>::N + j] = serialized_t[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let M: u32> Deserialize for [T; M]\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Deserialize>::N, M>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T> Serialize for Option<T>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N + 1;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..<T as Serialize>::N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T> Deserialize for Option<T>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        if fields[0] == 1 {\n            let mut value_fields = [0; <T as Deserialize>::N];\n            for i in 0..<T as Deserialize>::N {\n                value_fields[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_fields))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n"
    },
    "383": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_padded_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_padded_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod assert_trailing_zeros;\npub mod find_index;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped,\n    assert_array_appended_reversed_to_empty_dest, assert_array_appended_reversed_up_to_some_length,\n    assert_array_appended_to_empty_dest, assert_array_appended_to_empty_dest_and_scoped,\n};\npub use assert_array_prepended::{assert_array_prepended, assert_array_prepended_up_to_some_length};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_padded_array::{\n    assert_sorted_transformed_i_padded_array_capped_size,\n    assert_sorted_transformed_padded_array_capped_size, check_padded_items,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    get_split_order_hints::{get_split_order_hints_asc, SplitOrderHints},\n};\npub use assert_split_transformed_padded_arrays::assert_split_transformed_padded_arrays;\npub use assert_trailing_zeros::assert_trailing_zeros;\npub use find_index::{find_first_index, find_last_index};\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use get_sorted_tuple::{get_sorted_tuple, SortedTuple};\npub use sort_by_counter::sort_by_counter_asc;\n\nuse crate::traits::{Deserialize, Empty, Serialize};\nuse super::for_loop::{for_i_in_0_, for_i_only_in_0_};\n\n//**********************************************************************************\n// ARRAY\n//**********************************************************************************\n\n// TODO: Consider making this a part of the noir stdlib.\n/// Helper fn to create a subarray from a given array.\npub fn subarray<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate.\n// If the element is not found, the function returns Option::none.\n// TODO: Consider making this a part of the noir stdlib.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> Option<u32> {\n    let mut index: Option<u32> = Option::none();\n    for i in 0..N {\n        if find(array[i]) {\n            index = Option::some(i);\n            break;\n        }\n    }\n    index\n}\n\n// Helper function to find the index of the first element (starting from the back) of an array that satisfies a given predicate.\n// If the element is not found, the function returns Option::none.\n// TODO: Consider making this a part of the noir stdlib.\npub unconstrained fn find_index_hint_in_reverse<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> Option<u32> {\n    let mut index: Option<u32> = Option::none();\n    for i in 0..N {\n        let j = N - i - 1;\n        if find(array[j]) {\n            index = Option::some(j);\n            break;\n        }\n    }\n    index\n}\n\n//**********************************************************************************\n// FREE ARRAY FUNCTIONS (to deprecate or make into methods of array wrappers)\n//**********************************************************************************\n\n/// Deprecated.\n///\n/// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n/// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n/// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if array[i].is_empty() {\n            seen_empty = true;\n        } else {\n            assert_eq(seen_empty, false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n/// Deprecated.\n///\n/// Helper function to count the number of non-empty elements in a validated array.\n/// Important: Only use it for validated arrays where validate_array(array) returns true,\n/// which ensures that:\n/// 1. All elements before the first empty element are non-empty\n/// 2. All elements after and including the first empty element are empty\n/// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let maybe_length = unsafe { find_index_hint(array, |elem: T| elem.is_empty()) };\n\n    let mut length = N;\n\n    if maybe_length.is_some() {\n        length = maybe_length.unwrap_unchecked();\n\n        array[length].assert_empty(\"Expected array empty\");\n    }\n\n    if length != 0 {\n        assert(!array[length - 1].is_empty());\n    }\n\n    length\n}\n\n// Returns an array length defined by fully trimming _all_ \"empty\" items\n// from the RHS.\npub unconstrained fn trimmed_array_length_hint<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty,\n{\n    let maybe_index_of_last_nonempty =\n        find_index_hint_in_reverse(array, |elem: T| !elem.is_empty());\n    let length: u32 = if maybe_index_of_last_nonempty.is_some() {\n        1 + maybe_index_of_last_nonempty.unwrap_unchecked()\n    } else {\n        0\n    };\n    length\n}\n\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !elem.is_empty() {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !elem.is_empty() {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n/// Helper function to convert a validated array to BoundedVec.\n/// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Returns the number of consecutive elements at the start of the array for which the predicate returns false.\n// This function ensures that any element after the first matching element (predicate returns true) also matches the predicate.\npub fn array_length_until<T, let N: u32, Env>(array: [T; N], predicate: fn[Env](T) -> bool) -> u32 {\n    let mut length = 0;\n    let mut stop = false;\n    for i in 0..N {\n        if predicate(array[i]) {\n            stop = true;\n        } else {\n            assert(\n                stop == false,\n                \"matching element found after already encountering a non-matching element\",\n            );\n            length += 1;\n        }\n    }\n    length\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to check if an array is padded with a given value from a given index.\n// Different to padded_array_length in that it allows the elements before the given index to be the same as the padded value.\npub fn array_padded_with<T, let N: u32>(array: [T; N], from_index: u32, padded_with: T) -> bool\nwhere\n    T: Eq,\n{\n    let mut is_valid = true;\n    let mut should_check = false;\n    for i in 0..N {\n        should_check |= i == from_index;\n        is_valid &= !should_check | (array[i] == padded_with);\n    }\n    is_valid\n}\n\n//**********************************************************************************\n// ARRAY WRAPPERS\n//**********************************************************************************\n\n/*\n *\n *\n *                                                                                                    \n *                          |-----------------------------------------|------------------------------| \n *                          | LHS                                     | RHS                          |\n *                          |-----------------------------------------|------------------------------|\n *       ClaimedLengthArray | Interspersed 0s possible.               | Unvalidated.                 |\n *                          | Possibly not fully trimmed.             | Nonempty elements possible.  |\n *                          |-----------------------------------------|------------------------------|\n *            EmptyRHSArray | Interspersed 0s possible.               | All 0s (validated).          |\n *                          | Possibly not fully trimmed.             |                              |\n *                          |-----------------------------------------|------------------------------|\n *             TrimmedArray | Interspersed 0s possible.               | All 0s (validated)           |\n *                          | Last lhs element validated as nonempty. |                              |\n *                          | (I.e. fully trimmed)                    |                              |\n *                          |-----------------------------------------|------------------------------|\n *        DenseTrimmedArray | Dense (validated).                      | All 0s (validated)           |\n *                          |-----------------------------------------|------------------------------|\n *\n *\n *                          | What guarantees do we have?                      |\n *                          |--------|--------|--------------------------------| \n *                          | Dense? | RHS    | Length vs Fully Trimmed Length |\n *                          |--------|--------|--------------------------------|\n *       ClaimedLengthArray | ?      | ?      | ?                              |\n *                          |        |        |                                |\n *                          |--------|--------|--------------------------------|\n *            EmptyRHSArray | ?      | All 0s | Length >= Fully Trimmed Length |\n *                          |        |        |                                |\n *                          |--------|--------|--------------------------------|\n *             TrimmedArray | ?      | All 0s | Length == Fully Trimmed Length |\n *                          |        |        |                                |\n *                          |        |        |                                |\n *                          |--------|--------|--------------------------------|\n *        DenseTrimmedArray | Yes    | All 0s | Length == Fully Trimmed Length |\n *                          |--------|--------|--------------------------------|\n *\n *\n * An ClaimedLengthArray is distinct from a regular array [T; N], because it carries a length.\n * \n */\n\n/// ClaimedLengthArray - An array interpreted by Kernel circuits.\n/// Its `length` is merely a claim that must eventually be validated.\n/// Validation must include:\n/// - Asserting all items to the LHS of the length are nonempty (dense).\n/// - Asserting all items to the RHS of the length are empty.\n#[derive(Deserialize, Serialize)]\npub struct ClaimedLengthArray<T, let N: u32> {\n    pub array: [T; N],\n    pub length: u32,\n}\n\nimpl<T, let N: u32> ClaimedLengthArray<T, N>\nwhere\n    T: Empty,\n{\n    // No constructor. Append to an empty one.\n\n    // For constrained append functions, see the dedicated file: assert_array_appended.nr\n\n    pub fn push(&mut self, item: T) {\n        assert(self.length != N, \"Array full\");\n\n        let next_index = self.length;\n        self.array[next_index] = item;\n        self.length += 1;\n    }\n\n    pub fn assert_dense_trimmed(self) {\n        for_i_in_0_(\n            self.length,\n            self.array.len(),\n            |i| {\n                assert(!self.array[i].is_empty(), \"LHS of input array is not dense\")\n                // Requires Noir #9002:\n                // self.array[i].assert_not_empty(\"LHS of input array is not dense\"); // LHS of input array is not dense.\n            },\n            |i| self.array[i].assert_empty(\"RHS of input array is not empty\"),\n            false,\n        );\n    }\n\n    pub fn assert_empty<let S: u32>(self, msg: str<S>) {\n        for i in 0..N {\n            self.array[i].assert_empty(msg);\n        }\n        assert_eq(self.length, 0);\n    }\n\n    pub unconstrained fn push_hint(&mut self, item: T) {\n        assert(self.length != N, \"Array full\");\n\n        let mut next_index = self.length;\n        self.array[next_index] = item;\n        self.length += 1;\n    }\n\n    pub unconstrained fn pop_hint(&mut self) -> T {\n        assert(self.length != 0, \"Array empty\");\n\n        let mut top_index = self.length - 1;\n        let popped_item = self.array[top_index];\n        self.array[top_index] = T::empty();\n        self.length -= 1;\n        popped_item\n    }\n\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        // We pass `false`, because by construction, we should know that self.length <= self.array.len().\n        for_i_only_in_0_(self.length, self.array.len(), |i| f(self.array[i]), false);\n    }\n\n    // E.g.\n    // dest.for_each_i(|source_item, i| { assert_eq(dest.array[i], source_item, \"bad copy\"); })\n    pub fn for_each_i<Env>(self, f: fn[Env](T, u32) -> ()) {\n        // We pass `false`, because by construction, we should know that self.length <= self.array.len().\n        for_i_only_in_0_(\n            self.length,\n            self.array.len(),\n            |i| f(self.array[i], i),\n            false,\n        );\n    }\n\n    pub fn from_bounded_vec(vec: BoundedVec<T, N>) -> Self {\n        Self { array: vec.storage(), length: vec.len() }\n    }\n}\n\n// TODO: compiler bug. No idea why this is needed, if we have #[derive(Eq)] above the struct definition.\nimpl<T, let N: u32> Eq for ClaimedLengthArray<T, N>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        (self.array == other.array) & (self.length == other.length)\n    }\n}\n\nimpl<T, let N: u32> Empty for ClaimedLengthArray<T, N>\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        Self { array: [T::empty(); N], length: 0 }\n    }\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nfn test_array_length_until() {\n    let array = [11, 22, 33, 44, 55];\n    assert_eq(array_length_until(array, |x| x == 55), 4);\n    assert_eq(array_length_until(array, |x| x == 56), 5);\n    assert_eq(array_length_until(array, |x| x > 40), 3);\n    assert_eq(array_length_until(array, |x| x > 10), 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_non_consecutive_fails() {\n    let array = [1, 1, 0, 1, 0];\n    let _ = array_length_until(array, |x| x == 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_first_non_matching_fails() {\n    let array = [1, 0, 0, 0, 0];\n    let _ = array_length_until(array, |x| x == 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let maybe_index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(maybe_index.unwrap_unchecked(), 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let maybe_index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(maybe_index.is_none(), true);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test]\nfn test_array_padded_with() {\n    let array = [11, 22, 33, 44, 44];\n    assert_eq(array_padded_with(array, 0, 44), false);\n    assert_eq(array_padded_with(array, 1, 44), false);\n    assert_eq(array_padded_with(array, 2, 44), false);\n    assert_eq(array_padded_with(array, 3, 44), true);\n    assert_eq(array_padded_with(array, 4, 44), true);\n    assert_eq(array_padded_with(array, 4, 33), false);\n    assert_eq(array_padded_with(array, 5, 44), true); // Index out of bounds.\n    assert_eq(array_padded_with(array, 0, 11), false);\n}\n"
    },
    "384": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "global KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\npub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO: This currently only exists to aid point compression in compress_to_blob_commitment().\n// Once compression is part of BigCurve it can either be removed or optimized to be used elsewhere.\npub fn byte_to_bits_be(byte: u8) -> [u1; 8] {\n    let mut mut_byte = byte;\n    let mut bits: [u1; 8] = [0; 8];\n    for i in 0..8 {\n        bits[7 - i] = (mut_byte & 1) as u1;\n        mut_byte >>= 1;\n    }\n    bits\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n/// Returns Option::some(sqrt) if there is a square root, and Option::none() if there isn't.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\nunconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n\n#[test]\nunconstrained fn sqrt_valid_test() {\n    let x = 16; // examples: 16, 9, 25, 81\n    let result = sqrt(x);\n    assert(result.is_some());\n    assert_eq(result.unwrap() * result.unwrap(), x);\n}\n\n#[test]\nunconstrained fn sqrt_invalid_test() {\n    let x = KNOWN_NON_RESIDUE; // has no square root in the field\n    let result = sqrt(x);\n    assert(result.is_none());\n}\n"
    },
    "388": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_u64(&mut self) -> u64 {\n        self.read() as u64\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert_eq(self.offset, self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "404": {
      "path": "/home/nerses/nargo/github.com/noir-lang/sha256/v0.2.1/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\npub(crate) mod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let (mut h, mut msg_block) = process_full_blocks(msg, message_size, INITIAL_STATE);\n\n        finalize_sha256_blocks::<N>(message_size, h, msg_block)\n    }\n}\n\npub(crate) unconstrained fn __sha_var<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    initial_state: STATE,\n) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = initial_state;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let msg_block = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n\n    finalize_last_sha256_block(h, message_size, msg)\n}\n\n// Helper function to finalize the message block with padding and length\npub(crate) unconstrained fn finalize_last_sha256_block<let N: u32>(\n    mut h: STATE,\n    message_size: u32,\n    msg: [u8; N],\n) -> HASH {\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let num_full_blocks = message_size / BLOCK_SIZE;\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let new_msg_block = build_msg_block(msg, message_size, msg_start);\n        (new_msg_block, modulo)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    __sha_var(msg, message_size, INITIAL_STATE)\n}\n\npub(crate) fn process_full_blocks<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    h: STATE,\n) -> (STATE, MSG_BLOCK) {\n    let num_blocks = N / BLOCK_SIZE;\n\n    // We store the intermediate hash states and message blocks in these two arrays which allows us to select the correct state\n    // for the given message size with a lookup.\n    //\n    // These can be reasoned about as followed:\n    // Consider a message with an unknown number of bytes, `msg_size. It can be seen that this will have `msg_size / BLOCK_SIZE` full blocks.\n    // - `states[i]` should then be the state after processing the first `i` blocks.\n    // - `blocks[i]` should then be the next message block after processing the first `i` blocks.\n    // blocks[first_partially_filled_block_index] is the last block that is partially filled or all 0 if the message is a multiple of the block size.\n    //\n    // In other words:\n    //\n    // blocks = [block 1, block 2, ..., block N / BLOCK_SIZE, block N / BLOCK_SIZE + 1]\n    // states = [INITIAL_STATE, state after block 1, state after block 2, ..., state after block N / BLOCK_SIZE]\n    //\n    // We place the initial state in `states[0]` as in the case where the `message_size < BLOCK_SIZE` then there are no full blocks to process and no compressions should occur.\n    let mut blocks: [MSG_BLOCK; N / BLOCK_SIZE + 1] = std::mem::zeroed();\n    let mut states: [STATE; N / BLOCK_SIZE + 1] = [h; N / BLOCK_SIZE + 1];\n\n    // Optimization for small messages. If the largest possible message is smaller than a block then we know that the first block is partially filled\n    // no matter the value of `message_size`.\n    //\n    // Note that the condition `N >= BLOCK_SIZE` is known during monomorphization so this has no runtime cost.\n    let first_partially_filled_block_index = if N >= BLOCK_SIZE {\n        message_size / BLOCK_SIZE\n    } else {\n        0\n    };\n\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let new_msg_block =\n            // Safety: separate verification function\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        // Verify the block we are compressing was appropriately constructed\n        verify_msg_block(msg, message_size, new_msg_block, msg_start);\n\n        blocks[i] = new_msg_block;\n        states[i + 1] = sha256_compression(new_msg_block, states[i]);\n    }\n    // If message_size/BLOCK_SIZE == N/BLOCK_SIZE, and there is a remainder, we need to process the last block.\n    if N % BLOCK_SIZE != 0 {\n        let new_msg_block =\n            // Safety: separate verification function\n            unsafe { build_msg_block(msg, message_size, BLOCK_SIZE * num_blocks) };\n\n        // Verify the block we are compressing was appropriately constructed\n        verify_msg_block(msg, message_size, new_msg_block, BLOCK_SIZE * num_blocks);\n\n        blocks[num_blocks] = new_msg_block;\n    }\n\n    // verify the 0 padding is correct for the last block\n    let final_block = blocks[first_partially_filled_block_index];\n    verify_msg_block_zeros(final_block, message_size % BLOCK_SIZE, INT_BLOCK_SIZE);\n    (states[first_partially_filled_block_index], final_block)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start` and pack them into a `MSG_BLOCK`.\npub(crate) unconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> MSG_BLOCK {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let int_input = (block_input + INT_SIZE - 1) / INT_SIZE;\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = (msg_item << 8) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    msg_block\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) {\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = msg_item << 8;\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n        }\n    }\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, 0);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], 0);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = msg_item << 8;\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u32) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = (item << 8) + b1 as u32;\n    item = (item << 8) + b2 as u32;\n    item = (item << 8) + b3 as u32;\n    item\n}\n\nglobal BIT_SHIFT_TABLE: [u32; 4] = [1, TWO_POW_8, TWO_POW_16, TWO_POW_24];\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u32) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        if shifts == 4 {\n            0\n        } else {\n            item * BIT_SHIFT_TABLE[shifts]\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\n#[inline_always]\nfn rshift8(item: u32, shifts: u32) -> u32 {\n    if is_unconstrained() {\n        if shifts >= 4 {\n            0\n        } else {\n            item >> (8 * shifts)\n        }\n    } else {\n        if shifts == 4 {\n            0\n        } else {\n            item / BIT_SHIFT_TABLE[shifts]\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    msg_block[INT_SIZE_PTR] = (len_bytes[0] as u32) << 24\n        | (len_bytes[1] as u32) << 16\n        | (len_bytes[2] as u32) << 8\n        | (len_bytes[3] as u32);\n\n    msg_block[INT_SIZE_PTR + 1] = (len_bytes[4] as u32) << 24\n        | (len_bytes[5] as u32) << 16\n        | (len_bytes[6] as u32) << 8\n        | (len_bytes[7] as u32);\n\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    std::static_assert(\n        INT_SIZE_PTR + 2 == INT_BLOCK_SIZE,\n        \"INT_SIZE_PTR + 2 must equal INT_BLOCK_SIZE\",\n    );\n    let reconstructed_len_hi = msg_block[INT_SIZE_PTR] as Field;\n    let reconstructed_len_lo = msg_block[INT_SIZE_PTR + 1] as Field;\n\n    let reconstructed_len: Field =\n        reconstructed_len_hi * TWO_POW_32 as Field + reconstructed_len_lo;\n    let len = 8 * (message_size as Field);\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\npub(crate) fn finalize_sha256_blocks<let N: u32>(\n    message_size: u32,\n    mut h: STATE,\n    mut msg_block: MSG_BLOCK,\n) -> HASH {\n    let mut msg_byte_ptr = message_size % BLOCK_SIZE;\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    // Safety: separate verification function\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n/**\n * Given some state of a partially computed sha256 hash and part of the preimage, continue hashing\n * @notice used for complex/ recursive offloading of post-partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the preimage to hash\n * @param message_size - the actual length of the preimage to hash\n * @return the intermediate hash state after compressing in msg to h\n */\npub fn partial_sha256_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    if std::runtime::is_unconstrained() {\n        // Safety: running as an unconstrained function\n        unsafe {\n            __sha_partial_var_interstitial(h, msg, message_size)\n        }\n    } else {\n        let (mut h, _) = process_full_blocks(msg, message_size, h);\n\n        h\n    }\n}\n\n/**\n * Given some state of a partially computed sha256 hash and remaining preimage, complete the hash\n * @notice used for traditional partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the remaining preimage to hash\n * @param message_size - the size of the current chunk\n * @param real_message_size - the total size of the original preimage\n * @return finalized sha256 hash\n */\npub fn partial_sha256_var_end<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n    real_message_size: u32,\n) -> [u8; 32] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    if std::runtime::is_unconstrained() {\n        // Safety: running as an unconstrained function\n        unsafe {\n            h = __sha_partial_var_interstitial(h, msg, message_size);\n\n            // Handle setup of the final msg block.\n            // This case is only hit if the msg is less than the block size,\n            // or our message cannot be evenly split into blocks.\n\n            finalize_last_sha256_block(h, real_message_size, msg)\n        }\n    } else {\n        let (mut h, mut msg_block) = process_full_blocks(msg, message_size, h);\n        finalize_sha256_blocks::<N>(real_message_size, h, msg_block)\n    }\n}\n\nunconstrained fn __sha_partial_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let msg_block = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n    h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        // Safety: test function\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "425": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    history::nullifier_inclusion::ProveNullifierInclusion,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{\n            GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER,\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT, PRIVATE_LOG_SIZE_IN_FIELDS,\n        },\n        hash::{compute_siloed_nullifier, poseidon2_hash_with_separator},\n        traits::{Deserialize, FromField, Hash, Packable, Serialize, ToField},\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[derive(Deserialize, Eq, Serialize, Packable)]\n#[custom_note]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullification: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullification, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(\n        self,\n        note_hash_for_nullification: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullification, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    pub fn get_owner(self) -> AztecAddress {\n        self.owner\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// This function inserts a partial note validity commitment into the nullifier tree to be later on able to verify\n    /// that the partial note and completer are legitimate. See function docs of `compute_validity_commitment` for more\n    /// details.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` so that they can discover the\n    /// note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        completer: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content =\n            UintPartialNotePrivateLogContent { owner, randomness, public_log_tag: commitment };\n\n        let encrypted_log = note::compute_partial_note_private_content_log(\n            private_log_content,\n            storage_slot,\n            recipient,\n        );\n        // Regardless of the original content size, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_private_log(encrypted_log, length);\n\n        let partial_note = PartialUintNote { commitment };\n\n        // Now we compute the validity commitment and push it to the nullifier tree. It can be safely pushed to\n        // the nullifier tree since it uses its own separator, making collisions with actual note nullifiers\n        // practically impossible.\n        let validity_commitment = partial_note.compute_validity_commitment(completer);\n        context.push_nullifier(validity_commitment);\n\n        partial_note\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            self.pack().concat([storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct UintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for UintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nglobal NOTE_COMPLETION_LOG_LENGTH: u32 = 2;\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, context: &mut PublicContext, completer: AztecAddress, value: u128) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        assert(\n            context.nullifier_exists(validity_commitment, context.this_address()),\n            \"Invalid partial note or completer\",\n        );\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Completes the partial note, creating a new note that can be used like any other UintNote. Same as `complete`\n    /// function but works from private context.\n    pub fn complete_from_private(\n        self,\n        context: &mut PrivateContext,\n        completer: AztecAddress,\n        value: u128,\n    ) {\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        // `prove_nullifier_inclusion` function expects the nullifier to be siloed (hashed with the address of\n        // the contract that emitted the nullifier) as it checks the value directly against the nullifier tree and all\n        // the nullifiers in the tree are siloed by the protocol.\n        let siloed_validity_commitment =\n            compute_siloed_nullifier(context.this_address(), validity_commitment);\n        context.get_anchor_block_header().prove_nullifier_inclusion(siloed_validity_commitment);\n\n        // We need to do two things:\n        //  - emit an unencrypted log containing the public fields (the value) via the private log channel. The\n        //  contract will later find it by searching for the expected tag (which is simply the partial note\n        //  commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_private_log(\n            self.compute_note_completion_log_padded_for_private_log(value),\n            NOTE_COMPLETION_LOG_LENGTH,\n        );\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Computes a validity commitment for this partial note. The commitment cryptographically binds the note's private\n    /// data with the designated completer address. When the note is later completed in public execution, we can load\n    /// this commitment from the nullifier tree and verify that both the partial note (e.g. that the storage slot\n    /// corresponds to the correct owner, and that we're using the correct state variable) and completer are\n    /// legitimate.\n    pub fn compute_validity_commitment(self, completer: AztecAddress) -> Field {\n        poseidon2_hash_with_separator(\n            [self.commitment, completer.to_field()],\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT,\n        )\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; NOTE_COMPLETION_LOG_LENGTH] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_note_completion_log_padded_for_private_log(\n        self,\n        value: u128,\n    ) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n        let note_completion_log = self.compute_note_completion_log(value);\n        let padding = [0; PRIVATE_LOG_SIZE_IN_FIELDS - NOTE_COMPLETION_LOG_LENGTH];\n        note_completion_log.concat(padding)\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nimpl ToField for PartialUintNote {\n    fn to_field(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl FromField for PartialUintNote {\n    fn from_field(field: Field) -> Self {\n        Self { commitment: field }\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, UintNote, UintPartialNotePrivateContent, UintPartialNotePrivateLogContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{address::AztecAddress, traits::{Deserialize, FromField, Packable}},\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content =\n            UintPartialNotePrivateLogContent { owner, randomness, public_log_tag: commitment };\n        // The following is a misuse of the `deserialize` function, but this is just a test and it's better than\n        // letting devs manually construct it when they shouldn't be able to.\n        let partial_note = PartialUintNote::deserialize([commitment]);\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(private_log_without_public_tag.concat(public_log_without_tag), note.pack());\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n"
    },
    "50": {
      "path": "/home/nerses/contracts/chains/aztec/contracts/train/src/lib.nr",
      "source": "pub fn bytes_to_u128_limbs(bytes: [u8; 32]) -> (u128, u128) {\n    let mut high: u128 = 0;\n    let mut low: u128 = 0;\n    for i in 0..16 {\n        high = (high << 8) + (bytes[i] as u128);\n    }\n    for i in 16..32 {\n        low = (low << 8) + (bytes[i] as u128);\n    }\n    (high, low)\n}\n\npub fn u128_limbs_to_bytes(high: u128, low: u128) -> [u8; 32] {\n    let mut bytes: [u8; 32] = [0; 32];\n\n    let mut temp = high;\n    for i in 0..16 {\n        bytes[15 - i] = (temp & 0xff) as u8;\n        temp >>= 8;\n    }\n\n    temp = low;\n    for i in 0..16 {\n        bytes[31 - i] = (temp & 0xff) as u8;\n        temp >>= 8;\n    }\n\n    bytes\n}\n"
    },
    "51": {
      "path": "/home/nerses/contracts/chains/aztec/contracts/train/src/main.nr",
      "source": "//     @@                                    @@@\n//    @@@\n//    @@@        @@   @@@@      @@@@@         @     @    @@@@@\n//  @@@@@@@@@   @@@@@@      @@@@    @@@@@    @@@   @@@@@@    @@@@\n//    @@@       @@@       @@@           @@@  @@@   @@@          @@@\n//    @@@       @@@       @@@           @@@  @@@   @@@          @@@\n//    @@@       @@@       @@@           @@@  @@@   @@@          @@@\n//     @@@      @@@        @@@@       @@@@@  @@@   @@@          @@@\n//       @@@@@  @@@           @@@@@@@@@ @@@  @@@   @@@          @@@\n\nmod lib;\nmod types;\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract Train {\n    use std::meta::derive;\n\n    use aztec::macros::{\n        functions::{external, initializer, internal, view},\n        notes::note,\n        storage::storage,\n    };\n\n    use dep::aztec::{\n        messages::message_delivery::MessageDelivery,\n        protocol_types::{address::AztecAddress, traits::{Deserialize, Packable, Serialize}},\n        state_vars::{DelayedPublicMutable, map::Map, private_immutable::PrivateImmutable},\n    };\n    use dep::sha256;\n    use dep::token::Token;\n\n    use crate::lib::{bytes_to_u128_limbs, u128_limbs_to_bytes};\n    use crate::types::events::{\n        TokenCommitted, TokenLockAdded, TokenLockedFirst, TokenLockedSecond, TokenRedeemed,\n        TokenRefunded,\n    };\n\n    #[derive(Packable)]\n    #[note]\n    #[derive(Eq)]\n    struct HTLC_Private {\n        owner: AztecAddress,\n        randomness: Field,\n    }\n    #[derive(Eq, Packable, Serialize, Deserialize)]\n    pub struct HTLC_Public {\n        src_receiver: AztecAddress,\n        amount: u128,\n        token: AztecAddress,\n        hashlock_high: u128,\n        hashlock_low: u128,\n        secret_high: u128,\n        secret_low: u128,\n        ownership_hash_high: u128,\n        ownership_hash_low: u128,\n        timelock: u64,\n        claimed: u8,\n    }\n\n    #[external(\"public\")]\n    #[initializer]\n    fn constructor() {}\n\n    #[storage]\n    struct Storage<Context> {\n        contracts_private: Map<Field, PrivateImmutable<HTLC_Private, Context>, Context>,\n        contracts_public: Map<Field, DelayedPublicMutable<HTLC_Public, 180, Context>, Context>,\n    }\n\n    #[external(\"private\")]\n    fn commit_private_user(\n        Id: Field,\n        src_receiver: AztecAddress,\n        timelock: u64,\n        token: AztecAddress,\n        amount: u128,\n        src_asset: str<30>,\n        dst_chain: str<30>,\n        dst_asset: str<30>,\n        dst_address: str<90>,\n        randomness: Field,\n    ) {\n        assert(amount > 0, \"FundsNotSent\");\n\n        // Safety: The contract intentionally exposes these parameters as external(\"public\").\n        Train::at(context.this_address())\n            .commit_public_user(\n                src_asset,\n                dst_chain,\n                dst_asset,\n                dst_address,\n                Id,\n                src_receiver,\n                timelock,\n                token,\n                amount,\n            )\n            .enqueue(&mut context);\n\n        let htlc_note = HTLC_Private {\n            owner: context.msg_sender().expect(f\"Sender must not be none!\"),\n            randomness: randomness,\n        };\n        storage.contracts_private.at(Id).initialize(htlc_note).emit(\n            context.msg_sender().expect(f\"Sender must not be none!\"),\n            MessageDelivery.CONSTRAINED_ONCHAIN,\n        );\n\n        Token::at(token)\n            .transfer_to_public(\n                context.msg_sender().expect(f\"Sender must not be none!\"),\n                context.this_address(),\n                amount,\n                randomness,\n            )\n            .call(&mut context);\n    }\n\n    #[internal]\n    #[external(\"public\")]\n    fn commit_public_user(\n        src_asset: str<30>,\n        dst_chain: str<30>,\n        dst_asset: str<30>,\n        dst_address: str<90>,\n        Id: Field,\n        src_receiver: AztecAddress,\n        timelock: u64,\n        token: AztecAddress,\n        amount: u128,\n    ) {\n        let htlc_public_current = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public_current.amount == 0, \"HTLCAlreadyExists\");\n        assert(context.timestamp() + 900 < timelock, \"InvalidTimelock\");\n        let htlc_public = HTLC_Public {\n            src_receiver: src_receiver,\n            amount: amount,\n            token: token,\n            hashlock_high: 0 as u128,\n            hashlock_low: 0 as u128,\n            secret_high: 0 as u128,\n            secret_low: 0 as u128,\n            ownership_hash_high: 0 as u128,\n            ownership_hash_low: 0 as u128,\n            timelock: timelock,\n            claimed: 1 as u8,\n        };\n        storage.contracts_public.at(Id).schedule_value_change(htlc_public);\n        let log_msg = TokenCommitted {\n            Id: Id,\n            amount: amount,\n            token: token,\n            timelock: timelock,\n            src_receiver: src_receiver,\n            src_asset: src_asset,\n            dst_chain: dst_chain,\n            dst_asset: dst_asset,\n            dst_address: dst_address,\n        };\n\n        context.emit_public_log(log_msg.pack());\n    }\n\n    #[external(\"private\")]\n    fn add_lock_private_user(Id: Field, hashlock_high: u128, hashlock_low: u128, timelock: u64) {\n        let hashlock = u128_limbs_to_bytes(hashlock_high, hashlock_low);\n        let htlc_private = storage.contracts_private.at(Id).get_note();\n        assert(\n            htlc_private.owner == context.msg_sender().expect(f\"Sender must not be none!\"),\n            \"NoAllowance\",\n        );\n\n        // Safety: The contract intentionally exposes these parameters as external(\"public\").\n        Train::at(context.this_address()).add_lock_public_user(Id, hashlock, timelock).enqueue(\n            &mut context,\n        );\n    }\n\n    #[internal]\n    #[external(\"public\")]\n    fn add_lock_public_user(Id: Field, hashlock: [u8; 32], timelock: u64) {\n        assert(context.timestamp() + 900 < timelock, \"InvalidTimelock\");\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n        assert(htlc_public.hashlock_high == (0 as u128), \"HashlockAlreadySet\");\n        assert(htlc_public.hashlock_low == (0 as u128), \"HashlockAlreadySet\");\n\n        let hashlock_tuple = bytes_to_u128_limbs(hashlock);\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: hashlock_tuple.0,\n            hashlock_low: hashlock_tuple.1,\n            secret_high: htlc_public.secret_high,\n            secret_low: htlc_public.secret_low,\n            ownership_hash_high: htlc_public.ownership_hash_high,\n            ownership_hash_low: htlc_public.ownership_hash_low,\n            timelock: timelock,\n            claimed: htlc_public.claimed,\n        };\n        storage.contracts_public.at(Id).schedule_value_change(modified_htlc_public);\n        let log_msg = TokenLockAdded { Id, hashlock, timelock };\n        context.emit_public_log(log_msg.pack());\n    }\n\n    #[external(\"private\")]\n    fn refund_private(Id: Field) {\n        // Safety: The contract intentionally exposes these parameters as external(\"public\").\n        Train::at(context.this_address()).refund_public(Id).enqueue(&mut context);\n\n        let htlc_private = storage.contracts_private.at(Id).get_note();\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n\n        let partial_note = Token::at(htlc_public.token)\n            .prepare_private_balance_increase(htlc_private.owner)\n            .call(&mut context);\n        Token::at(htlc_public.token)\n            .finalize_transfer_to_private(htlc_public.amount, partial_note)\n            .enqueue(&mut context);\n    }\n\n    #[external(\"public\")]\n    #[internal]\n    fn refund_public(Id: Field) {\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n        assert(htlc_public.timelock < context.timestamp(), \"NotPassedTimelock\");\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: htlc_public.hashlock_high,\n            hashlock_low: htlc_public.hashlock_low,\n            secret_high: htlc_public.secret_high,\n            secret_low: htlc_public.secret_low,\n            ownership_hash_high: htlc_public.ownership_hash_high,\n            ownership_hash_low: htlc_public.ownership_hash_low,\n            timelock: htlc_public.timelock,\n            claimed: 2 as u8,\n        };\n\n        storage.contracts_public.at(Id).schedule_value_change(modified_htlc_public);\n        let log_msg = TokenRefunded { Id };\n        context.emit_public_log(log_msg.pack());\n    }\n\n    #[external(\"private\")]\n    fn lock_private_solver(\n        Id: Field,\n        hashlock_high: u128,\n        hashlock_low: u128,\n        amount: u128,\n        ownership_hash_high: u128,\n        ownership_hash_low: u128,\n        timelock: u64,\n        token: AztecAddress,\n        randomness: Field,\n        src_asset: str<30>,\n        dst_chain: str<30>,\n        dst_asset: str<30>,\n        dst_address: str<90>,\n    ) {\n        assert(amount > 0, \"FundsNotSent\");\n        let hashlock = u128_limbs_to_bytes(hashlock_high, hashlock_low);\n        let ownership_hash = u128_limbs_to_bytes(ownership_hash_high, ownership_hash_low);\n        // Safety: The contract intentionally exposes these parameters as external(\"public\").\n        Train::at(context.this_address())\n            .lock_public_solver(\n                Id,\n                hashlock,\n                ownership_hash,\n                amount,\n                token,\n                timelock,\n                src_asset,\n                dst_chain,\n                dst_asset,\n                dst_address,\n            )\n            .enqueue(&mut context);\n\n        let htlc_note = HTLC_Private {\n            owner: context.msg_sender().expect(f\"Sender must not be none!\"),\n            randomness: randomness,\n        };\n        storage.contracts_private.at(Id).initialize(htlc_note).emit(\n            context.msg_sender().expect(f\"Sender must not be none!\"),\n            MessageDelivery.CONSTRAINED_ONCHAIN,\n        );\n\n        Token::at(token)\n            .transfer_to_public(\n                context.msg_sender().expect(f\"Sender must not be none!\"),\n                context.this_address(),\n                amount,\n                randomness,\n            )\n            .call(&mut context);\n    }\n\n    #[internal]\n    #[external(\"public\")]\n    fn lock_public_solver(\n        Id: Field,\n        hashlock: [u8; 32],\n        ownership_hash: [u8; 32],\n        amount: u128,\n        token: AztecAddress,\n        timelock: u64,\n        src_asset: str<30>,\n        dst_chain: str<30>,\n        dst_asset: str<30>,\n        dst_address: str<90>,\n    ) {\n        let htlc_public_current = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public_current.amount == 0, \"HTLCAlreadyExists\");\n        assert(context.timestamp() + 1800 < timelock, \"InvalidTimelock\");\n        let hashlock_tuple = bytes_to_u128_limbs(hashlock);\n        let ownership_hash_tuple = bytes_to_u128_limbs(ownership_hash);\n        let htlc_public = HTLC_Public {\n            src_receiver: AztecAddress::zero(),\n            amount: amount,\n            token: token,\n            hashlock_high: hashlock_tuple.0,\n            hashlock_low: hashlock_tuple.1,\n            secret_high: 0 as u128,\n            secret_low: 0 as u128,\n            ownership_hash_high: ownership_hash_tuple.0,\n            ownership_hash_low: ownership_hash_tuple.1,\n            timelock: timelock,\n            claimed: 1 as u8,\n        };\n        storage.contracts_public.at(Id).schedule_value_change(htlc_public);\n\n        let log_msg_1 = TokenLockedFirst {\n            Id: Id,\n            amount: amount,\n            token: token,\n            timelock: timelock,\n            src_receiver: AztecAddress::zero(),\n            src_asset: src_asset,\n            dst_chain: dst_chain,\n            dst_asset: dst_asset,\n            dst_address: dst_address,\n        };\n\n        let log_msg_2 =\n            TokenLockedSecond { Id: Id, hashlock: hashlock, ownership_hash: ownership_hash };\n\n        context.emit_public_log(log_msg_1.pack());\n        context.emit_public_log(log_msg_2.pack());\n    }\n\n    #[external(\"private\")]\n    fn redeem_private(\n        Id: Field,\n        secret_high: u128,\n        secret_low: u128,\n        ownership_key_high: u128,\n        ownership_key_low: u128,\n    ) {\n        let secret = u128_limbs_to_bytes(secret_high, secret_low);\n        let ownership_key = u128_limbs_to_bytes(ownership_key_high, ownership_key_low);\n\n        // Safety: The contract intentionally exposes these parameters as external(\"public\").\n        Train::at(context.this_address()).redeem_public(Id, secret, ownership_key).enqueue(\n            &mut context,\n        );\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n        if (htlc_public.ownership_hash_high == 0 as u128) {\n            if htlc_public.ownership_hash_low == 0 as u128 {\n                let partial_note = Token::at(htlc_public.token)\n                    .prepare_private_balance_increase(htlc_public.src_receiver)\n                    .call(&mut context);\n                Token::at(htlc_public.token)\n                    .finalize_transfer_to_private(htlc_public.amount, partial_note)\n                    .enqueue(&mut context);\n            }\n        } else {\n            let partial_note = Token::at(htlc_public.token)\n                .prepare_private_balance_increase(context.msg_sender().expect(\n                    f\"Sender must not be none!\",\n                ))\n                .call(&mut context);\n            Token::at(htlc_public.token)\n                .finalize_transfer_to_private(htlc_public.amount, partial_note)\n                .enqueue(&mut context);\n        }\n    }\n\n    #[external(\"public\")]\n    #[internal]\n    fn redeem_public(Id: Field, secret: [u8; 32], ownership_key: [u8; 32]) {\n        let mut htlc_public = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public.amount > 0, \"HTLCNotExists\"); // If it doesn't exist, all parameters will default to zero values.\n        let hashed_secret = sha256::sha256_var(secret, secret.len() as u64);\n        let hashed_secret_tuple = bytes_to_u128_limbs(hashed_secret);\n        assert(htlc_public.hashlock_high == hashed_secret_tuple.0, \"HashlockNotMatch\");\n        assert(htlc_public.hashlock_low == hashed_secret_tuple.1, \"HashlockNotMatch\");\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n\n        if (htlc_public.ownership_hash_high != 0 as u128) {\n            if htlc_public.ownership_hash_low != 0 as u128 {\n                let ownership_key_hashed =\n                    sha256::sha256_var(ownership_key, ownership_key.len() as u64);\n                let ownership_key_tuple = bytes_to_u128_limbs(ownership_key_hashed);\n                assert(htlc_public.ownership_hash_high == ownership_key_tuple.0, \"NotAnOwner\");\n                assert(htlc_public.ownership_hash_low == ownership_key_tuple.1, \"NotAnOwner\");\n            }\n        }\n\n        let secret_limbs = bytes_to_u128_limbs(secret);\n\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: htlc_public.hashlock_high,\n            hashlock_low: htlc_public.hashlock_low,\n            secret_high: secret_limbs.0,\n            secret_low: secret_limbs.1,\n            ownership_hash_high: htlc_public.ownership_hash_high,\n            ownership_hash_low: htlc_public.ownership_hash_low,\n            timelock: htlc_public.timelock,\n            claimed: 3 as u8,\n        };\n\n        storage.contracts_public.at(Id).schedule_value_change(modified_htlc_public);\n\n        let log_msg = TokenRedeemed {\n            Id: Id,\n            hashlock: u128_limbs_to_bytes(htlc_public.hashlock_high, htlc_public.hashlock_low),\n            secret: secret,\n        };\n\n        context.emit_public_log(log_msg.pack());\n    }\n\n    // This external(\"utility\") function should be invoked by the frontend before each function call\n    // where the existence or non-existence of an HTLC is a critical security check.\n    #[external(\"utility\")]\n    unconstrained fn is_contract_initialized(id: Field) -> bool {\n        storage.contracts_private.at(id).is_initialized()\n    }\n\n    #[view]\n    #[external(\"public\")]\n    fn get_htlc_public(key: Field) -> pub HTLC_Public {\n        storage.contracts_public.at(key).get_current_value()\n    }\n}\n"
    },
    "52": {
      "path": "/home/nerses/contracts/chains/aztec/contracts/train/src/types/events.nr",
      "source": "use crate::lib::{bytes_to_u128_limbs, u128_limbs_to_bytes};\nuse dep::aztec::protocol_types::address::AztecAddress;\nuse dep::aztec::protocol_types::traits::{Packable, Serialize};\n\n#[derive(Serialize)]\npub struct TokenCommitted {\n    pub Id: Field,\n    pub amount: u128,\n    pub token: AztecAddress,\n    pub timelock: u64,\n    pub src_receiver: AztecAddress,\n    pub src_asset: str<30>,\n    pub dst_chain: str<30>,\n    pub dst_asset: str<30>,\n    pub dst_address: str<90>,\n}\n\nimpl Packable for TokenCommitted {\n    let N: u32 = 12;\n    fn pack(self) -> [Field; Self::N] {\n        let zero: Field = 0;\n        let mut out = [zero; 12];\n        out[0] = 0x7A3F2B1C;\n        out[1] = self.Id;\n        out[2] = self.amount as Field;\n        out[3] = self.token.inner;\n        out[4] = self.timelock as Field;\n        out[5] = self.src_receiver.inner;\n\n        let src_asset_byte_array = self.src_asset.as_bytes();\n        let mut src_asset_byte_array_filled = [0 as u8; 30];\n        for i in 0..src_asset_byte_array.len() {\n            src_asset_byte_array_filled[i] = src_asset_byte_array[i];\n        }\n        out[6] = Field::from_be_bytes::<30>(src_asset_byte_array_filled);\n\n        let dst_chain_byte_array = self.dst_chain.as_bytes();\n        let mut dst_chain_byte_array_filled = [0 as u8; 30];\n        for i in 0..dst_chain_byte_array.len() {\n            dst_chain_byte_array_filled[i] = dst_chain_byte_array[i];\n        }\n        out[7] = Field::from_be_bytes::<30>(dst_chain_byte_array_filled);\n\n        let dst_asset_byte_array = self.dst_asset.as_bytes();\n        let mut dst_asset_byte_array_filled = [0 as u8; 30];\n        for i in 0..dst_asset_byte_array.len() {\n            dst_asset_byte_array_filled[i] = dst_asset_byte_array[i];\n        }\n        out[8] = Field::from_be_bytes::<30>(dst_asset_byte_array_filled);\n\n        let dst_address_byte_array = self.dst_address.as_bytes();\n        let mut dst_address_byte_array_filled_1 = [0 as u8; 30];\n        let mut dst_address_byte_array_filled_2 = [0 as u8; 30];\n        let mut dst_address_byte_array_filled_3 = [0 as u8; 30];\n\n        for i in 0..30 {\n            dst_address_byte_array_filled_1[i] = dst_address_byte_array[i];\n            dst_address_byte_array_filled_2[i] = dst_address_byte_array[i + 30];\n            dst_address_byte_array_filled_3[i] = dst_address_byte_array[i + 60];\n        }\n\n        out[9] = Field::from_be_bytes::<30>(dst_address_byte_array_filled_1);\n        out[10] = Field::from_be_bytes::<30>(dst_address_byte_array_filled_2);\n        out[11] = Field::from_be_bytes::<30>(dst_address_byte_array_filled_3);\n        out\n    }\n\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        assert(false, \"unpack not implemented\");\n        TokenCommitted {\n            Id: fields[1] as Field,\n            amount: 0 as u128,\n            token: AztecAddress::zero(),\n            timelock: 0 as u64,\n            src_receiver: AztecAddress::zero(),\n            src_asset: \"000000000000000000000000000000\",\n            dst_chain: \"000000000000000000000000000000\",\n            dst_asset: \"000000000000000000000000000000\",\n            dst_address: \"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n        }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenLockAdded {\n    pub Id: Field,\n    pub hashlock: [u8; 32],\n    pub timelock: u64,\n}\n\nimpl Packable for TokenLockAdded {\n    let N: u32 = 5;\n    fn pack(self) -> [Field; Self::N] {\n        let mut out = [0 as Field; 5];\n        out[0] = 0xC1D4E792;\n        out[1] = self.Id;\n\n        let (hashlock_high, hashlock_low) = bytes_to_u128_limbs(self.hashlock);\n        out[2] = hashlock_high as Field;\n        out[3] = hashlock_low as Field;\n        out[4] = self.timelock as Field;\n        out\n    }\n\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        let Id = fields[1];\n        let hashlock = u128_limbs_to_bytes(fields[2] as u128, fields[3] as u128);\n        let timelock = fields[4] as u64;\n        TokenLockAdded { Id, hashlock, timelock }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenRefunded {\n    pub Id: Field,\n}\n\nimpl Packable for TokenRefunded {\n    let N: u32 = 2;\n    fn pack(self) -> [Field; Self::N] {\n        let mut out = [0 as Field; 2];\n        out[0] = 0x2D17C6B8;\n        out[1] = self.Id;\n        out\n    }\n\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        let Id = fields[1];\n        TokenRefunded { Id }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenRedeemed {\n    pub Id: Field,\n    pub hashlock: [u8; 32],\n    pub secret: [u8; 32],\n}\n\nimpl Packable for TokenRedeemed {\n    let N: u32 = 6;\n    fn pack(self) -> [Field; Self::N] {\n        let mut out = [0 as Field; 6];\n        out[0] = 0x4F8B9A3E;\n        out[1] = self.Id;\n\n        let (hashlock_high, hashlock_low) = bytes_to_u128_limbs(self.hashlock);\n        out[2] = hashlock_high as Field;\n        out[3] = hashlock_low as Field;\n\n        let (secret_high, secret_low) = bytes_to_u128_limbs(self.secret);\n        out[4] = secret_high as Field;\n        out[5] = secret_low as Field;\n\n        out\n    }\n\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        let Id = fields[1];\n        let hashlock = u128_limbs_to_bytes(fields[2] as u128, fields[3] as u128);\n        let secret = u128_limbs_to_bytes(fields[4] as u128, fields[5] as u128);\n\n        TokenRedeemed { Id, hashlock, secret }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenLockedFirst {\n    pub Id: Field,\n    pub amount: u128,\n    pub token: AztecAddress,\n    pub timelock: u64,\n    pub src_receiver: AztecAddress,\n    pub src_asset: str<30>,\n    pub dst_chain: str<30>,\n    pub dst_asset: str<30>,\n    pub dst_address: str<90>,\n}\n\nimpl Packable for TokenLockedFirst {\n    let N: u32 = 12;\n    fn pack(self) -> [Field; Self::N] {\n        let zero: Field = 0;\n        let mut out = [zero; 12];\n        out[0] = 0x9E5A4F03;\n        out[1] = self.Id;\n        out[2] = self.amount as Field;\n        out[3] = self.token.inner;\n        out[4] = self.timelock as Field;\n        out[5] = self.src_receiver.inner;\n\n        let src_asset_byte_array = self.src_asset.as_bytes();\n        let mut src_asset_byte_array_filled = [0 as u8; 30];\n        for i in 0..src_asset_byte_array.len() {\n            src_asset_byte_array_filled[i] = src_asset_byte_array[i];\n        }\n        out[6] = Field::from_be_bytes::<30>(src_asset_byte_array_filled);\n\n        let dst_chain_byte_array = self.dst_chain.as_bytes();\n        let mut dst_chain_byte_array_filled = [0 as u8; 30];\n        for i in 0..dst_chain_byte_array.len() {\n            dst_chain_byte_array_filled[i] = dst_chain_byte_array[i];\n        }\n        out[7] = Field::from_be_bytes::<30>(dst_chain_byte_array_filled);\n\n        let dst_asset_byte_array = self.dst_asset.as_bytes();\n        let mut dst_asset_byte_array_filled = [0 as u8; 30];\n        for i in 0..dst_asset_byte_array.len() {\n            dst_asset_byte_array_filled[i] = dst_asset_byte_array[i];\n        }\n        out[8] = Field::from_be_bytes::<30>(dst_asset_byte_array_filled);\n\n        let dst_address_byte_array = self.dst_address.as_bytes();\n        let mut dst_address_byte_array_filled_1 = [0 as u8; 30];\n        let mut dst_address_byte_array_filled_2 = [0 as u8; 30];\n        let mut dst_address_byte_array_filled_3 = [0 as u8; 30];\n\n        for i in 0..30 {\n            dst_address_byte_array_filled_1[i] = dst_address_byte_array[i];\n            dst_address_byte_array_filled_2[i] = dst_address_byte_array[i + 30];\n            dst_address_byte_array_filled_3[i] = dst_address_byte_array[i + 60];\n        }\n\n        out[9] = Field::from_be_bytes::<30>(dst_address_byte_array_filled_1);\n        out[10] = Field::from_be_bytes::<30>(dst_address_byte_array_filled_2);\n        out[11] = Field::from_be_bytes::<30>(dst_address_byte_array_filled_3);\n        out\n    }\n\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        assert(false, \"unpack not implemented\");\n        TokenLockedFirst {\n            Id: fields[1] as Field,\n            amount: 0 as u128,\n            token: AztecAddress::zero(),\n            timelock: 0 as u64,\n            src_receiver: AztecAddress::zero(),\n            src_asset: \"000000000000000000000000000000\",\n            dst_chain: \"000000000000000000000000000000\",\n            dst_asset: \"000000000000000000000000000000\",\n            dst_address: \"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n        }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenLockedSecond {\n    pub Id: Field,\n    pub hashlock: [u8; 32],\n    pub ownership_hash: [u8; 32],\n}\n\nimpl Packable for TokenLockedSecond {\n    let N: u32 = 6;\n    fn pack(self) -> [Field; Self::N] {\n        let mut out = [0 as Field; 6];\n        out[0] = 0x9E5A4F03;\n        out[1] = self.Id;\n\n        let (hashlock_high, hashlock_low) = bytes_to_u128_limbs(self.hashlock);\n        out[2] = hashlock_high as Field;\n        out[3] = hashlock_low as Field;\n\n        let (ownership_hash_high, ownership_hash_low) = bytes_to_u128_limbs(self.ownership_hash);\n        out[4] = ownership_hash_high as Field;\n        out[5] = ownership_hash_low as Field;\n\n        out\n    }\n\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        assert(false, \"unpack not implemented\");\n        TokenLockedSecond {\n            Id: fields[1] as Field,\n            hashlock: [0 as u8; 32],\n            ownership_hash: [0 as u8; 32],\n        }\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n"
    },
    "62": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T)\n    where\n        T: Serialize,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T\n    where\n        T: Deserialize,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n\n    global SLOT: Field = 1230;\n\n    #[test]\n    unconstrained fn empty_array() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            let _: Field = array.get(0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            assert_eq(array.len(), 1);\n            assert_eq(array.get(0), 5);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            let _ = array.get(1);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(5);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            assert_eq(array.len(), 3);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 8);\n            assert_eq(array.get(2), 9);\n\n            array.remove(1);\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 9);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            array.remove(1);\n            array.remove(1);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n            // we do not care about the order in which each tuple was passed to the closure.\n            let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n            array.for_each(|index, value| { called_with.push((index, value)); });\n\n            assert_eq(called_with.len(), 3);\n            assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n            assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n            assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| {\n                if index == 1 {\n                    array.remove(index);\n                }\n            });\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 4);\n            assert_eq(array.get(1), 6);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all_no_copy() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We test that the utilityCopyCapsule was never called, which is the expensive operation we want to avoid.\n            let mock = std::test::OracleMock::mock(\"utilityCopyCapsule\");\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(mock.times_called(), 0);\n        });\n    }\n}\n"
    },
    "63": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    /// Makes the call to this private function.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (see https://github.com/AztecProtocol/aztec-packages/pull/16433)\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn call(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n\n    /// Makes a _read-only_ call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// See `call` for more general info on private function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateStaticCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    /// Makes a read-only call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PublicCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the call to this public function.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[external(\"public\")] function as `context`, through the\n    ///               #[external(\"public\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn call(self, context: &mut PublicContext) -> T {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Makes a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[external(\"public\")] function as `context`, through the\n    ///               #[external(\"public\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a call to this public function, to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, false, false)\n    }\n\n    /// Enqueues a call to this public function, to be executed later.\n    ///\n    /// As per `enqueue`, but hides this calling contract's address from the\n    /// target public function.\n    /// This means the origin of the call (msg_sender) will not be publicly\n    /// visible to any blockchain observers, nor to the target public function.\n    /// When the target public function reads `context.msg_sender()` it will\n    /// receive an `Option<AztecAddress>::none`.\n    ///\n    /// NOTES:\n    /// - Not all public functions will accept a msg_sender of \"none\". Many\n    ///   public functions will require that msg_sender is \"some\" and will\n    ///   revert otherwise. Therefore, if using `enqueue_incognito`, you must\n    ///   understand whether the function you're calling will accept a\n    ///   msg_sender of \"none\".\n    ///   Lots of public bookkeeping patterns rely on knowing which address made\n    ///   the call, so as to ascribe state against the caller's address.\n    ///   (There are patterns whereby bookkeeping could instead be done in\n    ///   private-land).\n    /// - If you are enqueueing a call to an _internal_ public function (i.e.\n    ///   a public function that will only accept calls from other functions\n    ///   of its own contract), then by definition a call to it cannot possibly\n    ///   be \"incognito\": the msg_sender must be its own address, and indeed the\n    ///   called public function will assert this. Tl;dr this is not usable for\n    ///   enqueued internal public calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    /// Advanced:\n    /// - The kernel circuits will permit _any_ private function to set the\n    ///   msg_sender field of any enqueued public function call to\n    ///   NULL_MSG_SENDER_CONTRACT_ADDRESS.\n    /// - When the called public function calls `PublicContext::msg_sender()`,\n    ///   aztec-nr will translate NULL_MSG_SENDER_CONTRACT_ADDRESS into\n    ///   `Option<AztecAddress>::none` for familiarity to devs.\n    ///\n    pub fn enqueue_incognito(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, false, true)\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, true, false)\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// As per `enqueue_view`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue_view_incognito(self, context: &mut PrivateContext) {\n        self.enqueue_impl(context, true, true)\n    }\n\n    fn enqueue_impl(\n        self,\n        context: &mut PrivateContext,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            is_static_call,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a call to this public function, and designates it to be the\n    /// teardown function for this tx. Only one teardown function call can be\n    /// made by a tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// See `enqueue` for more information about enqueuing public function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        self.set_as_teardown_impl(context, false);\n    }\n\n    /// Enqueues a call to this public function, and designates it to be the teardown\n    /// function for this tx. Only one teardown function call can be made by a\n    /// tx.\n    ///\n    /// As per `set_as_teardown`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    pub fn set_as_teardown_incognito(self, context: &mut PrivateContext) {\n        self.set_as_teardown_impl(context, true);\n    }\n\n    fn set_as_teardown_impl(self, context: &mut PrivateContext, hide_msg_sender: bool) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T> PublicStaticCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[external(\"public\")] function as `context`, through the\n    ///               #[external(\"public\")] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[external(\"private\")] function as `context`, through the\n    ///               #[external(\"private\")] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n            false,\n        )\n    }\n\n    pub fn enqueue_view_incognito(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// UtilityCallInterface\n\npub struct UtilityCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let M: u32, T> CallInterface<M> for UtilityCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        false\n    }\n}\n\nimpl<let M: u32, T> UtilityCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n"
    },
    "70": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        logs::notify_created_contract_class_log,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        block_header::BlockHeader,\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, MAX_CONTRACT_CLASS_LOGS_PER_CALL,\n        MAX_ENQUEUED_CALLS_PER_CALL, MAX_INCLUDE_BY_TIMESTAMP_DURATION,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        NULL_MSG_SENDER_CONTRACT_ADDRESS, PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    hash::poseidon2_hash,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    side_effect::Counted,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::{ClaimedLengthArray, trimmed_array_length_hint},\n};\n\n/// # PrivateContext\n///\n/// The **main interface** between an #[external(\"private\")] function and the Aztec blockchain.\n///\n/// An instance of the PrivateContext is initialized automatically at the outset\n/// of every private function, within the #[external(\"private\")] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it is always be available within\n/// the body of every #[external(\"private\")] function in your smart contract.\n///\n/// > For those used to \"vanilla\" Noir, it might be jarring to have access to\n/// > `context` without seeing a declaration `let context = PrivateContext::new(...)`\n/// > within the body of your function. This is just a consequence of using\n/// > macros to tidy-up verbose boilerplate. You can use `nargo expand` to\n/// > expand all macros, if you dare.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PrivateContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// > Advanced users might occasionally wish to push data to the context\n/// > directly for lower-level control. If you find yourself doing this, please\n/// > open an issue on GitHub to describe your use case: it might be that\n/// > new functionality should be added to aztec-nr.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a private function:\n///   - Data relating to how this private function was called.\n///     - msg_sender\n///     - this_address - (the contract address of the private function being\n///                      executed)\n///     - See `CallContext` for more data.\n///   - Data relating to the transaction in which this private function is\n///     being executed.\n///     - chain_id\n///     - version\n///     - gas_settings\n/// - Provides state access:\n///   - Access to the \"Anchor block\" header.\n///     Recall, a private function cannot read from the \"current\" block header,\n///     but must read from some historical block header, because as soon as\n///     private function execution begins (asynchronously, on a user's device),\n///     the public state of the chain (the \"current state\") will have progressed\n///     forward. We call this reference the \"Anchor block\".\n///     See `BlockHeader`.\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to functions of other smart contracts:\n///   - Private function calls\n///   - Enqueueing of public function call requests\n///     (Since public functions are executed at a later time, by a block\n///     proposer, we say they are \"enqueued\").\n/// - Writes data to the blockchain:\n///   - New notes\n///   - New nullifiers\n///   - Private logs (for sending encrypted note contents or encrypted events)\n///   - New L2->L1 messages.\n/// - Provides args to the private function (handled by the #[external(\"private\")] macro).\n/// - Returns the return values of this private function (handled by the\n///   #[external(\"private\")] macro).\n/// - Makes Key Validation Requests.\n///   - Private functions are not allowed to see master secret keys, because we\n///     do not trust them. They are instead given \"app-siloed\" secret keys with\n///     a claim that they relate to a master public key. They can then request\n///     validation of this claim, by making a \"key validation request\" to the\n///     protocol's kernel circuits (which _are_ allowed to see certain master\n///     secret keys).\n///\n/// ## Advanced Responsibilities\n///\n/// - Ultimately, the PrivateContext is responsible for constructing the\n///   PrivateCircuitPublicInputs of the private function being executed.\n///   All private functions on Aztec must have public inputs which adhere\n///   to the rigid layout of the PrivateCircuitPublicInputs, in order to be\n///   compatible with the protocol's kernel circuits.\n///   A well-known misnomer:\n///   - \"public inputs\" contain both inputs and outputs of this function.\n///     - By \"outputs\" we mean a lot more side-effects than just the\n///       \"return values\" of the function.\n///   - Most of the so-called \"public inputs\" are kept _private_, and never leak\n///     to the outside world, because they are 'swallowed' by the protocol's\n///     kernel circuits before the tx is sent to the network. Only the\n///     following are exposed to the outside world:\n///     - New note_hashes\n///     - New nullifiers\n///     - New private logs\n///     - New L2->L1 messages\n///     - New enqueued public function call requests\n///     All the above-listed arrays of side-effects can be padded by the\n///     user's wallet (through instructions to the kernel circuits, via the\n///     PXE) to obscure their true lengths.\n///\n/// ## Syntax Justification\n///\n/// Both user-defined functions _and_ most functions in aztec-nr need access to\n/// the PrivateContext instance to read/write data. This is why you'll see the\n/// arguably-ugly pervasiveness of the \"context\" throughout your smart contract\n/// and the aztec-nr library.\n/// For example, `&mut context` is prevalent. In some languages, you can access\n/// and mutate a global variable (such as a PrivateContext instance) from a\n/// function without polluting the function's parameters. With Noir, a function\n/// must explicitly pass control of a mutable variable to another function, by\n/// reference. Since many functions in aztec-nr need to be able to push new data\n/// to the PrivateContext, they need to be handed a mutable reference _to_ the\n/// context as a parameter.\n/// For example, `Context` is prevalent as a generic parameter, to give better\n/// type safety at compile time. Many `aztec-nr` functions don't make sense if\n/// they're called in a particular runtime (private, public or utility), and so\n/// are intentionally only implemented over certain\n/// [Private|Public|Utility]Context structs. This gives smart contract\n/// developers a much faster feedback loop if they're making a mistake, as an\n/// error will be thrown by the LSP or when they compile their contract.\n///\n#[derive(Eq)]\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub include_by_timestamp: u64,\n\n    pub note_hash_read_requests: BoundedVec<Counted<Field>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<Counted<Field>, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<Counted<NoteHash>, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Counted<Nullifier>, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<Counted<L2ToL1Message>, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub anchor_block_header: BlockHeader,\n\n    pub private_logs: BoundedVec<Counted<PrivateLogData>, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let max_allowed_include_by_timestamp = inputs.anchor_block_header.global_variables.timestamp\n            + MAX_INCLUDE_BY_TIMESTAMP_DURATION;\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            include_by_timestamp: max_allowed_include_by_timestamp,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            anchor_block_header: inputs.anchor_block_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA (\n    /// Externally-owned Account), the msg_sender is \"null\" for the first\n    /// function call of every transaction.\n    /// The first function call of a tx is likely to be a call to the user's\n    /// account contract, so this quirk will most often be handled by account\n    /// contract developers.\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///   Returns `Option<AztecAddress>::none` for the first function call of\n    ///   the tx. No other _private_ function calls in the tx will have a `none`\n    ///   msg_sender, but _public_ function calls might (see the PublicContext).\n    ///\n    pub fn msg_sender(self) -> Option<AztecAddress> {\n        let maybe_msg_sender = self.inputs.call_context.msg_sender;\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// \"Unsafe\" versus calling `context.msg_sender()`, because it doesn't\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    /// Returns the contract address of the current function being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    /// Returns the gas settings for the current transaction.\n    ///\n    /// This provides information about gas limits and pricing for the\n    /// transaction, similar to `tx.gasprice` and gas limits in Ethereum.\n    /// However, Aztec has a more sophisticated gas model with separate\n    /// accounting for L2 computation and data availability (DA) costs.\n    ///\n    /// # Returns\n    /// * `GasSettings` - Struct containing gas limits and fee information\n    ///\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    /// Returns the function selector of the currently executing function.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to access this.\n    ///\n    /// This is similar to `msg.sig` in Solidity, which returns the first 4\n    /// bytes of the function signature. In Aztec, the selector uniquely\n    /// identifies which function within the contract is being called.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// Only #[external(\"private\")] functions have a function selector as a protocol-\n    /// enshrined concept. The function selectors of private functions are\n    /// baked into the preimage of the contract address, and are used by the\n    /// protocol's kernel circuits to identify each private function and ensure\n    /// the correct one is being executed.\n    ///\n    /// Used internally for function dispatch and call verification.\n    ///\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: You shouldn't need to call this. The #[external(\"private\")]\n    /// macro calls this, and it makes the arguments neatly available to the\n    /// body of your private function.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    /// # Advanced\n    /// * Arguments are hashed to reduce proof size and verification time\n    /// * Enables efficient argument passing in recursive function calls\n    /// * The hash can be used to retrieve the original arguments from the PXE.\n    ///\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    /// Pushes a new note_hash to the Aztec blockchain's global Note Hash Tree\n    /// (a state tree).\n    ///\n    /// A note_hash is a commitment to a piece of private state.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note hashes.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The new note_hash.\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// note_hash into the protocol's \"note hash tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `note_hash` with the contract address of this function,\n    ///   to yield a `siloed_note_hash`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure uniqueness of the `siloed_note_hash`, to prevent Faerie-Gold\n    ///   attacks, by hashing the `siloed_note_hash` with a unique value, to\n    ///   yield a `unique_siloed_note_hash` (see the protocol spec for more).\n    ///\n    /// In addition to calling this function, aztec-nr provides the contents\n    /// of the newly-created note to the PXE, via the `notify_created_note`\n    /// oracle.\n    ///\n    /// > Advanced users might occasionally wish to push data to the context\n    /// > directly for lower-level control. If you find yourself doing this,\n    /// > please open an issue on GitHub to describe your use case: it might be\n    /// > that new functionality should be added to aztec-nr.\n    ///\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(Counted::new(note_hash, self.next_counter()));\n    }\n\n    /// Pushes a new nullifier to the Aztec blockchain's global Nullifier Tree\n    /// (a state tree).\n    ///\n    /// See also: `push_nullifier_for_note_hash`.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// A nullifier can only be emitted once. Duplicate nullifier insertions are\n    /// rejected by the protocol.\n    ///\n    /// Generally, a nullifier is emitted to prevent an action from happening\n    /// more than once, in such a way that the action cannot be linked (by an\n    /// observer of the blockchain) to any earlier transactions.\n    ///\n    /// I.e. a nullifier is a random-looking, but deterministic record of a\n    /// private, one-time action, which does not leak what action has been\n    /// taken, and which preserves the property of \"tx unlinkability\".\n    ///\n    /// Usually, a nullifier will be emitted to \"spend\" a note (a piece of\n    /// private state), without revealing which specific note is being spent.\n    ///\n    /// (Important: in such cases, use the below `push_nullifier_for_note_hash`).\n    ///\n    /// Sometimes, a nullifier might be emitted completely unrelated to any\n    /// notes. Examples include initialization of a new contract; initialization\n    /// of a PrivateMutable, or signalling in Semaphore-like applications.\n    /// This `push_nullifier` function serves such use cases.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// nullifier into the protocol's \"nullifier tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `nullifier` with the contract address of this function,\n    ///   to yield a `siloed_nullifier`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure the `siloed_nullifier` is unique (the nullifier tree is an\n    ///   indexed merkle tree which supports efficient non-membership proofs).\n    ///\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0 }.count(self.next_counter()));\n    }\n\n    /// Pushes a nullifier that corresponds to a specific note hash.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// This is a specialized version of `push_nullifier` that links a nullifier\n    /// to the specific note hash it's nullifying. This is the most common\n    /// usage pattern for nullifiers.\n    /// See `push_nullifier` for more explanation on nullifiers.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    /// * `nullified_note_hash` - The note hash of the note being nullified\n    ///\n    /// # Advanced\n    /// Important: usage of this function doesn't mean that the world will _see_\n    /// that this nullifier relates to the given nullified_note_hash (as that\n    /// would violate \"tx unlinkability\"); it simply informs the user's PXE\n    /// about the relationship (via `notify_nullified_note`). The PXE can then\n    /// use this information to feed hints to the kernel circuits for\n    /// \"squashing\" purposes: If a note is nullified during the same tx which\n    /// created it, we can \"squash\" (delete) the note and nullifier (and any\n    /// private logs associated with the note), to save on data emission costs.\n    ///\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash }.count(\n            nullifier_counter,\n        ));\n    }\n\n    /// Returns the anchor block header - the historical block header that this\n    /// private function is reading from.\n    ///\n    /// A private function CANNOT read from the \"current\" block header,\n    /// but must read from some older block header, because as soon as\n    /// private function execution begins (asynchronously, on a user's device),\n    /// the public state of the chain (the \"current state\") will have progressed\n    /// forward.\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The anchor block header.\n    ///\n    /// # Advanced\n    /// * All private functions of a tx read from the same anchor block header.\n    /// * The protocol asserts that the `include_by_timestamp` of every tx\n    ///   is at most 24 hours beyond the timestamp of the tx's chosen anchor\n    ///   block header. This enables the network's nodes to safely prune old txs\n    ///   from the mempool. Therefore, the chosen block header _must_ be one\n    ///   from within the last 24 hours.\n    ///\n    pub fn get_anchor_block_header(self) -> BlockHeader {\n        self.anchor_block_header\n    }\n\n    /// Returns the header of any historical block at or before the anchor\n    /// block.\n    ///\n    /// This enables private contracts to access information from even older\n    /// blocks than the anchor block header.\n    ///\n    /// Useful for time-based contract logic that needs to compare against\n    /// multiple historical points.\n    ///\n    /// # Arguments\n    /// * `block_number` - The block number to retrieve (must be <= anchor\n    ///                    block number)\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The header of the requested historical block\n    ///\n    /// # Advanced\n    /// This function uses an oracle to fetch block header data from the user's\n    /// PXE. Depending on how much blockchain data the user's PXE has been set\n    /// up to store, this might require a query from the PXE to another Aztec\n    /// node to get the data.\n    /// > This is generally true of all oracle getters (see `../oracle`).\n    ///\n    /// Each block header gets hashed and stored as a leaf in the protocol's\n    /// Archive Tree. In fact, the i-th block header gets stored at the i-th\n    /// leaf index of the Archive Tree. Behind the scenes, this\n    /// `get_block_header_at` function will add Archive Tree merkle-membership\n    /// constraints (~3k) to your smart contract function's circuit, to prove\n    /// existence of the block header in the Archive Tree.\n    ///\n    /// Note: we don't do any caching, so avoid making duplicate calls for the\n    /// same block header, because each call will add duplicate constraints.\n    ///\n    /// Calling this function is more expensive (constraint-wise) than getting\n    /// the anchor block header (via `get_block_header`). This is because the\n    /// anchor block's merkle membership proof is handled by Aztec's protocol\n    /// circuits, and is only performed once for the entire tx because all\n    /// private functions of a tx share a common anchor block header. Therefore,\n    /// the cost (constraint-wise) of calling `get_block_header` is effectively\n    /// free.\n    ///\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    /// Sets the hash of the return values for this private function.\n    ///\n    /// Very low-level function: this is called by the #[external(\"private\")] macro.\n    ///\n    /// # Arguments\n    /// * `serialized_return_values` - The serialized return values as a field array\n    ///\n    pub fn set_return_hash<let N: u32>(&mut self, serialized_return_values: [Field; N]) {\n        let return_hash = hash_args_array(serialized_return_values);\n        self.return_hash = return_hash;\n        execution_cache::store(serialized_return_values, return_hash);\n    }\n\n    /// Builds the PrivateCircuitPublicInputs for this private function, to\n    /// ensure compatibility with the protocol's kernel circuits.\n    ///\n    /// Very low-level function: This function is automatically called by the\n    /// #[external(\"private\")] macro.\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            include_by_timestamp: self.include_by_timestamp,\n            note_hash_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.note_hash_read_requests,\n            ),\n            nullifier_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.nullifier_read_requests,\n            ),\n            key_validation_requests_and_generators: ClaimedLengthArray::from_bounded_vec(\n                self.key_validation_requests_and_generators,\n            ),\n            note_hashes: ClaimedLengthArray::from_bounded_vec(self.note_hashes),\n            nullifiers: ClaimedLengthArray::from_bounded_vec(self.nullifiers),\n            private_call_requests: ClaimedLengthArray::from_bounded_vec(self.private_call_requests),\n            public_call_requests: ClaimedLengthArray::from_bounded_vec(self.public_call_requests),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: ClaimedLengthArray::from_bounded_vec(self.l2_to_l1_msgs),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: ClaimedLengthArray::from_bounded_vec(self.private_logs),\n            contract_class_logs_hashes: ClaimedLengthArray::from_bounded_vec(\n                self.contract_class_logs_hashes,\n            ),\n            anchor_block_header: self.anchor_block_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    /// Designates this contract as the fee payer for the transaction.\n    ///\n    /// Unlike Ethereum, where the transaction sender always pays fees, Aztec\n    /// allows any contract to voluntarily pay transaction fees. This enables\n    /// patterns like sponsored transactions or fee abstraction where users\n    /// don't need to hold fee-juice themselves. (Fee juice is a fee-paying\n    /// asset for Aztec).\n    ///\n    /// Only one contract per transaction can declare itself as the fee payer,\n    /// and it must have sufficient fee-juice balance (>= the gas limits\n    /// specified in the TxContext) by the time we reach the public setup phase\n    /// of the tx.\n    ///\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    /// Declares the end of the \"setup phase\" of this tx.\n    ///\n    /// Only one function per tx can declare the end of the setup phase.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase enables such a payment to\n    /// be made, because the setup phase _cannot revert_: a reverting function\n    /// within the setup phase would result in an invalid block which cannot\n    /// be proven. Any side-effects generated during that phase are guaranteed\n    /// to be inserted into Aztec's state trees (except for squashed notes &\n    /// nullifiers, of course).\n    ///\n    /// Even though the end of the setup phase is declared within a private\n    /// function, you might have noticed that _public_ functions can also\n    /// execute within the setup phase. This is because any public function\n    /// calls which were enqueued _within the setup phase_ by a private\n    /// function are considered part of the setup phase.\n    ///\n    /// # Advanced\n    /// * Sets the minimum revertible side effect counter of this tx to be the\n    /// PrivateContext's _current_ side effect counter.\n    ///\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    /// Sets a deadline (an \"include-by timestamp\") for when this transaction\n    /// must be included in a block.\n    ///\n    /// Other functions in this tx might call this setter with differing\n    /// values for the include-by timestamp. To ensure that all functions'\n    /// deadlines are met, the _minimum_ of all these include-by timestamps will\n    /// be exposed when this tx is submitted to the network.\n    ///\n    /// If the transaction is not included in a block by its include-by\n    /// timestamp, it becomes invalid and it will never be included.\n    ///\n    /// This expiry timestamp is publicly visible. See the \"Advanced\" section\n    /// for privacy concerns.\n    ///\n    /// # Arguments\n    /// * `include_by_timestamp` - Unix timestamp (seconds) deadline for inclusion.\n    ///                            The include-by timestamp of this tx will be\n    ///                            _at most_ the timestamp specified.\n    ///\n    /// # Advanced\n    /// * If multiple functions set differing `include_by_timestamp`s, the\n    ///   kernel circuits will set it to be the _minimum_ of the two. This\n    ///   ensures the tx expiry requirements of all functions in the tx are met.\n    /// * Rollup circuits will reject expired txs.\n    /// * The protocol enforces that all transactions must be included within\n    ///   24 hours of their chosen anchor block's timestamp, to enable safe\n    ///   mempool pruning.\n    /// * The DelayedPublicMutable design makes heavy use of this functionality,\n    ///   to enable private functions to read public state.\n    /// * A sophisticated Wallet should cleverly set an include-by timestamp\n    ///   to improve the privacy of the user and the network as a whole.\n    ///   For example, if a contract interaction sets include-by to some\n    ///   publicly-known value (e.g. the time when a contract upgrades), then\n    ///   the wallet might wish to set an even lower one to avoid revealing that\n    ///   this tx is interacting with said contract.\n    ///   Ideally, all wallets should standardise on an approach in order to\n    ///   provide users with a large anonymity set -- although the exact apprach\n    ///   will need to be discussed. Wallets that deviate from a standard might\n    ///   accidentally reveal which wallet each transaction originates from.\n    ///\n    // docs:start:include-by-timestamp\n    pub fn set_include_by_timestamp(&mut self, include_by_timestamp: u64) {\n        // docs:end:include-by-timestamp\n        self.include_by_timestamp = std::cmp::min(self.include_by_timestamp, include_by_timestamp);\n    }\n\n    /// Makes a request to the protocol's kernel circuit to ensure a note_hash\n    /// actually exists.\n    ///\n    /// \"Read requests\" are used to prove that a note hash exists without\n    /// revealing which specific note was read.\n    ///\n    /// This can be used to prove existence of both settled notes (created in\n    /// prior transactions) and transient notes (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled note _at a specific block\n    /// number_, use `note_inclusion::prove_note_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note_hash read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to read and verify\n    ///\n    /// # Advanced\n    /// In \"traditional\" circuits for non-Aztec privacy applications, the merkle\n    /// membership proofs to check existence of a note are performed _within_\n    /// the application circuit.\n    ///\n    /// All Aztec private functions have access to the following constraint\n    /// optimisation:\n    /// In cases where the note being read was created earlier in the same tx,\n    /// the note wouldn't yet exist in the Note Hash Tree, so a hard-coded\n    /// merkle membership check which then gets ignored would be a waste of\n    /// constraints.\n    /// Instead, we can send read requests for all notes to the protocol's\n    /// kernel circuits, where we can conditionally assess which notes actually\n    /// need merkle membership proofs, and select an appropriately-sized\n    /// kernel circuit.\n    ///\n    /// For \"settled notes\" (which already existed in the Note Hash Tree of the\n    /// anchor block (i.e. before the tx began)), the kernel does a merkle\n    /// membership check.\n    ///\n    /// For \"pending notes\" (which were created earlier in _this_ tx), the\n    /// kernel will check that the note existed _before_ this read request was\n    /// made, by checking the side-effect counters of the note_hash and this\n    /// read request.\n    ///\n    /// This approach improves latency between writes and reads:\n    /// a function can read a note which was created earlier in the tx (rather\n    /// than performing the read in a later tx, after waiting for the earlier tx\n    /// to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = Counted::new(note_hash, self.next_counter());\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    /// Requests to read a specific nullifier from the nullifier tree.\n    ///\n    /// Nullifier read requests are used to prove that a nullifier exists without\n    /// revealing which specific nullifier preimage was read.\n    ///\n    /// This can be used to prove existence of both settled nullifiers (created in\n    /// prior transactions) and transient nullifiers (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled nullifier _at a specific block\n    /// number_, use `nullifier_inclusion::prove_nullifier_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifier read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `nullifier` - The nullifier to read and verify\n    ///\n    /// # Advanced\n    /// This approach improves latency between writes and reads:\n    /// a function can read a nullifier which was created earlier in the tx\n    /// (rather than performing the read in a later tx, after waiting for the\n    /// earlier tx to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = Counted::new(nullifier, self.next_counter());\n        self.nullifier_read_requests.push(request);\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// Advanced function: Only needed if you're designing your own notes and/or\n    /// nullifiers.\n    ///\n    /// Contracts are not allowed to compute nullifiers for other contracts, as\n    /// that would let them read parts of their private state. Because of this,\n    /// a contract is only given an \"app-siloed secret key\", which is\n    /// constructed by hashing the user's master nullifier secret key with the\n    /// contract's address.\n    /// However, because contracts cannot be trusted with a user's master\n    /// nullifier secret key (because we don't know which contracts are honest\n    /// or malicious), the PXE refuses to provide any master secret keys to\n    /// any app smart contract function. This means app functions are unable to\n    /// prove that the derivation of an app-siloed nullifier secret key has been\n    /// computed correctly. Instead, an app function can request to the kernel\n    /// (via `request_nsk_app`) that it validates the siloed derivation, since\n    /// the kernel has been vetted to not leak any master secret keys.\n    ///\n    /// A common nullification scheme is to inject a nullifier secret key into\n    /// the preimage of a nullifier, to make the nullifier deterministic but\n    /// random-looking. This function enables that flow.\n    ///\n    /// # Arguments\n    /// * `npk_m_hash` - A hash of the master nullifier public key of the user\n    ///                  whose PXE is executing this function.\n    ///\n    /// # Returns\n    /// * The app-siloed nullifier secret key that corresponds to the given\n    ///   `npk_m_hash`.\n    ///\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// See `request_nsk_app` and `request_sk_app` for more info.\n    ///\n    /// The intention of the \"outgoing\" keypair is to provide a second secret\n    /// key for all of a user's outgoing activity (i.e. for notes that a user\n    /// creates, as opposed to notes that a user receives from others). The\n    /// separation of incoming and outgoing data was a distinction made by\n    /// zcash, with the intention of enabling a user to optionally share with a\n    /// 3rd party a controlled view of only incoming or outgoing notes.\n    /// Similar functionality of sharing select data can be achieved with\n    /// offchain zero-knowledge proofs. It is up to an app developer whether\n    /// they choose to make use of a user's outgoing keypair within their\n    /// application logic, or instead simply use the same keypair (the address\n    /// keypair (which is effectively the same as the \"incooming\" keypair)) for\n    /// all incoming & outgoing messages to a user.\n    ///\n    /// Currently, all of the exposed encryption functions in aztec-nr ignore\n    /// the outgoing viewing keys, and instead encrypt all note logs and event\n    /// logs to a user's address public key.\n    ///\n    /// # Arguments\n    /// * `ovpk_m_hash` - Hash of the outgoing viewing public key master\n    ///\n    /// # Returns\n    /// * The application-specific outgoing viewing secret key\n    ///\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    /// Pushes a Key Validation Request to the kernel.\n    ///\n    /// Private functions are not allowed to see a user's master secret keys,\n    /// because we do not trust them. They are instead given \"app-siloed\" secret\n    /// keys with a claim that they relate to a master public key.\n    /// They can then request validation of this claim, by making a \"key\n    /// validation request\" to the protocol's kernel circuits (which _are_\n    /// allowed to see certain master secret keys).\n    ///\n    /// When a Key Validation Request tuple of (sk_app, Pk_m, app_address) is\n    /// submitted to the kernel, it will perform the following derivations\n    /// to validate the relationship between the claimed sk_app and the user's\n    /// Pk_m:\n    ///\n    ///       (sk_m) ----> * G ----> Pk_m\n    ///         |                     |\n    ///         v                       We use the kernel to prove this\n    ///  h(sk_m, app_address)         | sk_app-Pk_m relationship, because app\n    ///         |                       circuits must not be trusted to see sk_m.\n    ///         v                     |\n    ///      sk_app - -  - - - - - - -\n    ///\n    /// The function is named \"request_\" instead of \"get_\" to remind the user\n    /// that a Key Validation Request will be emitted to the kernel.\n    ///\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element).\n    ///               This content has a very specific layout.\n    /// docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        let message = L2ToL1Message { recipient, content };\n        self.l2_to_l1_msgs.push(message.count(self.next_counter()));\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2).\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree;\n    /// messages never technically get deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target L2 contract. The message will need to be manually\n    /// consumed by the target contract through a separate Aztec transaction.\n    /// The message will not be available for consumption immediately. Messages\n    /// get copied over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// Validates message existence in the L1-to-L2 message tree and nullifies\n    /// the message to prevent double-consumption.\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let nullifier = process_l1_to_l2_message(\n            self.anchor_block_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n\n    /// Emits a private log (an array of Fields) that will be published to an\n    /// Ethereum blob.\n    ///\n    /// Private logs are intended for the broadcasting of ciphertexts: that is,\n    /// encrypted events or encrypted note contents.\n    /// Since the data in the logs is meant to be _encrypted_, private_logs are\n    /// broadcast to publicly-visible Ethereum blobs.\n    /// The intended recipients of such encrypted messages can then discover and\n    /// decrypt these encrypted logs using their viewing secret key.\n    /// (See `../messages/discovery` for more details).\n    ///\n    /// Important note: This function DOES NOT _do_ any encryption of the input\n    /// `log` fields. This function blindly publishes whatever input `log` data\n    /// is fed into it, so the caller of this function should have already\n    /// performed the encryption, and the `log` should be the result of that\n    /// encryption.\n    ///\n    /// The protocol does not dictate what encryption scheme should be used:\n    /// a smart contract developer can choose whatever encryption scheme they\n    /// like.\n    /// Aztec-nr includes some off-the-shelf encryption libraries that\n    /// developers might wish to use, for convenience. These libraries not only\n    /// encrypt a plaintext (to produce a ciphertext); they also prepend the\n    /// ciphertext with a `tag` and `ephemeral public key` for easier message\n    /// discovery. This is a very dense topic, and we will be writing more\n    /// libraries and docs soon.\n    ///\n    /// > Currently, AES128 CBC encryption is the main scheme included in\n    /// > aztec.nr.\n    /// > We are currently making significant changes to the interfaces of the\n    /// > encryption library.\n    ///\n    /// In some niche use cases, an app might be tempted to publish\n    /// _un-encrypted_ data via a private log, because _public logs_ are not\n    /// available to private functions. Be warned that emitting public data via\n    /// private logs is strongly discouraged, and is considered a \"privacy\n    /// anti-pattern\", because it reveals identifiable information about _which_\n    /// function has been executed. A tx which leaks such information does not\n    /// contribute to the privacy set of the network.\n    ///\n    /// * Unlike `emit_raw_note_log`, this log is not tied to any specific note\n    ///\n    /// # Arguments\n    /// * `log` - The log data that will be publicly broadcast (so make sure\n    ///           it's already been encrypted before you call this function).\n    ///   Private logs are bounded in size (PRIVATE_LOG_SIZE_IN_FIELDS), to\n    ///   encourage all logs from all smart contracts look identical.\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields). Although the input log has a max size of\n    ///   PRIVATE_LOG_SIZE_IN_FIELDS, the latter values of the array might all\n    ///   be 0's for small logs. This `length` should reflect the trimmed length\n    ///   of the array. The protocol's kernel circuits can then append random\n    ///   fields as \"padding\" after the `length`, so that the logs of this\n    ///   smart contract look indistinguishable from (the same length as) the\n    ///   logs of all other applications. It's up to wallets how much padding\n    ///   to apply, so ideally all wallets should agree on standards for this.\n    ///\n    /// # Advanced\n    ///\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0 }\n            .count(counter);\n        self.private_logs.push(private_log);\n    }\n\n    // TODO: rename.\n    /// Emits a private log that is explicitly tied to a newly-emitted note_hash,\n    /// to convey to the kernel: \"this log relates to this note\".\n    ///\n    /// This linkage is important in case the note gets squashed (due to being\n    /// read later in this same tx), since we can then squash the log as well.\n    ///\n    /// See `emit_private_log` for more info about private log emission.\n    ///\n    /// # Arguments\n    /// * `log` - The log data as an array of Field elements\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields).\n    /// * `note_hash_counter` - The side-effect counter that was assigned to the\n    ///                         new note_hash when it was pushed to this\n    //                          `PrivateContext`.\n    ///\n    /// Important: If your application logic requires the log to always be\n    /// emitted regardless of note squashing, consider using `emit_private_log`\n    /// instead, or emitting additional events.\n    ///\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter };\n        self.private_logs.push(private_log.count(counter));\n    }\n\n    pub fn emit_contract_class_log<let N: u32>(&mut self, log: [Field; N]) {\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n\n        let log_to_emit: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS] =\n            log.concat([0; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS - N]);\n        // Note: the length is not always N, it is the number of fields we want to broadcast, omitting trailing zeros to save blob space.\n        // Safety: The below length is constrained in the base rollup, which will make sure that all the fields beyond length are zero.\n        // However, it won't be able to check that we didn't add extra padding (trailing zeroes)\n        let length = unsafe { trimmed_array_length_hint(log_to_emit) };\n        // We hash the entire padded log to ensure a user cannot pass a shorter length and so emit incorrect shorter bytecode.\n        let log_hash = poseidon2_hash(log_to_emit);\n        // Safety: the below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\n        unsafe {\n            notify_created_contract_class_log(contract_address, log_to_emit, length, counter);\n        }\n\n        self.contract_class_logs_hashes.push(LogHash { value: log_hash, length: length }.count(\n            counter,\n        ));\n    }\n\n    /// Calls a private function on another contract (or the same contract).\n    ///\n    /// Very low-level function.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (feature not built yet - see github).\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    pub fn call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    /// Makes a read-only call to a private function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L2 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// See `call_private_function` for more general info on private function\n    /// calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    /// Calls a private function that takes no arguments.\n    ///\n    /// This is a convenience function for calling private functions that don't\n    /// require any input parameters. It's equivalent to `call_private_function`\n    /// but slightly more efficient to use when no arguments are needed.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    /// Makes a read-only call to a private function which takes no arguments.\n    ///\n    /// This combines the optimisation of `call_private_function_no_args` with\n    /// the safety of `static_call_private_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    /// Low-level private function call.\n    ///\n    /// This is the underlying implementation used by all other private function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args_hash` - Pre-computed hash of the function arguments\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values\n    ///\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1; // TODO: call `next_counter` instead, for consistency\n        ReturnsHash::new(returns_hash)\n    }\n\n    /// Enqueues a call to a public function to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a read-only call to a public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// See also `call_public_function` for more important information about\n    /// making private -> public function calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn static_call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            true,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a call to a public function that takes no arguments.\n    ///\n    /// This is an optimisation for calling public functions that don't\n    /// take any input parameters. It's otherwise equivalent to\n    /// `call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        hide_msg_sender: bool,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Enqueues a read-only call to a public function with no arguments.\n    ///\n    /// This combines the optimisation of `call_public_function_no_args` with\n    /// the safety of `static_call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        hide_msg_sender: bool,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            true,\n            hide_msg_sender,\n        )\n    }\n\n    /// Low-level public function call.\n    ///\n    /// This is the underlying implementation used by all other public function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use `call_public_function`\n    /// or `static_call_public_function` instead. This function is exposed for\n    /// performance optimization and advanced use cases.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let msg_sender = if hide_msg_sender {\n            NULL_MSG_SENDER_CONTRACT_ADDRESS\n        } else {\n            self.this_address()\n        };\n\n        let call_request =\n            PublicCallRequest { msg_sender, contract_address, is_static_call, calldata_hash };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    /// Enqueues a public function call, and designates it to be the teardown\n    /// function for this tx. Only one teardown function call can be made by a\n    /// tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - An array of fields to pass to the function.\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    pub fn set_public_teardown_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n        hide_msg_sender: bool,\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(\n            contract_address,\n            calldata_hash,\n            false,\n            hide_msg_sender,\n        )\n    }\n\n    /// Low-level function to set the public teardown function.\n    ///\n    /// This is the underlying implementation for setting the teardown function\n    /// call that will execute at the end of the transaction. Instead of taking\n    /// raw arguments, it accepts a hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use\n    /// `set_public_teardown_function` instead.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    /// * `hide_msg_sender` - the called function will see a \"null\" value for\n    ///                       `msg_sender` if set to `true`\n    ///\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n        hide_msg_sender: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let msg_sender = if hide_msg_sender {\n            NULL_MSG_SENDER_CONTRACT_ADDRESS\n        } else {\n            self.this_address()\n        };\n\n        self.public_teardown_call_request =\n            PublicCallRequest { msg_sender, contract_address, is_static_call, calldata_hash };\n    }\n\n    /// Increments the side-effect counter.\n    ///\n    /// Very low-level function.\n    ///\n    /// # Advanced\n    ///\n    /// Every side-effect of a private function is given a \"side-effect counter\",\n    /// based on when it is created. This PrivateContext is in charge of\n    /// assigning the counters.\n    ///\n    /// The reason we have side-effect counters is complicated. Consider this\n    /// illustrative pseudocode of inter-contract function calls:\n    /// ```\n    /// contract A {\n    ///    let x = 5; // pseudocode for storage var x.\n    ///    fn a1 {\n    ///        read x; // value: 5, counter: 1.\n    ///        x = x + 1;\n    ///        write x; // value: 6, counter: 2.\n    ///\n    ///        B.b(); // start_counter: 2, end_counter: 4\n    ///\n    ///        read x; // value: 36, counter: 5.\n    ///        x = x + 1;\n    ///        write x; // value: 37, counter: 6.\n    ///    }\n    ///\n    ///    fn a2 {\n    ///        read x; // value: 6, counter: 3.\n    ///        x = x * x;\n    ///        write x; // value: 36, counter: 4.\n    ///    }\n    /// }\n    ///\n    /// contract B {\n    ///     fn b() {\n    ///         A.a2();\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// Suppose a1 is the first function called. The comments show the execution\n    /// counter of each side-effect, and what the new value of `x` is.\n    ///\n    /// These (private) functions are processed by Aztec's kernel circuits in an\n    /// order that is different from execution order:\n    /// All of A.a1 is proven before B.b is proven, before A.a2 is proven.\n    /// So when we're in the 2nd execution frame of A.a1 (after the call to\n    /// B.b), the circuit needs to justify why x went from being `6` to `36`.\n    /// But the circuit doesn't know why, and given the order of proving, the\n    /// kernel hasn't _seen_ a value of 36 get written yet.\n    /// The kernel needs to track big arrays of all side-effects of all\n    /// private functions in a tx. Then, as it recurses and processes B.b(), it\n    /// will eventually see a value of 36 get written.\n    ///\n    /// Suppose side-effect counters weren't exposed:\n    /// The kernel would only see this ordering (in order of proof verification):\n    /// [ A.a1.read, A.a1.write, A.a1.read, A.a1.write, A.a2.read, A.a2.write ]\n    /// [         5,          6,        36,         37,         6,         36 ]\n    /// The kernel wouldn't know _when_ B.b() was called within A.a1(), because\n    /// it can't see what's going on within an app circuit. So the kernel\n    /// wouldn't know that the ordering of reads and writes should actually be:\n    /// [ A.a1.read, A.a1.write, A.a2.read, A.a2.write, A.a1.read, A.a1.write ]\n    /// [         5,          6,        6,         36,         36,         37 ]\n    ///\n    /// And so, we introduced side-effect counters: every private function must\n    /// assign side-effect counters alongside every side-effect that it emits,\n    /// and also expose to the kernel the counters that it started and ended\n    /// with.\n    /// This gives the kernel enough information to arrange all side-effects in\n    /// the correct order.\n    /// It can then catch (for example) if a function tries to read state\n    /// before it has been written (e.g. if A.a2() maliciously tried to read\n    /// a value of x=37) (e.g. if A.a1() maliciously tried to read x=6).\n    ///\n    /// If a malicious app contract _lies_ and does not count correctly:\n    /// - It cannot lie about its start and end counters because the kernel\n    ///   will catch this.\n    /// - It _could_ lie about its intermediate counters:\n    ///   - 1. It could not increment its side-effects correctly\n    ///   - 2. It could label its side-effects with counters outside of its\n    ///        start and end counters' range.\n    ///   The kernel will catch 2.\n    ///   The kernel will not catch 1., but this would only cause corruption\n    ///   to the private state of the malicious contract, and not any other\n    ///   contracts (because a contract can only modify its own state). If\n    ///   a \"good\" contract is given _read access_ to a maliciously-counting\n    ///   contract (via an external getter function, or by reading historic\n    ///   state from the archive tree directly), and they then make state\n    ///   changes to their _own_ state accordingly, that could be dangerous.\n    ///   Developers should be mindful not to trust the claimed innards of\n    ///   external contracts unless they have audited/vetted the contracts\n    ///   including vetting the side-effect counter incrementation.\n    ///   This is a similar paradigm to Ethereum smart contract development:\n    ///   you must vet external contracts that your contract relies upon, and\n    ///   you must not make any presumptions about their claimed behaviour.\n    ///   (Hopefully if a contract imports a version of aztec-nr, we will get\n    ///   contract verification tooling that can validate the authenticity\n    ///   of the imported aztec-nr package, and hence infer that the side-\n    ///   effect counting will be correct, without having to re-audit such logic\n    ///   for every contract).\n    ///\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            include_by_timestamp: 0,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            anchor_block_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "71": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_U32_VALUE, NULL_MSG_SENDER_CONTRACT_ADDRESS};\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\n/// # PublicContext\n///\n/// The **main interface** between an #[external(\"public\")] function and the Aztec blockchain.\n///\n/// An instance of the PublicContext is initialized automatically at the outset\n/// of every public function, within the #[external(\"public\")] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it will always be available\n/// within the body of every #[external(\"public\")] function in your smart contract.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PublicContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a public function:\n///   - Data relating to how this public function was called:\n///     - msg_sender, this_address\n///   - Data relating to the current blockchain state:\n///     - timestamp, block_number, chain_id, version\n///   - Gas and fee information\n/// - Provides state access:\n///   - Read/write public storage (key-value mapping)\n///   - Check existence of notes and nullifiers\n///     (Some patterns use notes & nullifiers to store public (not private)\n///     information)\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to other public smart contract functions:\n/// - Writes data to the blockchain:\n///   - Updates to public state variables\n///   - New public logs (for events)\n///   - New L2->L1 messages\n///   - New notes & nullifiers\n///     (E.g. pushing public info to notes/nullifiers, or for completing\n///     \"partial notes\")\n///\n/// ## Key Differences from Private Execution\n///\n/// Unlike private functions -- which are executed on the user's device and which\n/// can only reference historic state -- public functions are executed by a block\n/// proposer and are executed \"live\" on the _current_ tip of the chain.\n/// This means public functions can:\n/// - Read and write _current_ public state\n/// - Immediately see the effects of earlier transactions in the same block\n///\n/// Also, public functions are executed within a zkVM (the \"AVM\"), so that they\n/// can _revert_ whilst still ensuring payment to the proposer and prover.\n/// (Private functions cannot revert: they either succeed, or they cannot be\n/// included).\n///\n/// ## Optimising Public Functions\n///\n/// Using the AVM to execute public functions means they compile down to \"AVM\n/// bytecode\" instead of the ACIR that private functions (standalone circuits)\n/// compile to. Therefore the approach to optimising a public function is\n/// fundamentally different from optimising a public function.\n///\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl Eq for PublicContext {\n    fn eq(self, other: Self) -> bool {\n        (self.args_hash == other.args_hash)\n        // Can't compare the function compute_args_hash\n    }\n}\n\nimpl PublicContext {\n    /// Creates a new PublicContext instance.\n    ///\n    /// Low-level function: This is called automatically by the #[external(\"public\")]\n    /// macro, so you shouldn't need to be called directly by smart contract\n    /// developers.\n    ///\n    /// # Arguments\n    /// * `compute_args_hash` - Function to compute the args_hash\n    ///\n    /// # Returns\n    /// * A new PublicContext instance\n    ///\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    /// Emits a _public_ log that will be visible onchain to everyone.\n    ///\n    /// # Arguments\n    /// * `log` - The data to log, must implement Serialize trait\n    ///\n    pub fn emit_public_log<T>(_self: &mut Self, log: T)\n    where\n        T: Serialize,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    /// Checks if a given note hash exists in the note hash tree at a particular\n    /// leaf_index.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to check for existence\n    /// * `leaf_index` - The index where the note hash should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the note hash exists at the specified index\n    ///\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: u64) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    /// Checks if a specific L1-to-L2 message exists in the L1-to-L2 message\n    /// tree at a particular leaf index.\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// This function should be called before attempting to consume an L1-to-L2\n    /// message.\n    ///\n    /// # Arguments\n    /// * `msg_hash` - Hash of the L1-to-L2 message to check\n    /// * `msg_leaf_index` - The index where the message should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the message exists at the specified index\n    ///\n    /// # Advanced\n    /// * Uses the AVM l1_to_l2_msg_exists opcode for tree lookup\n    /// * Messages are copied from L1 Inbox to L2 by block proposers\n    ///\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        // TODO(alvaro): Make l1l2msg leaf index a u64 upstream\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index as u64) } == 1\n    }\n\n    /// Checks if a specific nullifier has been emitted by a given contract.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. An example is to check\n    /// whether a contract has been published: we emit a nullifier that is\n    /// deterministic, but whose preimage is _not_ private. This is more\n    /// efficient than using mutable storage, and can be done directly\n    /// from a private function.\n    ///\n    /// Nullifiers can be tested for non-existence in public, which is not the\n    /// case in private. Because private functions do not have access to\n    /// the tip of the blockchain (but only the anchor block they are built\n    /// at) they can only prove nullifier non-existence in the past. But between\n    /// an anchor block and the block in which a tx is included, the nullifier\n    /// might have been inserted into the nullifier tree by some other\n    /// transaction.\n    /// Public functions _do_ have access to the tip of the state, and so\n    /// this pattern is safe.\n    ///\n    /// # Arguments\n    /// * `unsiloed_nullifier` - The raw nullifier value (before siloing with\n    ///                          the contract address that emitted it).\n    /// * `address` - The claimed contract address that emitted the nullifier\n    ///\n    /// # Returns\n    /// * `bool` - True if the nullifier has been emitted by the specified contract\n    ///\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2) -- effectively\n    /// marking it as \"read\".\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree,\n    /// using the `l1_to_l2_msg_exists` method. Messages never technically get\n    /// deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1. It will not be available for consumption immediately. Messages\n    /// get copied-over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// * Validates message existence in the L1-to-L2 message tree\n    /// * Prevents double-consumption by emitting a nullifier\n    /// * Message hash is computed from all parameters + chain context\n    /// * Will revert if message doesn't exist or was already consumed\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element)\n    ///\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    /// Calls a public function on another contract.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Arguments to pass to the function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Makes a read-only call to a public function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Useful for querying data from other contracts safely.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Array of arguments to pass to the called function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Adds a new note hash to the Aztec blockchain's global Note Hash Tree.\n    ///\n    /// Notes are ordinarily constructed and emitted by _private_ functions, to\n    /// ensure that both the content of the note, and the contract that emitted\n    /// the note, stay private.\n    ///\n    /// There are however some useful patterns whereby a note needs to contain\n    /// _public_ data. The ability to push a new note_hash from a _public_\n    /// function means that notes can be injected with public data immediately\n    /// -- as soon as the public value is known. The slower alternative would\n    /// be to submit a follow-up transaction so that a private function can\n    /// inject the data. Both are possible on Aztec.\n    ///\n    /// Search \"Partial Note\" for a very common pattern which enables a note\n    /// to be \"partially\" populated with some data in a _private_ function, and\n    /// then later \"completed\" with some data in a public function.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The hash of the note to add to the tree\n    ///\n    /// # Advanced\n    /// * The note hash will be siloed with the contract address by the protocol\n    ///\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n\n    /// Adds a new nullifier to the Aztec blockchain's global Nullifier Tree.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. Hence why you're seeing this\n    /// function within the PublicContext.\n    /// An example is to check whether a contract has been published: we emit\n    /// a nullifier that is deterministic, but whose preimage is _not_ private.\n    ///\n    /// # Arguments\n    /// * `nullifier` - A unique field element that represents the consumed\n    ///   state\n    ///\n    /// # Advanced\n    /// * Nullifier is immediately added to the global nullifier tree\n    /// * Emitted nullifiers are immediately visible to all\n    ///   subsequent transactions in the same block\n    /// * Automatically siloed with the contract address by the protocol\n    /// * Used for preventing double-spending and ensuring one-time actions\n    ///\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    /// Returns the address of the current contract being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: If the calling function is a _private_ function, then\n    /// it had the option of hiding its address when enqueuing this public\n    /// function call. In such cases, this `context.msg_sender()` method will\n    /// return `Option<AztecAddress>::none`.\n    /// If the calling function is a _public_ function, it will always return\n    /// an `Option<AztecAddress>::some` (i.e. a non-null value).\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original\n    ///   transaction sender\n    ///\n    pub fn msg_sender(_self: Self) -> Option<AztecAddress> {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let maybe_msg_sender = unsafe { sender() };\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// \"Unsafe\" versus calling `context.msg_sender()`, because it doesn't\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n\n    /// Returns the function selector of the currently-executing function.\n    ///\n    /// This is similar to `msg.sig` in Solidity, returning the first 4\n    /// bytes of the function signature.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// * Extracted from the first element of calldata\n    /// * Used internally for function dispatch in the AVM\n    ///\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: The #[external(\"public\")] macro uses this internally.\n    /// Smart contract developers typically won't need to access this\n    /// directly as arguments are automatically made available.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n\n    /// Returns the \"transaction fee\" for the current transaction.\n    /// This is the final tx fee that will be deducted from the fee_payer's\n    /// \"fee-juice\" balance (in the protocol's Base Rollup circuit).\n    ///\n    /// # Returns\n    /// * `Field` - The actual, final cost of the transaction, taking into account:\n    ///             the actual gas used during the setup and app-logic phases,\n    ///             and the fixed amount of gas that's been allocated by the user\n    ///             for the teardown phase.\n    ///             I.e. effectiveL2FeePerGas * l2GasUsed + effectiveDAFeePerGas * daGasUsed\n    ///\n    /// This will return `0` during the \"setup\" and \"app-logic\" phases of\n    /// tx execution (because the final tx fee is not known at that time).\n    /// This will only return a nonzero value during the \"teardown\" phase of\n    /// execution, where the final tx fee can actually be computed.\n    ///\n    /// Regardless of _when_ this function is called during the teardown phase,\n    /// it will always return the same final tx fee value. The teardown phase\n    /// does not consume a variable amount of gas: it always consumes a\n    /// pre-allocated amount of gas, as specified by the user when they generate\n    /// their tx.\n    ///\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    /// Returns the current block number.\n    ///\n    /// This is similar to `block.number` in Solidity.\n    ///\n    /// Note: the current block number is only available within a public function\n    /// (as opposed to a private function).\n    ///\n    /// Note: the time intervals between blocks should not be relied upon as\n    /// being consistent:\n    /// - Timestamps of blocks fall within a range, rather than at exact regular\n    ///   intervals.\n    /// - Slots can be missed.\n    /// - Protocol upgrades can completely change the intervals between blocks\n    ///   (and indeed the current roadmap plans to reduce the time between\n    ///   blocks, eventually).\n    /// Use `context.timestamp()` for more-reliable time-based logic.\n    ///\n    /// # Returns\n    /// * `u32` - The current block number\n    ///\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n\n    /// Returns the timestamp of the current block.\n    ///\n    /// This is similar to `block.timestamp` in Solidity.\n    ///\n    /// All functions of all transactions in a block share the exact same\n    /// timestamp (even though technically each transaction is executed\n    /// one-after-the-other).\n    ///\n    /// Important note: Timestamps of Aztec blocks are not at reliably-fixed\n    /// intervals. The proposer of the block has some flexibility to choose a\n    /// timestamp which is in a valid _range_: Obviously the timestamp of this\n    /// block must be strictly greater than that of the previous block, and must\n    /// must be less than the timestamp of whichever ethereum block the aztec\n    /// block is proposed to. Furthermore, if the timestamp is not deemed close\n    /// enough to the actual current time, the committee of validators will not\n    /// attest to the block.\n    ///\n    /// # Returns\n    /// * `u64` - Unix timestamp in seconds\n    ///\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n\n    /// Returns the fee per unit of L2 gas for this transaction (aka the \"L2 gas\n    /// price\"), as chosen by the user.\n    ///\n    /// L2 gas covers the cost of executing public functions and handling\n    /// side-effects within the AVM.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of L2 gas\n    ///\n    /// Wallet developers should be mindful that the choice of gas price (which\n    /// is publicly visible) can leak information about the user, e.g.:\n    /// - which wallet software the user is using;\n    /// - the amount of time which has elapsed from the time the user's wallet\n    ///   chose a gas price (at the going rate), to the time of tx submission.\n    ///   This can give clues about the proving time, and hence the nature of\n    ///   the tx.\n    /// - the urgency of the transaction (which is kind of unavoidable, if the\n    ///   tx is indeed urgent).\n    /// - the wealth of the user.\n    /// - the exact user (if the gas price is explicitly chosen by the user to\n    ///   be some unique number like 0.123456789, or their favourite number).\n    /// Wallet devs might wish to consider fuzzing the choice of gas price.\n    ///\n    pub fn base_fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_l2_gas()\n        }\n    }\n\n    /// Returns the fee per unit of DA (Data Availability) gas (aka the \"DA gas\n    /// price\").\n    ///\n    /// DA gas covers the cost of making transaction data available on L1.\n    ///\n    /// See the warning in `fee_pre_l2_gas` for how gas prices can be leaky.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of DA gas\n    ///\n    pub fn base_fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_da_gas()\n        }\n    }\n\n    /// Returns the remaining L2 gas available for this transaction.\n    ///\n    /// Different AVM opcodes consume different amounts of gas.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining L2 gas units\n    ///\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n\n    /// Returns the remaining DA (Data Availability) gas available for this\n    /// transaction.\n    ///\n    /// DA gas is consumed when emitting data that needs to be made available\n    /// on L1, such as public logs or state updates.\n    /// All of the side-effects from the private part of the tx also consume\n    /// DA gas before execution of any public functions even begins.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining DA gas units\n    ///\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n\n    /// Checks if the current execution is within a staticcall context, where\n    /// no state changes or logs are allowed to be emitted (by this function\n    /// or any nested function calls).\n    ///\n    /// # Returns\n    /// * `bool` - True if in staticcall context, false otherwise\n    ///\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    /// Reads raw field values from public storage.\n    /// Reads N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to read from\n    ///\n    /// # Returns\n    /// * `[Field; N]` - Array of N field values from consecutive storage slots\n    ///\n    /// # Generic Parameters\n    /// * `N` - the number of consecutive slots to return, starting from the\n    ///         `storage_slot`.\n    ///\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    /// Reads a typed value from public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to read from\n    ///\n    /// # Returns\n    /// * `T` - The deserialized value from storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type that the caller expects to read from the `storage_slot`.\n    ///\n    pub fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    /// Writes raw field values to public storage.\n    /// Writes to N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// Public storage writes take effect immediately.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to write to\n    /// * `values` - Array of N Fields to write to storage\n    ///\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    /// Writes a typed value to public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to write to\n    /// * `value` - The typed value to write to storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type to write to storage.\n    ///\n    pub fn storage_write<T>(self, storage_slot: Field, value: T)\n    where\n        T: Packable,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn base_fee_per_l2_gas() -> u128 {\n    base_fee_per_l2_gas_opcode()\n}\nunconstrained fn base_fee_per_da_gas() -> u128 {\n    base_fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> u1 {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: u64) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: u64) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\n\nunconstrained fn call(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeBaseFeePerL2Gas)]\nunconstrained fn base_fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeBaseFeePerDaGas)]\nunconstrained fn base_fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> u1 {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "72": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\n/// A hash that represents a private contract function call's return value. Call `get_preimage` to get the underlying\n/// value.\n///\n/// The kernels don't process the actual return values but instead their hashes, so it is up to contracts to populate\n/// oracles with the preimages of these hashes on return to make them available to their callers.\n///\n/// Public calls don't utilize this mechanism since the AVM does process the full return values.\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    /// Fetches the underlying return value from an oracle, constraining that it corresponds to the return data hash.\n    pub fn get_preimage<T>(self) -> T\n    where\n        T: Deserialize,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it. If `T`\n        // is `()`, then `preimage` must be an array of length 0 (since that is `()`'s deserialization length).\n        // `hash_args_array` handles empty arrays following the protocol rules (i.e. an empty args array is signaled\n        // with a zero hash), correctly constraining `self.hash`.\n        let preimage = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage), \"Preimage mismatch\");\n\n        Deserialize::deserialize(preimage)\n    }\n}\n\nmod test {\n    use crate::{\n        hash::hash_args_array,\n        oracle::execution_cache,\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use super::ReturnsHash;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn retrieves_preimage() {\n        let env = TestEnvironment::new();\n        env.private_context(|_| {\n            let value = MockStruct::new(4, 7);\n            let serialized = value.serialize();\n\n            let hash = hash_args_array(serialized);\n            execution_cache::store(serialized, hash);\n\n            assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn retrieves_empty_preimage() {\n        let env = TestEnvironment::new();\n        env.private_context(|_| {\n            let value = ();\n            let serialized = [];\n\n            let hash = hash_args_array(serialized);\n            execution_cache::store(serialized, hash);\n\n            assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n        });\n    }\n\n    #[test(should_fail_with = \"Preimage mismatch\")]\n    unconstrained fn rejects_bad_preimage() {\n        let value = MockStruct::new(4, 7);\n        let serialized = value.serialize();\n\n        let mut bad_serialized = serialized;\n        bad_serialized[0] += 1;\n\n        let hash = hash_args_array(serialized);\n\n        let _ = OracleMock::mock(\"privateLoadFromExecutionCache\").returns(bad_serialized);\n        assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n    }\n\n    // This test passes due to a Noir bug.\n    // #[test(should_fail_with=\"Preimage mismatch\")]\n    // unconstrained fn rejects_bad_empty_preimage() {\n    //     let value = ();\n    //     let serialized = [];\n\n    //     let hash = hash_args_array(serialized);\n\n    //     let _ = OracleMock::mock(\"privateLoadFromExecutionCache\").returns([1]);\n    //     assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n    // }\n}\n"
    },
    "73": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{execution::get_utility_context, storage::storage_read};\nuse protocol_types::{address::AztecAddress, traits::Packable};\n\n// If you'll modify this struct don't forget to update utility_context.ts as well.\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        get_utility_context()\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        // We get a context with default contract address, and then we construct the final context with the provided\n        // contract address.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number: default_context.block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        // We get a context with default contract address and block number, and then we construct the final context\n        // with the provided contract address and block number.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "76": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/event/event_selector.nr",
      "source": "use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "78": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{\n        poseidon2_hash_subarray, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice,\n        sha256_to_field,\n    },\n    point::Point,\n    traits::ToField,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n\n    // `fields_to_hash` is the number of fields from the start of `packed_public_bytecode` that should be included in\n    // the hash. Fields after this length are ignored.\n    // +1 to account for the separator.\n    let num_fields_to_hash = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, num_fields_to_hash)\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = [0; 100];\n    for i in 0..100 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args_array(input);\n    dep::std::println(hash);\n    // Used in yarn-project/stdlib test snapshots:\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_calldata_hash() {\n    let mut input = [0; 100];\n    for i in 0..input.len() {\n        input[i] = i as Field;\n    }\n    let hash = hash_calldata_array(input);\n    dep::std::println(hash);\n    let hash_check = hash_calldata(input.as_slice());\n    assert(hash == hash_check);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x191383c9f8964afd3ea8879a03b7dda65d6724773966d18dcf80e452736fc1f3);\n}\n\n#[test]\nunconstrained fn public_bytecode_commitment() {\n    let mut input = [0; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS];\n    let len = 99;\n    for i in 1..len + 1 {\n        input[i] = i as Field;\n    }\n    input[0] = (len as Field) * 31;\n    let hash = compute_public_bytecode_commitment(input);\n    dep::std::println(hash);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x16d621c3387156ef53754679e7b2c9be8f0bceeb44aa59a74991df3b0b42a0bf);\n}\n"
    },
    "90": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    abis::block_header::BlockHeader, address::AztecAddress,\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::poseidon2_hash_with_separator,\n    utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(self.global_variables.block_number, public_data_tree_index)\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "93": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/keys/ecdh_shared_secret.nr",
      "source": "use dep::protocol_types::{\n    address::aztec_address::AztecAddress, point::Point, scalar::Scalar, traits::FromField,\n};\nuse std::{embedded_curve_ops::multi_scalar_mul, ops::Neg};\n\n/// Computes a standard ecdh shared secret: [secret] * public_key = shared_secret.\n/// The input secret is known only to one party. The output shared secret is derivable\n/// by both parties, through this function.\n/// E.g.:\n/// Epk = esk * G // ephemeral keypair\n/// Pk = sk * G // recipient keypair\n/// Shared secret S = esk * Pk = sk * Epk // see how this function can be called with two different sets of inputs, depending on which secret the caller knows (either esk or sk)?\n// See also: https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman\npub fn derive_ecdh_shared_secret(secret: Scalar, public_key: Point) -> Point {\n    let shared_secret = multi_scalar_mul([public_key], [secret]);\n    shared_secret\n}\n\n/// Computes a standard ECDH shared secret using the public key corresponding to an AztecAddress:\n///\n/// # Formula\n/// `[ephemeral_secret] * recipient_address_public_key = shared_secret`\n///\n/// # Usage\n/// The intention is that the _creator_ of a shared secret calls this function,\n/// providing the address of their intended recipient.\n///\n/// # Note\n/// The function returns `Option<Point>` because the recipient address might be invalid\n/// (i.e., not correspond to a point on the curve). Callers must handle the `None` case.\n/// This is unlike `derive_ecdh_shared_secret`, which always returns a `Point` because it\n/// operates on guaranteed-valid inputs.\npub fn derive_ecdh_shared_secret_using_aztec_address(\n    ephemeral_secret: Scalar,\n    recipient_address: AztecAddress,\n) -> Option<Point> {\n    recipient_address.to_address_point().map(|addr_point| {\n        derive_ecdh_shared_secret(ephemeral_secret, addr_point.inner)\n    })\n}\n\n#[test]\nunconstrained fn test_consistency_with_typescript() {\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let shared_secret = derive_ecdh_shared_secret(secret, point);\n\n    // This is just pasted from a test run.\n    // The original typescript code from which this could be generated seems to have been deleted by someone, and soon the typescript code for encryption and decryption won't be needed, so this will have to do.\n    let hard_coded_shared_secret = Point {\n        x: 0x15d55a5b3b2caa6a6207f313f05c5113deba5da9927d6421bcaa164822b911bc,\n        y: 0x0974c3d0825031ae933243d653ebb1a0b08b90ee7f228f94c5c74739ea3c871e,\n        is_infinite: false,\n    };\n    assert_eq(shared_secret, hard_coded_shared_secret);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let shared_secret = derive_ecdh_shared_secret(secret_a, pk_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_from_address_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let mut pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let mut pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let address_b = AztecAddress::from_field(pk_b.x);\n\n    // We were lazy in deriving the secret keys, and didn't check the resulting y-coordinates\n    // of the pk_a or pk_b to be less than half the field modulus.\n    // If needed, we negate the pk's so that they yield valid address points.\n    // (We could also have negated the secrets, but there's no negate method for\n    // EmbeddedCurvesScalar).\n    pk_a = if (AztecAddress::from_field(pk_a.x).to_address_point().unwrap().inner == pk_a) {\n        pk_a\n    } else {\n        pk_a.neg()\n    };\n    pk_b = if (address_b.to_address_point().unwrap().inner == pk_b) {\n        pk_b\n    } else {\n        pk_b.neg()\n    };\n\n    let shared_secret = derive_ecdh_shared_secret_using_aztec_address(secret_a, address_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret.unwrap(), shared_secret_alt);\n}\n"
    },
    "94": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/keys/ephemeral.nr",
      "source": "use std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul};\n\nuse dep::protocol_types::{point::Point, scalar::Scalar};\n\nuse crate::oracle::random::random;\n\npub fn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    // Safety: we use the randomness to preserve the privacy of both the sender and recipient via encryption, so a\n    // malicious sender could use non-random values to reveal the plaintext. But they already know it themselves anyway,\n    // and so the recipient already trusts them to not disclose this information. We can therefore assume that the\n    // sender will cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // TODO(#12757): compute the key pair without constraining eph_sk twice (once in from_field, once in the black box\n    // called by fixed_base_scalar_mul).\n    let eph_sk = EmbeddedCurveScalar::from_field(randomness);\n    let eph_pk = fixed_base_scalar_mul(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n"
    },
    "95": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n\nmod test {\n    use super::get_public_keys;\n\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    global KEY_ORACLE_RESPONSE_LENGTH: u32 = 13; // 12 fields for the keys, one field for the partial address\n\n    #[test(should_fail_with = \"Invalid public keys hint for address\")]\n    unconstrained fn get_public_keys_fails_with_bad_hint() {\n        let mut env = TestEnvironment::new();\n        let account = env.create_light_account();\n\n        // Instead of querying for some unknown account, which would result in the oracle erroring out, we mock a bad oracle\n        // response to check that the circuit properly checks the address derivation.\n        let mut random_keys_and_partial_address = [0; KEY_ORACLE_RESPONSE_LENGTH];\n        // We use randomly generated points on the curve, and a random partial address to ensure that\n        // this combination does not derive the address and we should see the assertion fail.\n        // npk_m\n        random_keys_and_partial_address[0] =\n            0x292364b852c6c6f01472951e76a39cbcf074591fd0e063a81965e7b51ad868a5;\n        random_keys_and_partial_address[1] =\n            0x0a687b46cdc9238f1c311f126aaaa4acbd7a737bff2efd7aeabdb8d805843a27;\n        random_keys_and_partial_address[2] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ivpk_m\n        random_keys_and_partial_address[3] =\n            0x173c5229a00c5425255680dd6edc27e278c48883991f348fe6985de43b4ec25f;\n        random_keys_and_partial_address[4] =\n            0x1698608e23b5f6c2f43c49a559108bb64e2247b8fc2da842296a416817f40b7f;\n        random_keys_and_partial_address[5] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ovpk_m\n        random_keys_and_partial_address[6] =\n            0x1bad2f7d1ad960a1bd0fe4d2c8d17f5ab4a86ef8b103e0a9e7f67ec0d3b4795e;\n        random_keys_and_partial_address[7] =\n            0x206db87110abbecc9fbaef2c865189d94ef2c106202f734ee4eba9257fd28bf1;\n        random_keys_and_partial_address[8] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // tpk_m\n        random_keys_and_partial_address[9] =\n            0x05e3bd9cfe6b47daa139613619cf7d7fd8bb0112b6f2908caa6d9b536ed948ed;\n        random_keys_and_partial_address[10] =\n            0x051066f877c9df47552d02e7dc32127ff4edefc8498e813bca1cbd3f5d1be429;\n        random_keys_and_partial_address[11] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // partial address\n        random_keys_and_partial_address[12] =\n            0x236703e2cb00a182e024e98e9f759231b556d25ff19f98896cebb69e9e678cc9;\n\n        let _ = OracleMock::mock(\"utilityGetPublicKeysAndPartialAddress\").returns(\n            random_keys_and_partial_address.serialize(),\n        );\n        let _ = get_public_keys(account);\n    }\n}\n"
    },
    "99": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v3.0.0-devnet.2/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::macros::{\n    dispatch::generate_public_dispatch,\n    functions::{stub_registry, utils::check_each_fn_macroified},\n    notes::NOTES,\n    storage::STORAGE_LAYOUT_NAME,\n    utils::{get_trait_impl_method, module_has_storage},\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[external(...)], #[contract_library_method], or #[test] are not allowed in contracts.\n    check_each_fn_macroified(m);\n\n    // We generate `_compute_note_hash_and_nullifier`, `sync_private_state` and `process_message`\n    // functions only if they are not already implemented. If they are implemented we just insert empty\n    // quotes.\n    let contract_library_method_compute_note_hash_and_nullifier = if !m.functions().any(|f| {\n        f.name() == quote { _compute_note_hash_and_nullifier }\n    }) {\n        generate_contract_library_method_compute_note_hash_and_nullifier()\n    } else {\n        quote {}\n    };\n    let sync_private_state = if !m.functions().any(|f| f.name() == quote { sync_private_state }) {\n        generate_sync_private_state()\n    } else {\n        quote {}\n    };\n    let process_message = if !m.functions().any(|f| f.name() == quote { process_message }) {\n        generate_process_message()\n    } else {\n        quote {}\n    };\n    let public_dispatch = generate_public_dispatch(m);\n\n    quote {\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n        $process_message\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    if NOTES.len() > 0 {\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..NOTES.len() {\n            let typ = NOTES.get(i);\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret its raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = <$typ as $crate::protocol_types::traits::Packable>::N;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullification);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_message` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `external` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::external(\"utility\")]` in the returned quote because the latter would result in\n    // the function attribute having the full path in the ABI. This is undesirable because we use the information in\n    // the ABI only to determine whether a function is `external(\"private\")`, `external(\"public\")`, or `external(\"utility\")`.\n    let external = crate::macros::functions::external;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[external(\"utility\")] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$external(\"utility\")]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    // We obtain the `external` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::external(\"utility\")]` in the returned quote because the latter would result in\n    // the function attribute having the full path in the ABI. This is undesirable because we use the information in\n    // the ABI only to determine whether a function is `external(\"private\")`, `external(\"public\")`, or `external(\"utility\")`.\n    let external = crate::macros::functions::external;\n\n    quote {\n        #[$external(\"utility\")]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::messages::encoding::MESSAGE_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            aztec::messages::discovery::process_message::process_message_ciphertext(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n"
    }
  },
  "functions": [
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14576755381182599325": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 24
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7864183510978589985": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 20
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9039158960469613821": {
            "error_kind": "string",
            "string": "NoAllowance"
          },
          "9460929337190338452": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock_high",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "hashlock_low",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "private"
      ],
      "debug_symbols": "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t6Rb0i3pduh26Hboduh26Hboduh26Hbodp5bNcE1DuIkLuImGtGJQUwi3QbdBt2YJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJQdZ8l2NH2QJcBAncRE30YhODGIS6XboduiGLLHCRdxEIzoxiEk8F+cPWQIcxElcxE00ohODmES6DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26bboZ3ZAlUTiJi/i5jV+hEZ0YxCSeh5UlFwdxEheRbk43p5vTzenmdAu6Bd2CbkG3oFvQLegWdAu6Bd2Sbkm3pFvSLemWdEu6Jd2Sbkm3Q7dDt0O3Q7dDt0O3Q7dDt0O389zwjK6LgziJi7iJRnRiEJNIt0G3QbdBt0G3QbdBt0G3QbdBt0G3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt003o5vRzehmdGOWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZMn6EFkCHMRJXMRNNKITg5hEui26LbohS3bhIm6iEZ0YxCSeh8gS4CDSbdNt023TbdNt023TbdPN6GZ0M7oZ3YxuRjejm9HN6GZ0c7o53ZxuTjenm9PN6eZ0c7o53YJuQbegW9At6BZ0C7oF3YJuQbekW9It6ZZ0S7ol3ZJuSbekW9Lt0O3Q7dDt0O3Q7dDt0O3Q7dDtPLf9+xEHcRIXcRON6MRy88IknofIklM4iJO4iJtoRCcGMYnn4aTbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptumm9HN6GZ0M7oZ3YxuRjejm9HN6OZ0c7o53ZxuTjenm9PN6eZ0c7oF3YJuQbegW9At6BZ0C7oF3YJuSbekW9It6ZZ0S7ol3ZJuSbek26Hboduh26Hboduh26Hboduh23lu9vsRB3ESF3ETjejEICaRbswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZkkwS4JZEsySakX9++yjcBON6MQgJvE8rCy5OIiTSLdBt0G3ypLv6zZmNaY2JvE8rCy5OIiTuIibaES6TbpNuk26Lbotui26LbotulWWTCt0YhCTeB5WllwcxElcxE2k26bbptum26ab0c3oZnQzuhndjG5GN6Ob0c3o5nRzujndnG5ON6eb083p5nRzugXdgm5Bt6Bb0C3oFnQLugXdgm5Jt6Rb0i3plnRLuiXdkm5Jt6Tboduh26Hboduh26Hboduh26HbeW7V69o4iJO4iJtoRCcGMYl0G3QbdBt0G3QbdBt0G3QbdBt0G3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RjliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWHGbJYZYcZslhlhxmyWGWHGbJYZYcZslhlhxmyWGWHGYJ+l5nFG6iEZ0YxCSeh8gS4CBOIt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TbdjG5GN6Ob0c3oZnQzuhndjG5GN6eb083p5nRzujndnG5ON6eb0y3oFnQLugXdkCWn0IhO/Nzq673Q93rxPKwsuTiIk7iIm2hEJ9It6ZZ0O3Q7dDt0O3Q7dDt0O3Q7dDt0O+220Pd6cRAncRE30YhODGIS6TboNug26DboNug26DboNug26DboNuk26TbpNuk26TbpNuk26TbpNum26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbpZnQzuhndjG5GN6Ob0c3oZnQzujndnG5ON6eb083p5nRzujndnG5Bt6Bb0C3oFnQLugXdgm5Bt6Bb0i3plnRLuiXdkm5Jt6Rb0i3pduh26Hboduh26Hboduh26HboxiwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLEHf6/eVugt9rxeTWG7+IbIEOIiTuIibaEQnBjGJdHO6IUt+hZO4iJtoRCcGMYnnIbIESLegW9At6BZ0C7oF3YJuQbekW9It6ZZ0S7ol3ZJuSbekW9Lt0O3Q7dDt0O3Q7dDt0O3Q7dDtPDf0vV4cxElcxE00ohODmES6DboNug26DbpVlmwrNKITP7fthUk8D5ElUTiIk7iIm2hEJwYxiefhotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptumm9HN6GZ0M7oZ3YxuRjejm9HN6OZ0c7o53ZxuTjenm9PN6eZ0c7oF3YJuQbegW9At6BZ0C7oF3YJuSbekW9It6ZZ0S7ol3ZJuSbek26Hboduh26Hboduh26Hboduh23lu6Hu9OIiTuIibaEQnBjGJdBt0w73XXTiJi7iJRnRiEJN4HuLeK5Buk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum25GN6Ob0c3oZnQzuhndjG5GN6Ob083p5nRzujndnG5ON6eb083pFnQLugXdgm5Bt6Bb0C3oFnQLuiXdkm5Jt6Rb0i3plnRLuiXdkm6Hboduh26Hboduh26Hboduh27nuaHv9eIgfm42ChdxEz83w886MYifm3nheVhZcnEQJ3ERN9GITgwi3QbdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TbdjG5GN6Ob0c3oZnQzuhndjG5GN6eb083p5nRzujndnG5ON6eb0y3oFnQLugXdgm5Bt6Bb0C3oFnRLuiXdkm5Jt6Rb0i3plnRLuiXdDt0O3Q7dDt0O3Q7dDt0O3Q7dznND3+vFQZzERdxEIzoxiEmkG7PEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmCfpev6/rWOh7vTiJi7iJRnRiEJN4Hk66TbpNuk26VZb4KTSiE3lszJJglqDvNWbhIE7i5/Y9P3ih7/WiET+37xHCC32vF5N4HlaWXBzESVzETTQi3TbdNt023SpLchUO4iR+bt8zihf6Xi8asXaJFQYxiechsgQ4iJO4iJtoRLo53ZxuTregW9At6BZ0C7oF3YJuQbegW9At6ZZ0S7ol3ZJuSbekW9It6ZZ0O3Q7dDt0O3Q7dDt0O3Q7dDt0O88Nfa8XB3ESF3ETjejEICaRboNug26DboNug26DboNug26DboNuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbptuRjejm9HN6GZ0M7oxS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzBH2v37PbF/peL56HlSVnFg7iJH5u33OQF/peLxrxz23+yu3LksYkng+/17fqe20cxD+3+T0SY1Xfa+Mm2oe70IlB/NxGTefLEmD1vTYO4iQu4iYa0YlBTCLdBt0G3QbdBt0G3QbdBt0G3QbdBt0m3SbdJt0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RbdNt023TbdNt023TbdNt023TbdNt2MbkY3o5vRzehmdDO6Gd2MbkY3p5vTzenmdHO6Od2cbk43p5vTLegWdAu6Bd2CbkG3oFvQLegWdEu6Jd2Sbkm3pFvSLemWdEu6Jd0O3Q7dDt0O3Q7dDt0O3Q7dmCXnZcn+vSzZv5cl+/eyZP9eluzfy5L9e1myfy9L9u9lyf69LNm/H90G3QbdBt0G3QbdBt0G3QbdBt0G3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt023YxuRjejm9HN6FZZ8t3N39X32hhEuhndnG6VJV97+q6+18ZF/Ny+JoJdfa+NTvzcVrlVllw8DytLVg1WWXJxEj+3XYNVllw04ue2ozCISfzcdh1QZcnFQfzcvrfKu/peGzfxc7MarLLkYhA/N68DqiwBVpZc/Ny+77za1ffauIifW4xCIzrxc4uab2XJxdNYfa/z+yKfXX2vjZP4uaUXbqIRP7eMwiAm8fSiVt9r4yDOXtTqe23cROtFrb7XxiBmL2r1vV6sLLn4uX3fKrSr77VxETfRiE4MYhLPw8qSi3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt023QzuhndjG6VJccKN9GIf27rh58NYhLPh9+mrb7XxkGcxEXcRCM6MYhJpFvQLegWdKssQbVUllw0or9qqSy5mMTzqqWy5OIgzlctlSUXN7GODejEINax1XTyPDw/4ndsow7oy5LGRfxWctR0vixpdOLnNsrty5LG01h9r+t7usCuvtfGSVzETTSiE4OYxPNw0G3Q7cuS9f0F/q6+18ZN/NxmzffLksYgfm5rFZ6HX5Y0fm71OlR9r42L+LnVy0z1vTY68XPbozCJ5+GXJWuX25cljZP4uVkN9mVJoxE/N8NgQUzi51bhWH2vjYP4uVkWLuJ+iCdeFNWwtf61zbz+a22zi4u4iUZ0YhCTeBqrJbJxECdxETfRiE4MYhLpNug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26bbotui26Lbotui26Lbotui26Lbotum26bbptulW26wugqolstGJQUzieWjlloWDOImLWG6n0IifW/wKg5jE87Besi4O4iR+brEKN9GI5WaFQUxiudV86yXr4iBO4iJu4ueWs9CJQUzi55Y1s+8lq3EQP7eshfpesho38XM7NVi9ZF2Mh/XiFF74jXtq3MqHumaoNsd1auqVDxeDmMTTWG2OjX/j/r3hK5zERdxE+3AVOjE+9MIknodfPjQO4iR+bt8zf3e1OTYa0Ymf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",
      "is_unconstrained": false,
      "name": "add_lock_private_user",
      "verification_key": "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"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15367606449725535591": {
            "error_kind": "string",
            "string": "Function add_lock_public_user can only be called internally"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16075137377171297093": {
            "error_kind": "string",
            "string": "HashlockAlreadySet"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "2360858009427093503": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "4493654309393309420": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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JwIUBAsAKhQTFC0KExUOKhQVFiQCABYAAAcxLQ4GFQAiFQIVIwAABxYtCAETAAABAgEtDhATJwIQBAwtCgwHIwAAB0wMKgcNFCQCABQAACr0IwAAB14tCxMUACoJDxUtCxUTHAoTFQQcChUJABwKCRMFACoSDxUtCxUJACoSERYtCxYVHAoVFwYcChcWABwKFhUGACISRBctCxcWJwIXBAQAKhIXGS0LGRgcChgaBhwKGhkAHAoZGAYnAhkEBQAqEhkbLQsbGhwKGhwGHAocGwAcChsaBicCGwQGACoSGx0tCx0cHAocHgYcCh4dABwKHRwGJwIdBAcAKhIdHy0LHx4cCh4gBhwKIB8AHAofHgYnAh8ECAAqEh8hLQshIBwKICIGHAoiIQAcCiEgBicCIQQJACoSISMtCyMiHAoiJAYcCiQjABwKIyIGACoSDSQtCyQjHAojJAIcCiQSABwKEiMCACoUDyQtCyQSACoUESUtCyUkHAokJgYcCiYlABwKJSQGACIURCYtCyYlACoUFyctCycmHAomKAYcCignABwKJyYGACoUGSgtCygnHAonKQYcCikoABwKKCcGACoUGyktCykoHAooKgYcCiopABwKKSgGACoUHSotCyopHAopKwYcCisqABwKKikGACoUHystCysqHAoqLAYcCiwrABwKKyoGACoUISwtCywrHAorLQYcCi0sABwKLCsGACoUDS0tCy0sHAosLQIcCi0UABwKFCwCDCoKExQWChQKHAoUEwAcCgotAAQqEwkuBCotEgkAKi4JEhwKFAkGHAoKLgYEKgkVLwQqLiQVACovFSQEKhMWFQQqLSUTACoVExYEKgkYEwQqLiYVACoTFRgEKgkaEwQqLicVACoTFRoEKgkcEwQqLigVACoTFRwEKgkeEwQqLikVACoTFR4EKgkgEwQqLioVACoTFSAEKgkiEwQqLisJACoTCRUcChQJAhwKChMCBCoJIwoEKhMsCQAqCgkTJwIJAgEKKhMJCiQCAAoAAAoQJQAALuMnAgkGAAoqGAkKJAIACgAACiclAAAu9QoqGgkKJAIACgAACjklAAAu9S0LAgoAIgoCCi0OCgItCAEKAAABAgEtDgkKLQgBEwAAAQIBLQ4JEycCFAQQJwIYBggtCgwHIwAACnMMKgcUGiQCABoAACqvIwAACoUnAhoEIC0K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",
      "custom_attributes": [
        "internal",
        "external",
        "public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "add_lock_public_user"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14576755381182599325": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 24
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "15835548349546956319": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 32 limbs"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "3380315280177356474": {
            "error_kind": "string",
            "string": "FundsNotSent"
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "6565645037161677025": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 101
          },
          "7555607922535724711": {
            "error_kind": "string",
            "string": "Preimage mismatch"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "src_receiver",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "src_asset",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 90
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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mu1S3aU5Lu3k0s4u7eLSri7t5tLuLu3h0p4u7eXS3i7t49K+Lu3n0v4uHeDSoEsHunSQSwe79AyX5rp0iEvzXDrUpcNcOtylI1w60qX5Lh3l0gKXjnbpGJeOdWmhS8e5dLxLJ7h0oksnuXSyS6e4dKpLp7n0TJdOd+kMl850aZFLZ7m02KWzXTrHpXNdOs+l8126wKULXVri0lKXlrm03KWLXFrh0sUurXTpEpdWuXSpS5e5dLlLV7h0pUtXuXS1S89y6RqXnu3SapeGXGq4tMala11a69I6l65zab1Lz3HpepducOl3XLrRpee6dJNLG1y62aXnuXSLSxtd2uTSZpdudek2l253aYtLd7h0p0t3uXS3S/e4dK9Lwy6NuLTVpW0u3efS/S4936UHXHrQpRe49EKXXuTSi116yKWXuPSwSy916RGXXubSy116hUuvdOlRl17l0qtdeo1Lr3XpdS693qU3uPRGl97k0ptdeotLb3XpbS693aV3uPROl97l0rtd+l2Xfs+l33fpPS79gUvvdel9Lv2hS3/k0h+79H6XPuDSB136E5c+5NKfuvRnLj3m0p+79Bcu/aVLf+XSh136a5c+4tJHXfqYSx936RMufdKlT7n0Ny592qXPuPRZl/7Wpc+59Hcufd6lv3fpCy590aUvufQPLv2jS1926Ssu/ZNLX3Xpay593aVvuPRNl/7ZpW+59G2X/sWl77j0XZf+1aXvufRvLn3fpR+49EOX/t2lH7n0Y5d+4tJPXfoPl37m0n+69F8u/dylx136hUv/7dIvXfqVS//j0v+69GuXfuPS/7n0/1z67bQnnZKaS9Nc6nGp16XpLvW5tINLM1zqd2lHl2a6NODSLJdmu1R3aY5LO7m0s0u7uLSrS7u5tLtLe7i0p0t7ubS3S/u4tK9L+7m0v0sH+L2kLh3o0kEuHezSM1ya69IhLs1z6VCXDnPpcJeOcOlIl+a7dJRLC1zy36n335D333f3317330X33yz33xP33/r23+H238j236/235b2333232T230v23zL23xn23wD23+f1387137X135z134P132r131H13zj13x/13wb13+3039T037v036L034n033D031f03z703yX03wz03/Pz39rz38Hz36jz34/z33bz313z30Tz3yvz3xLz3/ny3+Dy38fy367yvqH/5pP/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",
      "custom_attributes": [
        "external",
        "private"
      ],
      "debug_symbols": "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r5Knv0qeXjR5etGkwW1wG9wGt8F9+quks97OejvrxVd53g8mz/vB5OlFk+f9YOjbk8AN3MDFV/TtoW8PfXvo25PADdcXX9G3h749GXAHXHxF3x769tC3h7499O2hb08m3Mn1xVf07aFvTybcCRdf0beHvj307aFvD3176Nt/z3CL64uv6NtD354suAsuvqJvD3176NtD3x769tC3Jxvu5vriK/r20LcnG+6Gi6/o20PfHvr20LeHvj307cmBe7i++Iq+PfTtydMzZDw9Q+jbQ98e+vbQt4e+PfTtoW/PeHqGjKe/Cn176NtD357R4Da4+Iq+PfTtoW8PfXvo20PfnsH91eD+ir499O2hb8/g/mpwf0XfHvr20LeHvj307aFvD317RuA+/VXo20PfHvr2jAF3wMVX9O2hbw99e+jbQ98e+vaMCXdyffEVfXvo2zMm3AkXX9G3h7499O2hbw99e+jbMwpucX3xFX176NszCu6Ci6/o20PfHvr20LeHvj307RkL7uL64iv69tC3Z2y4Gy6+om8PfXvo20PfHvr20LdnHLiH64uv6NtD355x4B64+Iq+PfTtoW8PfXvo20Pfnvn0V5lPfxX69tC3h749s8FtcPEVfXvo20PfHvr20LeHvj2zw336q9C3h7499O2ZPA9Ongfp20PfHvr20LeHvj307aFvzwzcpxcNfXvo20Pfnsnz4Bxw8RV9e+jbQ98e+vbQt4e+PXPAHVxffEXfHvr2TJ4H54SLr+jbQ98e+vbQt4e+PfTtmQW3uL74ir499O2ZPA/Ogouv6NtD3x769tC3h7499O2ZC+7i+uIr+vbQt2fyPDg3XHxF3x769tC3h7499O2hb888cA/XF1/Rt4e+PZPnwXng4iv69tC3h7499O2hbw99e+rpRVNPLxr69tC3h749xfNgNbj4ir499O2hbw99e+jbQ9+eanCfXjT07aFvD317iudB+vYU91fF/RV9e4rnwepwOb+ibw99e+jbU9xf1dOLpp5eNPX0oqmnF009vWjq6UVTTy+aenrR1NOLpp5eNPX0oqkBd8AdcAfcCXfCnXAn3Al3wp1wJ9wJd8ItuAW34BbcgltwC27BLbgFl/P24v1gcd5evB8s3g8W5+3F+8Hi/WBx3l5PL5racDlvL87ba8PdcDfcDZf3g7XhbrgH7mG9h/XyfrB4P1i8H6wD98B9+qvU019lPb1oFu8HFz3DevqrrKe/ynp60aynF83i/eDi/eDi/eCiZ1j0DOvpr7Ke/irr6UWzeD+46BnW019lPf1V1tOLZj29aBbvBxfvBxfvBxc9w6JnWE9/ldVZb2e9vB9c9Azr6a+ywj6HfQ77zPvBxfvBxfvBRc+w6BnWYJ8H6x2sl/eDi55hDa7vYJ8H+zzYZ94PLt4PLt4PLnqGRc+wJvs8We9kvbwfXPQMa3J9i30u9rnYZ94PLt4PLt4PLnqGRc+win0u1rtYL+8H6duzeD+4eD+4FvvM+0H69ix6hsX7wcX7Qfr20LeHvj307aFvz6JnWJvri6/o20PfnkXPsOgZ6NtD3x769tC3h7499O2hb8+mZ9j0V/TtoW8PfXs2PcOmZ6BvD3176NtD3x769tC3h749m55h01/Rt4e+PfTt2fQMm56Bvj307aFvD3176NtD3x769mx6hk1/Rd8e+vbQt2fTM2x6Bvr20LeHvj307aFvD3176Nuz6Rk2/RV9e+jbQ9+eTc+w6Rno20PfHvr20LeHvj307aFvz6Zn2PRX9O2hbw99ezY9w6ZnoG8PfXvo20PfHvr20LeHvj2b+6vN/RV9e+jbQ9+ezf3V5v6Kvj307aFvD3176NtD3x769mz6q01/Rd8e+vbQt2fTX236K/r20LeHvj307aFvD3176Nuz6a82/RV9e+jbQ9+eQ3916K/o20PfHvr20LeHvj307aFvz6G/OvRX9O2hbw99ew791aG/om8PfXvo20PfHvr20LeHvj2H/urQX9G3h7499O059FeH/oq+PfTtoW8PfXvo20PfHvr2HPqrQ39F3x769tC359BfHfor+vbQt4e+PfTtoW8PfXvo23Porw79FX176NtD355Df3Xor+jbQ98e+vbQt4e+PfTtoW/Pob869Ff07aFvD317Ds+Dh+dB+vbQt4e+PfTtoW8PfXvo23PoRQ+9KH176NtD357D8+ChF6VvD3176NtD3x769tC3h749h1700IvSt4e+fdC3j9fzPDheTy866NsHffugbx/07YO+fdC3D/r28Wpwn1500LcP+vZB3z5eDW6D2+A2uA3u46tB3z7o2wd9+3h1uE8vOujbB337oG8frw43cAM3cAM37HNYb1hvWG/ghus72OfBPg/2ecAdcAfcAXfAHezzYL2T9U7WO+FOru9knyf7PNnnCXfCnXALbsEt9rlYb7HeYr0Ft7i+xT4X+7zY5wV3sd7FehfrXXAX3AV3wV2sd7PeDXez3qcXHZ++/efPMx+fvn2/P+dyf/485/Hp2z/zZj7P/PbVZ27MnTnMg3kywz1wD9zzcD99+2duzJ05zIN5MhfzYt7McBvcBvftq58/1318+vbPPJgnczEv5s18nvntq8/cmOF2uB1uh9vhdrgdbocbuIEbuIEbuIEbuIEbuIE74A64A+6AO+AOuAPugDvgDrgT7oQ74U64E+6EO+FOuBPuhFtwC27BLbgFt+AW3IJbcAvugrvgLrgL7oK74C64C+6Cu+BuuBvuhrvhbrgb7oa74W64G+6Be+AeuAfugXvgHrgH7oF7Hu6nb//Mjbkzh3kwT+ZiXsybGW6D2+Diq46vOr7q+Krjq46vOr7q+Krjq46vOr7q+Krjq46vOr7q+Krjq46vOr7q+Krjq46vOr7q+Krjq46vOr7q+Krjq46vOr7q+Krjq46vOr7q+Krjq46vOr7q+Krjq46vOr7q+Krjq46vOr7q+Krjq46vOr7q+Krjq46vOr7q+Krjq46vOr7q+Krjq46vOr7q+Krjq46vOr7q+Krjq46vOr7q+Krjq46vOr7q+Krjq46vOr7q+Krjq46vOr7q+Krjq46vOr7q+Cr4Kvgq+Cr4Kvgq+Cr4Kvgq+Cr4Kvgq+Cr4Kvgq+Cr4Kvgq+Cr4Kvgq+Cr4Kvgq+Cr4Kvgq+Cr4Kvgq+Cr4Kvgq+Cr4Kvgq+Cr4Kvgq+Cr4Kvgq+Cr4Kvgq+Cr4Kvgq+Cr4Kvgq+Cr4Kvgq+Cr4Kvgq+Cr4Kvgq+Cr4Kvgq+Cr4Kvgq+Cr4Kvgq+Cr4Kvgq+Cr4Kvgq+Cr4Kvgq+Cr4Kvgq+Cr4Kvgq+Cr4Kvgq+Cr4Kvgq+Cr4Kvgq+Cr4Kvgq+Cr4Kvgq+Cr4auCrga8Gvhr4auCrga8Gvhr4auCrga8Gvhr4auCrga8Gvhr4auCrga8Gvhr4auCrga8Gvhr4auCrga8Gvhr4auCrga8Gvhr46tO3//xdS+Pdt6+fv2tpvPv29Xp/zrzzuHMx/3BXe8+b+Ye7fv5+lvHu279zY+53rjtfbr/fw/XVd77cfu5czJeb+71dX630v/76m//193/509//w5//6X/+zX/5P7//73//93/+x3/707/88+f//tv//tfvP/mHv/zpz3/+0//4u3/9y7/84z/9t3//yz/93Z//5R9//tnfvH7+5+eXxn9t9au3v/39ye3z8f/683eMnl8/f6Po+dvfp7Dvj6zXz0f26/dH2ueT+vz5UO6H2vtDe9zPqp+v13++3s+/nf5r9O+/N9uvef9x/vgOevvV74fGf/ym5veL/N6o7O8XGePXOD//uP7jv7Gerzt+9ftZ+48PZfzK/dB5/sXzq4+7fvbk9x3Lr9//s/9Y2u9bj1+/jxreG/XsVPav3w/M311qvzekzz926Pc1/30i8ceXmL+/Qr2/QP///QLP5rX1q/f7sfGfLGn+v69Be/Yv59d4/zvrP93yzz//61//9q//Fw==",
      "is_unconstrained": false,
      "name": "commit_private_user",
      "verification_key": "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"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14427754132438837229": {
            "error_kind": "string",
            "string": "Function commit_public_user can only be called internally"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "2360858009427093503": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "4736483829072576196": {
            "error_kind": "string",
            "string": "HTLCAlreadyExists"
          }
        },
        "parameters": [
          {
            "name": "src_asset",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 90
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "src_receiver",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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ASEAAAECAScCIwABLQ4jIS0IASUnAicEIQAIAScBJwMlBAEAIiUCJy0KJyktDgspACIpAiktDgspACIpAiktDgspACIpAiktDgspACIpAiktDgspACIpAiktDgopACIpAiktDgspACIpAiktDgspACIpAiktDgspACIpAiktDgspACIpAiktDgspACIpAiktDgspACIpAiktDgspACIpAiktDgspACIpAiktDgspACIpAiktDgspACIpAiktDgspACIpAiktDgspACIpAiktDgspACIpAiktDgspACIpAiktDgspACIpAiktDgspACIpAiktDgspACIpAiktDgspACIpAiktDgspACIpAiktDgspACIpAiktDgspACIpAiktDgspACIpAiktDgspACIpAiktDgspACIpAiktDgspACIpAiktDgspJwInBCEnAikEIC0KFTQjAAAWcgwqNCcqJAIAKgAAL5UjAAAWhC0LISoEKjIqIQAqDyEqLQgBDwAAAQIBLQ4jDy0IASEnAiwEIQAIASwBJwMhBAEAIiECLC0KLC0tDgstACItAi0tDgstACItAi0tDgstACItAi0tDgstACItAi0tDgstACItAi0tDgstACItAi0tDgotACItAi0tDgstACItAi0tDgstACItAi0tDgstACItAi0tDgstACItAi0tDgstACItAi0tDgstACItAi0tDgstACItAi0tDgstACItAi0tDgstACItAi0tDgstACItAi0tDgstACItAi0tDgstACItAi0tDgstACItAi0tDgstACItAi0tDgstACItAi0tDgstACItAi0tDgstACItAi0tDgstACItAi0tDgstACItAi0tDgstACItAi0tDgstACItAi0tDgstACItAi0tDgstACItAi0tDgstACItAi0tDgstLQoVJSMAABffDColJywkAgAsAAAvJSMAABfxLQsPJQQqMyUPACoqDyUcCjUPAC0IASoAAAECAS0OIyotCAEsJwItBCEACAEtAScDLAQBACIsAi0tCi0uLQ4LLgAiLgIuLQ4LLgAiLgIuLQ4LLgAiLgIuLQ4KLgAiLgIuLQ4LLgAiLgIuLQ4LLgAiLgIuLQ4KLgAiLgIuLQ4LLgAiLgIuLQ4LLgAiLgIuLQ4LLgAiLgIuLQ4LLgAiLgIuLQ4LLgAiLgIuLQ4L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",
      "custom_attributes": [
        "internal",
        "external",
        "public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "commit_public_user"
    },
    {
      "abi": {
        "error_types": {
          "14415304921900233953": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "9967937311635654895": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          }
        },
        "parameters": [],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "initializer",
        "public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "constructor"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "2907544755768338616": {
            "error_kind": "string",
            "string": "Function get_htlc_public can only be called statically"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "key",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "src_receiver",
                "type": {
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                }
              },
              {
                "name": "amount",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "token",
                "type": {
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                }
              },
              {
                "name": "hashlock_high",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "hashlock_low",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "secret_high",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "secret_low",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "ownership_hash_high",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "ownership_hash_low",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "timelock",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "claimed",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 8
                }
              }
            ],
            "kind": "struct",
            "path": "Train::HTLC_Public"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "view",
        "external",
        "public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "get_htlc_public"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "utility"
      ],
      "debug_symbols": "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3QbdmCXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJdQmOMQo30YhOPMQg5sPKkouDOIl0S7ol3SpLxiw8xCDmxVlthI2DOImLuIlGdOIhBpFug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum25GN6Ob0c3oZnSrLBm70ImHWG6nMB9WllwcxElcxE00ohMPkW5Ot0O3Q7dDt0O3Q7dDt0O3Q7dDt0O3oFvQLegWdAu6Bd2CbkG3oFvQLemWdEu6Jd2Sbkm3pFvSLemWz238fsRBnMRF3EQjOvEQg0i3QbdBt0G3QbdBt0G3QbdBt0G3QbdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TTejm9HN6GZ0M7oZ3YxuRjdmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJYsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWLGZJdWKO792ks1oxG43oxEMMYj6sLLk4iJNIt0W3RbfKkjkKDzGI+bCy5OIgTuIibqIR6bbptum26WZ0M7oZ3YxuRjejm9HN6GZ0M7o53ZxuTjenm9PN6eZ0c7o53Zxuh26Hboduh26Hboduh26Hboduh25Bt6Bb0C3oFnQLugXdgm5Bt6Bb0i3plnRLuiXdkm5Jt6Rb0i2fW7V1Ng7iJC7iJhrRiYcYRLoNulWWzFU4iYtYbl5oRCceYhDzYWXJxUGcxEWk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26ab0c3oZnQzuhndjG5GN6Ob0c3o5nRzujndnG5ON6eb083p5nRzuh26Hboduh26Hboduh26Hboduh26Bd2CbkG3oFvQLegWdAu6Bd2Cbkm3pFvSLemWdEu6Jd2Sbkm3fG72+xEHcRIXcRON6MRDDCLdBt0G3QbdBt2YJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklziw5zJLDLDnMksMsOcySwyw5zBL0vc4sDGI+RJYAB3ESF3ETjehEug26DbpVlnzf+DHR93pxEhdxE43oxEMMYj5cdFt0W3RbdFt0W3RbdFt0W3SrLFnfx63oe704iJO4iJtoRCceYhDpZnQzuhndjG5GN6Ob0c3oZnQzujndnG5ON6eb083p5nRzujndnG6Hboduh26Hboduh26Hboduh26HbkG3oFvQLegWdAu6Bd2CbkG3oFvSLemWdEu6Jd2Sbkm3pFvSLZ8b+l4vDuIkLuImGtGJhxhEug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26LboxS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJeh7XbswiPkQWQIcxElcxE00ohPpNuk26bbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptulmdDO6Gd2MbkY3o5vRzehmdDO6Od2cbk43p5vTzenmdHO6Od2cboduh26Hboduh26Hboduh27IEi/Mh8gSYLlF4SQu4iYa0YmHGMR8iCwB0i3plnRLuiXdkm5Jt6RbtttC3+vFQZzERdxEIzrxEINIt0G3QbdBt0G3QbdBt0G3QbdBt0G3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt003o5vRzehmdDO6Gd2MbkY3o5vRzenmdHO6Od2cbk43p5vTzenmdDt0O3Q7dDt0O3Q7dDt0O3Q7dDt0C7oF3YJuQbegW9At6BZ0C7oF3ZJuSbekW9It6ZZ0S7ol3ZJuzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzBL0vX7f6rvQ93pxEj+3vQo30YhOPMQg5sPKkouDOIl0c7ohS06hEw8xiPkQWQIcxElcxE2k26Hboduh26Fb0C3oFnQLugXdgm5Bt6Bb0C3olnRLuiXdkm5Jt6Rb0i3plnTL54a+14uDOImLuIlGdOIhBpFug26DboNug26DboNug26DbpUlNgvzYWXJxc/NVuEkLmKdk7vQiE48xCDmw8qSi4M4iYtIt0W3RbdFt0W3RbdNt023TbdNt023TbdNt023TbdNN6Ob0c3oZnQzuhndjG5GN6Ob0c3p5nRzujndnG5ON6eb083p5nQ7dDt0O3Q7dDt0O3Q7dDt0O3Q7dAu6Bd2CbkG3oFvQLegWdAu6Bd2Sbkm3pFvSLemWdEu6Jd2Sbvnc0Pd6cRAncRE30YhOPMQg0m3QbdBt0G3QbdANWTIKnXiIQcyHuC8BDuIkLuIm0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt083oZnQzuhndjG5GN6Ob0c3oZnRzujndnG5ON6eb083p5nRzujndDt0O3Q7dDt0O3Q7dDt0O3Q7dDt2CbkG3oFvQLegWdAu6Bd2CbkG3pFvSLemWdEu6Jd2Sbkm3pFs+N/S9XhzESVzETTTi52ZReIhB/Ny8/m1lycVB/Nx8FS7iJhrRiYcYxHxYWXJxEOk26TbpNuk26TbpNuk26bbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptulmdDO6Gd2MbkY3o5vRzehmdDO6Od2cbk43p5vTzenmdHO6Od2cboduh26Hboduh26Hboduh26HboduQbegW9At6BZ0C7oF3YJuQbegW9It6ZZ0S7ol3ZJuSbekW9Itnxv6Xi8O4iQu4iYa0YmHGES6DboN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",
      "is_unconstrained": true,
      "name": "is_contract_initialized"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14576755381182599325": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 24
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "15835548349546956319": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 32 limbs"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "3380315280177356474": {
            "error_kind": "string",
            "string": "FundsNotSent"
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "6565645037161677025": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 101
          },
          "7555607922535724711": {
            "error_kind": "string",
            "string": "Preimage mismatch"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock_high",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "hashlock_low",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "ownership_hash_high",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "ownership_hash_low",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "src_asset",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 90
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "private"
      ],
      "debug_symbols": "TL3JjjXLjpz7LnuswfKGdLJe5Q6Eq9sIBRRUgJpRQe+uDJrTzSbn/2yfTJo3QUasWMyI//jn//3//sv/+q//+V//2///7//jn3/5v/7jn//y3//13/7tX//rf/63f/9//u//+a///t/+/ut//PP7/mfsf/5ljfD//Z/+GZ/e/s+/jP/0zz74J/BP1j/2wz8D/0z8s/DPxj+GfxDFEMUQxRDFEcURxRHFEcURxRHFEcURxRHFEeUgykGUgygHUQ6iHEQ5iHIQ5SDKQZRAlECUQJRAlECUQJRAlECUQJRAlESURJRElESURJRElESURJRElESU8fvdf8f9d95/1/1333/t/uv333P/jfvvjTduvHHjjRtv3Hjjxhs33rjxxo03brxx480bb95488abf/HW9+++/9r91++/f/H8+zfuv4l/11+8/P794n0/uGbDatgN1uAN3yjPB9GQF/av4YscH8yG1fBF/ka/rcEb/iLP/UE05IUvAwCjYTasht1gDd7Qka0jW0f+smJ+q/LlBWA2rIbdYA3ecBqiIS+cjnw68unIpyOfjnw68unIpyOfjnw6cnTk6MjRkaMjR0eOjvxl0vy24MslQDTkhS+jAKNhNqyG3WANHTk7cnbkvJHn79cwGmbDatgN1uANpyEaOvLoyKMjj448OvLoyKMjj448OvLoyKMjz448O/LsyLMjz448O/LsyLMjz448O/LqyKsjr468OvLqyKsjr468OvLqyKsj7468O/LuyLsj7468O/LuyLsj7468O7J1ZOvIXw6u8cFq2A3W4A2nIRrywpeDgNHQkb0je0f+cnDtD7zhNHyR84O88OUgYDTMhtWwG6zBG05DRz4dOTpy3Io0Yzasht1gDd5wGqLhVqSZv4aOnB05O/KXg3t+YA3ecBqiIQHry0HAaJgNq2E3WIM3nIYv8vogL3w5CBgNs2E17AZr8IbT0JFHR54d+cvB7R/MhtXwF9l+H1iDN5yGaMgLXw4CRsNsWA0deXXk1ZFXR14deXXk3ZF3R94deXfk3ZF3R94deXfk3ZF3R7aObB3ZOrJ1ZOvI1pGtI1tHto5sHdk7sndk78jekb0je0f2juwd2Tuyd+TTkU9HPh35dOTTkU9HPh35dOTTkU9Hjo4cHTk6cnTk6MjRkaMjR0eOjhwdOTtyduTsyNmRsyNnR86OnB05O3LeyPv3axgNs2E17AZr8IbTEA0deXTk0ZFHRx4deXTk0ZFHRx4deXTk0ZFnR54deXbk2ZE7B3fn4O4c3J2Du3NwVw7+VZJdOVgwGmbDatgN1uANpyEaOvLuyLsj7468O/LuyLsj7468O/LuyLsjW0e2jmwd2TqydWTryNaRrSNbR7aO7B3ZO7J3ZO/I3pG9I3tH9o7sHdk78unIpyOfjnw68unIpyOfjnw68unIpyNHR46OHB05OnJ05OjI0ZGjI0dHjo6cHTk7cnbk7MjZkbMjZ0fOjpwdOW9k+/0aRsNsWA27wRq84TREQ0ceHXl05NGRR0ceHXl05NGRR0ceHXl05NmRZ0eeHXl25NmRZ0eeHXl25NmROwetc9A6B61z0DoHrXPQOgetc9A6B61z0DoHrXPQOgetc9A6B61z0DoHrXPQOgetc9A6B61z0DoHrXPQOgetc9A6B61z0CoH7YNoyAuVgwWjYTasht1gDd7Qkb0je0c+Hfl05NORT0c+Hfl05NORT0c+Hfl05OjI0ZG/HPS6A7QadoM1eMNpiIa88OUgYDR05C8H/VvMLwcB1uANpyEaEuBfDgJGw2xYDbvBGrzhi7w/iIa88OUgYDTMhtWwG6zBGzry6MijI8+OPDvy7MizI8+OPDvy7MizI8+OPDvy6sirI6+OvDry6sirI6+OvDry6sirI++OvDvyl4NuH6yG3fBF9g+84TR8keODvPDlIOAv8qm7h7NhNfxFPucDa/CGv8infj0a8sKXg/H7YDTMhtWwG6zBG05DNOSF05FPRz4d+cvBqLueu8Eavsjf0n05CIiGvPDlIGA0zIbVsBusoSNHR46O/OVgfJvy5SBgNMyG1bAbrMEbTkM03Mjn92sYDbNhNewGa/CG0xANHXl05NGRR0ceHXl05NGRR0ceHXl05NGRZ0eeHXl25NmRZ0eeHXl25NmRZ0eeHXl15NWRV0deHXl15NWRV0deHXl15NWRd0feHXl35N2Rd0feHXl35N2Rd0feHdk6snVk68jWka0jW0e2jmwd2TqydWTvyN6RvSN7R/aO7B3ZO7J3ZO/I3pFPRz4d+XTk05FPRz4d+XTk05FPRz4dOTpydOToyNGRoyNHR46OXDkYH0RDXqgcLBgNs2E17AZr8IaOnB05b+T4/RpGw2xYDbvBGrzhNERDRx4deXTk0ZFHRx4deXTk0ZFHRx4deXTk2ZFnR54deXbk2ZFnR54deXbk2ZFnR14deXXk1ZFXR14deXXk1ZFXR14deXXk3ZF3R94deXfk3ZF3R94deXfk3ZF3R7aObB3ZOrJ1ZOvI1pGtI1tHto5sHdk7sndk78jekb0je0f2juwd2Tuyd+TTkU9HPh35dOTTkU9HPh35dOTTkU9Hjo4cHTk6cnTk6MjRkaMjdw5G52B0DkbnYHQORudgdA5G52B0DkbnYHQORudgdA5m52B2DmbnYHYOZudgdg5m52B2DmbnYHYOZudgdg5m52B2DmbnYHYOZudgdg5m52B2DmbnYHYOZudgdg5m52B2DmbnYHYOZudgdg5m52B2DmbnYHYOZudgdg5m52B2DmbnYHYOZudgdg5m52B2DmbnYHYOZudgdg5m52B2DmbnYHYOZudgdg7ml4NZXwlbgzechmjIC18OAkbDbFgNHdk7snfkLwdzfhANeeHLQcBomA2rYTdYgzd05NORT0eOjhwdOTpydOToyNGRoyNHR46OHB05O3J25OzI2ZGzI2dHzo6cHTk7ct7If1/C/x6NR/PRerQf2SN/dB7Fo+cxnsd4HuN5jOcxnsd4HuN5jOcxnsd4HvN5zOcxn8d8HvN5zOfxpWfuovMoHn0epxoTfo/Go/loPdqP7JE/Oo/i0fPYz2M/j/089vPYz2M/j/089vPYz2M/D3se9jzsedjzsOdhz8Oehz0Pex72PPx5+PPw5+HPw5+HPw9/Hv48/Hn48zjP4zyP8zzO8zjP4zyP8zzO8zjP4zyPeB7xPOJ5xPOI5xHPI55HPI94HvE88nnk88jnkc8jn0c+j3we+TzyeWR7VLfNpfFoPlqP9iN75I/Oo3j0PMbzGM9jPI/xPMbzGM9jPI/xPMbzGM9jPo/5PObzmM9jPo/5PObzmM9jPo+X5+Pl+Xh5Pl6ej5fn4+X5eHk+Xp6Pl+fj5fl4eT5eno+X5+Pl+Xh5Pl6ej5fn4+X5eHk+Xp6Pl+fj5fl4eT5eno+X5+Pl+Xh5Pl6ej5fn4+X5eHk+Xp6Pl+fj5fl4eT5eno+X5+Pl+Xh5Pl6ej5fn4+X5eHk+Xp6Pl+fj5fl4eT5eno+X5+Pl+Xh5Pl6ej5fn4+X5eHk+Xp6Pl+fj5fl4eT5eno+X5+Pl+Xh5Pl6ej5fn4+X5eHk+Xp6Pl+fj5fl4eT5fns+X5/Pl+Xx5Pl+ez5fn8+X5fHk+X57Pl+fz5fl8eT5fns+X5/Pl+Xx5Pl+ez5fn8+X5fHk+X57Pl+fz5fl8eT5fns+X5/Pl+Xx5Pl+ez5fn8+X5fHk+X57Pl+fz5fl8eT5fns+X5/Pl+Xx5Pl+ez5fn8+X5fHk+X57Pl+fz5fl8eT5fns+X5/Pl+Xx5Pl+ez5fn8+X5fHk+X57Pl+fz5fl8eT5fns+X5/Pl+Xx5Pl+ez5fn8+X5fHk+X57Pl+fz5fl8eT5fns+X5/Pl+Xx5Pl+ez5fn8+X5fHk+X57Pl+fz5fl8eT5fns+X5/Pl+Xx5Pl+ez5fn8+X5fHk+X57Pl+fVTvR3Yi40ohMPMYjZWK1FjYM4iYu4iUZ0YrmNwiDmw+qwvTiIk7iIm2hEJ9Jt0G3QbdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TzehmdDO6Gd2MbkY3o5vRzehmdHO6Od2cbk43p5vTzenmdHO6Od0O3Q7dDt0O3Q7dDt0O3Q7dDt0O3YJuQbdqpP9Vl3Y101/cxHKrJvBqrL94iEHMh9Vof3EQJ3ERN5FuSbekW9Itn9v+/YiDOImLuIlGdOIhBpFug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum25GN6Ob0c3oZnQzuhndjG5GN6Ob083p5nRzujndnG5ON6eb083pduh26Hboduh26Hboduh26HbodugWdAu6Bd2CbkE31pLNWrJZSzZryWYt2awlm7Vks5Zs1pLNWrJZSzZryWYt2awlm7XEWEuMtcRYS4y1xFhLjLXEWEuMtcRYS4y1xFhLjLXEWEuMtcRYS4y1xFhLjLXEWEuMtcRYS4y1xFhLjLXEWEuMtcRYS4y1xFhLjLXEWEuMtcRYS4y1xFhLjLXEWEuMtcRYS4y1xFhLjLXEWEuMtcRYS4y1xFhLjLXEWEuMtcRYS4y1xFhLjLXEWEuMtcRYS4y1xFhLjLXEWEuMtcRYS4y1xFhLjLXEWEuMtcRYS4y1xFhLjLXEWEuMtcRYS4y1xFhLjLXEWEuMtcRYS4y1xFhLjLXEWEuMtcRYS4y1xFhLjLXEWEuMtcRYS4y1xFhLjLXEWEuMtcRYS4y1xFlLnLXEWUuctcRZS5y1xFlLnLXEWUuctcRZS5y1xFlLnLXEWUuctcRZS5y1xFlLnLXEWUuctcRZS5y1xFlLnLXEWUuctcRZS5y1xFlLnLXEWUuctcRZS5y1xFlLnLXEWUuctcRZS5y1xFlLnLXEWUuctcRZS5y1xFlLnLXEWUuctcRZS5y1xFlLnLXEWUuctcRZS5y1xFlLnLXEWUuctcRZS5y1xFlLnLXEWUuctcRZS5y1xFlLnLXEWUuctcRZS5y1xFFLsjAfopYAB3ESF3ETjejEQ6Rb0C3pVrWk/ti1Wu0aF3ETjejEQwxiNlbrXeMgTuIibqIRnXiIQaRb1ZIxCwdxEhdxE43oxEMMYj6cdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt023QzuhndjG5GN6Ob0c3oZnQzuhndnG5ON6eb083p5nRzujndnG5Ot0O3Q7dDt0O3Q7dDt0O3Q7dDt0O3oFvQLegWdAu6Bd2CbkG3oFvQLemWdEu6Jd2Sbkm3pFvSLemWzy1+P+IgTuIibqIRnXiIQaQba0mwlgRrSbCWBGtJsJYEa0mwlgRrSbCWBGtJsJYEa0mwlgRrSbCWBGtJsJYEa0mwlgRrSbCWBGtJsJYEa0mwlgRrSbCWBGtJsJYEa0mwlgRrSbCWBGtJsJYEa0mwlgRrSbCWBGtJsJYEa0mwlgRrSbCWBGtJsJYEa0mwlgRrSbCWBGtJsJYEa0mwlgRrSbCWBGtJsJYEa0mwlgRrSbCWBGtJsJYEa0mwlgRrSbCWBGtJsJYEa0mwlgRrSbCWBGtJsJYEaskuzIeoJcBBnMRF3EQjOvEQ6ZbPLX8/4iBO4iJuohGdeIhBpNug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbphtqyXe9nqglwEEstyhcxE00ohMPMYj5ELUEOIh0c7o53ZxuTjenm9PN6Xboduh26Hboduh26Hboduh26HboFnQLugXdgm5Bt6Bb0C3oFnQLuiXdkm5Jt6Rb0i3plnRLuiXdst3m7/cjDuIkLuImGtGJhxhEug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum26Gd2MbkY3o5vRzehmdDO6Gd2Mbk43p5vTzenmdHO6Od2cbk43p9uh26Hboduh26Hboduh26HboduhW9At6BZ0C7oF3YJuQbegW9At6JZ0S7ol3ZJuSbekW9It6ZZ0Yy0ZrCWDtWSwlgzWksFaMlhLBmvJYC0ZrCWDtWSwlgzWksFaMlhLBmvJYC0ZrCWDtWSwlgzWksFaMlhLBmvJYC0ZrCWDtWSwlgzWksFaMlhLBmvJYC0ZrCWDtWSwlgzWksFaMlhLBmvJYC0ZrCWDtWSwlgzWksFaMlhLBmvJYC0ZrCWDtWSwlgzWksFaMlhLBmvJYC0ZrCWDtWSwlgzWksFaMlhLBmvJYC0ZrCWDtWSwlgzWksFaMlhLBmvJYC0ZrCWDtWSwlgzWksFaMlhLBmvJYC0ZrCWDtWSwlgzWksFaMlhLBmvJYC0ZrCWDtWSwlgzWksFaMlhLBmvJYC0ZrCWDtWSwlgzWkslaMllLJmvJZC2ZrCWTtWSylkzWkslaMllLJmvJZC2ZrCWTtWSylkzWkslaMllLJmvJZC2ZrCXVrvpXUAoncRE/t7kKjejEQwxiPqxacnEQJ3ER6bbohlpyCg8xiPkQtQQ4iJO4iJtoRLptum26bboZ3YxuRjejm9HN6GZ0M7oZ3YxuTjenm9PN6eZ0c7o53ZxuTjen26Hboduh26Hboduh26Hboduh26Fb0C3oFnQLugXdgm5Bt6Bb0K1qyZofVi25OIif26pDrmrJxU2sY3IXOvEQg5iN6Hu9OIiTuIibaEQnHmIQ6TboNug26DboNug26DboNug26DboNuk26TbpNuk26TbpNuk26TbpNum26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbpZnQzuhndjG5GN6Ob0c3oZnQzujndnG5ON6eb083p5nRzujndnG6Hboduh26Hboduh26Hboduh26HbkG3oFvQLegWdAu6oZaMwkMMYj7EdQlwECdxETfRiHRLuiXd8rmh7/XiIE7iIm6iEZ14iEGk26DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26ab0c3oZnQzuhndjG5GN6Ob0c3o5nRzujndnG5ON6eb083p5nRzuh26Hboduh26Hboduh26VS1ZURjEfFi1ZNfPVi25OImf2/fw2Ym+14tGdOIhBjEfVi25OIiTSLekW9It6ZZ0S7rlc0Pf68VBnMRF3EQjOvEQg0i3QbdBt0G3QbdBt0G3QbdBt0G3QbdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TTejm9HN6GZ0M7oZ3YxuRjejm9HN6eZ0c7o53ZxuTjenm9PN6eZ0O3Q7dDt0O3Q7dDt0O3Q7dDt0O3QLugXdgm6sJcZaYqwlxlpirCXGWmKsJcZaYqwlxlpirCXGWmKsJcZaYqwlxlpirCXOWuKsJc5a4qwlzlrirCXOWuKsJc5a4qwlzlrirCXOWuKsJc5a4qwlzlrirCXOWuKsJc5a4qwlzlrirCXOWuKsJc5a4qwlzlrirCXOWuKsJc5a4qwlzlrirCXOWuKsJc5a4qwlzlrirCXOWuKsJc5a4qwlzlrirCXOWuKsJc5a4qwlzlrirCXOWuKsJc5a4qwlzlrirCXOWuKsJc5a4qwlzlrirCXOWuKsJc5a4qwlzlrirCXOWuKsJc5a4qwlzlrirCXOWuKsJc5a4qwlzlrirCXOWoK+1x2FTjzEIOZD1BLgIE7iIm4i3ZJuSbeqJeaF2Yi+14tvboe15LCWoO/V8BoHIzrxc/ueaTrR93oxH1Yt+Z5sOtH3enESF3ETjejEQwxiPpx0m3SbdJt0q1pyfoVGdOLn9j1DdaLv9WI+RC2ZhYM4iYu4iUZ04iEGMR9uum26bbptum26bbptum26bbptuhndjG5GN6Ob0c3oZnQzuhndjG5ON6eb083p5nRzujndnG5ON6fboduh26Hboduh26Hboduh26HboVvQLegWdAu6Bd2CbkG3oFvQLeiWdEu6Jd2Sbkm3pFvSLemWdMvnhr7Xi4M4iYu4iUZ04iEGkW6DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNurCXBWhKsJcFaEqwlwVoSrCXBWhKsJcFaEqwlwVoSrCXBWhKsJcFaEqwlwVoSrCXBWhKsJeh7/Z4wPdH3enERqyrXW32qllx04uf2PSx2ou/1Yj6sWpLlVrXk4iR+brkKN9GIf27zew7GrL7XxiDmh985oPpeGwdxfljDqReNXdxEIzrxEIOYD+u1YxcHkW5Bt6Bb0C3oFnQLugXdkm5Jt6Rb0i3plnRLuiXdkm753KrvtXEQJ3ERN9GITjzEINJt0G3QbdBt0G3QbdBt0G3QbdBt0G3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt083oZnQzuhndjG5GN6Ob0c3oZnRzujndnG5ON6eb083p5nRzujndDt0O3VhLkrUkWUuStSRZS5K1JFlLkrUkWUuStSRZS5K1JFlLkrUkWUuStSRZS5K1JFlLkrUkWUuStSRZS5K1JFlLkrUkWUvy1ZL1e7Vk/V4tWb9XS9bv1ZL1e7Vk/V4tWb9XS9bv1ZL1e7Vk/X50G3QbdBt0G3QbdBt0G3QbdBt0G3SbdJt0m3SbdJt0m3SbdJt0m3SrWvLdwl/V99o4iHRbdFt0q1ry9aSv6nttPMTP7escWNX3erFqycXPbZZb1ZKLi/i5zQpWteSiEz+3iWBBzIdVS77XFq7qe22cxM9t1YSqllw04uf2fVReP7zgFBjEz21XsKolFwfxc7OaUNWSi5v4uX2vzFnV99p4iJ+bRWE+rFpy8XPzGi9efwpcxM/Na83wElSgEz+3UxOqWnIxH1YtOTWhqiUXJ3G9Ra1actGI/ha1asnFIOZbVLyeETiI8y0qXtII3MTP7dTOVy25eIhBzMbqe20cxElcxE00ohMPMYh0G3QbdBt0G3QbdBt0G3QbdBt0G3SbdJt0m3SbdJt0m3SbdMPLVmdhEPMhXrlaP4uXrgIn8XP7nhS+Bl69CjSiEw8xiPkQr2EFDuIk0m3TbdNt061qSWULXo18MR9WLalswQuSL07i6mzBa5IvGtE7W/Cy5ItB/NyysGrJxUH83LKGU7Xk4iZ+blkTqlpy8RD/3NavhlMvcAXWK1wvjg/LrV7jenER94c143qZ60UnHmIQ82G91vXiIE7iItIt6PbVkjVqvF8taQzi5zZqvF8taRzEz23+ChdxEz+3Og9V32vjIX5udZqpvldg9b02fm7fO3xX9b02LuLntn6FRnTi57YQLIj58Ksla1Wwr5Y0TuLnVsWx+l4bjfi5bSs8xHiInoai+lEv/Iawy6HeK3xxECdxETfRiE48xCDS7dDt0O3Q7dDt0O3Q7dDt0O3Q7dAt6BZ0C7oF3YJuQbegW9At6BZ0S7ol3ZJuSbekW9It6ZZ0S7rlc6umysZBnMRF3EQjOvEQg0i3QbdBtzpQ6yKomiobN9GITjzEz+17G9+qpsqL30mvcRDLzQsXsdxOoRGdeIhBzIfrR/zc/Fc4iYv4uX0v11vVVNnoxM+tTjjVVNmYD7+TXuMgTmK5ZeEmGtGJn9upkX0nvcZ8+J301qmF+k56jZP4uZ0KVu8lv2jEmsUq/OJGxa36UNcM1Si5ooZe9eGiEZ14iEGsuOVW9eHiIE7i55Y1BryTHPi5ZQ0S7yUHHmIQ8yHeTw783LIOgqoPFxdxE8utMqDqw8Vyq0FWfbiYD6s+XPxz23W+rkbJxkXcRCM68XxYw6l3mF/MxmqUbCy3KJzERSy3UWhEf1hvLL9YEbLw+9nvz/JX9TbuOnVXb2NjPqxXlF8cxC9YfZqs3sbGTTSiEw/xc6sTevU2XvxSunEQP7dZ4/1SunETP7dZI/tSuvEQy80Ky+3Loept3HVJUL2NjZO4iJtoxC/uqkF+yXvxS97GQZzE9dALd+Emfhb16ayaCXdddVQz4cXzIw7iJK6HUf+1xhuLuIlGdOIhBjEf5o84iHRLuiXdkm5Jt3xu1d73t02FX4SNl8N/Eb6vOlY18jU68YtQH1irka8xH37nwsZBnMSKuwsrghVWhBpZJcPFQawIp3ARN9GITjzEcqsZVzIAKxnwIvtKhouT+MWt83E13O26a1ENdxfrAK8rx2q4+zvuCidxETex4tY6fOesxkMst1qdOuyBddhfpJvRzehmdDMj+tsL424ad9O4m87ddO5m5RC20M/bwsohbJZzNw93s3IIe3G4m4e7ebibh7t5uJvnvH073M2Tb7OCuxnczcpCbGHlG/YtuJuVb9jCyjcsVHJ9k+ubXN/KN2xWcjeTu1n5hs1K7ma+3azGOASrxrjGSVzEt5vVXbbroqy6yxo3sYaThU48xCDmQyQDcBAncRE/t7r0qe6yRiceYhDzYSWO13grcS5O4iKWWxQa0YnlViOrxLmYDytx6rqvussaJ3ERP7evSWZVH9lfyS8MYj6sFLlYcXdhxa09rpNPXU9WH1mjEZ1YbjXjSqeL+bDS6WK51dwqh6LGWzlU157VPLajhlM5FPi1QwxiPqwcujiIk1huteqVWRc/tyzjOr9dPMQg5sPKt4ufW9Y6VL5dXMRNLLcaTuXbxUMstxpZ5VthNY81/rnZ9334quYx+83CRdxEIzrxPPzOelZfHVSbWON8OOu/lvGcxHLLwk00ohMPMYh/c/s75374Ja/VzYxq52qcxEXcRCN+ceuStVq0rC5Dq0XL6luPatFq3MSKUNP8ErLxEIOYD+1HLLdTOInlVgtlm2jEilvr8KWe1b2tartqrAi7cL+FciM68RC/uHVVXG1XF7/UaxxvA84kcjcP3Q7dDt0O3U48/LLF6mK62qMa82FlS33Wq/aoxklcxE004jeGWUuShxjEbKz2qMZBnMRvbnXFX41QjYcYxHxY2XJxECdxETeRboNug26DboNuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbptuRjejm9HN6GZ0M7oZ3YxuRjejm9PN6eZ0c7o53ZxuTjenm9PN6Xboduh26Hboduh26Hboduh26HboFnQLugXdgm5Bt6Bb0C3oFnQLuiXdkm5Jt6Rb0i3plnRLuiXd8rnl70ccxElcxE00ohMPMYh0Yy1J1pJkLUnWkmQtSdaSZC1J1pJkLUnUku+UlKglwEFcXRETBQRoRCceYhBf0c31Iw7iJNJt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt083oZnQzuhndjG5GN6Ob0c3oZnRzujndnG5ON6eb083p5nRzujndDt0O3Q7dDt0O3Q7dDt0O3Q7dDt2CbkG3oFvQLegWdAu6Bd2CbkG3pFvSLemWdEu6Jd142ZG87EheduS77Ni/d9mxf++yY//eZcf+/RZxE43oxEMMIt0G3QbdBt0G3QbdBt0G3QbdBt0G3SbdJt0m3SbdJt0m3SbdJt0m3aqWfF+x7up+ahzEz+17qMmu7qfGTfzcvjunu7qfGg8xiPmwasnFcrPCSVzETTSiEw8xiPmwaslFuhndjG5VS1atTtWSi048xCDmw6ol353eXd1PjZNYblG4iUZ0YsXND6s+7NqWqg8XN/GLsGtbqj5cPMRvvN99uV0dTRerPlwcxHKrCVV9uLiJRqy4tXyV89/tsV1dSo2LWDMui8r5i048xCBmY3UpNZZbFk7iItZ4o9CITjzEIObDyvmLgziJi0i3QbfK+e/u4q4uJfvuLu7qUmrMh5XzFwdxEhdxE43oRLpVzn83Gnd1KV2snL9YbrNwEhex3LzQiE783BzBgpgPK+e/r2Z3dSk1TuLn9t3D29Wl1GjEz+3UcCrnLwYx389Wzl8cxM/tlFvl/MVN/NyiNqty/uIhfm5Ri1o5D6ycv/i5RS1J5fzFRfzcooZTOX/RibWS+Nkg5sO6fsha1Lp+uDiJn1vWhKo+XDTin5v/as2++tAYxPywkuyrD42D+Ofmo5bkqw+Nm2gf1pJ81w+Nh/i5jRrOd/1w8bt+aPzcZv3sV0saF3HzZ43oxM9t1pp9taQxG6tLyb8r811dSo2T+LnViaq6lBqN+LktBDvEIH5uVfirS6lxED+3KqTVpdS4iZ9bldfqUmo8xM/tu92/6+l8F79a0vi5VaLX0/kaF/Fz85rQV0sanfi5fZ0Zu57O15gPv1ri3/31XU/na5zERdxEIzrxEIOYDzfdNt023b5a4pXS9XS+RiN+bqd26KsljUH83KKW76sljYP4uUUt31dLGjfR3haaEw8x3hZ+teTiV0sax9tCn8RF3G8Lv1rS6MTPrcpKNZI15sOvlnjWFn61pHESP7fEz26iET+3rFWvWnIxiPlWvWrJxUGcb9WrllzcRHurXrXk4iHGW/WqJcCqJRf/3M4POImLuD+s4Xy1pNGJ58Oa0FdLGrOxGsnOdx98VyNZ4yR+bt8t5l2NZI1G/Ny+G+W7Gskag/i5zQr21ZLGQfzc6tq+GskaN/Fzq2v7aiRrPMTPrUpbNZJd/GpJ4+dWlasayRoX8XOrq9dqJGt04udWl6zVSNaYD79acnYF+2pJ4yR+bnV1VY1kjUb83CoDqpGsMYif2/fF6q5GssZBfNc71Rxm978GMR/WtcbFQZzERdzEb7ywMCceYhDzof+IgziJ3+p837zuaiRrNGK51Ur6IQaxrn8L61rj4iB+bl6b9VWCUyeJahlrPMQg5sOvEjQO4iQu4ibSLegWdAu6Bd2Sbkm3pFvSLemWdEu6Jd2SbvncqmWscRAncRE30YhOPMQg0m3QbdBt0G3QbdBt0G3QbdBt0G3QbdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TzehmdDO6Gd2MbkY3o5vRzehmdHO6Od2cbk43p5vTzenmdHO6Od0O3Q7dDt0O3Q7dWEs2a8lmLdmsJZu1ZLOWbNaSzVqyUUtm4SYa0YmHGMR8iFoCHMRys8JF3MRyW4VOPMQgZqOhlgAHcRIXcRON6MRDLLdTmA9RS4Cf29ehsqslr3ERP7e6gDNUjfo11AcvHMSKkIWLuIlGdOIhfuOti71qybtY9eHiIH5udd1Xz8tr3MTPLWroVR8uHmK51dCrPgCrPlwcxHKryVd9iBpvVYKvqXpXo15jEPNhVYK62q5GvZM1i6oE9XG9GvVOlltVgotGdGK51XCqElzMh1UJLpZbjfdL//jVcL70j69Jedfj8KI+8Nfj8OJXFl/6NwYxH37p3ziIk1huNYazif4Oo8Mj6vBIPTxSg0cqch44iYu4iUakW9At6BZ0S7plTajWLCdxEb8J1T2QavVrdOIhBjEbq9WvcRAncRE30YjltgoPMYj5cPyIg1hup3ARN9GI5RaFhxjEz23WyL76EHX7pp6B1/i5fb3ju7oUGz+3+mBTXYqNTjzEIObD9SMO4iQuIt0W3RbdFt0W3RbdNt023TbdNt023TbdNt023TbdNt2MbkY3o5vRzehmdDO6Gd2MbkY3p5vTzenmdHO6Od2cbk43p5vTrQpIfWKt3sXGSVzE3aekamNsdOIhBjEfVi25OIiTWLOwwuizXrUmRt1HrNbExkGcxEXcRCPWOnzpVO2GWIdqN8Q0q92wcRONWOsbhYcYxHw43m5WE2LjJC7iJhrRieeNoXL+Yj6cP+J4Y0DOAxeRbsz5w5w/zPnDnD/M+cOcP+sdO2dxJRdXcnElkfM1hsWVXFxJ5vxhzh/m/GHOH+b8Yc4f5vzZ3DfkPJArubmSm/uGnAdyJZnzhzl/mPOHOX+Y84c5f5jzhzl/nPvmXEnnSjpX0rmSyPksdOLnVveYqmmyMR9Wzl/83OorvmqabFzETTSiEw8xiOVWg4wfsa4faiVjvyysnK/vhOupdI2HGETuUHKHkjuUPNaTxzoqAZBHX3KHkjuU3KF8O1Rtl42DOImLuIk1Cy8MYj6s+lC386rtMurGXbVdNi7iJhrRiYcYxHw4392kwN0D4CYa0YmHGMR8iLsHwEGk26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbppvRzehmdDO6Gd2MbkY3o5vRzejmdHO6Od2cbk43p5vTzenmdHO6HboduvGeYxy6Hboduh26Hboduh26Bd2CbkG3oFvQLegWdAu6Bd2Cbkm3pFvSLemWdEu6Jd2Sbkm3fG75+xEHcRIXcRON6MRDDCLdBt0G3QbdBt0G3QbdBt0G3QbdBt0m3SbdWEuStSRZS5K1JFlLkrUkWUuStSRZS5K1JFlLkrUkWUuStSRZS5K1JFlLkrUkWUuStSRZS5K1JFlLkrUkWUuStSRZS5K1JFlLkrUkWUuStSRZS5K1JFlLkrUkWUuStSRZS5K1JFlLkrUkWUuStSRZS5K1JFlLkrUkWUuStSRZS5K1JFlLkrUkWUuStSRZS5K1JFlLkrUkWUuStSRZS5K1JFlLkrUkWUuStSRZS5K1JFlLkrUkWUuStSRZS5K1JFlL8tUS+71aYr9XS+z3aon9Xi2x36sl9nu1xH6vltjv1RL7vVpivx/dBt0G3QbdBt0G3QbdBt0G3QbdBt0m3SbdJt0m3eoTyteSZ9Vr2ejEQwxiPqxPKBcHcRIXkW6Lbotui26Lbotum26bbptum27vW09Dr+VFJx5iEPNhfUL53mhj1WvZOImf29ePaNVr2WjEb25fE6JVr2VjEPNhfUK5OIiTuIibaES6Od2cbk63Q7dDt0O3Q7dDt0O3Q7f6hPL1gVj1Zcau5atPKMD6hHJxECdxETfRiE48RLpFd+dZPWmucRC7O8/Qw3lxE6s7ryZUPZwXDzGI2YgezouDOImLuIlGdGKt2fmwPqF8rZ9WfZnxtV1a9WU2GtGJX4Svz9Gq1zKs4tZdiYubaEQnHuK3vt83/Fa9lhcr5y8O4iQu4iYasdxG4SEGMR9WzldCVq9lY3UkROEibqIRnVhutb51V8JqfeuuBLBy/uIgztuHZ9VrGV4jq5y/aEQnHmIQ82Hl/MVBnES6VXZj6JWbXntcuXnRiH7bRK16IhuDmA/jRxzESVzETTQi3YJuQbegW9It6ZZ0S7ol3ZJuSbekW9Itn9v8/YiDOImLuIm1krvQiYdYu2mF+bD6qw9wECdxESuuF1aEMq6e6aj/OgdxEqv3Fj+7iUas3tuyqJ7pi0HMh9UzfXEQJ3ERN9GIdFt0q4z9bkJZ9S7G93QBq97F+J4uYNW72OjE87Cy8HvAolU/Ypxa9cq3i0Z04iEG8VvfU8tX+XZxECdxETfRiE4st1kYxHxY59iL5VY7VOfYi/VrWZgP62R58fu1qOWrk+XFbhs2NBZeNKITv7hRWDfuooaDxuOaRTUeXzSi37Zhm2g8BgaxGo+/7V5oPAYO4iQu4iYa0YmHGES6DbrVafH7mtyqATAC//XblsqWagBszId1C/9iRYjCipCFhxjEfFgnwIuD+K1vjsJF3EQjOvEQg5gPK50qu6upr3ESF7HcZqERy+1Lhmrqi6zJ14XsxUXcRCM68RCDmA8ryS7Szbs13Kqpr3ETuzXcqqmv8RCrxbi2u5p+gdX0e3EQJ3ERN9GITjxEuh26VRZmLXVdnGbt/Jdv+TUcWLXvNQYxH35ZmL/ali/f8ldx04mHGMRsrJa8xvGhFU7iIm6iEZ14iEEst+/oq5a8xkGcxHLzwk0styh04iEG8XP7vuy3aslrHMRJXMRNNKITDzGIdFvdwm3Vktc4id3CbdWS12jEar3fhYcYxHxYjf4XB3ESF3ETjUi3TTerNau9sFqdOjSsVgc/YEQnnodeEWpCXhFO4SYa0YmHGMRa3y8vqnWucRAncRE30YhOLLfalhPEfBg/4uc2a4+/jG384n7tGFaNbzlr8jmIk7iIm2hEJx5iELOxGt8a+88grBrfGhex/wzCqvGt0YnfztcHvGp8a8yHdYa8OIiTuIibaEQn0m3QrXKzTsLV+JZ1TVCNb/l98WfV+NZ4iPHwy7f8viG1ambLryHfqpmt0YmHGMR8+GVWrlq+PYiTuIibaEQnHmKNNwvzYeXbxUEst9qhysKL5eaFRnTiIdbcanUsH1ZuXhzESVzETTSiEw+RbvgTmprx+REHsf88yKrbrXET649a6tCos+nFQwxiPqw/obk4iJO4iJtIt6BbnWPr1l81s2XdoqtmtqybcdXM1mhEJ34R6mKkGtSyLjuqQa1xE43oxEP81rfu5FSD2sU6m14cxElcxE00YrmtwkMMYj6ss+n3VyRWDWqNX9y6WVStaI1OPMQg5sPvvJl1d6Za0Rq/WVR9qFa0xnKr4VR2Xyy3WurK7ovlVstX2Q2s7K67PtWK1lhutSSV3RfLraZZ2X2x3LLwED+3ug9erWgXK7vrjku1ojV+bnVvpVrRGj+3unFXrWiNn1vdJ6hWtMZyqwlVdgMru+s2QLWiNZZbTaiy++KXAfWxulrRGp14iEHMh3U+vjiIk/i51UfwakVrNKITDzGI+bDOxxcHcRLpFnSrK+j61FytaFm3AaoVLet6p1rRGhdxE43I8SbHmxxvvvHWU/IaB3ESF3ETjejE51YNaphQtaJhQtWKhkFWK1qjEw8xiBzv5Hgnxzs53snxTo53cryT450c7wwi3RbdKrsxocpjTGhxvIvjrTwGVh5fHESOd3O8m+PdHO/meDfHuznezfEax2tcHaOb0a0yFhOq3MSEnON1jtcncRG5m87drDNvfZKolrHGOheewnyIMy9wECuuF1YE/Ne4f7Fq1QZ2sc6mF8f9i1WrV5Y2LuJXS+qDeTWHNTrxEIOYD+sPUi8O4iQuIt2SbsjCbzjV8JV1c6savrJuWFXDV+MmGvGLUJco1dqVdTFSrV2Ni7iJRnTit751W6hauxrzYeXbxUGcxEXcxHKbhU48xCCW27eF1fDVWG5ZOImLuIlGdOIhBjEfVm5epFs1afxqdapJ4+Imfl9R1y0DNHxdPMTvK+q6V4GGL2A1aVwcxElcxE00ohMPkW5Gt8rYrIOrcrPuiVUTVyZ+4BCDmA/rDJk1oToX1vFbjVmNhxjEfFjnwovf+lYWVmNW4yJuohGdeIhBLLfaljpvXhzESSy32uM6b178c/v7OrOmXO8Tbj7F+M0orrWohoq6bYDmrIuDOImLuIlGdOIhBpFug271SuHf9zc3Vt1Zj5fwFjZhFz7CIZzkerdwM3yjeAov4S1swk6uFwT/vqfPWvVaPTZhFz7CIVzjrFs/1XH1GD+/i0M4yYafr/WsV/02T+Fv/2aFrIy8aMRv/ybiHWIQv/2ruy9om7o4iJO4iJtoRCceYhDpduh2sNq1gwermsW1SnWXqLqhHie53gjeXHEQs97z/cMixBEO4STnT3gI12rXTZVqdnq8hU3YhY9wCGezV8/TH4/iITyFlzB8vdiE4ZvF5bvw8yGc5Hr/d/MQnsJLeAubsAuLL57ycArzIZ7yAPwOse9Oh6ML6uIifofYqsnhKQ9AJx5iEPNhdVReHMRJXES6Lbohl78H0Xm1Nv3xLsYq1Q7uJbyFTRhxauLIZcwRuXx5CW9hE3bhWu3veRZevUuPk1zv724ewlN4CW9h+NY6uAsf4RCGb+3++Qkn545svTyEpzDGU2seMl9k8eUQhu/6GFl8eQhjvrV3Keucss4p65zim+Kb4ossLh7I4stDeAovYRPG3llxkpGhlzGXUzyFl/AWrvi74iNDLx/hEIbvVz0GzpvfLSUfOG9e3sIV/7vB5APnzctHOISTvH7CQxi+s3gJb2ETduEjHMJJRp5+t7S8eo/+uNYW5+LLIZxknIsvD2GMudYc+Xt5C5uwCx/hEE4y8tdqj5C/l6fwEt7CJuzcO+Tv5RBO8sHx5sWb63ZM2IWPMGLWsRSyVsjxy0u44nv5hgm7cMX3Ok5C9ihkj1L2KMU3xTfFF7l/2YTl2Eg5NpK+8/cTflcdPu/ZGWzCLoy5FI931eFzDOEpXPEdvIVNGGu1i4/8bggneYrvFN8pvsj9y1vYhF1YfKd4Ia+91gp5fXkLYy6n2IWPcAhX/O/uqE9cV18ewlMYvllc8b/uJ5/I/cshXPG/21A+kfuXh/AUXsJb2IThW/uO3L8cwklG7l8ewlN4CSNmHQM4/55aW+Ty5Sm8hLewCWPMtebI8cshnGSc3y8P4Sm8hOFbe4Tcv+zCRziEk4zcx94h9y9P4SWM482Lg+uGc3rxQo5fHsKImcVcq4Ucv3yEK/53G80Xzu9g5P7liv/dPvM1uEdrLOEtLL5DfIf4IvcvJ3n+hIew+E7xqntiCQxiPqx7Yhcxj1m8780VrxarRifWYL8bhb6Q3JeTjOSOWvi6BYZfrdvTFxeRjpuOm477EIOYD+1HpJvRAkkcNVkk8eUQxvi/A3whiS8P4Slcm/z1u/nCCfyyCbswfOsARKJnHURI9MtTuOJnHVxI9Msm7MJHOISTjETP2mgk+uUpvIS3sAm78CEjibP2HSdqHGBI3MsufIRDOB9vJPR3K943EvryFF7CW9iEXfgIwzeKk4xEvzyEp/AS3m/vNhL9sgsfYRxv3/G5kcS1bhsn8Mtb2IQRM4tlrXCRfnkIf/HHr3zrZN68ha14FLv87hEOYfHd4rvFFyfzy0t4C5uw+G7xqqyu0lLPQWtcxE3EPGZx3G8kvB55drG+i7o46ofrF30KL2EsEn7e+KtOPEQ6Oh0PHc8gTuIibiLdDi0qicevFiaG8BTG+OsAjy1swi58iutArrN1c5LzJwzfOgAr0ceog6gSvdmFK/6og6sSvTkfV2PX4yE8hZcwfGexCbvwEQ7hJI+f8BBGzF2M37XiJM+f8BCewksYYz7FJuzCRziEk7x+wkMYvlG8hLewCbvwEY63d9Ub1rx/wkMYx5sXO9dtH+EQTrIhZhbLWtkWNuGKP8u3TubNIVzx695rNX3177rskcseufi6+Lr4ugsfYTk2XI6NI75HvOoEPupTZTV4/fEqPsIhnGTk/uUhPIXX/W7bDZ0gQCM68RCDmA/RNQLsTgU3pPys7UPKX3bhI4zp1PSR8sWOlL88hKfwEt7CNaFV6MRDDGI+HD/iIE7iInYrg1d72J2NoxhcTjKKwWWZzZTZTJnNlNmgGFx24SPMCU1OaHFCixNanNDihOri/iKXb3H50GFSM94yG6T65Sm8hGU2W2azZTZbZrNDWI4Jk2PCOCHjhIwTMk7IOCHjhIzHg3H5jMuHFpSasctsfAubsAvLbFxm4zKbI7M5ckwcOSaOHBOHEzqc0OGEDid0OKHDCQWPh+DyBZevKkHdVK+3rDYeYhAxla+uo1WsbmyjVeziJmKdTrELH2GsUxRn/yraxS4O4iQu4iYa0YmHGES6DVoM7HMWm7AL1/jrC7KD3L+cZOT+5drn+vrpIPcvL+EtXL5fl7QfnPDr66qDEz4YJ/zLiF/jxwn/8hLewibswkcYvl6cZFSBy0N4Ci/hLWzCiPnte/WN/XGtLU74l7ewCbvwEa4x19dVByd8ME74l4fwFF7CW9iEy7e+0jrI9cshnGTk+uUhPLl3yPXLW9iEMcfvQubghI91wwn/8hRewphLHUsha4WL+stJxkV9JfvBRf3lKYy1quMkZY9S9ihlj1J8U3yTvoEz/+UhPIWX8BZ24WpU/5aqnk3WOIiTiHl4cf9FhKNX7WIQsbFf0Qok9+UhjEWK4vV+dW6iEek46TjpOPNhndMvDuIk0m3RAklc3wcGkhiMJL5c46/v7gJJfHkJb+Ha5PouLnAqv3yEQ7h8v8Z0DyR6fb8USPTLWxjxrdiFj3AIJxmJfnkIw7c2Gol+eQubsAsf4RBOMpK4vqMLXMHX92aBxL0cwklGQl8ewjXm+q4skNCXt7AJu/ARDuEkI9Hr+6tAol+ewkt4C5uwc++Q6JdDOB8nkru+n0wkca1b4hP7ZRc+wpjLdyyhNw1rhd605iWMMZcvTuaXXRhrZcUhv8s9Qm9as/hO8Z3ii5P5ZRN24SMsvku8Kqu/FjGv9rVGIzoR8yiuhtO6AVBPBWucRGwseAubMBapFn4f/moQ86HR0ehodMQfTwI30YhOpJvRAklcX/4lkvjyFq7x1xd1iSS+fIRDuDa5rvYTZ+vLQ3gKl29dNqPFbdSXSWhxaw5hxK+DC4l+eQhP4SW8hU0YvrXRSPTLIZxkJPrlITyFlzBi/u37QVvb+L4kO2hra57CS3gLm3CN+fti7KCtrTmEk4xbcJeH8BRewuX7fWF10NbW7MJHOISTjET/9u78kOiXp/ASxhx/xcF1w5U6GAl9eQhjLqtY1gpX5JePMMZcvjiZg3Eyv4y1smLZoy17tGWPtvhu8d3ii5P55SSbHBsmx4aJr4lXZfWvlrk+eV/Mh3Ub/iLm4cVfufjVMtXd9otOxMae4hBOMpI7auHrjjt+te64X1xEOh46HjrWZ+6LQcyH9Zn7It2CFkjiqIVBEl8O4Rp/1gGOJL48hKdwbXLWAuJsfdmEXbh8vyb8g8638X2ZdND51jyFEd+Kt7AJu/ARDuEkI9G/L2UPuuOap/AS3sIm7MKHjCT+vpA76Hwb35dkB51vzS58hEM4yZXQ8/ti7KDzrXkKL+EtbMIufISjeBYnef+Eh/AUXsKbe4dEv+zCRxhz/IoZOuLuuuFK/fIWNmHMpY4lk7XCFfnlIYwxl68v4S2MtarjxGWPXPbIZY9cfI/4HvHFyfzyEpZj48ixccT3iBeeHVRTx7ODgIu4iZhHHY/1TL1AiHxYzwK/iI09xVN4CWORKng9D/z+qhMPkY75HKvzrXEQJ3ERN9GIzwLtb/MHHsJTuMb/fVF30P7WbMIuXAnxffF20P7WnOQ6WzeX7/dnGQdtbvP7Mumgza3ZhRHfikM4yUj0y0N4Ci9h+HqxCbvwEQ7hJCPRLw9hxIxi/G6t7U6y/YSH8BRewjXmWWteCd3swkc4hJNcid48hMt31h4h0S9vYRN24SMc3DtP8vkJD2HM8VfsXLdzhEM4yYG51LEUslaxhU0YYy7fOMIhjLWq4yRlj1L2KGWPUnxTfFN804WPsBwbyWMDrXDNUxjr78WYyyk+wiGcZOT+5SE8hdd9Ntqp7rdGIzrxEIOYD/GAMeC6D4481enWaERMpiaJhL8cwklGwl8ewlN4CW9hExbfJb5LfJf4bvHd4rvFd4vvFt8tvnje3yo8xCDmQxSK70boWe8xgGe9xwCe9R4DeNAvN7+bigf9cs0hXBNatTN4FGD9Kh4FCJxEOjodnY54FCDwEIOYDw/dDi3qND5XTRYV4PIRxvjrYEEFAKMCXB7CtSGrMgWV4fIWNmH4VhagAnx35c9CBbg8hBG/NhMV4PIWNmEXPsIhXL7fHwMd9M41D+EpvIS3sAk7GRXg+2bjoP9tft82HPS/NZuwCx/hEMaYvzXfOMtfHsJTeAlvYRN2Yfh6cQgnGcXg8hCewuvtHXrnmk3YhbEv3/GJvri7bkj0y0t4C2Mup1jWCmd/MJL6MuKXL87+l5cw4mex7JHJHpnskYmvia+LL87+l6ewHBsux4aLr4sXzuxWxxjO7N8XEKe65B4v4S1swi58hOM+GfbUc84u1vNBLw7iJC7iJhqx4taW1SU+sC7xL477LNyz36N5z36P5j37PZr37Pdo3rPfo3nPfo/mPfs9mvfs92jeY+/RvMfeo3mPvUfzHnuP5j32Hs177GdEJx5iEOk26DboNug26DboNug26DboNug26FYXAN/98VMddo04KnbxEq49GoVGdCIOCSsO4c/xu+t7qrmucRAnEYebFyNGDfU7x9v3pwGnGuUaB/GLUbcwq2OucRO/Nar7Z9VG13iIQcyH9aLxi4M4iYu4iXQzuiHRv29gDnrkptfgkdBYRST0ZRN24YrzfXtz0P82vbYISXx5C5uwCx/hWm2vlccJHIwT+OUhPIWX8BY2YfjWLuPS/nIIJxkndhyoOLFfhm+tJ07sl7ewCbvwEQ7hfIzGueYhPIW/y+W6NVR9c41G9A9X4SEGMT/8NrPa5hoHcRIXcRON6MRDDCLdJt2Q3HXLHY1xs3IQjXGzrm0deXw5yTilX0YcK0YcLz7CIZxkXK9fHsK12nV7H61wzVvYhF34CIdwknF6r8tbx+n98hRewvCt3cfpHYxTdFUYR0ZfXsL1u/VBCw1vzd+2LfzIIQYxHyLL6ysORzbX1xTVvuZ1hVzta41BrBhf5lT7WuMgfgdaXZPXg84aN9GITjzEIObDevDSxUGkW9INORrg2qX6ruEgF+ve30EuXp7CS7ji1H3Xg4/WdT//4ML68hCewkt4C9dq1719tK41H+EQTjIuuC8P4SmM8WfxFjZhF4bvLg5h+H6bjpa25iE8hZfwFjZhFz7CISy+9ejgOkVVR1vjJH57XvW92tkajfgdYXVSrEenNQYxH9qPOIiTuIibaES6Gd1wCZ51BCKP6041mtnWDz9jwi58yHXZveqEgOa0VbUfzWnNJuzCRziEs/jLFDSwNQ/hKbyEt7AJuzB8a7MihJOcP2H41u7nFF73Ue4Hr9HE8VG3zQvxGs2LgziJi7iJRnTiIQbxO1S+PrtTDWyNg/gdKvUxthrYGjfxO1TqM1R1tTUeYhDzYZ1jLw7iJC7iJtJt0q2e518HY+DJ/VlYX4D+CjfRiE58XwxXWxq+N62utMZNNKITD7G+pa3VqaYVYDWtXBzESVzETTRiuY3CQwxiPsTX27XH9cTDi+UWhYu4iUasFplaHTwdHBjEfIingwMHcRIXcRONSLc6SdelUrWxNebDOknXNVD1sDVO4nfs1EVJNbA1GtGJhxjEfFgn6YuDOIl0S7rVM0rr26V6olo9yv1UP1o9qf3UE9UaF3ETz223OvWUtGpMOtWJ1jiJi7iJRqz1zcJDDGI+xJP7gYM4iYtYblZoRCce4uf2/YXUqVdYXqy+0vrapbrK6uHqpx6I1pgPq9Xs4iBO4iJuohGdSLc6eVrtUJ08gXXyvPjtfH3GrzazxkX8dt5qFnXyvOjEQwxiPvQfcRAncRHp5nSr3KwvfaqlrB7lfqqjrJ7UfqqhrHETjVj9wLUt0Z2/p3rGGhdxE43oxOozruWrv+m4mA/rr7suDuIkLuIm1njr6MOT+4GHGMRy+9uhqO6yxnLzwklcxE2suUWhEw8xiPkQ7eDAQZzERdxEutXZ9Ps0E9VM1hjE79iJmlCdTS8O4nfsfJ+jotrIGjfRiE48xCDmw3rXxsVBpNuiG579n4X1JzDjw8rjXT9QeXxxEhex/0ooqiGs/nImqh+scRAncRE3sf5k5xQ68RCDmA/rbHpxECex3Gpb6mx60YhOLLfa48pY4MFVIngKL+EtbMIujKvTWvF7VQyuq9PvDBt4olpz+Y7aFlwVXy7fUVuAq+LL5TtqJrgqvly+o/YJV8WX4Vurj6viy/CtHMNV8WX41qrmFoZvzTFdGL41xwzh8v1OMYF+s+by/doFAv1mzeX7nYcC/WbN5ft9PR/oN2su3+/0Eeg3a4bvN0f0mzV/mZIVsq6pLy7iJhrRiXD04hBO8oRjFg/hKbyEt7AJu/ARDuEkL/Fd4lufmteqla9Px2vVaten47VqXvXp+HLd62oewlNYxr9l/FvGv2X8W8a/Zfxbxm8yfpPxm6ybia+Jrx3O0X+co8v4XcZfn5ebt7AJy/hdxu8yfpfxHxn/kfEfGf+R8R8Z/5F1O+J7xBcVA3NEZcAcQ8YfMn5UhstHWPY9ZPwp408Zf8r4U8afMv6U8aeMP2X8KeuW9J2/n/B6c8Sz1zBHPHsNY56/EOZxi6a05iE8hRF/FW9h+55vHYVOPMR4iJyuqxg0nq3v7mBU49mpQlx9Z42H+MUY+L18WA87vTg+rIHWw04vLuImGtGJhxjEfFivj79It003ZHBdd6HlbNWlEFrOVl1FoOWseQhP4YpTlxpoIVt1KYEWssvI1MtDeAov4Vrtug5BC1mzCx/hEE4yMvXyEIZvHX3I1Mtb2IThW7uPTL0M31OcZGTw5SE8hZfwFjZhFz7C4lsvg0ci1cvgLw7it+fIrnoZ/MVN/I4wpGW9DP7iIQYxG6vnrHEQJ3ERN9GITsTqfUcgGszW1x4QeL7a+r7WDzxfrdmEXbjifJ8jA89LW99Hxlg4D1/ewibswke4Vvv7DjjQU3YZ5+HLQ3gKL+EtbMLwncVHOISTjPP29z10oKesuXy91gHn7cvl6/jd8vVan3r1QB3g1VPWGMR8WK8euDiIk7iIm2hEuhndUDG+v9ELtJldRsW4PISn8BLewibswkcYvrX+qBhgVIzLQ3gKLzIy/dRckOmXp/AS3sImXOM8tV/IdDDOvaf2Dufeyy6Mn69jFefey/m42sNOFYzqDmucxNq/KNxEI9b+eeEhBjEf1osGLg7iJC7iJhqRboNuuOL+bkwGGsPWqcEjo0+NExl92YUPGZn7NWoEGr3W981ooNGr2YRd+AiHcK123S3AQ9Kah/AUXsJb2IRdGOPP4hBOMs7Xl+Fbu4/z9WX41rrhyjrw8ybswkc4hJOMbL08hKfwEhbfejtBFdp6zlrjIX6HmNWe19sJgPV2govfIVYlvzrIGhdxE43oxEMMYj6MH5FuQTfkctYRhbNzfY7EU9VW1s/guvvyEJ7CiFPzQi5nHfnI5WI8Pa15CE/hJVyr/f01T+Dpac0ufIRDOMm47r48hOG7i5fwFjZh+GbxIdf72qusVp9X4yYa8Yuxv69fAn1ezSGc5Mr45iE8hZfwFjZh8V3iu8R3ie8W3y2+W3y3+G7x3eK7xXfD91cM31WcZPsJD+EpvIS3sAm78BEW368SGLb2KwSNg/htbB3T1VnWuInfxlYCVFtZ4yEGMR+eH3EQJ3ERN5Fuh24Hq1cDDqxSHWmBVTrFW9iEXRhx6oiuzN517w+9Yc1b2IRd+AjXatfnNvSGgdEb1jyEp/AS3sImjPFH8REO4SQP+K7iIQxfK17CW9iEXfgIh3CS5094CIsv/nTkV7iJRvzu8tV91+osawxidad9G1htZY2DOImLuIlGdOIhBpFum26oCXWXFr1ku+7AopdsD/xMCCcZuX+54tRdV0cu151WRy5fDuEk11m9eQjXatcdWPSVNW9hE3bhIxzCST7wrc06Q3gKL2H41u4fE4ZvrSGyGxw/YcSvtUXWX0b8WkNk/WUTrvj1Ibvazx6HcJLr/N88hKfwEt7CJiy+Kb4pvklfdK01D+EpvIS3sAm78BEOYfFFlah7DOhya57CS3gLm/B3HqiPuGhgw+GMBrbmKbyEEXIW85BHo1ozD3k0qu26VYhGteYpjCHv4i2/a8IuLL5LfJf47p/wEJ7CS1h8t3ihDNRtyoMycHkIYy61nigPl7ewCWPbo/gIh3CSUTbq5iDa1XZ91Ee7WrMJV/y6gYh2teYQTjLKw+UhPIXhW2uC8nDZhF34CIdwklE2LiNmHQNI/bohiBa15iQj9S8P4SmMMdeaI/Uvm7ALH+EQzsd49lozfKN4Ci/hLWzCLnze3gVS/3KSkfqXcbx5sb11C5z8Lx/hEEbM71jCI9iwVoEcv7yFK37dOgx8RLh8hCt+3S6MyT2K9RMewuK7xHeJL3L/sgsf4RAW3y1e9/K/5nsv/8EufIQxl++YDOR4XePgcWzNS7ji10dWPI6t2YWxVrX+yPH7u0lGjl8WXxdfF1/fwibswkdYfI94Ia/rY38gry+bMOZSxzzy+nIIJxl5bXVs43Lg8hRewvCt9Ufue40NuX85ycj9uhWLx7E1T+ElvIVN2IXhW/uO3L+cjxO5f3kIT+ElvIUR8zsG8Di2XbdN8Ti25iW8hU3YhTHmUxzCScb5/fIQnsJLeAvDN4pd+AiHcJKR+5fH27tE7l9ewlsYx5sXJ9cN5/TLQ3gKI2YWy1ohxy+HcMWvW8Z4/WjzEK74dfs4TfbIZI9M9sjE18TXxBe5D0buX5Zjw+XYcPF18cJt9wQnGbfdLw9hzKWOSXwhV7e08IS25iNcY/7+DCjwhLbLyPHLWKta/+AtMzyhrXkLi2+Ib4hvhDBv1WX+hIew+KZ4Ia/rBjdeSNqczYknt+3vxnfiyW3NU3gJ175/N74TT25rduEjDN/8GLn/3ShPPKGteQlX/O8meOIJbc0ufIRDOMnI/cvwncVTeAlvYRN24SMcZOT1d0M88YS2HbW2yOXLRziEk4wcv4wx15ojxy8v4S1swi58hEMYvrVHyP3LQ3gKL+EtbNw75P7lIxxk5PvX7J14FeldN5zTL5uwCyNmHUtH1grX7ZencMXP8sX5/bIJV/ys4+TIHh3ZoyN7FOIb4hvii/P75S0sx0bIsRHiG+KFvMa6oYXm8hY2Ycyljknc4q/j/zbRXR7CNebvhmWiia55C2OtdrHL7x7hEBbfIb5DfHGL//IS3sImLL5DvJDXX21PtMk1L2HM5RSbsAsf4dr376uIRJvcZZzTLw9h+GbxF9++W+mJh7Y1H+EorvFX7l+u3G8ewlN4CW9h+M5iFz7CIZxk+wkP4SmMmHUMGH631tZ/wkN4Ci/hLYwx15q7Cx/hEE7y+QkP4SkM39qjs4VN2IWPcAgn9y5+wkN4CuN48+LDdYsQTnL+hBGzjqWUtUoTduGKP8q3zu/N+Rhtcvbdis56gtv93XqE2+MlvIVN2IWPcAjz2EBbXbP4DvG6rTar+AiHcJIn5jKLXwtOTrbg5GQLTuI5bjbwu0c4hLFW9fO3BQc8hKew+C7xXeK7XPgIh3CSt/hu8UJej1or5PXlI4y5nOIkI68vD+Ha9+/2f+L5bs1b2IThm8UVf9Zxhdy/PIQr/qzjDbl/eQubsAsf4RCGb+07cv/yEJ7CS3gLm7CTkdez1jzwu7W2sYVN2IWPcAhjzLXmyPHLQ3gKL+EtbMIuDN/aI+T+5XyM57g1D+EpvN7eLeT+ZRN2YRxvX33Dc9ywbmiza17CWxgxs5hrhTa7y8jxyxV/lW+d35uXcMX/bu0n2u/6d134CIvvFN8lvmsIT+ElvIXFd4kX8nrX2NC4c3kKL2HMZRajQRMcwklGjn/fI+RCjl+ewlirWn806NzfNWEXFl8TXxNfNuDmYgNuLjbg5mIDbt52usvihbxetVbI68tDGHM5xUt4C5tw7fuqYxvn9MshnGTk/qpjErm/67hC7l824YqP/ULuXw7hJCP3Lw/hKQzfWhPk/mUTduEjHML5GE9wa0bMXYzfteIQTjLO3ZeH8BTGmE/xFjZhFz7CIZxk5P5l+EbxFF7CW9iEXfi8vcMT3JqTjNy/jOPNi43rhuv5y0c4hBHzO5bQnHfXCtftl7dwxbfyxfn98hGu+N/3C4nmvPu7Jntkskcmvia+Jr44v192YTk2TI4NE18XL5zTrY4xnNPrOm3jnH75CIdwkpH7l4cw/jCgvNAme3kLm7ALH+EQTjLu19V5BC8+tbruwotPm03YhTEvxAnhJCP3Lw/hKbyEMa/aa3yuv+zCRziE8/Ft6bs8hKewvbmjdQ/zQutecwgneXBeaN1rnsJLeAubsAtzXnhparPMa8q8psxryrzmEt7CJhyc+5R5oQ5cHsJTWOa1ZF5L5rVkXusIhzCPE9syry3z2jKvLfPaMq8t89ouLOu5ZT3vH97U3E3mZUt4C5uwzMtkXibzMpmXy3Hicpy4HCcu83KZl8u8XOblMi+XebkcJ0fW88h61l/OV6murr1GJx7iF7teYJj1YLj6K+SsXr7GRdz1w6fYhF34FEdx8FfzYf1R/UU6Jh2Tju/tiVktf41OPMTn5u91idmvR83iLWzCNf5aPHTyNYdwkvGWhrqARSdf8xRewuVbF6r3Ral1oXpflHo5yfdliTX++7JE8BRewlvYhF0Yvl4cwkm+L1EED+EpvIS3MGJ++35fh1oXm/d1qJeX8BY2YReuMdfF430d6uUk47Url4fwFF7CW7h86+IRfX7NRziEk3xfogge3Du8lunyEt7CmOOvOLlueEvD5SE8hTGXOpaOrNV9KSI4hDHm8sUrly4PYaxVHSchexSyRyF7FOIb4hviy5coJnr4muXYSDk2UnxTvCqrsVR4VMaHeB/qxUHEPLzY7mM+Eq8+vXiI2NhTnGQk92UsUhTP96t4MgZwE+k46Djo+N6emPV8uYv1LJuLg0i3SQskcV153zehXk7yfWFa/TyS+PIUXsK1yXV1e9+EetmFj3D51pXrfeNpnTXvG08vL2HEt2ITduEjHMJJRqJfhm9t9H2JIngJb2ETduEjHOT7gsTa9/sixFrb+yJE8BEO4SQjoS/XmL3WHAl9eQlvYRN24SMcwuXrtUdI9MtDeAov4S1s3Dsk+uUjHGQkd32Ku29CxbrhlUuXTdiFMZfvWLpvPK21um88vTyFMeZdvIVNGGtlxUd+N4S5R+i6axbfIb58iWIGTuaXTdiFxXeIF55Q5YWLuIlGxDzAX7moG9t49enFQcTGgpfwFsYiRbHzVw8xiHTcdNx0fG9PTDyE7uImGpFumxZIYq+FQRJfXsI1/q8tJ++bUC+78BGuTf5aX/K+CRWMs/XlIVy+pw7A+7LEOojuyxLBRxjx6+C6L0ssvi9LBA/hKbyEtzB8a6PvSxTBRziEk3xfoggewlMYMWvf74sQa23vixDBQ3gKL+EtXGOur6fvG08vH+EQzsdosWsewlO4fKvt5L4V9bIJu/ARDuF8e5dI9MtDeApjjr/i89btvgn1cpLvCxLBmMsq5lrdN55edmGMuXxxMr+cZJzMq00iF/cILXbNS1h8l/gu8eVLFDNxMr/MYwNteM3iu8ULj5asZcajJYFBzIc4eX8vMEy8+vRXy4SnSAKNiI09xUc4hLFItfB4kmT9Kp4kCZxEOjodnY7v7YlZr0ZtDGI+PHQ7tEASV8/OfRPq5SNc468enPsmVDCS+PIQrk2uPpf7JtTLW9iEy7f6We4bT6uf5b7x9PIQRvw6uO7LEsFb2IRd+AiHMHz/Nnr87utSWwwVU8VSsVWYChdxX5QYEAiQEFuFqXAVR0Wo+KZQ7x78E3j4c4uhYqpYKrYKU+EqTokJESpSxH294hVDxVSxemM/sVWYCleBaf9KIM3viuJivsVSsVVgcgtCF/G+PBEC2d8CU8AI8KT2FksFFtEgdBtNt9F0G01HYDoC1xHwxYufmCr0QHI9kFxH4GrKB0R/YqiYKpYK3HnEocynRH8iVKQIfIP3dd9/YqiYKnCDE/tzHxZ9A5gKV6EjCB1B6AjuI6OvGCqmiqVCR5Bqim/xrBYRrXtPDBU1OR8QS8VWYSrqBq5PiKMiVKQI3Oz3BQGfDbFVmAr4GMRRESpSBL78azFUTBUYgUNsFabCVRwVoSJF4PZ/C4QOCATAwuMufosUgR6+FkPFVFFTONgSfB/YwlS4iqMiVKQIfCvYokZwsI24199iqdgqTIWrOLLBuOPfIkXgnn8LTPsHYbKi+IqwxVERKjA5HHxHFxG9AC22CkwBI0A7QIujAouIo+roNoZuY+g2ho4gdAShI8B3hi1chR5IoQdS6AhSTfHqF5yM0Ar4hKs4KjC5OpTR9lfve/jEVLFU4Dg4EKbCVWARAyI0QIrgSyk+oSMYOoKhI+CLKT5hKlzFUaEjmGqKSnESYqswFTW5uL9zVISKFIFKERNiqJgqlooaQSwI+GyIUJEiUFDCIIaKqWKp2CpMhavACHCEoKC0SBEoKC2GiqliqdgqEBqHC74EDCw8ikOLpWKrMBWuoqZwdxtlo0WKQHdBi6FiqlgqtooaQWIbUVBaHBWhIkWgoLQYssEoKC2Wiq0C0/5BpKwoWgxaDBVTBSaHgy91EdFL1CJUYAo1gttK2GKowCIahGzjbSdsYSpcxVERKlIErkNaDBVThY5gqCkuPfAx6bYcZpW023PYYqiYKpaKrcJUVK3Czt23ybYIFSkCn2VaDBVTxVLh/+D9tR8f4RAuk4kF4NtjPzFUTBVLxVZhKlzFUREqdASmIzAdgekITEdgOgLTEZiOwHQEpiPAa+lwokfr4hNDxVSBrQ6I8sHJFI/9eyJU4JCC6S06VwwVn4//fhBLAuCddi1MhY7g6AiOjgAvtrsCb7ZrMVRMFTqCUNO6PHF8JkdLY4sqOk+MEgtiqlgqtgorgeO4ytETR0WowAhqf/AeWv85xFKxVcDnQLiKoyJUpIjxUzFUYAQBsVRsFabCVRwVoSJFVNGpZw19ogKMAXFUhIoUUaXliaGipjAWxFKxVZgKV3FUhIoUsTGCDTFUTBVLxVZhKlw2eB8VoSJFGHZuQmxZUTMVruKowORw8Lkuok8VSwV8MAI3Fa4CPjiqXLfRdRuPbuPRERwdwdERnK3CVOiBdPRAOjqCUNP7Gkzs6X0P5hWmwlUgNA7l+85LbON96eUVUwWmkBBbhamoKUzsz3315Q0QKpLCfj8VQ8VUsVRsFabCVRwVaopKMQfEUrFV1OTmgnAVR0WoqCNkwqeuYp4YKqYKjMAg4OMQR0WogE8do+iSfGKomCqWiq3CVGAEAXFUhIoUgYLSYqiYKpaKCr3qcMHzDOvdk58YKqaKpWKrMBU1hYUtQdloESpShP9UDBVTxVKBEWAbUVBauIqjIlSkCBSUu8EoKC2miqUCOzchQlb0pAiUjRZDBSaHgy90EcNVHBXwwQhwHXIFrkNawAdHVeo2pm5j6jamjiB1BKkjwHVIi6TAIxOfGCqmiq0CoQMCoRMiReDSo8VQMVUsFVtF1Src/cazEZ84KkJFisDdlBZDxVRh38u1J9iFj3AI1yx3HRDVQRm2wEt4C9cubawe6kWLo6KWcsPkqxf9+1+5eDyExXuL9xbvbcIufIRDWHxNvFA99hWmwlVgQgYRKlIEqkeLOja2Q0wVS8VWgRFgA1EjNg5I1IgrUCNawAcHF2pEi6ViqzAVruKoqBEYDgmUkitQSloMFVPFUrFVmAqExiGCGnH3BzWixVZhKlzFUYEpYEtQIyDwwMQnhoqpYqnYKkwFRuAQR0WoSBEoJS2GiskNxtMTn9gqTAV2rs4ieITiXVE8Q/GJqWKpwOQOhCwiWjefSBG46MC3d+jefGKqgE9CbA1gKlyFjmDpCJaOABcdLYaKqWKp0BFsNf3qhCGBq4HzcQXGNybo4HxiqdgqTIWrOCpqavhWD49YbIFy0gIjwDBRTlosFRjBgDAVruJ8c8PBVo9dbk5yPXi5eQhP4SW8hU3Yhb/4OBFW0+djzA4HL0pIi6ViqzAVruKowPrCH5XmClyntMAIcPSjBrVYKjACHBWoQS1cRa0vNjhDOB9XA+njITyFl/AWNmEXxvwq69Ap+sRQgfklxFKxVdT8DkLjs0+LWmF8oYlnOT6RIlCG8E1loAy1mCqWiq3CVLgKjGBBhIoUgQLVYqiYKr51xofW6jWtp1l8/O0jPglWt+njJH8V6PEQnsJL+NvHH1b4u4557MJH+PPFPZt6+3Fz1afmITyFl/AWNmEXxtpV5qAJ9YmhAmtnEEvFVoHdcwhXgd07EKEiReBCB19qok/1ialiqdgqTIWrwAiwxLjQaZEicKHTYqiYKv5GsHEerf7VjfNwPTqynrL5cQgn+StDj4fwFF7C+2Os8FeBHrvwEf589+V8XH2tj4fwFF7CW9iEXViOHzSwPjFUyPGDR0w+sVXI8ZPDVcjxkyNUyPGTU46fnEPFVLFUbBWmwlXI8ZMzVMjxk+unYqiYKnj8VO/rPX6q9/Xue/W+PubxU72vj4fwFF7CPH7qPc6PXfgI8/ipFtlmk+PH5PgxOX5Mjh+T48fk+DE5flB/8I0qnkH5xFAxVdTuoQUgUX9amApX8c1v398P4SSfn/AQnsJLeAubcB0c+HYQfbQtUFxaDBVTxVKBCeIgxCVQC1dxVGAEONRwCXQFLoFa1AjQqoJm2yeWihoBvjZHv63jG2w03Dq+gEbH7ROhIp8Y6Ll9YqhAAIMIFQjgJVBlWiDAgfibwjr3/1jCW9iEXfiQUUXqW8eBzlmvLw1Hdc7Wm5g+NmEXrkj3l0M4yV+VeDyEp/BnfOoLyoGG2SesxIBwFUdEfVI69W3LqB7Zeq/Wx1sWDV/qtHAVR0VUsAWRIuynQvcDn5taLBU6AtMRGEJj3/2nYqiYJbDivlRsFabCVRwVNbmBKdQFSYu6IHliqKgRDBy6dUHyxFZRIxg4sOqC5AyY1gXJE6EiRcRPxVAxVSwVW0WNYOLQqZrxRI1g4mipmvFEiqia8USNYGJyVTOeWCq2ClPhKo6KUIER1G6j+/YJHAcOgRFcsVRsFabCVcD0QKSI8VOBaQfEVLFUlGndZB9oxX2iTOvW80Ar7hOhokawKmfRivvEUDFVLBVbhanACBbEUREqUsT6qRgqsAYJYSyY4xak+2NHRaiQGjL2T8VQMVUslv5xq9gVpsJVoIphoPhqukWKwFdRLYaKqWKp2CpMBVZ0Q6QIlLQWQ8VUgT3FwYeS1sJUuIqjIlTUCDYOMZS0FkPFVFEj2Dh2UNJamIoawcb+oKS1CBUYATIYJW1jf1DSNgaKktZiqdgqTIWr+PO5mf2VrcZBnMRF3I1ov623Y37CVLiKv6miVFXzbWM+/MpH4yBOImInRC1W3R4f9axNHAfVSds4iN9lwgIu4iYa0YmHCL8BkSKQ8vXRZKCn9ompokZviIbENgwOiX3Fl9ioP+ibrZc7fmKqWCq2ClPhb+02V39z9TdX37j6xtW3LUteN2V7yZGwhkMACXsFErbukg80zj6BOeB4+BIWx3q1zTYa0YmHGA+RiobBIeEcg6sPFxjNl26Nh1ifFIH5MH7EQZzERYQfDgGkV4s66h17iCuGFiEC1wWOqeDs71h0nP1b1Gc/4JHlw7m/RVKg4/UJuBjEVLFUbG4TOl6fcBVHQ4cKHcHQEQwdwdARDB3B0BEMHcHQEQwdwdARDB3B1BHgQqDF7PxCW+zNFbTFPmEqXMURgXO1Y2RI6RYp4ktpXO5U82rjJC7iJhrRiYcYxHxodDO6Gd2MbkY3w0GXEK7iqKhZ1s3rgQbVFkh7RzSkfYupYqnYKkyFq6gR1J2xgdbVJ1IEztMHm4vi0GKqqBEcbCHKRgtT8Z0GMLWvcDQGMR9+haNxEBHbITAHHBEoBPjYig7VFvjo0GKoqDnUHZ2BDtUntgpT4Sq+Iwe7iOIRGCaKBwSevvlE+ddffgx0rj6xVMDfIEwF/B3iqAgV30rWyKpvtXEQJ3ERNxGxa3XxNM5Td3YGHsd5Aj+GTwEtloqtouaQWASkf4ujIlSkiO+SAJd71bjaOInfieT+7CYa0YmHGET4IRw+DbQYKrYKjB67hvsTLb6TYB0m9XzOxkGslcPdJTye84mtAiuHfUAVaQFvbAqqSAvMBEtfVSRw2wb9qoGbM+hXDdycQb/qE1uFqXAVR0WoSBEHI8C6HPhsiK3CVLgK+GBBTn0lBsyH9cXuxUGcxEXcRCM68RDpFnRLuiXdkm5Jt6Rb0i3plnRLuuVzq1bVxkGcxEXcxC/YD5gPv3LQOIiTuIibaEQnHiLdBt0m3SbdJt0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt3qCj+qtXngwZlPHBWhIkXUB/cnhoqpAod+QNShP7BVBp/KEDRtRjWYDzRtPpEikFXVLD7wlur73ydxETfRiE48xCDmw8qwi3QLugWWEdMLjDsh/qLg4rv6NBsHcRIXcRON6MRDDOJzq57MxkGcxEXcRCM68XMzYBDz4Zda1dkxqkmzcRJrhXDnE82WgVuaaLaM6qYdaLZ8YqiYKpaKrcJUuIqjIlToCJaOYOkIFkawIJaKrcJUuIqjIlSkiP1TMVToCLaOYOsIto5g6wi2juBLalwTV7/mxS+hGwdxEhcRsXGMGOaA4+E78+JSvhozGyfxL8rB0fCdcRuN6MRDjIcHK3MgMH8MC2fTFq4C80+IUJEi4qdiqJgqloqtwlS4Ch1B6Ajqyj1wtY9HYj4xVNQIcB8J/ZpP1Ahwjwr9mrGwG3XlHrgbiX7NJ0IFRlDDQb/mEzUCXL2hXzNw5Vj9mnH/+yYa0YmHGA8HYk+ImgNuyaDfMnCLpJ6ZSXFU1BxwL+agmlyBatJiqJgq4HMgEC0gEA2LgMrQYqiYKpaKrcJUuIqjokaAEzSaL1ugMrSoEeC2IZovn1gqtooaAS6S0In5xFHx7c4G5sOvMjR+Pd3YpK8yNC7iJhrRidU5DgxiPsS1O+5wohvzialiqXAVWDkMGFcMLRANPmeqWCq+OeA4+CpKoxMPMYj58KsjjYM4iYtIt6Bb0C3oFnQLuiXdkm5Jt6Rb0i3plnRLuiXd8rnheZyBu7R4IOcTUwVW9P7OVmEqaudwwxWP5XyisgF3NtFv2aJuDD4xVEwVNQJcyKDf8okaAa5g0G8ZuFpBv2Xgjhv6LZ9IEagvOBmi3/KJqWJ9D7UEbqIRnXiI8RDVBnfN8NDOwFkQT+2Mc3/MVRwVoaLmcLA8qCkthoqpYqn4ZjGB3yywGqgnuOGFF2rHuf9PiKgPCfgYfp/fid24z+kEh3CSURRwDwstkk9MFUvFVmEqXEUNGPeq0CL5RIrA0zsxYjy98/ISrlnhSLqP6QW7MOzuL4SKFIErEdzZQj/kEzVhFEu8SvuJraL8MUU8APDyEQ7hJOPBgJeH8BRewltYfFN8U3xTfJO+/QRQ8BCewkt4C5uwCx/hEMZq1+GFDsonhgqsNn4HFaXFVlGHF278oYPyiaMiVNQIqtlroIMykPXooJyXp/ASLnskI9onn3AVR0WoSBG4xGkxVEwVS4WOYOkIlo6gyhE+/+Gxos1JxqM5Lg/hKbyEt3D9nd8Cu/ARxsSvSBG4jdFiqMDEN8RSsVUcEShT6IBAJ2WgRqKT8omlYqtANBwgde2SuIuJF3k/MVUsFVuFqfAS2JSqQk+EihQRPxVDxVSxVGA+yAt8HmrhKo4KjAALHykiMQIsbw4VU8U3AnwyQd9kswm78BGO5onGyKy7rhOPHM3qeJp45GjW0y8mHjn6xFERKjCTLDF+KoaKqWKpqBHUDbOJZ5Y+4SqOilCRIqrG1FPEPzFUTBVLBUaA+UxT4SowAoy6ykxWek48s7RFlZmcWOsqM0/UCCYGWmXmia3CVLiKoyJUpIj9UzFU6Ai2jmDrCLaOYOsIto5g6wi2jsB0BKYjMB2B6QhMR2A6AtMRmI7AdASmI3AdgesIXEfgOgLXEbiOwHUEriNwHYHrCI6O4OgIjo7g6AhQ2aqgT7R3PuEqjgp8ogYnGVdXl4fwFF7CW9iEXRgT3CVQnCb+n1wqMA1kV5oKV3FUhIqkQIfmE/A5ELIteNbpXRS0Xj6RIlCiWmBbAmKqWCq2Cjkw0Hr5xFERKuTAQOvlE0PFlLGhRLXYKkyFy9hQolqECh3B0hEsHYGWqKElamiJGlqixpJDcyzdhaW7sHQXbonC2LbuwtZd0BI1tEQNLVFDS9TQEjW0RA0tUUNL1LglCmMz3QXTXTDdBdNduCUqIY6KGkF16k60a7ZAiWoxVNQIFkKjRLXYKkyFqzgqQkWKQImqm6oT7ZpPaJqhKtXt1okOzSdcxVGhBx+ut64I3frQrQ/d+tAEDE3A0K0P3frQrQ/d+tCtT9361MM/9fBPPfhQuBaKEApXi1CB5a11w3vZs54CMvGE1iemiqViqzAVruKoCBEoaXVre+I5rE8sFVtF+dQd8InnsD5xVIQKXPfVtPFQ1ieGiqliqdgqTIWrwCcZDPR+hLtiqJgqygeXu3hTOz4gTDyU9YlQUfOpO/UTD2V9Yqio+dQ9/Inm0g6wtwpToSPYOoKtI0B5usJ+KoaKqUJHYGpq+Di4IVLE/QB3BSZnEFMFFhGHMupOC1OBwwUHH+pOi1BRkzOMDXWnxVAxVdQIDNuIItTCVLiKGoFhs1BqDJuFUtNiqoAPFgSlpoWpcBVHRahIESg1hhVFqWkxVSwVW4WpcBWHAs2rWZ2fEy2qWTefJ1pUn3AVR0WoSBG4YKob1hMtqk9MFUvFVmEqXMVRUSOozuCJFtUWqC4thoqpYqnY3GA0qT7hKo4KlICqIXgoa68oCkqLrcJUYHITQhcRBaXFUIEpYAQoKC22CizihtBt3LqNW7dx6whMR2A6AhSUFkuFHkimB5LpCExN/d0Bn2hnbV7CX9wfJlbFpNmFcWxgYVFKWqQIlBKHN0pJi6mi3B28hU3YhY9wCCe5qkvzEJ7C4hviG+Ib4hviG+Ib4pvim+Kb4pvim+Kb4pvim+KLCxpHGuCCBgItr0/UYte3LhMtr0/UMVTf4Uy0vD5hKuoYqm9dJlpen6gR1JctEw9rbYFiVI3CEw9rfWKqqOljnFWLmk3YhY9wkFFs6rudicbXrG9UJhpf89wfcxVHRaiomQQWCZ/BWgwVU8VSUSOob08mntn6hKs4KkJFikBNCswHNanFVLFUYASYD2pSC1dRI0iMGjWp7pRPPLO1BWpSYtNRk1rUCHCNgibaJ7YKU+EqjopQkSLwGazFUKEjcB2B6whcR+A6AtcRuI7AdQRHR3B0BEdHcHQER0dwdARHR3B0BEdHcHQEoSMIHUHoCEJHEDqC0BGEjiB0BKEjCB0BrpISKY6rpBZTxVLxjQCfefDQ2GYXPsIhnI/xvNjmITyFMUGHwDQORIpAcUr8DopTi6liqdgqTIWrgE9lF571etcOz3q9i2IoUS1Mhav4/r7hhw8K1XJLkSK+EkUhBwaeAvvEUrFVmApXcVSEipSB7p+KoWKq0DWovwv64UqjWoApvMSEOCpCRYowrAFC118JPTFVLBVbhalwFUcFRoBDzFLErUrYeocpjjdfKrYKU+Gyja5b77r1rlt/dOvPUDFV6NZrVTKtSqZVybQqmVYl06pkWpVMq5IFZorECFPhKjBTrFvUTAdGXX/I26L+lPeJoWKqWCq2ClPhKuBTB1+1LFMMFVMFfCbEVmEqXAWuOAIiVKSIe+10xVAxVSwVW4WpiNsmM6vJ+WK90PvinwN2rNqbGxcRszMIU+EqvqahBQxiPkSZwnd51dRMMVWs28wzq6W50YhOPMQg5sN6L/DFQZxEum26bbptum26bbptuhndjG5GN6Ob0c3oZnRD2RlXhIoUcbuRsAe3G+kKrCoOA9SgFltFXWv/wC58hEM4yXVR1AyHhKgjY97/p2aCL1er4ZkiRcRPRR0fuGtfDc8US8VWYSowAhzCqDEtQkW1/OBX0Gp0eQhXyw+yBa1Gl7ewCbvwEQ7hfIwu5+YhPIWXMCZtEJi0Q7iKoyJUpIjxUzFUTBVLxVahIxgYQUIcFaECI6hDuDqkKYaKGgG+bakH11JsFUcE3t+zwUN4Ci/hLWzCLnyEax7VCD+rM/qJ+qvoJ4aKqWKp2CpMRa0kvuc5uApqESowAhwZuApqMVTUsYTIeHn55S1swi58hOGNYw+F6Ar/qYB3QEwVSwVmj0MHF0MtXAVmj0MHF0MtUgQuhvC9x0E56v/n+3NnjKz+3Pli/fLGOqL6tBgqpoqlYquo4eM2+kH1aXFUhAqMAIPEFU6LoaJGgLvtB1c4LbaKGgFusB9c4bQ4KkJFjQD34QPXPrglHrjCwX3rQMlpYSpcBXwOBHwConxwCzlQcnAHOFByWkwVS0WNAPdsAyWnhas4KmoEuBkbqDKOgaLKVKP1DFQZ3IEMVBncIQtUmRamwlUcFaEiReAC6GBsuABqIQdrtVZTmApXcVSECphi2ihKLYaKmjYuFgJFqcVWYSpcxVERKlIEilKLoUJHYDoCfDTDJWzgo1kLV3FUhIoUgdIUWGuUphZTxVJRI6g/FJmB0tTCVdQI0HYTKE2Bowql6QqUpkBi4HNaC4wAA0XRarFVmApXcVSEihSB+tZiqNARhI4gdAShIwgdQegIQkcQOoLUEaSOIHUEqSNIHUHqCFJHkDqC1BGkjCB/PxVDxVSxVGwVpsJVHBWhQkcwdARDRzB0BENHMHQEQ0cwdARDR4DKh7u8iYutK1AGWwwV3yVC/cXMzPtqZ/AWNmEXPsIhnOT7TmdwTbD6zWeirO0rahq4JZ0oay1SBMpai6Fiqlgqygcfe3PrtpguiumioES1WCpqW/DZNlGiWriKo0IPDNMRuB4YrgeG64HhemC4Hhi3RGFst0RdcVTogYESdceGEtViqNARaIlKLVGpJSq1RKWWqNQSlUcPzdBdCN2F0F1AibpjC92F0F3QEpVaolJLVGqJSi1RqSUqtURl6nFwS9QVugupu5B6HKBEteAurJ+UqPWTEvUnpoqlYqswFa7iqOBxsH6/FDF+KoaKqQK7sCG2CuyCQbiKoyJUYA0wNpSoFkPFVLFUbBWmwlVgBJgCrtRaVKX6FeN+VBWKVQ3gEzc5VjWAU5gKV3FkS1eo0M3ePxVDxVSxVOhmb93srZu9dbN3qEgRpoeb6eFmergZZjogXMVRESWwblXe0CWwqs2bYqiYKpaKrcJUuIojAkVsYRdQxFpMFUvFVmEq4IND9BwVoQIz9RLxUzFUYKYHYqnYKkyFqzgqQkWKyJ+KoUJHkDqC1BGkjiB1BKkjSB1BygiqE5xiqJgqMIKAqBHUHflVz+qlcBVHRahIEVXEnhgqpoqlQkdQ99Dr3slC83jzEa6vKhc4ydUH1VxfVQ7wFF7CW9iEXfgIh3CS6wKrWXyX+KJmjSuwfhjpwvpVDa++b4qhYqpANIdANOztThH2UzFUTBVLBXYjIUyFqzgqQkWKQP1pMVRgBAaxVGwVpqJGMHGkoP60qD8qxHrUjfLLdaO8eQhP4TKf2JoqSviTwVW93BSu4qjADRdwzX5CoCa1GCqmiqViqzAVruKoCBU6AlSeOzfUCsx6ola0GCq+takO3oXe6+YtbMIufIRDOMn1PVvzEBbfIb5DfIf4DvEd4jvEd4jvFN8pvlN8p/hO8Z3iO8V3iu8U3ym+S3wXFjogpoqlAgdBQpiK+vB3+QiHcJJRNnBenSgbqEjouj73/zjCIfxFOvh5vGvg8hD+ls/hdh/RDd7CJuzCRziEk4w3k1wewuLr4osigVNFtVV/f5tToi5SRt2EXtVWTTFVLBWIdiAQDXuE5G4xVEwVS8VWUbuxsdJI7hZHRahIEbjgaDFUTBUYAZIbFxwtTIWrwAiww7jggFi4XsDhvHC90MJVIMCGCBU4PxTfywXwEJ7C8DAIRHKIigSuzy7NQ7giHfAS3sLlAIP61NJ8hEM4yXVvuXkIT+ElvIXFd4kvrgg2BocEri8kFh7vez8t4QG/T5gKV4HRVj7g4b3DsEc477fYKkyFqzgqsCgYNc77V+C832KomCqWiq3CVGAEOB5w3m8RKlIEkt1wFCDZW2AEAVHRHEuFTxctUgSSvcVQMVUsFVuFqXAVOoJKdpSr6mlurlRv/uxRnqqn+fES/rxxKVw9zY9d+AiHcD6ujubHQ3gKL+EtbMJY2dqajUx3/D9I9fquaG18LmixVZgKRKvt3DfbD8RUsVRsFabCVWA3EiJUpAikfYuhYqpYKrYKjMAgXMVRESpqBDg1b3xSaFEjqC+11kbFaLFUbBU1goMVRcVocVSEihSBTxcthoqpYqnYKnQEVWXuRKvINIfwZ3+3vSpM8xD+vO9xUuWleQubsAsf4RBOctWV5iEsvkd8cQFxMAHUlINDDTWlvipbGzWlxVSxVFS0wK7jYiCQVLgYaDFUTBVLxVZRuxHISlwMtDgqQkVSGD5RtBgqpgrMJyG2ClPhKjCCDREiUEvq275VLcHfH7ZCHBWhIkXgwqHFUDFVLBVbhanQEVQtwfUQuoibk1yFBFdG1UL8eAp/3vX3lav6hx+bsAsf4RBOcpWP5iE8hcV3iy/qA+5HowF41Dc9Cw3AAzdw0QD8xFKxVVQ03MM2XDfg5rThuqHFVLFUbBWmonaj+voWOnufCBUpAtcNLYaKqWKpwAiwo7hp0MJVHBUYAY4U1IUrqi5M3NGuzl6KqWKp2CWwonWt8YSrOCpCRYrIn4qhYqpYKnQEVUsOJlqlpPkIf/Yo/ugEBqMRuPnzxvkKbcDNS3gLm7ALH+EQTnJ9FmkW3yG+Ayu7ILB+BoH1qzpUXb4UQ8VUgWgBgWgJkSLWT8VQMVUsFbUb+ARVPbwUruKoCBUpoorFE0MFRnAgloqtwlRgBFjRfUQYfLD3NlRMFUvFVmEq4IP9saMCM8UuWIpwjAAD9aECI8Bm+VKBEWDh3VTUCHCLsvp6KWoEuC9Xnb1PVP2ZEwtS9eeJGgHuOaLr94kawcS0q/48gRFg2ueowAgw7ZMiUH8mpo360wIjwLRRf1pgBJg26k+LGgFuQKEf+IkaAe5GOerPFVV/8AGtGoIfT+ElvIVNGN5YvjwqQgW8a12qKZhiqJgqloqtwlS4iqMiVOgIho5gwMchEO1AIFpAhIoUgVrUYqjQ+Uydz9T5TJ3P1PlMnc/U+Uydz9L5LF3RpSNYOgJUqTtt1KI77a3z2Tof1KIWS8VWofPZOp+t89k6n63zMZ2P6XxM52M6H9MVNR2B6QhQi+60UXHutF3n4zofVJwWrkKPENf5uM7n6HyOzufofI7O5+h8js7n6HyOrujRERwdAerKnTaqx5126HxC5xN6xIce8alHSOoRgquX6tZc6Od9oi4i4ImLl8sufB6jY3fiBis6difuj6JjN+5PmbALf5HwIQHdus1JriqAzzVo1W2ewkt4C5uwCx/hEE7yFN8pvqgJ+ASAxtv78QSNtxM3aNF42wKZ32KoQDQsB65CNuaNq5AWKQKZ32KomCpqN3DzEx21T5gKV3FUhIoUgcxvgRFgdZD5LZaKrQIjwJGCzG+BESyIUJEicH3SYqiYKpaKrcJUuAodQVULfCZDQ+3lqhXNnz0+aaGbtnkJf974xINW2mYXPsIhnOS6JmkewlN4CYtviC+qhmECqA24K4xe2Gk4IlEbWmwVpgLRqoSgr3XiPi76Wp9YKrYKU+Eqajeqn36hr/WJFIFrhRZDxVSxVGwVmE9AuIqjIlRgBLWi6Gt9AiM4EFMFRoAAqCW4E1qtrQufiKq19fERDuEk17vcm4fwFF7CW1h8l/iiGuHLTTTCPpEiUI1aDBVTxVKxVZgKV4ERYINQjVqkCFSjFkPFVIHfweRQP1oMFVPFUrFVYNTYVNSPK3B9gPuUaFB9wlTU7+AOJhpUnwgV3y6jQybxTsTLQ/jbZXzYq+bUx1v422V8vKzO1MdHOISTnD/hITyFl/AWFt8UX3zWqFuuG62ls+6LbrSWzrqtudFa+oSpcBWI5iWQ8XWJsdEm+sRWYSpcxVGB3UiIFIGMbzFUTBVLxVZhKjACgzgqQkWKwHVFdbHvH64rWtQIEiuKTxR5f2erMBWu4qgIFSkC2d9iqJgqdARf9q+J1f2S/7ELf4dlfabe1T36OMlf3q+JPf/S/vEUXsJb2IRd+AiHcJJdfF18UR/yCqwfRorPHImNxmeOK/CZo8VQUd8g/pAgVR9W3VTc6P18IkXU1cETQ8VUUV9U/pA6sVWYCldxVISKFIHvZ1tgBDgi8Q1ti6Viq8AIcKTgW1oI9GTeBUFP5hNHRajA2GpL0Hl51wCdl09sFfA5EK7iqIBPQMguVPslxVChI5g6gqkjmKbCVRwVoUJHsNR0IXRCmApXUaEH1q0S/okUUQn/RPkM+FTCP7FUbBU1gjpzbbRs4hS10bLZwn4q4IPjwKaKpWKrMBWu4qjACHCEWIrwn4qhYqpYKrYKU4HQOFwOAmDhz1KxVZgKV3FU1BQmtgT14ArUgxZDxVSxVGwVpqJGMLGNqActQkWKQD1oMVRM2WDUgxZbhanAtKtSoHHzrigaN5+YKpYKTG5ByCJOlI0WKWJgChtiqJgqsIgGsTWAqXAVOoKhIxg6AhSUFkPFVLFU6Aimmk65Vpq4gmgxVEwVmNwVcq0011ERKnAcQKBstBgqsIjYny1Xa3NvFaZCR7B1BFtHgE8JV+BTQouhYqrQEZiaolJMLCIqxRWoFC3QHTQgpoqlYqtAh9CEcBVHRahAdxIOZRSUhSMRBaXFVgEfHKMoKC2OilCRIlBQWgwVGAGOEBSUFluFqXAVR0WoSBGoFAuHy+3iwsLfNq4rQkVSrNvJdcVQUVOo25d/YqnYKkyFqzgqQkWKQEGpO4gb3Z5PTBVLxVZhKpwbvFBQWoSKFIEaUl8/bXSA3hVFC+gTruKowOTq4EO7Zy/imiqWCkwBI8B1SAtXgUU0iNAAuo1bt3HrCLaOYOsIcB3SwlS4iqNCR2BqikphV2wVpsJVYHJ1KKM3FPe5NnpDn5gqcBwciK3CVGARsT/49NEBQkWKODqCoyM4OoKzVGwVpsJV6AiOmqJSbCwIKkWLraImZ0gZVIoWR0WoqCPEkBi49GgxVEwV6BbFoYyCYjgSUVBahAr41DF6W0NbDBVTxVKxVZgKjMAhjopQkSJQUFoMFVPFUoHQdbhsXGDgGEUf6RNTxVKxVZiKmkL1uG70kT4RKlJEXYc8MVRMFUtFjaDu3270kT7hKo6KUJEiUFCwwegjfWKqWCow7R9EyIris8wVKBsthgpMbkHoIuITS4ujAlPACHAdcgWuQ1pgEXFUuW6j6za6bqPrCFxH4DoCXIe0SBFHD6SjB9LRERw1RaVAFdu499kiRaAbowUmh0MZPReofBvfmrZwFTgOboBQkSJQNhy/k0MC5FSxVOgIUkeQOoI8KkIFv9/b9vupGCqWChzkCXFUhIqaXN1R34ZK0WKomCrqCKn75ttw6dHCVLiKGkH1tG00k65qXttoJn1iqoCPQWwVpsJVHBWhIkWgoNTN+o2G0iemiqViqzAVruKIQKU42BJcYBwsPIpDC1dxVISKFIGygVvk6Ch9YqpYKrYKU+EqjooaQWAbUVCuQEFpMVRMFUvFlg1GQWnhKo4KTLvqKNpLe0XxWabFVmEqMDkcfEcXEZ9YWgwVmAJGgOuQFlsFFhFHVeg2hm5j6DaGjiB1BKkjwHVIi6VCD6TUAyl1BCmm6BFd+MCOJtGFT67oEn1iqzAVruKoCBWoVXXsoFn0iaFiqlgqtgpT4SrYA7TRSbqqJWSjk/SJqWKpwEyxOigoLVzFUREqUgQKSgt002BB1lSxVGwVpsJVHBWhIkXsKQuydaaoOy1MhavQmW6d6daZms701p0rpoqlQmdqOlPTmZrO1HSmpjPFJ6MWutaua307vrAgrjNFdWkRKlLE0ZkenenRmR6d6dGj6uhRdfSoOjrTozM9OtPQmYbONHSmoUdV6FqHrvXtBcOChM40NX9S8yc1f1JnmjrT1JmmzjT1qEo9qlKOqu4nPRBDxVSxVGwVpsJVHBWy1nicLDrLNx4n+8RSsVXUTPE96u0nxVckt5/0ivlTUStaf/yx0U/6xFJRK1p/77FvP2kHcBVHhY5g6giWjkD64feRfvh9pB9+H1SkFjqCpab4MISvj9Fc+sRUgckZxFZhKlxFHS74lhTNpU+kCBShFhgB9hSXOPhmFS2kT7gK+GA+uMRpkSJwidNiqJgqlor6GyB8YYm20ydcxVERKlJEFaEnhgqExuFyEAALf1JE/FQMFVPFUoEpYEvCVLiKoyJUpIj8qRgqMAJsYy4VW4WpcBVHRcgGo7pAoA/1iaECO7chnCuK7tMnQkWKGJjcgZBFRKvpE6YCPhjBOCpCBXzqqELDaQeYQ8VUoSP4P+y9y64sv47e+S417kHoLvlVGo1GwV0NGCiUDbvcE6PevTPFCPG3c59kcmVozXwmR99/rySp2xe6UGSkBZEWxErQCDoBBpK4qS5ApfJK92xEeaV7gUbQCaZouawTz1R5jpbFM3WBTDCrILfL4pm6QCOYVZALZfFMvQSUgyAQ0IJCCwotKIWgEjSCTkALKpUKU8hlt7icLlAJpHLnbzrBABCmuMAcIXK7LG6nCySCTCAWyFAWQpGLUfExvYAQygVEj4xRIZQLJIJMUAgqQSOQN5kyQoRQTiCEcoFAEAkSQSYoBCJ6DhfxSM1yBSweqQtkgkJQCRqBVKEIGABCGxcIBJEgEWSCQiAWVAGNoBMMACGUCwSCqB0sHqkLZIJCID035/YQpjhbVJ7rXiASJAKpXBPARjzf5p5gAJyvc8WC83nuCSKB6BkC2I2Z3ZjZjZkWZFqQaUE5CAIBB1LhQCq0oFCpMMV07czig7pAIIgEU3Q6gbyrDgIaQSeQl9UChDYuEAhmFeRCWfxWLwEtExQCWtBoQaMF8pL3BP0gCASRgBZ0KhWmkMtuiZh6AWGKC0jlZMoIU1wgEWSCOUJkzyQRUxdoBJ1ALHgO5SLOq3lejBZxXl0gE4ieIaASNIJOMACEUC4QCKYF8xFOEYfXBTJBIagEjaATDABhinnvXMRfNc8r4CL+qgt0ggFwPvI/QSCQKhQBiSATFIJK0Ag6wQAQQpkXsEX8VReIBIkgExSCig4WQrlAJxgAwiHzIr4cwhRni5ZCUAkagVROBl9lI9ZIkAhEj1gg65ALVALRI6Oqshsru7GxGxstaLSg0QJZh1ygEHAgNQ6kRgs6lZ7xhaQXzvhCJygElWCKLjKUJUpIlUaUKCEXiASzCvN2uYif6gKFYFahSP9IlJBLQCcYCs4YpRcIBJEgEWSCQlAJGgGVClPMy+4iLrALZAKpXBFQCRpBJ5gjZN4uF3GBXSAQRAKxQGwTQpkXo0UcXRfoBKJnjtEghHKBQBAJEkEmKATTgummUMQfdoFOMACEUC4QCCJBIhDRc7iIo2uu0vBCDheIBIkgExQCqYJ0idDGBTrBAKgHQSCIBIlALJBuFEK5QCVoBJ1gAAihnB0shHKBSJAIpOeygI4Wlb3MCYQ2LhAIpHIy+DobUXYsF2gEokcskHXICWQdcgHRI6NqsBsHu3GwGwctGLRg0AJZh1xgKBB/2AUCQSTIBJMphLjEBXaBASDhCS8wRc/LuiKOrhIGr4ij6wKVYFZh3i4XcXRdYAAIbTTRIzGITgESg+gCiYAWRFoQacEZw/AEnWAAnGEMT0ALEpUKU7QTNIJOIJWbU0ZcYBcIBJFgjpB5u1zEBXaBQlAJxII5lMXRNc+L0SKOrgtEAtEzBGSCQlAJGkEnGABCKF1GiBDKBSJBIsgEhaASNABhii7DRRYYXRpeyOEClaARdIIBILTRpUuENi4QCRJBJigElaARiAXSjUIoJxBCuUAgiASJIKODhVAuUAkagfTc5FFxgT1bVFxgF8gEhUAq1wSgEcXRdYFAIHq6gESQCUTPEFApoBF0AloQaUGkBbIOuUAiyASFgBZEKpWlx7wzKuICm+eVTxEX2AUyQSGoBI2gE0yukt2HuMAuEAgiQSLIBIWgEjz1zCP8Ik6vVzmgLNWUBhA2uUAmKASVoBF0ggEgbHKBQEALKi2otKDSgkoLKi2otKDSgkYLGi044yXL2D/jJZ8gExQCsUAmHCIpl4RIyiUhknIRn9k8pOGFdC6QCaSm0oey+bkENIJOQAsGLRi0QLZFF0gEmaAQ0IIBpeImm+eFXhE32QUSgVRuCCgElaARPPWUeYNWxE32ApOOFggEcYIgoEwQBVSCRiB6koABEA+CQBAJEkEmEAuygErQCDrBAEgHQSCIBCK6ChAB0vD5IAgEkSARZAKpgnRJrgSNoBMMgHIQBIJIMC0I0o2TdxYoBJWgEXSCgQ6uB0EgiAQyRmVc14YWrZ1gALSDYIoOMvgaG7EVgkogVRALWicYAJNQSpBR1dmNnd3Y2Y2dFnRa0GlBbwSdgANpcCANWjCodEj/yLAcUrkioBMMBeImu0AgiASJQLgqCCgElaARdIIBINuiCwSCqWfethTxmV2gErQrI0Ipmq2hFM3WUIpmayhFszWUotkaStFsDaVotoZSNFtDKZqtoZQIvRF6I/Qm6E3Qm6A3QW+C3gS9CXoT9CboTdCboTdDb4beDL0ZejP0ynomnqARyJDqAgaA3B5HGStye3yBSCBDagjIBNOAU1hFuaHctSy0Mq8pi3jOligjaGZFn678ZTrOrnJD+SlJDmSmC+1VnslervKzCWW3Pz1rVzmhnFEuKFeUG8od5aHlfqAMvR16hVHmlWARp9kSpTbCG2cTC29cIBBEApHWBIg0aVmhCgESSnWBQBAJEsHsjXntVsRPdoFK0Ag6wQCQtccFAoFYUAUkgkxQCMSCIKARiAVJwACQVckFAkEkSASZoBBUgkZACyahTH+3Mh1oVzmg/Bwdsp6e3rOrnFF+jkrZA03X2VVuKHeUh5YnoVzlgHJEOaGcUYbeDL3CGnKJI16xJUnXCDfIUl+8YhcoBJVApE0KEQ/XIjduEl91gUxQCCpBI5i9ITdH4vt6AVmDXCAQRIJEkAkKgdRHpo6sTi7QCQaArE6ErsX3dQGpQhHQCQaAkIRsWc/4qBeYDpDSV/JS5yxnlAvKomN2hzinFmHo0zm1SjmhnFGeks4fV5QbytONs0h5aFkc6M9yQDminFDOKBeUK8oNZegN0CuTXq76xBW1yGWWuKIWOewVV9QFOsEAkG2FHMaLW2mRayEJYLpAI+gEA0B2HxeYvSF3ROJ9ukAiyASFoBI0gk4gFswBKN6nCwSCSCAWyEiRyX6BaYHc94hf6gKNoBMMANl9XCAQRIJEkAlogRCE9K/ww1nuKMsXc5aFHM5yQFm2DVJOKGeUC8oV5YZyR3loWSjhLAeUobdDr2xJqlRAuEHWGeKSWmShJC6pC0SCRCDSZFLLAkKuh8S9dIFAEAkSQSaQ3hgCKkEj6AQDQBYQFwgEkUAsKAIyQSGoBNMCudAR/9QF5GpkDul+Jo6RfzkTx5ygEjSCTjAAzsQxJwgEkSAR0IIzgoCUK8oNZXmoKuWh5fOtr5Sns3CSckQ5oZxRLihXlBvKHeWh5TN+gJSht0CvOKDKkD7dTOv5L9J+UjVxHrtAIIgEcIcQz9LTFUA8Sy/QDoJAEAkSgfSGjDs54bxAJWgEnWAAnImlThAIxALprdPx4wSZoBBMC5qMFDn7vMC0QK4Yxef0AnL2eYFAMC2QKxLxOV0gExSCStAIOsFQMMQl5AKBIBI8LZCKis/qVS4oP9VLt4vD6lXuKD91yzgRb9WrHFCOKCeUM8oF5YpyQ7mjDL0Res+0dFIB4RS50hTfU0n9U4ZwygUGgHDKBcSZ8BCgTotFfE8X6AQDIB8EgUCcFpOARJAJCkElaASdYACciaWGgEAQCRKBWCAtKlxyAdEjfS+JY+SaTQKbLlAIKkEj6AQDQLjkAoEgEtACubyVWsvd7VmuKItrmJQ7ykPLcm0bpRxQjignlDPKBeWKckO5ozy0PKB3QO+ZWEq6RlhAdpDiT3pugcWfVMDjrOIgCATyUCEL0OcIVbxGFxgA4SAIBJFAHkQ0AZmgEFSCRtAJBoAklrqAWJAERIJEkAnEgi6gEsibtUNAJxgA50O5E8hDOWnR86HcCRJBJigElaARdIIBIGFSL0ALJpc0qeikkqucUX6qb9Ltk0euckP5qbudMoeWJ4dc5YByRDmhnFEuKFeUG8rQW6BXHuoeUgF5qHvIUJNgyfPyo55hUi/QCQZA06ebVbxH5aViFe/RBRpBJxgA/SCYvTGvX6qESV0gEWSCQlAJGkEnEAtkGpyJpU4QCCKBWCAtep5dnEDW7CfoBEOBOJkuEAgiwdw1yGgTJ9MF5q5Bxpg4mS4gFhQBnUAsmD0XZN9yAbGgCYgEYkEXkAnEgiGgEkwL5he+ii/qAtOC+bWu4ou6wLSgS7XlDOQC04Iu1ZaDzwtMC7pUW05HLiAWSLXldOQCYoFUW65jLyAWSLXl3OQCYoFUO2UCsUCqLScqF3hacNZg0s9VHlqe5HOVA8oR5al7SPPJWcoFCsHULbwsbqwLdIIBIGcpFwgEkSARZIJCQAsKLZATE/k6irNqkY+bOKuWIe0v5yIXqASNoBOwPo31aaxPY30a69NYn8b6NNansT6NLdpoQacFchxyVlvOQ85qd9ansz5yUnICOSm5QCBgfQbrM1ifwfoM1mewPoP1GaiPeK4uEAgiQSKoWm1xVj2rLc6qZxXEWXWBSJAIMgHqI26sCzSCTsD6RNYnsj6R9YmsT8wEtCDSAuGVs9rCHme1E+uTWJ9UCCpBI+gEomcSk3iuLvCsj6y/xHH1KieUM8qiQ8DJBUNAeCabkHrNmO1XOaGcn2Wp7ozZfpUryu1ZjlLuKA8tz5jtVzmgHFFOKGeUC8oVZeit0CvZcGW5KW6p9fqXuVM+qzZn/gKNoAN0kSad3EWa9FEvBJWgEXSCATBnfpVVlbiYLhAJEkEmKASVoBGIBdJbYyiQYKwLBAKxYAhIBNMCWVWJJ+oClaARdIIBIAcfFwgEkSAR0IInW6R5g1+ni+oqN5SfoyOefz+0/CSKVX6OyiBVfNLEKieUM8oF5YpyQ7mjPLQ808VcZehN0JukZaMAaT/pmiTtN0ekOKEuEAgigUhrAkRaFzAAykEQCCJBIpi9cbb0XCssUAkaQScYAJJO+wKBQCyoAhJBJigEYoH0sGTVvoBYIK0jebVPIIm1owgQLonSbs/1hUTtrdPZdJUzygXlinJDuaM8tDzzy1zlgDL0dugVNooyXoSNLlAJGkEnGADCRhcIBJEgEUwLTnOEjS5QCRpBJxgKxKm0zruDKk6lC3SCASD8cYFAMK2etwxVYq9eQA49p8NAFQfRBSKB/KYLyASFYPZyk3JDuaM8e1n+fk7+qxxQnr0sqmeuqKucUS4oV5Qbyh3loeV8oBxQht4MvVl6YwiQM+M5d8Q3tM4jtiq+oQtEgkQgB9PSNTLjs/SGzPgLBIJIkAgygZx/S0vLjL9AI+gEA0Bm/AUCQSQQC5KATFAIKoFYID0s64oLTAuKtOjcUdQiv5EVxwUiQSLIBIWgEjSCTjAABi2YSabOvppJpq5yQvk5LM8emEmmrnJF+Tksz5Z4TvtVHqs83UhXOaAcUU4oZ5QLyhXlhrLqFR/ROt0kqviI1vkStoqPaJ2uCFV8RBdoBB1AmGO+Xa0SPbXOu9Eq0VMXqASNoBMMgHliUedDySrRUxeIBIkgExSCStAIpD5dwACQdcUFAoFYIC2aE8H0rBTJeWi5HCgHlEVSEZAIMkEhqASNoBMMAGGYCwQCWlBpQaUFlRZUWlBpQaUFlRY0WtBoQaMFwjBVxqcwTJWxJgxzgUrQCDrBABCGuUAgiASJgBY8GUbu9uoMw7rKDeXnAJDTwelOepWf5LLKzwEgp47Tl3SVE8oZ5YJyRbmh3FEeqzz9Tlc5oBxRlpbtAmb7zavqKg6kdT6NreJAukAgiARTmhzeijNolfNacQa9gKxALhAIIkEimL0hJ7niDLpAJWgEnWAACMNcIBCIBVFAIsgEhUAskBYVhrmAWDAEDABhmAsEgkiQCDJBIagEjYAWyMM66V95WHeWA8pP9Yf052Slq5xRno6pInM6ml/lhnJHeWi5HigHlCPKCeWMMvRW6BW2keN3cSCtcrIsDqRVjtLFgXSBQlAJRNokJQmEWuX0XAKhLpAJCkElaASzN+RcXbxJLyArkAsEgkiQCDJBIRALZOrI/uMCnWAokBCpVU72xQt1gWmBHMKLu+kClWDqkdti8ThdYOqRQ0TxOV0gEIgeMUf2LBfIBIWgEjSCTjAAhH8uEAhoQaQFkRZEWhBpQaQFkRZEWpBoQaIFiRYkWpBoQaIFwj9yEitergt0ggEg/HOBQPCcfPEsV50K4r26QCfAjBHv1SonueKjeo5+8VFdoBBIDZqARtAJpAZzjIuP6iVA1jUXiAS0oNKCSgtqJWgEnWAANFrQqFTIRdhJ3FAXaATz+lpIVTxRLzAXLAsEgnl1Lke64o26QCYoBPP6XI50xVG1yUGnOKouEAhEj/TpSASZoBBUgkbQCcSC2VTi3LpAIIgEiSATFIIKEER0FyAChoBMUAgqQSPoBLMKcggrsVMXCASRIBFkgkJQCaYFcg4q/qwLDIB0EASCSJC0g8WfdYFCUAmk2pPixV31alFxHrlAIsgEUrkkgI0oniInEFeRC0gVxAJxFrlAIpBGLALYjYXdWNiNhRYUWlBpQQ0EkYADqXIgVVpQqVSYQhbG4uG6QCRIBFI5GcpCG7IWFj/WBbCyFj/WJgfd4se6QCSQRpT+kXXMJaAQVAJa0GlBpwXjIAgEkSAR0IJBpcIUcicgDqoLBAJxJwoCEkEmKATiUhQFNIJOMACEUOZDzioOqW0+H6zikbpAIRA9RUAj6AQDQAjlAoEgEogFVUAmKASVoBF0ggEghHIBEd0FiABpeCGHCwyAfBAEgkggTmfSJafX2QkKQSVoBJ1gAAihXGBakKQbhVAukAgyQSGoBA0dfPqgnWAACKFcQKp9CCho0VoJGkEnkMrJ4GtsxJYIMoFUQSxolaARSCPKqGrsxs5u7OzGTgs6Lei0QNYhF6gEHEidA6nTgkGlwhTlBIWgEjQCqdxzKDfxaJVzxiaxUxdIBDIOmoBCUAmkEbuATgEDQHY8F6AFgRYEWhAyQSGoBI2AFkQqFaaYtxlN3FsXKATi3hkENIJOMACEKeaZZhP31gUiQSKYFsxj6SZOrG2eqzdxYl1gAAihzKP1Jk6sC0SCRJAJCkElEAtkhAihXGAACKFcIBBEgkSQCUS0DBdZYGRpeCGHCySCTFAIKsGsQpEuEdq4wACY65AFAkEkSASZYFpQpBuFUC7QCDrBABBCuUBABwuhXCARZAKptoxrYYqzRWUvc4FAEAmkcjL4BhtRdiwX6ARShWmBuLUuEAikEYsAdKO4tS5QCCpBI+gEA0DWIRcIBJGAFgQqPR/EiNXnixgB55OYEwQCqVwVIHd+UlM5AblAI5Bx0AQMAKGNC0gjdgERAlIiyAS0INGCRAvkBOQCAyAfBIGAFmQqFaYo0ojCFBcYAMIU8xVdE6fTBSJBIpgjZN5MNXE6XaASNIJpwbx/ahI7tVXpLCGUCyQC0SP1EUK5QCVoBJ1gAAihXEAskBEihHKBRJAJCkElaAQdQJiiynCRBUaVhhdyuEAj6AQDQGjjArMKTbpEaOMCiSATFIJK0Ag6wbRg3h808UBdIBBEgkSQCYp2sPimLtAIOoBwiKwPxB31bFFxR12gEFQCqdwcfOJ0ejaiOJ0uEAmkCmKBrEMuUAikEYuARgGdAN0osVMXoAWJFsg65AKZoBBUAlqQqPT0MmsCEkEmKARSuSpA/c9ahP9Zi/A/axI7tTURILRxgUwgjXj+plJAI+gEtKDSgkoLaiRIBJmgENCCSqXCFE0aUZjiAolgVm4+nmjivrpAJWgEc4R0mRiy9DiBLD0uEAimBV2GshBKl5EohHKBRiB6ZIwKoZxACOUCgSASJIJMIBbICBFCuUAj6ARDgTi2LhAIIoGI7gJEwGx48UtdIBBEgkSQCWYV5mvDJrFTF2gEnWAACKFcIBBEgmnBvGZqEjt1gUJQCRpBJxjawUkI5QKBIBJItQ8BDS0qe5kLDADZy1xAKpcEsBFlx3KBSiBVEAtkHXKBASDrkHmv08Sh9RJQ2I2F3VhoQaEFhRbIOuQCnYADqXIgVVpQqVSY4hBD5fblAp1gAMjSY8hQlpPT4wSZoBDIOGgCGkEnkEaU/hHfkVPA6Q9/gkhACzot6LQAnvItwVO+JXjKtwRP+Xb6pl6ASoUphjSiMMUFGsF8m3XIlJlMcYI8mWKBQDDfZ80LpCZxURfIBIWgTpAEiJ45EsVRdYFAIHqKgESQCQpBJWgEnUAsmE0lbq8LBIJIkAgyQSGoAElEdwEiYAjIBIWgEjSCTjCrEKRL5CndBQJBJEgEmaAQVIJpQZBunISywAAoB0EgiAQJHVwyQSGoBFLtyaPiCHu1aI0EiSATSOVk8FU2Yh0A7SCQKogFLRIkAmlEGVWN3djYjY3d2GhBowWdFvRAEAk4kDoHUqcFnUqH9I8MyyGVawIiQSLIBIWgEjQCea11Kh0KzrioFwgEkSARZIJCIHqyABmJs7cl+ukCgSASSE1FmhDKBQpBJWgEnWAAnO/sioBAEAkSQSYoBJWgEXQAeb97NkhiTYV3LpAJCgFrmljTxJom1vTknRMEgkjAmmbWNLOmmTXNrGlmTfMAKGzrwrY+3+pKgxTWVNjlAo2gE7CmlTWtrGllTStHVeWoqhxVlTWtrGllTStr2ljTxpo2jqrGtm5s6/MVrzRIY00b50/n/OmcP5017axpZ007a9o5qjpHVeeo6qzpYE0HazpY08GaDtZ0cFQNtvVAW0v4VYne0CT86gKRIBE89UgW7iZBViVgQxMf2QUGwGQkybXdxEd2gUiQ/unKwt3qmfr7FFAIKgEtCLQg0AIkBW/iV7tAJEgEtCBS6dwMSa7tJg6zCwQCqZy0dUoEmaAQ1H+60ms3cZhdoBMMgDMpeBMgeqSzztTfJygEokfqc6b+PkEnGABn6u8TBIJI8LRAUmU38Y1doBBUgkbQCQaApJy4gIiW4XLm9JaGP3N6n2AAnDm9TxAIIoFUQbpEYiBdoBBUgkbQCQbAmRT8BGKBdOOZFPwEiSATFIJK0NDBvRMMgHEQSM9lAQUtemb7PkEj6ARSuTn4xB32bESJyrpAJhA9XUAlaASiZwhAN7ZwEAQCWhBoQaAFSAre2pkU/ASNoBPQgkilZ1SkLKAQVIJGMEXP/AZN/Fwl5FMTP9cFEsGsguxLxM91gUowqyAbjnam/j4FDACJo3YBWpBpQaYFSAreJJrrApWgEdCCQqXCFLIvERfYBQqBVO78TSPoBANAmEKW++ICu0AkSARigQzlM/W3jMQz9fcJBsCZ+lvG6Jn6+wSRIBFkgkJQCaYFUUaIEMoFBsAZWu0EgSASJIJMIKJluJxB0qThz5zeJ0gEmaAQVAKpgnSJ0MYFhgJxdF0gEESCRJAJxIIqoBI0gk4wAM6k4CcI2sESxXWBRJAJpOeygKEt2s9s3ycIBJFAKtcEoBHF0XWBTiB6xIIz9fcJAoHoGQLQjT1lgkJACxItSLQAScFbP5OCnyAQRAJakKn0jLh4CBgAQhsXCARTdDrBZCS57hBH1wUawaxCOsEAENq4wKxCkv45U3+f/5IIMgEtqLSg0gIkBW9nxNcTnFEaTxAIaEGjUmGKJI0oTHGBASBMkWTKCFNcIBIkgjlCxEVMXGAXqASNQCyQoXym/paReKb+PkEiED0yRs/U3yeoBI2gEwwF4g+7wLRA3GLEH3aBRJAJCkElaAQd4Mz2HQWIgCSgEjSCTjAAhDYuIFUoAiJBIsgEhaASNIJOIBbMbhxnUvATBIJIkAgyQdEOlkivCzSCDiAcMp0v2zizfUuLntm+T1AIKoFUbg4+cXS9GlFSbl4gEogeseBM/X2CQiB6ZFQVdmNhNxZ2Y6UFlRZUWoCk4G2cScFPwIFUOZAqLahUesaGll44Y0OfIBMUgim6yFA+I0BLI54RoE8QCGYVxP/tDN96gUwwqyCObeNM/X0KaASdgBYMWjBoAZKCP0AiyASFgBYgD3gXF1jJtd3FBXaBRCCVKwIKQSVoBHOETBexLi6wF5ClxwUCgVggtp2pv7uAStAIRM8QMADO1N8nCASRIBFkgmnBdIvp4g+7QCPoBANACOUCgSASiOgoQARIw585vU8QCCJBIsgEUgXpEqGNCzSCTjAAzqTgJwgEkUAskG48k4KfoBBUgkbQCQY6WAjlAoEgEkjPZQENLXpm+z7BAJC9zAWkcjL4GhtRdiwXqASiRyw4U3+fYACcqb9lVHV2Y2c3dnZjpwWdFnRagKTg/TiTgp+AA2lwIA1aMKgUeSf6Gdn1Ap1gKBAX2D63Vj0g70QPyDvRz/itF5hnxPP1TRdH1wU6wTylnvuFfsZvPQWceSdOEAloQaAFgRaceSdO0Ag6wQCItCBSqdwHz0V9FxfYBRqBVK4IGABybXyBQDCP4KO0tVzsXCATFAKxQGw7A7DOkXhFYD1BIBA9Q0AiyASFoBI0gk4wLUgyQuTa+AKBIBIkgkxQCCqA3NgkGS5yL5Ok4eVe5gKFoBI0gk4gVZAukWvjCwSCSJAIMkEhqARigXSj3NhcYADIjc0FAkEkSOhgubG5QCGoBNJzk0fFBfZqUbk2vkAiyARSORl8g40o3iYCxNF1AdHTBUSCRCB6hoBCAZWgEXQCWhBogVwbXyASJIJMQAsClQpTyMfojLt6gUiQCKboubXq8cx2VQR0ggEgtDFf33RxdF0gEswqzP1CPyOyXgIKQSWgBYkWJFqADFk9nhmyThAJEgEtyFQqTJGlEYUpLhAIpHLyG2GKC2SCQjBHyNyodXGBXaATDAAhlLm16uLo2rOMRCGUCxQC0SNjVAjlAp1gAAihXCAQRIJpQZERIoRygUJQCRpBJxgAQigXENEyXOQGVzYC4ui6wAAQb5MLBIJIIFWQLhHauEAhqASNoBMMBeLouoBYUAVEgkSQCQpBJWjawRLBdYEBIIRyAem5LKBoi4oL7AKNoBNI5ebgE0fXsxHF0XWBTCB6xAJZh1ygEYieIQDdKI6uCwQCWpBoQaIFsg65QCVoBJ2AFmQqlaWHbJPEBbbPJzJdXGAXaASdYAAIoVwgEEyuOntO4r9fIBMUgkrQCDrBAJg7lkOG6OSTq5xRnmv9IQ0g5x8XaASdYADIruYCgSASJIJMQAsaLWi0oNGCRgs6Lei0oNOCTgs6LZDcvPKhFzfZBRpBJ5CulskjbiPyMZVArQtkAhlSolRI5wKNQIaUzGXZ/IgA8ZldIBBEgkSQCQpBJWgEnYAWBCqV5YnsyU832QtUAqlcE9AJBoC4yV5A5ksXEAkSQSYQC4aAqaeJoUI6JxDSucDUM59G9Sykc4FEkAkKQSVoBGJBFDAAZFt0gUAQCRJBJigEInoOl9MZtknDy1rlApmgEFSCRiBVkC6RtcoJZK1ygUAQCRJBJigEYoF0o6xiLtAJBoCsYi4QCCI6WFYxF8gEhUDG6PwAn26yZ4vKfucCkSARiGgZfJ2NKKuYCwwAWcV0sUBWMReIBFNPl1E12I2D3TjYjYMWDFowYIH4zC4QCCJBIsgElWAyhRwEiJvsAoEgEkjlooDJSLI1FGfYBTrBrMJ8NNXFGXaBQCCNmAUkCBBn2AsUAloQaUGkBbItOoGkublAIIgEtCBRqTBFl0YUpjiBMMUFpHLSbsIUF0gEmWCOkC56ZBVzgUbQCcSCOZQlVmyf/ohdYsUukAmmnulo2E//1ws0gk4wAIRQLhAIxAIZIUIoF8gEhaASNIJOMACEKYYMF9nVDGl4IYcLdIIBILRxgUAgVZAuEdq4QCYoBJWgEXSCASCEMqQbhVAuEAkSQSYoBBUdLIRygU4wFIiXa5+v/Lr4sp4tKvFeF6gEjUBEz8EnvqxnI4ov6wKJ4KlnHGLBXIcsUAnaBEFApwB0o/iyLkALIi2ItEDWIRcoBJWgEdCCRKWTKcZ0AOziyzqmJ1wXX9YFKkEj6AQDYBLKAsJV0iBygHKBRJAJCkElaAQdQBxKggwKSeF5gUSQCaSmMigkhef0HOvisXoBSQd8gTB/I404aWOBRCAtKnrEoeQSUAkaAS2otKDRAnEouUAkSASZgBY0Ku3SWScIBJFAKidTpmeCQlAJ5nAJMjEmoSwwACahLDAtCNKnkzZGkDE6aWOBSiB6ZLyNTjAUSATYBQJBJEgEYkEWUAgqQSPoBAMgHASBQERXASKgCRgA8SAIBJEgEUgVhoBCUAkaQScYAOkgCATTArk0E5fXBTJBIagEjaBrB4vL6wWEXS4QCGSMdgEVLZobQScYAPM0ZQihiGPr1YglExQCqYJYUBpBJ5h65NJMHFsvAZXdWNmNlRZUWlBpQa0EjYADqXIgNVrQqLRJ/8iwbJWgEXQCqdxkPvFlXSAQRIJ5VnT29iSUBQpBJWgEnWAATEJZQEaidLAQygUKQSWQmkqDCKFcYCgQl9cFHjUN505vurwqSASZoBBUgkbQAYQ2ZFEvjq0LJIJMUAgqgdRnzmDxZR1y8yi+rGN6UXYJ57pAIZjS5J5MvFwXmO0mt0fi5XoB4ZALzPpMZ7EuXq4LJIJMUAgqQSMQC4qAASAccoFAEAkSwew5udnqQihnuwmhXIAtKoQiV5fi8rpAJEgEmUBqKkNMqOYCjaATSE3FAqGaCwSCaYFcp4kz7AKZYFogF23iDLtAIxALZFQJ1cjNljjDDrk1EGfYIfdX4gy7QCIQPdIGwjsX6AQDQHhHbrbE//UayrJcuUAhqAQdYGayOO/JpsurgkQwB4UchU+XVwWVoBF0gqFgurwqCASRQLrkBJWgEXQCaarZ9RLodYFAEAmkpklAJigElaARdIIBEA+CQDD1CKlO/1cFs6ZyoSf+rwt0ggEgVDN9GLv4vy4QCRJBJigEs6ZCndP/VUEnGAD5IAgEkSARZIJCIDWNAgaAUM0FAoHUVJpXqOYCmaAQSE2LgEbQCQZAPQgCQSRIBNKnWUAj6AQDQAjlAoHgoUfuA6bH7FXMWixarFpsWnxolQPa6T97Fp/UchWDFqMWkxalRiJO9jly5SoesAsEAmkfGWTCLxfIBIWgEjSCTjAWeNDLQRAIIkEiyASFoBI0gk5AC4Rf5g3wkIiwC2SCQiAt2gU0gk4wAGSjdIFAEAkSgVgwBBSCStAIpgXzNneIo+wFhHkuEAji6vpxnMxzgkxQCCpBI+gEAyAfBFNPlV6QFMIXKARTz7xxHOJPO+aF4RB/2gUGgDDPBaSmWUAkSASZQCwQQ2WRU6VLZJFzgU4wAGSRc4FAEAkSQSYoBLTgyUln2zwZ6SqOVXyy0dleTy66ilGLT26Qnp9MdBaLFqsWmxa7FscqTiY6i0GLUYuqras2OYmpMmaFh5qYLzzUxNR5gLtAIsgEU9q8kxriKzvm5cyQcLELRIJEkAkKwWz7eWM3xIt2gU4wAGQ1c4FAEAkSgViQBBSCStAIxIIuYAAI28ybtCFRZce8bBriUrtAIsgEhaASNIJOMACEbS5AC55sc1b6yTVXMWvxofusx5NlrmLT4kPrjOc4puPtWXyyy1UMWoxaTFrMWixarFpsWlRtWbUJk3TpCOGLLiNG+KKff9YIOsEAEFboUj2Z+/Mmaojv7AKNoBMMAFmPXGC2/bxVGuI7u0AiyASFoBI0gk4gFkgXytbnAoEgEogFMi5kU3QBsUBaVFYwF2gEnWAACKdcIBBEArFAGl445QKFoBI0gk4wFIjz7QIPC+Zd9piut1cxaTFrsWixalFkz06dzrPpmDc8YzrPKpiro3D+WSGoBI2gEwwA2RVdIBBEgjItEENnhuJj3uOM6WOroBMMgJmleIFAEAmkpklAJigElUAsyAI6wQDIB0EgiASJQCwoAsSCKqASNIJOMADKQRDQp4W9XdjbJRMUgkrQCDrBACALiSvuApmgEIieJgAsFMlC4nC7gNRHBLREkAmkPudvKgU0gk5ACzot6LTgZKETJIJMUAhoQafSmcD4CNKIM4PxAolgVi7IUJ5JjBeoBI1gdlaQoTwTGZ9guuIqCARiQRYgeoqAStAIRE8VMADCQRAIIkEiyARiQRNQCRpBJxgA8SAIBJFARA8BU8A8cR9J2OUCgSASJIJMMKswL05GEna5QCPoBANA2OUCgSASiAXSjcIuFygElaARdIKBDhZ2uUAgiATSc0FAQ4sKbVxgANSDQCong6+yEWshqARSBbGgdoIB0KQRZVQ1dmNjNzZ2Y6MFjRY0WtAaQSfgQOocSJ0WdCoVppDtiDjTLtAJBsAQ0TKUB/YmaWSCQiBV6AIaQSeQKsz+ydwdZe6OMndHmbujzN1R5u4on7ujEzSCTjAAAi0IVCpMMc+7RxamuEAjmJWblzojC1OcQJjiAoFgjpB5wzOmM62CTFAIxIIsQPSIoUIoFwgEoqcKSASZoBBUgkbQCcSCOUKyEMoFAkEkSASZoBBUAGGKJMNFVhtZGl7I4QKFoBI0gk4wq5ClS4Q2LhAIIkEiyASFoBKIBdKNQigXGABCKBcIBJEgoYOFUC5QCCqB9Nzk0SxMcbZojwSJIBNI5WTwdTZiHwBCGxeQKogFsg65QCKQRpRRNdiNg9042I2DFgxYUI6DIBBEgkSQCQoBlE5n2iCx4sd0plUQCUR0F5AJpuhySqsEjWBWbl6pjCKEcgIhlAvMys37iFGEUC6QCDJBIRALqoBG0AkGgFDNBQJBJEgEoqcJGLOpxAIhBzleLkIOF8gEYvUQUAmm1XKIV2S1cYEBIBwiB5JFVhsXiASJIBMUgkogFkjXC7tcYAAIu1wgEESChNYRDqknaASdYAAIh8i5cREOuUAkSATPPbqkI3iAQlAJGkEnGAD9IAgE0qJFQCGoBI1AaioDSajmBEI1FwgEczbK6d10s1WQCQpBJWgEnWAoqEIo9QSJIBNITbuAStAIpKZDwACQLc90bxlVtjwXiATTAjm2rsI7FygElaARdIIBILwjp9tVeOcCkSARZIJCMNtaBt8MMxskcdaYDrhB0kmNGWZWQSRIBJmgEFSC2adCQtM1V8EAmLfRC4gF0rw5EiSCTFAIKkEj6AQDoEw9WRpEGEnO16sw0gUKQSVoBJ1gAAgjyXK/CiNdIBIkgllT+UxNp10FlaARdIIB0A6CQBAJpKbSjbKquUAjkJpWAQNAtkkXkJpKB8vi5wJSU5mNwlUXKARigfSPcNUFOsEAEK66QCCIBNMCuSapsiy6QCGoBI2gE0hbz56bHrzXqGoHRlU7MkEhqASNoBNgVLWAUdVCIIgEiQCjajr6KqgEjaATYFRNF2AFgQCjasYAfZwfBQGRIBHkCaRysxcWqASNoBMMBdMhUkEgiASJIBMUgkrQCDoBLQi0INCCQAsCLQi0INCCQAsCLQi0INCCSAsiLYi0INKCSAsiLYi0INKCSAsiLUi0INGCRAsSLUi0INGCRAsSLUi0INGCTAsyLci0INOCTAsyLci0INOCTAsyLSi0oNCCQgsKLSi0oNCCQgsKLSi0oNCCSgsqLai0oNKCSgsqLai0oNKCSgsqLWi0oNGCRgsaLWi0oNGCRgsaLWi0oNGCTgs6Lei0oNOCTgs6Lei0oNOCTgs6LRi0YNCCQQsGLSAndnJiJyd2cmInJ3Zy4iAnDnLiICcOcuIgJw5y4iAnDnLiICcOcuIgJw5y4iAnDnLiICcOcuIgJw5y4iAnDnLiICcOcuIgJw5y4iAnDnLiICcOcuIgJw5y4iAnDnLiICcOcuIgJw5y4iAnDnLiICcOcuIgJw5y4iAnDnLiICcOcuIgJw5y4iAnDnLiICcOcuIgJw5y4iAnDnLiICcOcuIgJw5y4iAnDnLiICcOcuIgJw5y4iAnDnLiICcOcuIgJw5y4iAnDnLiICcOcuIgJw5y4iAnDnLiICcOcuIgJw5y4iAnDnLiICcOcuIgJw5y4iAnDnLiICcOcuIgJw5y4iAnDnLiICcO5cR4HMqJTxAIIkEiyASFoBI0gk5ACwItCLQg0IJACwItCLQg0IJACwItCLQg0oJICyItiLQg0oJICyItiLQg0oJICxItSLQg0YJECxItSLQg0YJECxItSLQg04JMCzItyLQg04JMCzItyLQg04JMCwotKLSg0IJCCwotKLSg0IJCCwotKLSg0oJKCyotqLSg0oJKCyotqLSg0oJKCxotaLSg0YJGCxotaLSg0YJGCxotaLSg04JOCzot6LSg04JOCzot6LSg04JOCwYtGLRg0IJBCwYtGLRg0IJBCwYtICcGcmIgJwZyYiAnBnJiICcGcmIgJwZyYiAnBnJiICcGcmIgJwZyYiAnBnJiICcGcmIgJwZyYiAnBnJiICcGcmIgJwZyYiAnBnJiICcGcmIgJwZyYiAnBnJiICcGcmIgJwZyYiAnBnJiICcGcmIgJwZyYiAnBnJiICcGcmIgJwZyYiAnBnJiICcGcmIgJwZyYiAnBnJiICcGcmIgJwZyYiAnBnJiICcGcmIgJwZyYiAnBnJiICcGcmIgJwZyYiAnBnJiICcGcmIgJwZyYiAnBnJiICcGcmIgJwZyYiAnBnJiICcGcmIgJwZyYiAnBnJiICcGcmIgJwZyYiAnRnJiJCdGcmIkJ0ZyYiQnRnJiJCdGcmIkJ0ZyYiQnRnJiJCdGcmIkJ0ZyYiQnRnJiJCdGcmIkJ0ZyYiQnRnJiJCdGcmIkJ0ZyYiQnRnJiJCdGcmIkJ0ZyYiQnRnJiJCdGcmIkJ0ZyYiQnRnJiJCdGcmIkJ0ZyYiQnRnJiJCdGcmIkJ0ZyYiQnRnJiJCdGcmIkJ0ZyYiQnRnJiJCdGcmIkJ0ZyYiQnRnJiJCdGcmIkJ0ZyYiQnRnJiJCdGcmIkJ0ZyYiQnRnJiJCdGcmIkJ0ZyYiQnRnJiJCdGcmIkJ0ZyYiQnRnJiJCdGcmIkJ0ZyYiQnRnJiJCdGcmIkJyZyYiInJnJiIicmcmIiJyZyYjr5LQuQ3xQB8psqQH7TBIjVXcC0+uld+wQDQFjsAoEgEiSCTFAIKkEjoAWRFiRakGhBogWJFiRakGhBogWJFiRakGhBpgWZFmRakGlBpgWZFmRakGlBpgWZFhRaUGhBoQWFFhRaUGhBoQWFFhRaUGhBpQWVFlRaUGlBpQWVFlRaUGlBpQWVFjRa0GhBowWNFjRa0GhBowWNFjRa0GhBpwWdFnRa0GlBpwWdFnRa0GlBpwWdFgxaMGjBoAWDFgxaMGjBoAWDFgxaMGBBPg6CQBAJEkEmKASVoBF0AloQaEGgBYEWBFoQaEGgBYEWBFpATszkxExOzOTETE7M5MRMTszkxExOzOTETE7M5MRMTszkxExOzOTETE7M5MRMTszkxExOzOTETE7M5MRMTszkxExOzOTETE7M5MRMTszkxExOzOTETE7M5MRMTszkxExOzOTETE7M5MRMTszkxExOzOTETE7M5MRMTszkxExOzOTETE7M5MRMTszkxExOzOTETE7M5MRMTszkxExOzOTETE7M5MRMTszkxExOzOTETE7M5MRMTszkxExOzOTETE7M5MRMTszkxExOzOTEQk4s5MRCTizkxEJOLOTEQk4s5MRCTizkxEJOLOTEQk4s5MRCTizkxEJOLOTEQk4s5MRCTizkxEJOLOTEQk4s5MRCTizkxEJOLOTEQk4s5MRCTizkxEJOLOTEQk4s5MRCTizkxEJOLOTEQk4s5MRCTizkxEJOLOTEQk4s5MRCTizkxEJOLOTEQk4s5MRCTizkxEJOLOTEQk4s5MRCTizkxEJOLOTEQk4s5MRCTizkxEJOLOTEQk4s5MRCTizkxEJOLOTEQk4s5MRCTizkxEJOLOTEQk4s5MRCTizkxEJOLOTEQk4s5MRCTizkxEJOLOTEQk4s5MRCTizkxEpOrOTESk6s5MRKTqzkxEpOrOTESk6s5MRKTqzkxEpOrOTESk6s5MRKTqzkxEpOrOTESk6s5MRKTqzkxEpOrOTESk6s5MRKTqzkxEpOrOTESk6s5MRKTqzkxEpOrOTESk6s5MRKTqzkxEpOrOTESk6s5MRKTqzkxEpOrOTESk6s5MRKTqzkxEpOrOTESk6s5MRKTqzkxEpOrOTESk6s5MRKTqzkxEpOrOTESk6s5MRKTqzkxEpOrOTESk6s5MRKTqzkxEpOrOTESk6s5MRKTqzkxEpOrOTESk6s5MRKTqzkxEpOrOTESk6s5MRKTqzkxEpOrOTESk6s5MRGTmzkxEZObOTERk5s5MRGTmzkxEZObOTERk5s5MRGTmzkxEZObOTERk5s5MRGTmzkxEZObOTERk5s5MRGTmzkxEZObOTERk5s5MRGTmzkxEZObOTERk5s5MRGTmzkxEZObOTERk5s5MRGTmzkxEZObOTERk5s5MRGTmzkxEZObOTERk5s5MRGTmzkxEZObOTERk5s5MRGTmzkxEZObOTERk5s5MRGTmzkxEZObOTERk5s5MRGTmzkxEZObOTERk5s5MRGTmzkxEZObOTERk5s5MRGTmzkxEZObOTERk5s5MRGTmzkxEZObOTERk5s5MRGTmzkxEZObOTETk7s5MROTuzkxE5O7OTETk7s5MROTuzkxE5O7OTETk7s5MROTuzkxE5O7OTETk7s5MROTuzkxE5O7OTETk7s5MROTuzkxE5O7OTETk48n5TEJEBEVwGVoBGI6C5gAJxkdwKpwhAwpT2D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3754P7jw1cJXC1/Rb4/FffvCVwtfLXy18BX99qDfHvTbY3Hfvng/uPDVwlcLX9Fvj8V9+8JXC18tfLXwFf32oN8e9Ntjcd++eD+48NXCVwtf0W8P+u1Bvz3ot8fCV/TbY3Hfvri/ot8e9NuDfnvQb49Pv/37/vOn315x8+VW3Xy5dX//21f1/v2Xu96//3K//5sD8dNv/8mXu+fNTb7cfT//7auffLn7fv7bV/3+9UlO8uX2XfvbVz/5cr9/0nz89Nt/8uWe+zW/ffWTL/fcz3z76idP8uWeO4e3r37yNzdfl3t99clNPr/ld7/9/qj3ePfbPznI39yvJ7ib8+a4uciX+/2DuePdb//ky/3+Cdfx7rf/5OurT77c7x+/E+9++ydfbtyv4frqk4t8ufN+bddXn3y5835t11c/+foqv3+WfLz77Z8c5MvNeXOSL/f+3X7327+ehm7e5CZfbt2v5/rqky+37mdeX33yJF/u/Tv/7rd/8uXev8/vfvsnN/ly1/06r68++XLXne311Sdf7r5rv7765Mvd9zOvrz55ky93vz//PPn6Ku/3xbvf/slBvty+fweurz75cvt+bddXn3y55872+uqTz5Ovr+p153x99clx8+VeX9X77/b11dcJ/+YiL/ImN/ncfPfr+uqTBznIlzvu17Df3LuuXeRF3uTLjbuW66uffH31yZcbl3V9VXFZ11efnOTLjTvz66tPvtz399H11SefJ19fffLlvr+/rq8++XLf31PXV59c5Mt9f39dX33y5b6/166v3vndb6/7/fXut3/y5da4eZKTfLn3++vdb//ky73/7nj32z/5PPn6qu7317vf/smXe7+/3v32T77c+++Rd7/9kxf5cve+ucmX2/drvr765Mvt+zVfX33y5d5/17z77Z9c5Mu9P+333W//5Mu9/+5499t/8vXVJw/y5Z5z8yQn+Zu7Xvdrvr76OvHevMl9853D9dVPvr5a93vz3W//5CB/c9f999G73/7Jl3u/X9799k/e5MuN+7VdX/3k66t1v3fe/fZPvtz79/ndb//kJF/uvH8frq8++XLnnf/11SefJ19ffZ08b77cede4gjzJSb7c+/3y7rd/8iY3+XLf30fXV+uend799k8O8iQn+XL3Xfv11Sdf7n5/fpPPk6+vPnmQgzzJSS7yIsNtuA33wD1wD9wD98A9cA/c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2XCb/cVX9NuTfnvmgXvg4iv67Um/Pem3J/32pN+e9Nuznv5V1tO/SvrtSb896bdnPf2rrKd/lfTbk3570m9P+u1Jvz3ptyf99qwB9+lfJf32pN+e9NuzAm7AxVf025N+e9JvT/rtSb896bdnBdynf5X025N+e9Jvz5pwJ1x8Rb896bcn/fak357025N+e1bCTfYXX9FvT/rtWQk34eIr+u1Jvz3ptyf99qTfnvTbswpusb/4in570m/P4nmweB6k357025N+e9JvT/rtSb896bdnbbib/cVX9NuTfnsWz4O14eIr+u1Jvz3ptyf99qTfnvTbsxpus7/4in570m/P4nmwDlx8Rb896bcn/fak357025N+e9bTF8319EWTfnvSb0/67bl4HlxPXzTptyf99qTfnvTbk3570m9P+u25BtynL5r025N+e9Jvz8Xz4Bpw8RX99qTfnvTbk3570m9P+u25Au7TF0367Um/Pem35+J5cE24+Ip+e9JvT/rtSb896bcn/fZcCTfZX3xFvz3pt+fieXAlXHxFvz3ptyf99qTfnvTbk357roJb7C++ot+e9Ntz8TxIvz0X56vF+Yp+ey6eB9eCy/0V/fak357023NxvlpPXzR/+u3f/z3z/Om3n/fvudzv/55z/vTbf/ImN/k8+e2rnzzIQZ7kJMNtuA234TbcA/fAPXAP3AP3wD1wD9wD9zzcn377T/7m7u//rnu+++2fPMlJLvIib3KTz5Ovrz4Z7oA74A64A+6AO+AOuANuwA24ATfgBtyAG3ADbsANuBPuhDvhTrgT7oQ74U64E+6Em3ATbsJNuAk34SbchJtwE27BLbgFt+AW3IJbcAtuwS24C+6Cu+AuuAvugrvgLrgL7oK74W64G+6Gu+FuuBvuhrvhbrgNt+E23IbbcBtuw224DbfhHrgH7oF74B64B+6Be+AeuOfhvvvtnzzIQZ7kJBd5kTe5yXDxVeOrxleNrxpfNb5qfNX4qvFV46vGV42vGl81vmp81fiq8VXjq8ZXja8aXzW+anzV+KrxVeOrxleNrxpfNb5qfNX4qvFV46vGV42vGl81vmp81fiq8VXjq8ZXja8aXzW+anzV+KrxVeOrxleNrxpfNb5qfNX4qvFV46vGV42vGl81vmp81fiq8VXjq8ZXja8aXzW+anzV+KrxVeOrxleNrxpfNb5qfNX4qvFV46vGV42vGl81vmp81fiq8VXjq4OvDr46+Orgq4OvDr46+Orgq4OvDr46+Orgq4OvDr46+Orgq4OvDr46+Orgq4OvDr46+Orgq4OvDr46+Orgq4OvDr46+Orgq4OvDr46+Orgq4OvDr46+Orgq4OvDr46+Orgq4OvDr46+Orgq4OvDr46+Orgq4OvDr46+Orgq4OvDr46+Orgq4OvDr46+Orgq4OvDr46+Orgq4OvDr46+Orgq4OvDr46+Orgq4OvDr46+Orgq4OvDr46+Orgq4OvDr46+Orgq4OvDr46+Orgq4OvDr46+Orgq4OvDr46+Oo8vqrX46t6Pb6q1+Orej2+qtfjq3o9vqrX46t6Pb6q1+Orer3gDrgD7oA74A64A+6AO+AOuANuwH376vtnLdW7376/f9ZSvfvtX0+aN1/u98+CqXe//ZMvN955ky/3++ez1Lvf/pPfvvrJl/v984zq3W/feb+Gt69+8uVm3lzky837tb19lftvv373///hr3/6h3/88x//3+/+179//d//86//9Id/+dNf/unn//7Lv/3z55/841//9Oc//+n//v0///Uvf/jj//7Xv/7x7//8lz98/7Pfvb7/53tb/u5r5TF+//Wbx8+v/934+v46v77+d53f//rdfP/Kfn3/Sr++fmX8/Kao71+a95fG+5c67+9a358X35/3/adn/Mr4/Lkav+r+4/nbVxDjV9xfyv/8RdXnQ6J/zf58yNd08nz/4/Wf/8R+Pjd/xf1d/dsvzfw17y+d5w+eX5F3/cwkzvz19T/929LifE1kvt6DeiY1+9eo/kzp6y/UiPptQrG+/sj47SPq6xPW+wPif/oBz/DG/hVxfy3/iyXVf78H45nfPL/y/Wf2fznyn3/+t7/9/m//AQ==",
      "is_unconstrained": false,
      "name": "lock_private_solver",
      "verification_key": "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"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "2360858009427093503": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "4736483829072576196": {
            "error_kind": "string",
            "string": "HTLCAlreadyExists"
          },
          "7920565393106506482": {
            "error_kind": "string",
            "string": "Function lock_public_solver can only be called internally"
          }
        },
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "ownership_hash",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "src_asset",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 90
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "internal",
        "external",
        "public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "lock_public_solver"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "message_ciphertext",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 17,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "message_context",
            "type": {
              "fields": [
                {
                  "name": "tx_hash",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "unique_note_hashes_in_tx",
                  "type": {
                    "fields": [
                      {
                        "name": "storage",
                        "type": {
                          "kind": "array",
                          "length": 64,
                          "type": {
                            "kind": "field"
                          }
                        }
                      },
                      {
                        "name": "len",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "std::collections::bounded_vec::BoundedVec"
                  }
                },
                {
                  "name": "first_nullifier_in_tx",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "recipient",
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::messages::processing::message_context::MessageContext"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "utility"
      ],
      "debug_symbols": "TL1JrgRJc6R5l1z3ImzQwXiVXhS6ugYQIIpADStevp6rmJrIhvnJz0wTdXNXCY9wfRH/8c9/+a//+f/89//0r//jv/37//rnX/7f//jnP//Pf/23f/vX//6f/u3f////73//67//j7//9T/++X3/J//+7/p//snxz7/43z/mP/+y//6x8I+Nf9g//5J//3D8I/CPxD9O/eP88I+Bf0z8Y+EfG//AKgerHKxysMrBKuP3u/8c95/z/nPdf+77T7v/9PvPuP/M+8+73rjrjbveuOuNu96464273rjrjbveuOuNu96868273rzrzbvevOvNu96868273rzrzbveuuutu96666273rrrrbveuuutu96666273r7r7bvevuvtu96+6+273r7r7bvevuvtu57d9eyuZ3c9u+vZXc/uenbXs7ue3fXsrud3Pb/r+d964/fBatgN1vC35lgfREM2nAvxt+7wD/4Wnt9/FbNhNewGa/CGv5Xn/iAbzoWvPQDfyvbBbFgNX83f4XyNAvCGv5XX+CAbzoWvZQCjYTasht1gDd7QK59e+dyV59dFa30wGmbDatgN1uAN0ZAN58LolUevPHrl0SuPXnn0yqNXHr3y6JVHrzx75dkrz1559sqzV5698tdfyz6Ihmw4F74eA4yG2bAadoM19MqrV1698uqVd6+8e+XdK+9eeffKu1fevfLulXevvHtl65WtV7Ze2Xpl65WtV7Ze2Xpl65WtV/Ze2Xtl75W9V/Ze2Xtl75W9V/Ze2Xvl6JWjV45eOXrl6JWjV45eOXrl6JWjV85eOXvl7JWzV85eOXvl7JWzV85eOXvl0yufXrl6MD9YDbvBGrwhGrLhAFb1YMFomA2rYTf8rbzHB94QDX8rb//gXPh6EDAaZsNq2A3W4A3R0CuPXnn2yvMm0pqzYTXsBmvwhmjIhptIa/0aeuXVK69e+evBfT6wBm+Ihmw4F74eBIyG2bAaeuXdK+9eeffKXw/a74Nz4etBwGiYDathN1iDN0RDr2y9svfKXw9afDAbVsNusAZviIZsOBe+HgT0ytErR68cvXL0ytErR68cvXL0ytkrZ6+cvXL2ytkrZ6+cvXL2ytkrZ698euXTK59e+fTKp1c+vfLplU+vfHrlc1fev1/DaJgNq2E3WIM3REM29MqjVx698uiVR688euXRK49eefTKo1cevfLslWevPHvl2SvPXnn2yrNXnr3y7JVnr7x65dUrr1559cqrV1698uqVV6+8euXVK+9eeffKu1fevfLulXevvHvl3SvvXnn3ytYrW69svbL1ytYrW69svbL1ytYrW6/svXL34O4e3N2Du3twdw/u7sHdPbi7B3f34O4e3N2Du3twdw/u7sHdPbi7B3f34O4e3N2Du3twdw/u7sHdPbi7B3f34O4e3N2Du3twdw/u7sHdPbi7B3f34O4e3N2Du3twdw/u7sHdPWjdg9Y9aN2D1j1o3YPWPWjdg9Y9aN2D1j1o3YPWPWjdg9Y9aN2D1j1o3YPWPWjdg9Y9aN2D1j1o3YPWPWjdg9Y9aN2D1j1o3YPWPWjdg9Y9aN2D1j1o3YPWPWjdg9Y9aN2D1j1o3YPWPWjdg9Y9aN2D1j1o3YPWPWjdg9Y9aN2D1j1o3YPWPWjdg9Y9aN2D1j1o3YPWPWjdg9Y9aN2D1j1o3YPWPWjdg9Y9aN2D1j1o3YPWPWjdg9Y9aN2D1j1o3YPWPWjdg9Y9aN2D1j1o3YPWPWjdg9Y9aN2D1j1o3YPWPWjdg9Y9aN2D1j1o3YPWPWjdg9Y9aN2D1j3o3YPePejdg9496N2D3j3o3YPePejdg9496N2D3j3o3YPePejdg9496N2D3j3o3YPePejdg9496N2D3j3o3YPePejdg9496N2D3j3o3YPePejdg9496N2D3j3o3YPePejdg9496N2D3j3o3YPePejdg9496N2D3j3o3YPePejdg9496N2D3j3o3YPePejdg9496N2D3j3o3YPePejdg9496N2D3j3o3YPePejdg9496N2D3j3o3YPePejdg9496N2D3j3o3YPePejdg9496N2D3j3o3YPePejdg9496N2D3j3o3YPePejdg9496N2D3j3o3YPePejdg949GN2D0T0Y3YPRPRjdg9E9GN2D0T0Y3YPRPRjdg9E9GN2D0T0Y3YPRPRjdg9E9GN2D0T0Y3YPRPRjdg9E9GN2D0T0Y3YPRPRjdg9E9GN2D0T0Y3YPRPRjdg9E9GN2D0T0Y3YPRPRjdg9E9GN2D0T0Y3YPRPRjdg9E9GN2D0T0Y3YPRPRjdg9E9GN2D0T0Y3YPRPRjdg9E9GN2D0T0Y3YPRPRjdg9E9GN2D0T0Y3YPRPRjdg9E9GN2D0T0Y3YPRPRjdg9E9GN2D0T0Y3YPRPRjdg9E9GN2D0T0Y3YPRPRjdg9E9GN2D0T0Y3YPRPRjdg9E9GN2D0T0Y3YPRPZjdg9k9mN2D2T2Y3YPZPZjdg9k9mN2D2T2Y3YPZPZjdg9k9mN2D2T2Y3YPZPZjdg9k9mN2D2T2Y3YPZPZjdg9k9mN2D2T2Y3YPZPZjdg9k9mN2D2T2Y3YPZPZjdg9k9mN2D2T2Y3YPZPZjdg9k9mN2D2T2Y3YPZPZjdg9k9mN2D2T2Y3YPZPZjdg9k9mN2D2T2Y3YPZPZjdg9k9mN2D2T2Y3YPZPZjdg9k9mN2D2T2Y3YPZPZjdg9k9mN2D2T2YXw/674NoyIa/lf17LPf1IGA0zIbVsBuswRuiIRt65dMrn1759MqnVz698umVT698euXTK5+78vn9GkbDbFgNu8EavCEasqFXHr3y6JVHrzx65dErj1559MqjVx698uiVZ688e+XZK89eefbKs1eevfLslWevPHvl1SuvXnn1yqtXXr3y6pVXr7x65dUrr15598q7V9698u6Vd6+8e+XdK+9eeffKu1e2Xtl6ZeuVrVe2Xtl6ZeuVrVe2Xtl6Ze+VvVf2Xtl7Ze+VvVf2Xtl7Ze+VvVeOXjl65eiVo1eOXjl65eiVo1eOXrl78HQPnu7B0z14ugdP9+DpHjzdg6d78HQPnu7B0z14ugdP9+DpHjzdg6d78HQPnu7B0z14ugf/nrL/Ho1H89F6tB/ZI38Uj/LR8xjPYzyP8TzG8xjPYzyP8TzG8xjPYzyP+Tzm85jPYz6P+Tzm85jPYz6P+Tzm81jPYz2P9TzW81jPYz2P9TzW81jPYz2P/Tz289jPYz+P/Tz289jPYz+P/Tz287DnYc/Dnoc9D3se9jzsedjzsOdhz8Ofhz8Pfx7+PPx5+PPw5+HPw5+HP494HvE84nnE84jnEc8jnkc8j3ge8TzyeeTzyOeRzyOfRz6PfB75PPJ55PM4z+M8j/M8zvM4z+M8j/M8zvM4z+P1+Xh9Pl6fj9fn4/X5eH0+Xp+P1+fj9fl4fT5en4/X5+P1+Xh9Pl6fj9fn4/X5eH0+Xp+P1+fj9fl4fT5en4/X5+P1+Xh9Pl6fj9fn4/X5eH0+Xp+P1+fj9fl4fT5en4/X5+P1+Xh9Pl6fj9fn4/X5eH0+Xp+P1+fj9fl4fT5en4/X5+P1+Xh9Pl6fj9fn4/X5eH0+Xp+P1+fj9fl4fT5en4/X5+P1+Xh9Pl6fj9fn4/X5eH0+Xp+P1+fj9fl4fT5en4/X5+P1+Xh9Pl6fj9fn4/X5eH0+Xp+P1+fj9fl4fT5en4/X5+P1+Xh9Pl6fj9fn4/X5eH0+Xp+P1+fj9fl4fT5en4/X5+P1+Xh9Pl6fj9fn4/X5fH0+X5/P1+fz9fl8fT5fn8/X5/P1+Xx9Pl+fz9fn8/X5fH0+X5/P1+fz9fl8fT5fn8/X5/P1+Xx9Pl+fz9fn8/X5fH0+X5/P1+fz9fl8fT5fn8/X5/P1+Xx9Pl+fz9fn8/X5fH0+X5/P1+fz9fl8fT5fn8/X5/P1+Xx9Pl+fz9fn8/X5fH0+X5/P1+fz9fl8fT5fn8/X5/P1+Xx9Pl+fz9fn8/X5fH0+X5/P1+fz9fl8fT5fn8/X5/P1+Xx9Pl+fz9fn8/X5fH0+X5/P1+fz9fl8fT5fn8/X5/P1+Xx9Pl+fz9fn8/X5fH0+X5/P1+fz9fl8fT5fn8/X5/P1+Xx9Pl+fz9fn8/X5fH0+X5/P1+fz9fl6fb5en6/X5+v1+Xp9vl6fr9fn6/X5en2+Xp+v1+fr9fl6fb5en6/X5+v1+Xp9vl6fr9fn6/X5en2+Xp+v1+fr9fl6fb5en6/X5+v1+Xp9vl6fr9fn6/X5en2+Xp+v1+fr9fl6fb5en6/X5+v1+Xp9vl6fr9fn6/X5en2+Xp+v1+fr9fl6fb5en6/X5+v1+Xp9vl6fr9fn6/X5en2+Xp+v1+fr9fl6fb5en6/X5+v1+Xp9vl6fr9fn6/X5en2+Xp+v1+fr9fl6fb5en6/X5+v1+Xp9vl6fr9fn6/X5en2+Xp+v1+fr9fl6fb5en6/X5+v1+Xp9vl6fr9fn6/V5DSw55rDXo/3ozyN+Rf4oHuWjc6kGly6NR/PRerQf2SN/FI/y0fMYz2M8j/E8xvMYz2M8j/E8xvMYz2M8j/k85vOYz2M+j/k85vOYz2M+j/k85vNYz2M9j/U81vNYz2M9j/U81vNYz2M9j/089vPYz2M/j/089vPYz2M/j/089vOw52HPw56HPQ97HvY87HnY87DnYc/Dn4c/D38e/jz8efjz8Ofhz8Ofhz+PeB7xPOJ5xPOI5xHPI55HPI94HvE88nnk88jnkc8jn0c+j3we+TzyeeTzOM/jPI/zPM7zOM/j9fl+fb5fn+/X5/v1eQ1HxSwaj+aj9Wg/skf+KB7lo9M0nsd4HuN5jOcxnsd4HuN5jOcxnsd4HvN5zOcxn8d8HvN5zOcxn8d8HvN5zOexnsd6Hut5rOexnsd6Hut5rOexnsd6Hvt57Oexn8d+Hvt57Oexn8d+Hvt57Odhz8Oehz0Pex72POx52POw52HPw56HPw9/Hv48/Hn48/Dn4c/Dn4c/D38e8TziecTziOcRzyOeRzyPeB7xPOJ55PPI55HPI59HPo98Hvk88nnk88jncZ7HeR7neZzncZ7HeR7neZzncZ7HaQ9/fe6vz/31ub8+99fn/vrcX5/763N/fe6vz/31ub8+99fn/vrcX5/763N/fe6vz/31ub8+99fn/vrcX5/763N/fe6vz/31ub8+r+GssKLTVH0OGo/mo/VoP7JH/igePY/1PPbz2M9jP4/9PPbz2M9jP4/9PPbz2M/Dnoc9D3se9Qd0o2g/skf+KB7lo9NUf04HGo/mo+fx9XnWjn99fskfxaN8dJq+Pr80Hs1H69HziOcRzyOex9fnuYtO09fnl8aj+Wg92o/skT+KR88jn8d5Hud5nOdxnsd5Hud5nOdxnsd5Hqc9asjr0ng0H61H+5E98kfxKB89j/E8xvMYz6P+sNWK9iN79HngzyTjUT76PL53LDX4dWk8+vM4o2g92o/+PE4U+aN49OdxsMpp+vr80vj+0rP+DvNr9MZF3EQjOjGISTwPv4ZvpNum26bbLrc6qm1EJ5ZbbfdO4nloP+IgTuIibqIRnUg3o5vRzcutzq8P4iQu4iYa0YlBTOJ5GHQLugXdgm5Bt6Bb0C3oFnQLuiXdkm5Jt6Rb0i3plnRLuiXdkm6Hboduh26Hboduh26Hboduh27nudU0WuMgTuIibqIRnRjEJNJt0G3QbdBt0G3QbdBt0G3QbdBt0G3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt083oZnQzuhndjG5GN6Ob0Q1Zgj9aPw+RJcBBnMRF3EQjOjGIdHO6Bd2CbkG3oFvQLegWdAu6Bd2Cbkm3pFvSLemWdEu6Jd2Sbkm3pNuh26Hboduh26Hboduh26Hbodt5buf3Iw7iJC7iJhrRiUFMIt0G3QbdBt0G3QbdBt0G3QbdBt0G3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt023YxuRjejm9HN6GZ0M7oZ3Zglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJedlyfy9LJm/lyXz97Jk/l6WzN/Lkvl7WTJ/L0vm72XJ/L0smb8f3QbdBt0G3QbdBt0G3QbdBt0G3QbdJt0m3SbdJt0m3SpLRn21SmXJxSAm8TysLLk4iJO4iJtIt0W3RbfKkjELz8PKkouDOImLuIlGdGIQ6bbpZnQzuhndjG5GN6Ob0c3oZnQzujndnG5ON6eb083p5nRzujndnG5Bt6Bb0C3oFnQLugXdgm5Bt6Bb0i3plnRLuiXdkm5Jt6Rb0i3pduh26Hboduh26HboduhWWTJ2YRJPYw0gjhGFgziJi7iJRnRiEJN4Hg66DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum26Gd2MbkY3o5vRzehmdDO6Gd2Mbk43p5vTzenmdHO6Od2cbk43p1vQLegWdAu6Bd2CbkG3oFvQLeiWdEu6Jd2Sbkm3pFvSLemWdEu6Hboduh26Hboduh26Hboduh26nec2mSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZMpklk1kymSWTWTKZJZNZspgli1mymCWLWbKYJYtZspgli1mymCWLWbKYJYtZspgli1mymCWLWbKYJYtZspgli1mymCWLWbKYJYtZspgli1mymCWLWbKYJYtZspgli1mymCWLWbKYJYtZspgli1my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GcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySzB3OvGT+gu4iZ+bnsVOjGISTyNmHu9OIiTuIibaEQn1rFFYRLPQ2QJcBAncRE30YhOpNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26ab0c3oZnQzuhndjG5GN6Ob0c3oVllis3AQJ/Fzs7rkKksuGrGuyV0YxCSeh5UlFwdxEhdxE41It6Bb0C3olnRLuiXdkm5Jt6Rb0i3plnRLuh26Hboduh26Hboduh26Hbodup3nhrnXi4M4iYu4iUZ0YhCTSLdBt0G3QbdBt0G3QbdBt0G3QbdBt0m3SbdJt0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RbdNt023TbdNt023TbdNt023TbdNN6Ob0c3oZnQzuhndjG7IklGYxPMQ9yXAQZzERdxEIzqRbk43p1vQLegWdAu6Bd2CbkG3oFvQLeiWdEu6Jd2Sbkm3pFvSLemWdEu6Hboduh26Hboduh26Hboduh26neeGudeLgziJi7iJRnRiEJNIt0G3QbdBt0G3QbdBt0G3QbdBt0G3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbfKEsvC87Cy5OLn5vXvVpZcXMTPzVehEZ0YxCSeh5UlFwdxEheRbk43p5vTzenmdAu6Bd2CbkG3oFvQLegWdAu6Bd2Sbkm3pFvSLemWdEu6Jd2Sbkm3Q7dDt0O3Q7dDt0O3Q7dDt0O389ww93pxECdxETfRiE4MYhLpNug26Dbo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",
      "is_unconstrained": true,
      "name": "process_message"
    },
    {
      "abi": {
        "error_types": {
          "12037992570023391496": {
            "error_kind": "string",
            "string": "NotAnOwner"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14415304921900233953": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "14427754132438837229": {
            "error_kind": "string",
            "string": "Function commit_public_user can only be called internally"
          },
          "14924807131364042204": {
            "error_kind": "string",
            "string": "HashlockNotMatch"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15367606449725535591": {
            "error_kind": "string",
            "string": "Function add_lock_public_user can only be called internally"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16075137377171297093": {
            "error_kind": "string",
            "string": "HashlockAlreadySet"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16810041750452690220": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 27
          },
          "17487453435310197877": {
            "error_kind": "string",
            "string": "Function refund_public can only be called internally"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "2175217314894115242": {
            "error_kind": "string",
            "string": "Function redeem_public can only be called internally"
          },
          "2360858009427093503": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "2369193878689457446": {
            "error_kind": "string",
            "string": "HTLCNotExists"
          },
          "2907544755768338616": {
            "error_kind": "string",
            "string": "Function get_htlc_public can only be called statically"
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4493654309393309420": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "4736483829072576196": {
            "error_kind": "string",
            "string": "HTLCAlreadyExists"
          },
          "5029608433027800177": {
            "error_kind": "string",
            "string": "NotPassedTimelock"
          },
          "7920565393106506482": {
            "error_kind": "string",
            "string": "Function lock_public_solver can only be called internally"
          },
          "9967937311635654895": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          }
        },
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "public_dispatch"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14576755381182599325": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 24
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15711892660910782274": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16216212843441549037": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "2014890719615096298": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 40 limbs"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "4648451262681811962": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "7555607922535724711": {
            "error_kind": "string",
            "string": "Preimage mismatch"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9589626482238399944": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret_high",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "secret_low",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "ownership_key_high",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "ownership_key_low",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "H4sIAAAAAAAA/+xdB5wUxdLv4TIcHEEUAfUQkGwgiaIIggQlSTZLEgmCCKgY78Cc8zM8c8769DPnnHN45vzMOeevW6fv6upqZ6d6emsXb+f3q5u96e76V1fqnp4UqL+3ZuF+r9mzZs/eY5c995q79/Sls88pU2p02d8lgaaCcN9IUyU6ZvfwdwuiXitNg9Gx1TVVoWNrEMfaE/zWIo6tTRxbhzhWSWB0II6tSxzrSBzrRGCsR9TrQhzrShzrFh4rVDG2INxXhvsNZ43d652Nzut2y/itbqqunrZT1z4fjVx+654nDn3n+5O/0uXHFdTWTbP1TIJzfHqcYsi7XNV2OAjlNPvOqlahQcjX1jtB/z5R00maTi6oy7wAyZtmC7ow6p5QEF8Pp8TXd52NK39XRt0TGfKfKiR/N0bdkxjyn8aQn/LDU0I/PDXcnxbuTwZ++C/9+3RNZ2g6E/lho3BfqeKJ0ErF79tZcfsWbFsFE4xpN1glk7OTii/nv+PbIIByUu24cv6b4StnO8pp2xWq2sGwXgOm3EH8urWbEaCpqlVSEgHWUw4CgK0yVq2gjqznhMFzLp5emIJ90TFTqRSx42Yd2Mko7/jyzz+DcxiedC4j66zqRjsvVPr52GjnEUY7X9ho5zGMdn6WjHZegbzRLgiVfiE22gWE0S70YLS4hjBGu4BhtAsbkNEuCpV+MTbaRYTRLhY22kUMo12cJaNdlAWjXRIq/VJstEsIo13qwWgXMYx2CcNolzYgo10WKv1ybLTLCKNdLmy0yxhGuzxLRrssC0a7IlT6ldhoVxBGu9KD0S5jGO0KhtGubEBGuypU+tXYaFcRRrta2GhXMYx2dZaMdlUWjHZNqPRrsdGuIYx2rQejXcUw2jUMo13bgIx2Xaj067HRriOMdr2w0a5jGO36LBntuiwY7T+h0m/ARvsPYbQbPBjtOobR/sMw2g0NyGg3hkr/P2y0Gwmj/Z+w0W5kGO3/smS0G7NgtJtCpd+MjXYTYbSbPRjtRobRbmIY7eYGZLRbQqXfio12C2G0W4WNdgvDaLdmyWi3ZMFot4VKvx0b7TbCaLd7MNotDKPdxjDa7Q3IaHeESr8TG+0Owmh3ChvtDobR7syS0e7IgtHuCpV+NzbaXYTR7vZgtDsYRruLYbS7G5DR7gmVfi822j2E0e4VNto9DKPdmyWj3ZMFo90XKv1+bLT7CKPd78Fo9zCMdh/DaPc3IKM9ECr9QWy0BwijPShstAcYRnswS0Z7IAtGeyhU+sPYaA8RRnvYg9EeYBjtIYbRHm5ARnskVPqj2GiPEEZ7VNhojzCM9miWjPZIFoz2WKj0x7HRHiOM9rgHoz3CMNpjDKM93oCM9kSo9Cex0Z4gjPaksNGeYBjtySwZ7YksGO2pUOlPY6M9RRjtaQ9Ge4JhtKcYRnu6ARntmVDpz2KjPUMY7Vlhoz3DMNqzWTLaM1kw2nOh0p/HRnuOMNrzHoz2DMNozzGM9nwDMtoLodJfxEZ7gTDai8JGe4FhtBezZLQXsmC0l0Klv4yN9hJhtJc9GO0FhtFeYhjt5QZktP+GSn8FG+2/hNFeETbafxlGeyVLRvtvFoz2aqj017DRXiWM9poHo/2XYbRXGUZ7LUtGYzz7SW6VsWrVNdrrodLfwEZ7nTDaGx6MBjuZzmivM4z2RgMy2puh0t/CRnuTMNpbwkZ7k2G0t7JktDezkB7fDpX+Djba24TR3vFgtDcZ6fFthtHeaUBGezdU+nvYaO8SRntP2GjvMoz2XpaM9m4WjPZ+qPQPsNHeJ4z2gQejvcsw2vsMo33QgIz2v1DpH2Kj/Y8w2ofCRvsfw2gfZslo/8uC0T4Klf4xNtpHhNE+9mC0/zGM9hHDaB83IKN9Eir9U2y0TwijfSpstE8YRvs0S0b7JAtG+yxU+ufYaJ8RRvvcg9E+YRjtM4bRPm9ARvsiVPqX2GhfEEb7UthoXzCM9mWWjPZFFoz2Vaj0r7HRviKM9rUHo33BMNpXDKN93YCM9k2o9G+x0b4hjPatsNG+YRjt2ywZ7ZssGO27UOnfY6N9Rxjtew9G+4ZhtO8YRvu+ARnth1DpP2Kj/UAY7Udho/3AMNqPWTLaD1kw2k+h0n/GRvuJMNrPHoz2A8NoPzGM9nMDMtovodJ/xUb7hTDar8JG+4VhtF+zZLRfsmC030Kl/46N9hthtN89GO0XhtF+Yxjt9wZktD9Cpf+JjfYHYbQ/hY32B8Nof2bJaH9kwWj2tbeBfd2pNZApwEYzlZIa7Q+G0YwMcep+FcoWU4ZV3miNQqMVYKM1IoxWIGy0RgyjFWTJaI0K5Y1WGBqtCButkDBakQejxTWEMVohw2hFDchoxaHRSrDRigmjlQgbrZhhtJIsGa04C0YrDY1Who1WShitzIPRihlGK2UYrawBGa1xaLQm2GiNCaM1ETZaY4bRmmTJaI2zYLTy0GhNsdHKCaM19WC0xgyjlTOM1rQBGa1ZaLQKbLRmhNEqhI3WjGG0iiwZrVkWjNY8NFoLbLTmhNFaeDBaM4bRmjOM1qIBGa1laLRW2GgtCaO1EjZaS4bRWmXJaC2zYLTVQqO1xkZbjTBaaw9Ga8kw2moMo7VuQEZbPTTaGthoqxNGW0PYaKszjLZGloy2ehaM1iY02prYaG0Io63pwWirM4zWhmG0NbNktK5K3mhtQ6O1w0ZrSxitnQejwU6mM1pbhtHaNSCjtQ+NthY2WnvCaGsJG609w2hrZclo7bOQHtcOjbYONtrahNHW8WC09oz0uDbDaOs0IKNVhkbrgI1WSRitg7DRKhlG65Alo1VmwWjrhkbriI22LmG0jh6MVskw2roMo3VsQEbrFBqtMzZaJ8JonYWN1olhtM5ZMlqnLBhtvdBoXbDR1iOM1sWD0ToxjLYew2hdGpDRuoZG64aN1pUwWjdho3VlGK1btqb8WTBa99BoPbDRuhNG6+Fjys8wWneG0Xo0IKP1DI3WCxutJ2G0XsJG68kwWq8sGa1nFoy2fmi0DbDR1ieMtoEHo/VkGG19htE2aEBG2zA02kbYaBsSRttI2GgbMoy2UZaMtmEWjNY7NFofbLTehNH6eDDahgyj9WYYrU8DMlrf0Gj9sNH6EkbrJ2y0vgyj9cuS0fpmwWj9Q6NtjI3WnzDaxh6M1pdhtP4Mo23cgIw2IDTaJthoAwijbSJstAEMo22SJaMNyILRNg2NNhAbbVPCaAM9GG0Aw2ibMow2sAEZbbPQaJtjo21GGG1zYaNtxjDa5lky2mZZMNqg0GhbYKMNIoy2hQejbcYw2iCG0bZoQEYbHBptCDbaYMJoQ4SNNphhtCFZMtrgLBhty9BoQ7HRtiSMNtSD0QYzjLYlw2hDG5DRhoVG2wobbRhhtK2EjTaMYbStsmS0YVkw2vDQaCOw0YYTRhvhwWjDGEYbzjDaiAZktJGh0UZho40kjDZK2GgjGUYblSWjjcyC0bYOjbYNNtrWhNG28WC0kQyjbc0w2jYNyGijQ6ONwUYbTRhtjLDRRjOMNiZLRhudBaONDY02DhttLGG0cR6MNpphtLEMo41rQEYbHxptW2y08YTRthU22niG0bbNktHGZ8FoE0KjTcRGm0AYbaIHo41nGG0Cw2gTG5DRJoVGm4yNNokw2mRho01iGG1ylow2KQtGmxIabSo22hTCaFM9GG0Sw2hTGEabmiWjdVPyRpsWGm07bLRphNG282A02Ml0RpvGMNp2Dcho24dG2wEbbXvCaDsIG217htF2yJLRts9CetwxNNpO2Gg7EkbbyYPRtmekxx0ZRtupARlt59Bou2Cj7UwYbRdho+3MMNouWTLazlkw2q6h0aZjo+1KGG26B6PtzDDargyjTW9ARpsRGm0mNtoMwmgzhY02g2G0mVky2owsGG1WaLTZ2GizCKPN9mC0GQyjzWIYbXYDMtpuodHmYKPtRhhtjrDRdmMYbU6WjLZbFoy2e2i0udhouxNGm+vBaLsxjLY7w2hzG5DR5oVGm4+NNo8w2nxho81jGG1+low2LwtGWxAabQ9stAWE0fbwYLR5DKMtYBhtjwZktIWh0RZhoy0kjLZI2GgLGUZblCWjLcyC0fYMjbYYG21PwmiLPRhtIcNoezKMtrgBGW2v0GhLsNH2Ioy2RNhoezGMtiRLRtsrC0ZbGhptGTbaUsJoyzwYbS+G0ZYyjLasARlt79Bo+2Cj7U0YbR9ho+3NMNo+WTLa3lkw2r6h0ZZjo+1LGG25B6PtzTDavgyjLW9ARtsvNNr+2Gj7EUbbX9ho+zGMtn+WjLZfFox2QGi0A7HRDiCMdqAHo+3HMNoBDKMd2ICMdlBotIOx0Q4ijHawsNEOYhjt4CwZ7aAsGK0qNFo1NloVYbRqD0Y7iGG0KobRqhuQ0VaERluJjbaCMNpKYaOtYBhtZZaMtiILRjskNNqh2GiHEEY71IPRVjCMdgjDaIc2IKMdFhrtcGy0wwijHS5stMMYRjs8S0Y7LAtGOyI02pHYaEcQRjvSg9EOYxjtCIbRjmxARjsqNNrR2GhHEUY7WthoRzGMdnSWjHZUFox2TGi0Y7HRjiGMdqwHox3FMNoxDKMd24CMdlxotOOx0Y4jjHa8sNGOYxjt+CwZ7bgsGO2E0GgnYqOdQBjtRA9GO45htBMYRjuxARntpNBoJ2OjnUQY7WRho53EMNrJWTLaSVkw2imh0U7FRjuFMNqpHox2EsNopzCMdqqj8rCR0uGcFh+nRxKcf8XEubd46bNJcE5PjzMU8i5Xfzu9/d/oIwjlNfvO4XHD19Y7Q/84U9NZmv5dWJc5139eK4hf9wyG/5zt6D9c+V9myH8mQ/5zhOR/niH/WQz5z2XIT/nh2aH/nRPuzw33/wZ+eJ7+cb6mCzRdmNAPn2bo4TyGHi4SsuPjDPnPZ8h/sZD8DzPkv4Ah/yUJ/fCi0O8uDveXhPsLgR9eqn9cpulyTVck9MP7GXq4lKGHK4XseDdD/ssY8l8lJP/tDPkvZ8h/dUI/vDL0u6vC/dXh/grgh9foH9dquk7T9Qn98GaGHq5h6OE/Qna8gSH/tQz5bxCS/1qG/Ncx5L8xoR/+J/S7G8L9jeH+euCH/6d/3KTpZk23JPTDKxl6+D+GHm4VsuOlDPlvYsh/m5D8FzLkv5kh/+0J/fDW0O9uC/e3h/tbgB/eoX/cqekuTXcn9MNzGXq4g6GHe4TsyPhKcnAnQ/57heRnfE89uIsh/30J/fCe0O/uDff3hfu7gR/er388oOlBTQ8l9MMWDD3cz9DDw0J2bMqQ/wGG/I8IyV/GkP9BhvyPJvTDh0O/eyTcPxruHwJ++Jj+8bimJzQ9mdAPixh6eIyhh6eE7Bgw5H+cIf/TQvL/zhiPnmDI/0xCP3wq9Lunw/0z4f5J4IfP6h/PaXpe0wsJ/fBnhh6eZejhRSE7fs+Q/zmG/C8Jyf81Q/7nGfK/nNAPXwz97qVw/3K4fwH44X/1j1c0varptYR++DlDD/9l6OF1ITt+zJD/FYb8bwjJ/wFD/lcZ8r+Z0A9fD/3ujXD/Zrh/DfjhW/rH25re0fRuQj98h6GHtxh6eE/Ijm8w5H+bIf/7QvIzXtEYvMOQ/4OEfvhe6Hfvh/sPwv27wA//p398qOkjTR8n9EPGS2GD/zH08ImQHRmvjw4+ZMj/qZD8jBfNBx8x5P8soR9+Evrdp+H+s3D/MfDDz/WPLzR9qemrhH7I+LRF8DlDD18L2ZHxEZzgC4b83wjJz/hcVvAlQ/5vE/rh16HffRPuvw33XwE//E7/+F7TD5p+TOiHjA/0Bd8x9PCTkB0Zn/IMvmfI/7OQ/IyP/gY/MOT/JaEf/hT63c/h/pdw/yPww1/1j980/a7pj4R+yPjMePArQw9/CtmxB0P+3xjyqyIZ+bsw5P+dIX9QlMwP/wz9zughCPmZ/R/ADxvpYwWaCjUVFdXlydVDR4YeGhXF10OxkB3XYchfwJC/REj+dgz5Cxnylyb0w+LQ70rCfWm4N/5m65Xp3401NdFUntAPGfeZBmUMPTQVsiPjjvSgMUP+ZkLyM55dCZow5K9I6IdNQ79rFu4rwn058MPm+ncLTS01tUroh4yn5YLmDD2sJmRHxnO1QQuG/K2F5Gc8gR+0ZMi/ekI/XC30u9bhfvVw3wr44Rr6dxtNa2pqm9APGe/8CNZg6KGdkB0ZbwcK2jDkby8kP+M9YsGaDPnXSuiH7UK/ax/u1wr3bYEfrq1/r2NwNHVI6IeMNxcGazP0sK6QHRnvOA3WYcjfUUh+xtuQg0qG/J0S+uG6od91DPedwn0H4Ied9e/1NHXR1DWhHzLevx50Zuihm5AdGV9qCNZjyN9dSH7GN12CLgz5eyT0w26h33UP9z3CfVfghz31716a1te0QUI/ZHxFKujJ0MOGCfWwYdjvXuF+/XC/AdDDRvp3b019NPUNj5uHFgsisCpVrG1Lg7VlAh7webuA0c5U76z4McDFYDwf54zxsgDG8wIYTwtgPC6A8bAAxv0CGHcLYNwugHGzAMYNAhjXCmBcKYBxqQDGhQIY5wpgMO77d8ZoLYDRQgCjqQBGmQBGkQBGIIDxu0B8/CyA8b0AxtcCGJ8LYHwsgPGBAMY7AhhvCGBMFYjziQIY4wQwthHAGCGAMVQAYwsBjIECGBsLYPQRwNhAAKOHAEYXAYyOAhjrCGC0E8A4VQDjRAGMYwUwjhTAOFQAo1oA40ABjOUCGMsEMBYLYOwhgDFXAGO2AMZ0AYydBDC2c8BwwdnI8VpjzdaICXg2OLFKdwGtX3zhAtNx+/JN264wPFZINWDKHajcNggX5+wCGZwCldDBMGA6p+kfX4GNkuBs7MlQ6XAGpMdpBHnjq8j9w6vGncP/Nw7/HwCuIm+if2+qaaCmzcLjzVStrFHyp9mCTZhXwe22eVECwM3BLQGV4T6dogtVbcZIJViliieDVLbYRChbtIhfV7UHvweFdtgi3A8O90PC/Zbhfmi4Hxbutwr3w8P9iHA/MtyPCvdbh/ttwv3ocD8m3I8N9+PC/fhwv224nxDuJ4b7SeF+crifEu6nhvtp4X47s4dDjulgFTo2hDi2JXFsKHFsGHFsK+LYcOKYUdZgdMworhQd25poO5o4NoY4NpY4No44Np44ti1xbAIh80RC5klEvclhRoPHphD1phL1phH1tguPwa0k3FeqWFswKTIw6+bVyVF161b9q18p66IWU9PWrWU+rShW3/5qsB3jHqjti2LrrD6Qio+zQ3qcNSBvPEpuH/rGoKLaeA5Cvrbejvr3Tpp21rRLwnvOBjOmtjsy9L2ro7658g9hyL8TQ/7pQvJvyZB/Z4b8MxLe87dr6HfTw/2McL8L8MOZ+vcsTbM17ZbQD4cy9DCToYc5QnYcxpB/FkP+3YXk34oh/2yG/HMT+uGc0O92D/dzw/1uwA/n6d/zNS3QtEdCPxzO0MM8hh4WCtlxBEP++Qz5FwnJP5Ih/wKG/Hsm9MOFod8tCvd7hvs9gB8u1r/30rRE09KEfjiKoYfFDD0sE7Lj1gz592LIv7eQ/Nsw5F/CkH+fhH64LPS7vcP9PuF+KfDDffXv5Zr207R/Qj8czdDDvgw9HCBkxzEM+Zcz5D9QSP6xDPn3Y8h/UEI/PCD0uwPD/UHhfn/ghweb82tN1ZpWJPTDcQw9HMzQw0ohO45nyF/FkP8QIfm3ZchfzZD/0IR+uDL0u0PC/aHhfgXww8P078M1HaHpyIR+OIGhh8MYejhKyI4TGfIfzpD/6IR2PCq029Hh/ohwfySw4zH697GajtN0fFF9nmarjCnvCfHlXQP+w73MuAlDhyc6ysTt+0npcQogb2yrE4pq1y+DUO4g5Gvrnax/n6LpVE2nhceNyXx8dJFzESAJzskMny4Gv/8V+ubp4f6McH9muD8r1FfXsP6/9f9nazpH07maztN0vqYLNF2o6SJNF2u6RNOlmi7TdLmmKzRdqekqTVdrukbTtZqu03S9pv9oukHTjZr+T9NNmm7WdIumWzXdpul2TXdoulPTXZru1nSPpns13afpfiOzz8twpzMThd0eKEoA+EARv92DjMh1letBkMUq47XzaowzHI3xkKsxDOBDDsZ4OMPGMHI9nGVjnOlojEdcjWEAH3EwxqMZNoaR61EHY7hgPRganjuGPlaUHSc5y9FJHnd1EgP4uIOTPJFhJzFyPSHkJMYZH3NwkieLeHKlki/tB1XS4xRC3nhCd3rYtzPCvZ2gPAUmdE/r389oelbTc0V1mXNPQhiZLnia4UfPM4MD6+H5sN/PhPtnw/1zQA8v6N8vanpJ08tFtW3NVhlTTuO3Tzr4038ZejPyVig/dxH9y9GPFQ+na4K2jWyf4MT6FS33q5pe0/S6pjc0vanpLU1va3pH07ua3tP0vqYPNP1P04eaPtL0saZPNH2q6TNNn2v6QtOXmr7S9LWmbzR9q+k7Td9r+kHTj5p+0vSzpl80/arpN02/a/pD05/Gb4pDYe3dHq8U1Z5R2WOvEsdeI469Thx7gzj2JnHsLeLY28Sxd4hj7xLH3iOOvU8c+4A49j/i2IfEsY+IYx8Txz4hjn1KHPuMOPY5cewL4tiXxLGviGNfE8e+IY59Sxz7jjj2PXHsB+LYj8Sxn4hjPxPHfiGO/Uoc+4049jtx7A/i2J/EMRMcNqDt1i3cV6pYW52klS6xvhKz7pd//vnnq/Hr/v5a/Lo/vx6/7tdvxK/7zpvx6977Vvy61W/Hrxu8E7vuH8G7sev+FrwXu+5Pwfux634VfBC77tvB/2LXvSf4MHbdquCj2HVV8HHcun+o4JO4dX9Twadx6/6kgs/i1v1KBZ/Hrfu2Cr6IW/ceFXwZt26VCr6KW1fnkq9j1v1C1/0mZt3PdN1vY9b9SNf9Lmbdt3Xd72PWfUbX/SFm3et03R9j1t1T1/0pXt2TdP4Nfo5X90RT95d4dY83dX+NV/doU/e3eHVXmrq/x6u7xNT9I17diabun/HqtjJ1zRhp63I2fAXD19j41xcK4ssU1PxR8duYk6//FtVvl06uRkxdca/ymBX8VxgnZ0ZPjYr5/SgQ6AfHhqbPLv0oZPTD8MYn6gUhZmG4p54lKtJlxZpKNJUW17aFcqaDPruo9hyM07/9S3l24vI3MhU56P0Aplx2K0Q46bpTVBxfpjKGvzH0Gkj19WxGfmxc7OZDPu1KxVNZ6EuNI+KpiS4r19RUUzPHeDJXOF9ziKcDMxxPRqYmDvF0kJCPNWH4TQUjnhh6DaT6eg4jnpoXu/mQT7tS8VQR+lLziHhqoctaamqlaTXHeDJ3C7zuEE8HZziejEwtHOKpSsjHWjD8pjUjnhh6DaT6ei4jnlYvdvMhn3al4ql16EurR8TTGrqsjaY1NbV1jCdz580bDvFUneF4MjKt4RBPK4R8bA2G37RjxBNDr4FUX89jxFP7Yjcf8mlXKp7ahb7UPiKe1tJla2tax/TBMZ7MXWxvOsTTygzHk5FpLYd4OkTIx9Zi+E0HRjwx9BpI9fV8RjytW+zmQz7tSsVTh9CX1o2Ip466rJOmzprWc4wnc0foWw7xdGiG48nI1NEhng4T8rGODL/pwognhl4Dqb5ewIinrsVuPuTTrlQ8dQl9qWtEPHXTZd019dDU0zGezN3VbzvE0+EZjicjUzeHeDpCyMe6MfymFyOeGHoNpPp6ISOe1i928yGfdqXiqVfoS+tHxNMGumxDTRtp6u0YT+ZJhXcc4unIDMeTkWkDh3g6SsjHNmD4TR9GPDH0Gkj19SJGPPUtdvMhn3al4qlP6Et9I+Kpny7rr2ljTQMc48k89fOuQzwdneF4MjL1c4inY4R8rB/DbzZhxBNDr4FUXy9mxNOmxW4+5NOuVDxtEvrSphHxNFCXbaZpc02DHOPJPEH3nkM8HZvheDIyDXSIp+OEfGwgw2+2YMQTQ6+BVF8vYcTT4GI3H/JpVyqetgh9aXBEPA3RZVtqGqppmGM8madR33eIp+MzHE9GpiEO8XSCkI8NYfjNVox4Yug1kOrrpYx4Gl7s5kM+7UrF01ahLw2PiKcRumykplGatnaMJ/Nk9wcO8XRihuPJyDTCIZ5OEvKxEQy/2YYRTwy9BlJ9vYwRT6OL3XzIp12peNom9KXREfE0RpeN1TRO03jHeDJvSfifQzydnOF4MjKNcYinU4R8bAzDb7ZlxBNDr4FUXy9nxNOEYjcf8mlXKp62DX1pQkQ8TdRlkzRN1jTFMZ7MG0c+dIinUzMcT0amiQ7xdJqQj01k+M1URjwx9BpI9fUKRjxNK3bzIZ92peJpauhL0yLiaTtdtr2mHTTt6BhP5u09HznE078yHE9Gpu0c4ul0IR/bjuE3OzHiiaHXQKqvVzLiaediNx/yaVcqnnYKfWnniHjaRZftqmm6phmO8WTehPWxQzydkeF4MjLt4hBPZwr52C4Mv5nJiCeGXgOpvl7FiKdZxW4+5NOuVDzNDH1pVkQ8zdZlu2mao2l3x3gyb5X7xCGezspwPBmZZjvE07+FfGw2w2/mMuKJoddAqq9XM+JpXrGbD/m0KxVPc0NfmhcRT/N12QJNe2ha6BhP5g2NnzrE09kZjicj03yHeDpHyMfmM/xmESOeGHoNpPp6DSOe9ix28yGfdqXiaVHoS3tGxNNiXbaXpiWaljrGk3nb6WcO8XRuhuPJyLTYIZ7OE/KxxQy/WcaIJ4ZeA6m+XsuIp72L3XzIp12peFoW+tLeEfG0jy7bV9NyTfs5xpN5c/DnDvF0fobjyci0j0M8XSDkY/sw/GZ/Rjwx9BpI9fU6RjwdUOzmQz7tSsXT/qEvHRARTwfqsoM0HaypyjGezFu4v3CIpwszHE9GpgMd4ukiIR87kOE31Yx4Yug1kOrr9Yx4WlHs5kM+7UrFU3XoSysi4mmlLjtE06GaDnOMJ/NG+y8d4uniDMeTkWmlQzxdIuRjKxl+czgjnhh6DaT6+h9GPB1R7OZDPu1KxdPhoS8dERFPR+qyozQdrekYx3gyX4f4yiGeLs1wPBmZjnSIp8uEfOxIzn2fjHhi6DWQ6usNjHg6rtjNh3zalYqnY0NfOi4ino7XZSdoOlHTSY7xZL608rVDPF2e4XgyMh3vEE9XCPnY8Zz7ahjxxNBrINXXGxnxdEqxmw/5tCsVTyeHvnRKRDydqstO0/QvTac7xpP5atE3DvF0ZYbjych0qkM8XSXkY6dyrlsy4omh10Cqr//HiKczi918yKddqXg6I/SlMyPi6Sxd9m9NZ2s6xzGezBfAvnWIp6szHE9GprMc4ukaIR87i7MuzIgnhl4Dqb7exIin84rdfMinXal4Ojf0pfMi4ul8XXaBpgs1XeQYT+Zret85xNO1GY4nI9P5DvF0nZCPnc8572bEE0OvgVRfb2bE0yXFbj7k065UPF0c+tIlEfF0qS67TNPlmq5wjCfzZcrvHeLp+gzHk5HpUod4+o/UM3aceQ0jnhh6DaT6egsjnq4qdvMhn3al4unK0Jeuioinq3XZNZqu1XSdYzyZr7z+4BBPN2Q4noxMVzvE041S97Rx/IYRTwy9BlJ9vZURT/8pdvMhn3al4un60Jf+ExFPN+iyGzX9n6abHOPJfDH5R4d4+r8Mx5OR6QaHeLpJag2Z4Tc3M+KJoddAqq+3MeLplmI3H/JpVyqebg596ZaIeLpVl92m6XZNdzjGk/n6+E8O8XRzhuPJyHSrQzzdIpWzGX5zJyOeGHoNpPp6OyOe7ip28yGfdqXi6c7Ql+6KiKe7ddk9mu7VdJ9jPN1RVPsdR9guXf9uzXA8GZnudoin24R87G6G39zPiCeGXgOpvt7BiKcHit18yKddqXi6P/SlByLi6UFd9pCmhzU94hhPdxbVfgMVtkvXv9szHE9Gpgcd4ukOIR97kOE3jzLiiaHXQKqvdzLi6bFiNx/yaVcqnh4NfemxiHh6XJc9oelJTU85xtNdRbXfD4bt0s5hMhxPRqbHHeLpLiEfe5zhN08z4omh10Cqr3cx4umZYjcf8mlXKp6eDn3pmYh4elaXPafpeU0vOMbT3UW1396G7dL17+4Mx5OR6VmHeLpHyMeeZfjNi4x4Yug1kOrr3Yx4eqnYzYd82pWKpxdDX3opIp5e1mX/1fSKplcd4+meotrv1sN26fp3b4bjycj0skM83SfkYy8z/OY1Rjwx9BpI9fUeRjy9XuzmQz7tSsXTa6EvvR4RT2/osjc1vaXpbcd4ulfz+8Mhnu7PcDwZmd5wiKcHhHzsDYbfvMOIJ4ZeA6m+3suIp3eL3XzIp12peHon9KV3I+LpPV32vqYPNP3PMZ7u0/z+dIinBzMcT0am9xzi6SEhH3uP4TcfMuKJoddAqq/3MeLpo2I3H/JpVyqePgx96aOIePpYl32i6VNNnznG0/2an3Lw24czHE9Gpo8d5HpEyMc+ZvjN54x4Yug1kOrr/Yx4+qLYzYd82pWKp89DX/oiIp6+1GVfafpa0zfFdXk2Ujydlav4ffuy2M2OBUyZTmbY8XRG3W8Z8htdN1O1cV1HQGZ/OLgQ77viBIDfFfPbfc8ICle5vgcOWxmv3V/GMM0aUUyZMkDn4mxcnNOL3Iz+A7Abe1T5npHBDe+CEMOCGkWXKD9ez1EANOyPoYP8VBwKCUHjKOAHB8//gZnaXOXipucfGBH5c8I+pKtuDPOzw1TnF2b6s05p2lWB4xAzHZufHGX91VHWXyNkjWO3Xxxkfczv1HZHxD8wcv3qINfjCeVKV90klp8dYomhr4DTB5M0dXVydLJbZYrjWOd1hEjTFm0BN87s9lvUiJOOz8+OAQNB02DWG4wM5m8OjvlEhs5DohJx2usFxZlx4CdK3ezyO0hkdkvXf9xHTv//AHVbbaReXuetfst7rN5/0bi9D3lr0tUHrXZhtw8r2nyxbLO9f359EQzKtfqMOeveCfOuO3bTihG9Gz9/4POHzevz0vFHruj+bdXU5cUdT3Lt/x9h/33OhE52nAn9aafKJUIB6sr/T4dgDErcDGTaVYHjEDOOrFCZlTFlbeQoa6OSZLOCwEHWpwRmBY0c5Ho6w7OCkx1nBQx9BU+vgrMCbpzZrUAq6cCAgaAus4ICB8d8JgdnBYUlmXHgZxxHxcIS2VlBUUn8WcHTjFmBa/+LSmpnBamCmhsjvxS7+Z1UAijORgIoTpgAih0SwLOOCaCIicMJgJKS+HU5pwWcZPGsY7CUxEgW6fpUWhI/qOFpgc9k4dr/0pLcOYUoK/l737iEWExNB5pq0ZKzCp32+XLG+W/NH8XvQ4FQH9LVbVKS2f4agzdxSILljqc45QlOxxo7ytrUUdamCU7HjJzlDrK+kOHTMSNXUwe5XhQ4HTOycU/HGPoKXlwFT8e4cWa3ZklmY00cA6ZZgtmYwWzm4JgvCZ2ONWHMsCpKMuPALznOMCo8nI5x+t+ccTr2ImOG5dr/5hmYYblerm4RzrBaSgWoK/8WDsHYyjFxtEowKzCytnSQdTVHWVdLOCto5SDrfwVmBas5yPWKwKVbl1kBQ1/BK6vgrIAbZ3ZrnY1ZQeuEs4LWDo75ag7OClYvyYwDv+o4Kq4uPCtYgzEreIUxK3Dt/xoZWKQtL3HzO6kE0CYbCaBNwgTQxiEBvCa0SMsJgDUZdTmnBZxk8ZpjsKzpYZG2LWOR9kXGIi0nWbj2vy3Rf+4aIWNRNjiTcZ96O0Zc+rxPvZ1jEmpfkgCwfQm/3VqMwHOVa62S2gOV8dp5vU/9TKH71E92vE997aiRJ51R1mJMnWDUWtBcuLSyTuggldSllTgKWNvB89dOuFAQVy7uCdrajIjskLAP6aobw3RwmGKs6zgdWjfBYkelo6wdHWXtmGCxw8i5roOsb2Z4scPI1dFBrrcELoF0cIglhr6Ct1bBxQ5unNmtU5JznQ6OAdMpwbmOwezk4JhvCy12dGAk7c4lmXHgtx3n7509LHZw+r8eY7HjLcb5i2v/18vAJZAzHWdCXcKZUFepAHXl38UhGLs5Jo5uCWYFRtauDrJ2d5S1e8JZQTcHWd8VmBV0d5DrvQzPCs50nBUw9BW8twrOCrhxZrce2ZgV9Eg4K+jh4Jjv5+CsoGdJZhz4fcdRsafwrKAXY1bwHmNW4Nr/Xhm4BLJuiZvfSSWA9bORANZPmADWd0gAHwhdAuEEwAaMupzTAk6y+MAxWDbwcAlkQ8YlkLcYl0A4ycK1/xvm0CnERuEpRG9qMTUdaKpFS84qdLq6jIXXoOaP4veBew3KtQ/p6vbJcH+Nwfs4JMG+jgm7b4LTsd6OsvZzlLVfgtMxI2dfB1k/yvDpmJGrn4NcHwucjvVxOB1j6Cv4eBU8HePGmd36J5mN9XEMmP4JZmMGs7+DY34idDrWh5G0Ny7JjAN/4jjD2NjD6Rin/wMYp2MfM2ZYrv0fkIEZluvl6k3CGdamUgHqyn8Th2Ac6Jg4BiaYFRhZN3WQdTNHWTdLOCsY6CDrZwKzgs0c5Ppc4NKty6yAoa/g81VwVsCNM7ttno1ZweYJZwWbOzjmFzk4KxhUkhkH/sJxVBwkPCvYgjEr+JwxK3Dt/xYZWKTtW+Lmd1IJYHA2EsDghAlgsEMC+FJokZYTAEMYdTmnBZxk8aVjsAzxsEi7JWOR9mPGIi0nWbj2f8sEM9RHtVM94fANkqEJZ/lxfHcosdaZDoazJjmU4fPDMtxf80zJMIdcshVzDZa7/m1muRyM08P6CuHEFjB+m+CMEIurs+EMW/p8dmK448A4oiQB4IgSfruRjMBwlWtkjjvJKMfZEjfAOLreOsPBfkwRD8PoaGtPdkwn2+Siv3XFPd3m6HebLCWGKY7P14x2TQwGcLRDYhiT4cRg5BojlBiMQ23jkBjGlmRWLtP/sQ6Ovg3DNuMyPJuZKhCs47MUrNMcg3Vb12A1gNs6BOuEDAerkWuCULAahxrvEKwTMxyspv8THRx9PMM2kzLch0FFcrOxLQSxBgtiDRHE2lIQa6gg1jBBrK0EsYYLYo0QxBopiDVKEGtrQaxtBLFGC2KNEcQaK4g1ThBrvCDWtoJYEwSxJgpiTZLMGyV/n8SxV1EyPJc0/Z/sINfIDMtl5tuTHOSaIqCvKTmor+0cfdmcaDdV9PVq7jlSKxVfH9ulPykPogorVby2sF9TQ/1MK1F1r8dNDQ0Kj5lKgxHXdDc0YCFcFZKi7gn2bp+pjJPRaSU8Rbuc6E91CIjtMryiZXQ/1eF6JMdmHDtsz1imh364PfBD7uWB7YrqypgO19Td3kFnMXyX1EO6ujs43iOyA9AZe8ANdcZNfpMZOthRYDXXpQ9TGX3YidkHpiw3TmX6rlncNDJx7iP58s8/x8Tt8191GfLswPDznePzvRH+w80HnHy1C/PSJXfcMH3exWHc2NUxJ+wa5gRqwsP2zZK/80TM+oGJd3OljPMcoPG3yY6+6UGH1iw3UoWVKlbbOjqeHk6+ZuDJ13Ri8jUjIoGn2f66JLmjg2P9ktnbz2+c7DhROruMJ5fduIlQwtnS1T3Hsa8xb7SsmUBPZ8g0g5EIGT4UMOwaxNBLTcDGSXBx7Mud0FAJLs12IyOJ3sgZfOMMEn/+vY2myiqjm5IJbmaY4GbhBDeTSHCziLNLrhPPZDjxLEZd6MSc5OQjuKFRuInfzCamOyTY2cyZrN24sy+OvXbL8OzL9Hk3hzOE2Yw+zMnwkpeRZY6DvXeP2QedCP/0eR/K7syZq93mliQAnFvCbzePYWRXueaV1B6oVPE3l6Qwz8FJ5mf4FN3KxQ3AXRi2WZDhU/TJzFN0OzPPldOgPZin3exZlMMSxnYlbqejlTFkMn1emFmf+GvmxYidwPjoHg7xuYjRj2xd45iUhWsce4Z5dTGehe5JzEIXC1/jmMS4xrEnw6kXl/AUzR1ETIAtdHDSgHk66zK4LXKQq5GnJYV08nF8Yy/O9RHGqXOjDNvA+OleDjZY4riOuSTBtQ0Tf3uW8K/vTCri6aMypjxLGXWhDpYK561lOeKbduOeeXJssneGzzyNLvd2iJd9HONln4h1f7txJwEcv92HOTbhrVLFawv7tW84CViOJwH7EpOA5R6CyVUh6SYB+zL4LmcomuMMnCSWTk/ZcIb9QmfYHzvDfoQz7B/DGTKlkHTOsB/DGfbP8IzQZLB9HbLYAczTL7txnZKjqwMznPFNnw90WOo4gNGHgzK81mhkOcjB3gdnaa3xYMe1xqqSBIBVJfx21Qwju8pVXVJ7oFLF31ySQrWDk6zI8FqjlYsbgHszbLMyw+tKZlBZyRxYVjjY4pCE60ouU/MlzOn5IQ5xdlaB/Mzj0DDuDsMzj0OJmcdhCc5rrRK57YrKMh94hzjIVezpNoh03YFOkW72dSjDSQ9jBCrDBkFx/NsgfNznFeDgTFff1d7ZCM7Dw+A8Agfn4URwHlHifLsC2cl0znY4w9mOKHELeA9BGHkKkY6/CajD+aNyI04gHpnhabGR5UgHhz8qS9PioxynxUe7TosN4NEOw/UxGZ4WG7mOcZwW2437VYtjsxeodTbuKGAePeesio4vqr3aBnHS9eM45tTTV1Ac5xgUx7sGhQE83iEoTshwUBi5TnAMCq5TDWc61baOTnVilpzqREenOsnVqQzgSQ5OdXKGncrIdbLQAsQJIRbXSU7J8Mn7IKazj3J09lMzO93p6arf0zI8DTP2O9VBrn8xg7Rc1V4NMP+fFmL+K9xvHL6XdkBRbb3TddkZms7UdFbJ38f1gF0ze6C2ShVPJHuaguXk8OD6jCvO6Q44gSvYKcys31jVns+ZzeVEeRvGTQImGQwGgJXKfauMUWfB7Xe1h/9LGM8Fp1+RDE5B/Lp1Fg3+HQ5kZ5cIOSdchPg3aOeC+W+HJfBTGLODcxz7dU5Ev9Jhuo5I5zKv+XH1Npg54m/jOOKfx0x0TZSf6e3ZDtNbOFqdLxlAeNg+ruDv/fkRw/YFuuxCTRdpujiMepfgOZsRQKb+BULnX1swHXRrRwe9JOHUL93qmE0AzP4XcBLbpYy6Ps8hL3U8h7zM9RzSAF7mcA55eYbPIY1clzsEBnUNhIndyGWE0Y75R9wkpX34D+p4pUq71RmZzHZFqKMr8TWNK4hrGle6TycauQ67rWWe5f4jZnSfZK61XMFw3isZGTNuX60DuIyClzvY4CrHuTz3yj5Hr1czp2NcXZk+X+2gq2v+AaPXtfH70IjbB+tPLrq9jmFzH3eaGFteW8KT71reoGNTbL2tUsVqW6d/14fY/8HJ/Hoimf8nwTmUVQy33eoZvnvEyHSdg1xrZH6Q+WvguJ7hTP9hODtDr0HMvtY4pktwX++wbnAVQzc3OA5I3OuvN5a4+bZvf3MZvCgbcAb6dHX/TzgZG5vfyJTvRn4ypp5vcErGN4XYN+NkfBORjG9OkIytYrjt2mQ4GRuZ/s9BrjWFkvFNDGe6meHsDL0Ga5bxHNMlGd+U4WR8S8IZb7rqZuZ6iYMf3So0SNxW4hZzvuPAZZC4KcODxO2ZPUvr4XomcUcGz9ImNyldy2USdOZ3P77P0e2dGY47E9e3Ouj2roRr7XeEmHeG+7vC/VNgrf1ufeweTfdquq+kLs9M+vP9TH/m5l2j89sYGKbu7Q42esAxN3JxHiyJ7/sm705Stfn3tMK/299a4o5vV7wyeRHzoQzHoTmpfcjBxg8z5DL6mUQcr1S8jdu3h0syj/EIE4PrK+eX1PWBOP7yiINPPsLAeFTO9gH+URmrmYztHxWKTa4tOf7yGHM8teeUtl22YnvjosxjPO44jnHnCBx7PZHhKxMm31zFnLfrKwcvceY5T8bvQ486wjFkMjhPMXSVLT9+SiBPPb0KjNX9BeL5mYRjdZy5PuPc769z5Lsd8vsdjFh7VqDPdzL7fI9Dn+9k9Pk5gT7fxezzvQ59vovR5+czPBe5KjwXjqmrY+2To5xx4YX0fShM0gdzfv1AhtcrX2TYwceFCzN3eIw5f3iRf+GC3CpVvLawfy+F2C/jCxcvERcuXk5w4cIqhtuuU4YvXFgDcNt1Frpw8RLDmV5mJEGGXoPO8S9c1PlRqeLJbRZgXsrwws1/mQmZ+w5I49+ME5TA+N2TzPrPOvjpKxkeiFLZLo7N49Z9NcMnWa66fc3xhJR70el1hq46lWUmh/kYHE0Mvs60++v8wZEcICtVrLZ1+vdGiP0mHhzfIAbHNxMMjlYx3HbdMjw4vuooV3ehwfENhjO9yUgiDL0G3TN8i5VJlG9keHB8K+EZWjpZzOD4NHOwe66Ef0X1CUaf3xYYGN/I8MD4jsDA+JxD/L8rNDC+x9BVt7LM5C8fA6OJv/eYdn+PPzB6u93t/RD7Azwwvk8MjB+AjkkphoHz10DyPgPjgxKewl0S/vsZTvj/y/DZkLmMz7k0YgYIxnLwX4npeYfE9KFA0n8/w0n/I4Gk76LbjzM8iTCTZMbZbGAmr6859OOTDPfD5DTG5CMwOe1dh358muF+mBzCiKfA+O3HDv34LMMxa/z9hfj5tmbJm3OZ+HNGH4z8+Da5T0K9fRruPwv3hq+t94X+/aWmrzR9HR43fDy8SabAjueuPMzk3P7m2of7iLgLxvmOE1YuzhcJ+uI0GMWs68z/nAxPVL5hBo6ddH4TMelMx8a8ZYbzAhCrB25i+5bRNxPMBQpdcLMCINx08p6Xw87ugnOOEA7nrUAYI6PB6/OlEpy6EO+7EsiBCfidQxb5jhGh3zMyTo1QiteH70v47b7PcIY2z48bDO66CudNohzd/sA8dbEb1zdOYOD8wJDf13eR7LP9cevG1Fug6BwQt22dfv0YBvRPeI3nR2KN5ydCQOZLOZwVkm5t50eGgX9iKpo75Bu5f3RIdhwn/TnDScX8+cFhuvOL4zDN1FVPjq5+zbCujC1+cdDVbwnPF38NMX8L99QrzH7XZX9o+tMEeGnuvXnU1V+4OL9LnpMxRkDyzaOuuK5zfsXASfoW0d+FDJ7rbxENSsNjpUKOBkdyA14JjnMxTftMjm4FpW79gu1cFiwYCxGBWTz41iHrFzL69hcQ4p+uuql/ioNcRRmWy8h0noNcxRmWy/iOi75KBPR1uoNcpQJyne0gV1mG5TIJ38WOjQX09W8HuZoIyHVuhhd2ywX68IWDbpsKyOWyWNyMKZeL7c5ljnGUj6TrR0X8fgStmbfh+Hp7dSPmHMPu7e/mkhO3VG+vtkJQp34tdFlLTa00rVZa25YrJ5yh2nbpHGBQhu9ZNXK1KOX3Z5DjPavMW2MaMdYmCzgT49al8eqa99/6vGDQ2iFYzLZ6aQLA1R0MvEZpfGW6yrVGae2BynjtsrWo/AdjUZncKlW8trBfbUL9rFmq6p6etSmtv6i8JuFZGVxU/oOzqNyG4UxrlvIU7ZKJ13DIxG2ZUwq7cYd8jq7aMaYHNX9U/Damz+0cdNXeUVe5MjqslXBaG8eXXPS6NsPePu60NnZcq5Qn31q8pA5ngnW2ShWrbZ3+rRNiV+KEuQ6RMCsj1u7iKobbbnCGp3NGprUd5Boi9AjSOgxnqmQ4O0OvwZAMP4Jkgnsdh3XdtgzddPCUYNPhrFvq5tu+/c1l4KJswBnk09XtKJyMjc3XZcq3Lj8Ze3vspVOI3Rkn405EMu6cIBlbxXDbbZnhZGxk6ugg11ChZNyJ4UydGc7O0GswNMNveTYB3SnDyXi9hLPFdNXNLd0ut5B0ERokupa6xZzvOHAZJDpleJDoltkztB6uZxLdM3iGY97y7DIJMo89cHTbI8NxZ+K6i4NuezLX+PCadPcQs0e47xnu4Vuee+lj62vaQNOGpXV5ZtKfN2L6MzfvGp13ZWCYut0cbNSbYSOTD7dX9d++3AXonYtvV6EyefNHnwzHhznZ7OOg+74MuYx+tieOVyrexu1b39LMY/TL8EXK5qV1fSCOv/Rz8Ml+DIz+crYP8I/KWM1kbN9fKDa5tuT4y8bMcc6e69l22YptibcvD3Cce3PHbo69Nsnw1QKTb9qWsi/DvcSZf2wavw89suVfEm9FHrgKjKESb0XeLOEYGmduzDhX+uucspdD3u3OiIHNBfrcg9nn9R363IPR50ECfe7J7PMGDn3uyejzFhmeI7QNzx25b0Xm5OvB6fuQ6K3I5ny0d4bX94Yw7OBjod+M6Rszx/Uh/IV+cqtU8drC/m0ZYg/FC/1bEgv9QxMs9FvFcNuNzfBCvzUAt904oYX+LRnONJSRBBl6DcbFX+iv86NSxZPbLIxsmeEFlWHMhMx9D5jxb8aJQ2D8blNm/c0d/HSrDA9EqWwXx+Zx6w7P8MmPq25HOJ4oci/SjGTkgLFlmclhPgZHE4OcvgwP6yuEE7HZIaveVqlita3Tv1Eh9tZ4cBxFDI5bJxgcrWK47SZmeHAc7ijXJKHBcRTDmbZmJBGGXoNJGb4lySTKURkeHLdJeIaWThYzOA5kDnaDHK5AbsLwh9ECA+OoDA+MYwQGxkEuk3ahgXEcw94TyzKTv3wMjCb+OH0ZE9ZXCCdiC5TH28PGh9jb4oFxPDEwbgs6JqUY7luRxzMwti3lKdwl4Y/PcMKfkOGzIXN5nXPJwgwQmzEHiC1cJkwCSX98hpP+JIGk76LbyRmeRJhJMuNsNjCT1xEO/ZiS4X6YnMaYfAQmp4116MfUDPfD5BBGPAXGbyc79GNahmPW+Pvg+Pm2Zsmbc/l2O0YfjPz4trIpod6mhvtp4d7wtfW217930LSjpp1K829F5mA0d5ywcnG2L3Xvi9NgFLOuM/+CDE9UdmYGjp107hyxGhNHvgKHRDUzw/c8mycmCx0mF7swkrREH8oz7DO7MnxmVXzb9PZCyapACkfxcXI2KRoHr8iwg093NAw3ccC66eTvrmRkClR8mXooGZkaqfgy9VQyMjGCKuil/MiUDmd9FV/+fxXIJJ8NlAzOhkoGZyPFw+Ha8Cxtl2MYucrUPdbhDWu9VXyMs4R8pY+SwemrZHD6KRmc/koGZ2MlgzNAyeBsomRwNlUyOAOVDM5mSgZncyWDM0jJ4GyhZHAGKxmcIUoGZ0slgzNUyeAMUzI4WykZnOFKBmeEksEZqWRwRikZnK2VDM42SgZntJLBGaNkcMYqGZxxSgZnvJLB2VbJ4ExQMjgTlRtOJtd4Jik/MqXDmaziy/9vofPRKUoGZ6qSwZmmZHC2UzI42ysZnB2UDM6OSgZnJyWDs7OSwdlFyeDsqmRwpisZnBlKBmemksGZpWRwZisZnN2UDM4cJYOzu5LBmatkcOYpGZz5SgZngZLB2UPJ4CxUMjiLlAzOnkoGZ7GSwdlLyeAsUTI4S1X8c5gkOMuUTH/2VjI4+ygZnH2VDM5yJYOzn5LB2V/J4BygZHAOVDI4BykZnIOVDE6VksGpVjI4K5QMzkolg3OIksE5VMngHKZkcA5XMjhHKBmcI5UMzlFKBudoJYNzjJLBOVbJ4BynZHCOVzI4JygZnBOVDM5JSgbnZCWDc4qSwTlVyeCcpmRw/qVkcE5XMjhnKBmcM5UMzllKBuffSgbnbCWDc46SwTlXyeCcp2RwzlcyOBcoGZwLlQzORUoG52Ilg3OJksG5VMngXKZkcC5XMjhXKBmcK5UMzlVKBudqJYNzjZLBuVbJ4FynZHCuVzI4/1EyODcoGZwblQzO/ykZnJuUDM7NSgbnFiWDc6uSwblNyeDcrmRw7lAyOHcqGZy7lAzO3UoG5x4lg3OvksG5T8ng3K9kcB5QMjgPKhmch5QMzsNKBucRJYPzqJLBeUzJ4DyuZHCeUDI4TyoZnKeUDM7TSgbnGSWD86ySwXlOyeA8r2RwXlAyOC8qGZyXlAzOy0oG579KBucVJYPzqpLBeU3J4LyuZHDeUDI4byoZnLeUDM7bSgbnHSWD866SwXlPyeC8r2RwPlAyOP9TMjgfKhmcj5QMzsdKBucTJYPzqZLB+UzJ4HyuZHC+UDI4XyoZnK+UDM7XSgbnGyWD862SwflOyeB8r2RwflAyOD8qGZyflAzOz0oG5xclg/OrksH5Tcng/K5kcP5QMjh/Khkc0yBmXdSQhxMI4TQSwikQwikUwikSwikWwikRwikVwikTwmkshNNECKdcCKepEE4zIZwKIZzmQjgthHBaCuG0EsJZTQintRDO6kI4azBxXN73x/n+hfnGRlEpvx9tMtwPI1cx46tg5oMxpt/cfqzJ7EfA6MfKYUM+MP04xeGd/W2D+Bjc77C4fP+C61MlDj7VTsCnShk+Zfr8u4NPtc+gT9l+lDl8F2etID7GoLLM2qJfEd+nGjv41NoCPtWE6VOBQz/WERqfKoVwOgjhrCuE01EIp5MQTmchnPWEcLoI4XQVwukmhNNdCKeHEE5PIZxeQjjrC+FsIISzoRDORkI4vYVw+gjh9BXC6SeE018IZ2MhnAFCOJsI4WwqhDNQCGczIZzNhXAGCeFsIYQzWAhniBDOlkI4Q4VwhgnhbCWEM1wIZ4QQzkghnFFCOFsL4WwjhDNaCGeMEM5YIZxxQjjjhXC2FcKZIIQzUQhnkhDOZCGcKUI4U5k4mH+cdfhdHa6JTAviY3Cvs9ktk99s2y7IPZm2F5KpQMWXaQdPMqXD2ZHhTxsVyci0E0OmswtkbMe4fyDYWcifGPcCBLsIycS4Jh7sypTJ5VpnU+a1zu0drnVOFxgrmjmMFTMYcTSzzM0/uLqaKTR+zxLCmS2Es5sQzhwhnN2FcOYK4cwTwpkvhLNACGcPIZyFQjiLhHD2FMJZLISzlxDOEiGcpUI4y4Rw9hbC2UcIZ18hnOVCOPsJ4ewvhHOAEM6BQjgHCeEcLIRTJYRTLYSzQghnpRDOIUI4hwrhHCaEc7gQzhFCOEcK4RwlhHO0EM4xQjjHCuEcJ4RzvBDOCUI4JwrhnCSEc7IQzilCOKcK4ZwmhPMvIZzThXDOEMI5UwjnLCGcfwvhnC2Ec44QzrlCOOcJ4ZwvhHOBEM6FQjgXCeFcLIRziRDOpUI4lwnhXC6Ec4UQzpVCOFcJ4VwthHONEM61QjjXCeFcL4TzHyGcG4RwbhTC+T8hnJuEcG4WwrlFCOdWIZzbhHBuF8K5QwjnTiGcu4Rw7hbCuUcI514hnPuEcO4XwnlACOdBIZyHhHAeFsJ5RAjnUSGcx4RwHhfCeUII50khnKeEcJ4WwnlGCOdZIZznhHCeF8J5QQjnRSGcl4RwXhbC+a8QzitCOK8K4bwmhPO6EM4bQjhvCuG8JYTzthDOO0I47wrhvCeE874QzgdCOP8TwvlQCOcjIZyPhXA+EcL5VAjnMyGcz4VwvhDC+VII5yshnK+FcL4RwvlWCOc7IZzvhXB+EML5UQjnJyYO5h/nme3pDs9s/xzEw/jyzz//dH2/B1dXvwjZ5FchnN+EcH4XwvlDCOdPIRwTNDHrooY8nEAIp5EQToEQTqEQTpEQTrEQTokQTqkQTpkQTmMhnCZCOOVCOE2FcJoJ4VQI4TQXwmkhhNNSCKeVEM5qQjithXBWF8JZQwinjRDOmkI4bYVw2gnhtBfCWUsIZ20hnHWEcCqFcDoI4awrhNNRCKeTEE5nIZz1hHC6COF0FcLpJoTTXQinhxBOTyGcXkI46wvhbCCEs6EQzkZCOL2FcPoI4fQVwuknhNNfCGdjIZwBQjibCOFsKoQzUAhnMyGczYVwBgnhbCGEM1gIZ4gQzpZCOEOFcIYJ4WwlhDNcCGeEEM5IIZxRQjhbC+FsI4QzWghnjBDOWCGccUI444VwthXCmSCEM1EIZ5IQzmQhnClCOFOFcKYJ4WwnhLO9EM4OQjg7CuHsJISzsxDOLkI4uwrhTBfCmSGEM1MIZ5YQzmwhnN2EcOYI4ewuhDNXCGeeEM58IZwFQjh7COEsFMJZJISzpxDOYiGcvYRwlgjhLBXCWSaEs7cQzj5COPsK4SwXwtlPCGd/IZwDhHAOFMI5SAjnYCGcKiGcaiGcFUI4K4VwDhHCOVQI5zAhnMOFcI4QwjlSCOcoIZyjhXCOEcI5VgjnOCGc44VwThDCOVEI5yQhnJOFcE4RwjlVCOc0IZx/CeGcLoRzhhDOmUI4Zwnh/FsI52whnHOEcM4VwjlPCOd8IZwLhHAuFMK5SAjnYiGcS4RwLhXCuUwI53IhnCuEcK4UwrlKCOdqIZxrhHCuFcK5TgjneiGc/wjh3CCEc6MQzv8J4dwkhHOzEM4tQji3CuHcJoRzuxDOHUI4dwrh3CWEc7cQzj1COPcK4dwnhHO/EM4DQjgPCuE8JITzsBDOI0I4jwrhPCaE87gQzhNCOE8K4TwlhPO0EM4zQjjPCuE8J4TzvBDOC0I4LwrhvCSE87IQzn+FcF4RwnlVCOc1IZzXhXDeEMJ5UwjnLSGct4Vw3hHCeVcI5z0hnPeFcD4QwvmfEM6HQjgfCeF8LITziRDOp0I4nwnhfC6E84UQzpdCOF8J4XwthPONEM63QjjfCeF8L4TzgxDOj0I4Pwnh/CyE84sQzq9COL8J4fwuhPOHEM6fQjiqQAYnEMJpJIRTIIRTKIRTJIRTLIRTIoRTKoRTJoTTWAiniRBOuRBOUyGcZkI4FUI4zYVwWgjhtBTCaSWEs5oQTmshnNWFcNYQwmkjhLOmEE5bIZx2QjjthXDWEsJZWwhnHSGcSiGcDkI46wrhdBTC6SSE01kIZz0hnC5COF2FcLoJ4XQXwukhhNNTCKeXEM76QjgbCOFsKISzkRBObyGcPkI4fYVw+gnh9BfC2VgIZ4AQziZCOJsK4QwUwtlMCGdzIZxBQjhbCOEMFsIZIoSzpRDOUCGcYUI4WwnhDBfCGSGEM1IIZ5QQztZCONsI4YwWwhkjhDNWCGecEM54IZxthXAmCOFMFMKZJIQzWQhnihDOVCGcaUI42wnhbC+Es4MQzo5CODsJ4ewshLOLEM6uQjjThXBmCOHMFMKZJYQzWwhnNyGcOUI4uwvhzBXCmSeEM98RpxHC2XDW2L3e2ei8breM3+qm6uppO3Xt89HI5bfueeLQd74/+Std3knFl2kBUyauLCeUKLVLafz6P+j6O5fydbuHkG4LVXyZFgrJVKTiy7RISKZiFV+mPYVkKlHxZVosJFOpii/TXkIylan4Mi0Rkqmxii/TUiGZmqj4Mi0TkqlcxZdpbyGZmqr4Mu0jJFMzFV+mfYVkqlDxZVouJFNzFV+m/YRkaqHiy7S/kEwtVXyZDhCSqZWKL9OBQjKtpuLLdJCQTK1VfJkOFpJpdRVfpiohmdZQ8WWqFpKpjYov0wohmdZU8WVaKSRTWxVfpkOEZGqn4st0qJBM7VV8mQ4TkmktFV+mw4VkWlvFl+kIIZnWUfFlOlJIpkoVX6ajhGTqoOLLdLSQTOuq+DIdIyRTRxVfpmMZMhWov9e3zDq32bpr6qGpp6ZemtbXtIGRT9NGmnpr6qOpr6Z+mvpr2ljTAE2baNpU00BNm2naXNMgTVtoGqxpiKYtNQ3VNEzTVpqGaxqhaaSmUZq21rSNptGaxmgaq2mcpvGattU0QdNETZM0TdY0RdNUTdM0badpe007aNpR006adta0i6ZdNU3XNEPTTNNfTbM17aZpjqbdNc3VNE/TfE0LNO2haaGmRZr21LRY016almhaqmmZpr017aNpX03LNe2naX9NB2g6UNNBmg7WVKWpWtMKTSs1HaLpUE2HaTpc0xGajtR0lKajNR2j6VhNx2k6XtMJmk7UdJKmkzWdoulUTadp+pem0zWdoelMTWdp+remszWdo+lcTedpOl/TBZou1HSRpos1XaLpUk2Xabpc0xWartR0laarNV2j6VpN12m6XtN/NN2g6UZN/6fpJk03a7pF062abtN0u6Y7NN2p6S5Nd2u6R9O9mu7TdL+mBzQ9qOkhTQ9rekTTo5oe0/S4pic0PanpKU1Pa3pG07OantP0vKYXNL2o6SVNL2v6r6ZXNL2q6TVNr2t6Q9Obmt7S9LamdzS9q+k9Te9r+kDT/zR9qOkjTR9r+kTTp5o+0/S5pi80fanJxODXmr7R9K2m7zR9r+kHTT9q+knTz5p+0fSrpt80/a7pD01/ajJBFmhqpKlAU6GmIk3Fmko0lWoq09RYUxNN5ZqaamqmqUJTc00tNLXU1ErTappaa1pd0xqa2mhaU1NbTe00tde0lqa1Na2jqVJTB03rauqoqZOmzprW09RFU1dN3TR119RDU09NvTStr2kDTRtq2khTb019NPXV1E9Tf00baxqgaRNNm2oaqGkzTZtrGqRpC02DNQ3RtKWmoZqGadpK03BNIzSN1DRK09aattE0WtMYTWM1jdM0XtO2miZomqhpkqbJmqZomqppmqbtNG2vaQdNO2raSdPOmnbRtKum6ZpmaJqpaZam2Zp20zRH0+6a5mqap2m+pgWa9tC0UNMiTXtqWqxpL01LNC3VtEzT3pr20bSvpuWa9tO0v6YDNB2o6SBNB2uq0lStaYWmlZoO0XSopsM0Ha7pCE1HajpK09GajtF0rKbjNB2v6QRNJ2o6SdPJmk7RdKqm0zT9S9Ppms7QdKamszT9W9PZms7RdK6m8zSdr+kCTRdqukjTxZou0XSppss0Xa7pCk1XarpK09WartF0rabrNF2v6T+abtB0o6b/03STpps13aLpVk23abpd0x2a7tR0l6a7Nd2j6V5N92m6X9MDmh7U9JCmhzU9oulRTY9pelzTE5qe1PSUpqc1PaPpWU3PaXpe0wuaXtT0kqaXNf1X0yuaXtX0mqbXNb2h6U1Nb2l6W9M7mt7V9J6m9zV9oOl/mj7U9JGmjzV9oulTTZ9p+lzTF5q+1PSVpq81faPpW03fafpe0w+aftT0k6afNf2i6VdNv2n6XdMfmv7UZAb8QFMjTQWaCjUVaSrWVKKpVFOZpsaammgq19RUUzNNFZqaa2qhqaWmVppW09Ra0+qa1tDURtOamtpqaqepvaa1NK2taR3zLh9NHTStq6mjpk6aOmtaT1MXTV01ddPUXVMPTT019dK0vqYNNG2oaSNNvTX10dRXUz9N/TVtrGmApk00bappoKbNNG2uaZCmLTQN1jRE05aahmoapmkrTcM1jdA0UtMoTVtr2kbTaE1jNI3VNE7TeE3bapqgaaKmSZoma5qiaaqmaZq207S9ph007ahpJ007a9pF066apmuaoWmmplmaZmvaTdMcTbtrmqtpnqb5mhZo2kPTQk2LNO2pabGmvTQt0bRU0zJNe2vaR9O+mpZr2k+T+ba9+e68+Sa8+V67+Za6+c65+Qa5+T64+Xa3+a62+ea1+R61+Va0+Y6z+cay+f6x+Tax+W6w+aav+d6u+Rau+U6t+Yas+b6r+faq+S6q+Wap+Z6o+dan+Q6n+Uam+X6l+bak+e6j+Saj+V6i+Zah+c6g+Qag+T6f+Xae+a6d+eac+R6c+Vab+Y6a+caZ+f6Y+TaY+W6X+aaW+d6V+RaV+U6U+YaT+b6S+faR+S6R+WaQ+Z6P+daO+Q6O+UaN+X6M+baL+e6K+SaK+V6J+ZaI+c6H+QaH+T6G+XaF+a6E+eaD+R6D+VaC+Y6B+caAef+/eTe/eW++eae9ed+8eRe8eU+7eYe6eb+5efe4eS+4eWe3eZ+2ede1eQ+1eUe0eX+zebeyee+xeSexeV+weZevec+ueQeueT+teXesea+reeeqeR+qeVepeY+oecenef+meTemeW+leaeked+jeRejeU+ieYeheb+gefefeS+feWeeeZ+dedeceQ+ceUebeX+aebeZee+YeSeYeV+XeZeWmWibd1CZ90OZdzeZ9yqZdx6Z9xGZdwWZ9/iYd+yY99+Yd9OY98aYd7qY962Yd6GY95SYd4iY93uYd2+Y92KYd1aY90mYdz2Y9zCYdySY9xeYdwuY5/7NM/nmefm/nmXXZJ4BN89nm2enzXPN5plj8zyweVbXPEdrnnE1z5+aZ0PNc5vmmUrzvKN5FtE8J2ie4TPP15ln38xzaeaZMfM8l3nWyjwHZZ5RMs8PmWd7zHM35pkY87yKeZbEPOdhnsEwz0eYZxfMcwXmnn9zP765V97cx27uMTf3f5t7s8190+aeZnO/sbkX2Nyna+6hNfe3mntPzX2h5p5Ncz+ludfR3Ido7hE09++Ze+vMfW/mnjRzv5i5l8vcZ2XugTL3J5l7h8z5jrnnxtwPY+5VMfeRmHs8zP0X5t4Icy+CuY5vrpub69TmurC5Dmuue5rrjOa6nrmOZq5bmetE5rqMuQ5irjuYdX6zrm7Wsc26sVmnNeuiZh3SrPuZdTazrmXWkcy6jVknMesSZh3AnHeb81xzXmnO44zrmHMyu4VDyV/nbeb6v7nebq5vm+vJ5vqtuV5qrk+a64Hm+pu53mWuL5nrOeb6ibleYa4PmPV4s/5t1pvN+q5ZTzXrl2a90KzPmfUws/5k1nvM+opdz+ig/j4/7qj+vrejs6b1NHXR1FVTN1V/2wH8bh/uT5jz0OPffVryDKy3dkRZZUSZydGpypaFZbPa9Fnxcofbb4NlX4Rln5z6XsdFk35oB8tuLvh7//kXy368/Pgm78Cye8OynUvPvXPL55pcDcvujyh7PKLsyYiyZyLKnosoezWi7PWIsnciyt6LKPswouzjiLKvI8q+jSj7IaLsp4iyvwInRVmjiLKSiLKyiLJWEWWtI8rWiihbJ6Js3YiyThFlPSPK1o8o6xNR1i+ibJOIsoERZUMjyraKKBsZUbZ1RNmEiLJJEWXbRZTtEFG2S1j2y9Fv7P/42SsGw7LdwrIt97l0yw6vNXkVli0Jyx65+OAt9+vd+lBYtjSibFlE2d4RZftElO0bUbY8omy/iLL9I8oOiCg7MKLsoIiygyPKqiLKqiPKVkSUrYwoOySi7NCIssMiyg6PKDsiouzIiLKjI8qOjSg7LqLs1LCMGt//FZa9/snrWzwz+446Y/jZEe3ujCi7O4Ln/RHtfowo+y0su3TvN5/Y5eNXd4dlvYpSt9s5omx2WHZ28y6PPlq2zWNrqtRbpYq1TUzQdnaCtgsTtJ2VoG0SmfdK0LYy9sH62x4J2i5L0HZJgrZLE7StjH2w/pbErxYlaJut/s5I0DZJLFTGPlh/y5aNkuAm0VWHBG3/2pZEjAkrwjJqnFkZUXZ9BM93UpQ1D/ddw/30JUtm77V0l5mL9thz+tK5MxbM3mXRXtNn6t3es/daMnfRwl322Wv6nnvO3mv1sH5puA9Pw/9a2zCnbZUq1haUgnb89lXDSjFDVnv1V/tAueL/3X+7nuPSvtgKAtpDWSxfszbUBPxuivAd5R+WVP6WETJb2wwF9StVrK3ArH+Zflr/NH3vFP5etnTugrlLlw/5y1WH1njquL8cdcrffooZBuj/oSmONwZyF4I68XWy7zDLM1y++Gt9r4CoWYj2tk7rcF8G8O0+zvNCrz74/Us3bt17jxaovdmsbRoDnFlzl8xcpON7l4Wz99llj9lLlkyfM3vJuAl/F2Y5wHdOGOA7J3TwoBS0cWhfE+A7gfZYFrOVq7qBBNuUhOX2d5fwd8Lg3zlXg9+2HUa1/W7Jy5c8fuwND1y29NKLT2vxatMzmvRsfPChh37Z7ov2Z3516IW27VZApkDFxi627YdT2INuLth+9+t/WdRkxMpr93n1lbHLmrafft86R1y8/YMnrvPxLofZtiOoth8dc9bBFdeedF5ljye/Lx5x/Ge7fDuqaMCrTx6w5v0rfvv4q5Nt25FU2+e2/+2NGytO3m/fY2/df0DXVtOvOvnlrz95+PFrKr595+rFL/ezbUeBPrvE6NagPePBxBpbb+PWvgZ/tFv7Rrb9GNCe0f/mtv1YcLDS/qi+6LI3hhz75Ibv/db4qDHTD9m3z9HPT/18vzaXdv5g3tXtr2ph246j2r67dOiJS9fYo//npU8fu9H57dZ667tLb/zwh+WzB3z24Uc3dfjWth1PtU2z2bbbEm3b9O6yyZ6nP7Pa613XfW3wPVetf8qa33Xa7PVbRp7/1S+P/gTahimeq68afU90a19o209ya1+THyaD9owYr/G3KW7ta/CnurWv0d80cLAyuk3NsGDbbhe/bQ0L23Z7dltVZNvuQLTtvlnZVxcfddCh6u1LPz3uh+53DO7VYu0hLdZ/4ayX2i3ca4c1v7Jtd6yRhGXv9nYy+Gvo7NS4xdD/eGpMZ7SfbdsXurXfy7Yvcmu/m21f7NZ+kW1f4tZ+D9u+1K39XNu+zK39Qtu+sVv7ObZ9E7f2lbZ9uVv7JbZ9U7f20237Zm7tZ9n2FW7tZ9r2zd3a723bt3Brv9zOlVuCgzZBWt6twHFGrlkLzmXtVoCOQf5lSBbu3CtA/Cwe7p/NdbbvqxGyVBBlOEeuRuCsRuBQvAo88ir0yKvII6/iHO1jiUdepR55lXnk1dgjryYeefnUvc8YKs9RXk098vLpEz5179O/mnnk5TO2ffpEhUdePnN0c4+8cnV8tPMsO3eAc40gxd7i4GMWpwzxsv2vVLG2IKpfrQi8UkXru1LFBAypNYFHzbNs/dVjymfygfXx8ALFsNkzls0ZvWiOQlsh+n+rFCK2V3XFXy1CNMw3QISPY94FRF24NQF4YfeGz146c/dJ0+fMmT1Ld7LenQWY07AUx61TtibaWqOvjiStVLG2RnGcGvIvQ7K4OjXlNLB/0Gms84VaHb1o+qyh0/dcsmzB7EaQtap7ioG1ArnCY5RNAyCZiqg3DP0/iminCN7Ql9YAZZQmLM9mqn6f1kjRDocsPtaIqL864rU60c7KXhDRHvKA7bDHRHl1HK+0/TBbhUrd/zinwo7Rs5pr9CQ9FY7StdnwkLCGG16rKB+FPK08VtdtiDLLy96/V5yCl21biOqfFe4rUD2zjUcYbQh54TGrH3NafBqSHeoW+0kSPUJ+Vi54DPIvU4n8MoiyG+wf9pM2bngt4+gdymN1vSZRZnm1Df8vTsHLti1E9S8L9xWontmwn6xJyAuPQT+5EMkOdYv9xFGPQ+L6ieVfphL5ZRBlN9g/7CdruuENjqN3KI/VdVuizPKyNy4Xp+Bl2xai+v8X7itQPbNhP2lLyAuPQT+5LvxdmkLeShVrW0DpmtF+n1JVX3eM9ktt+3Zu7Xe37du7td/ftl/Lrf2Gtv3abu0PtL63DjiI47wSHOdcrosb55Xh7zIki2ucVyI83D+8hN6BkKWCKMOnhB0InA4EDsWr0COvYo+8KjzyKvDIqzxHeZV65FXmkVdjj7yaeOTVxiMvn36fq/pa0yMvn77a1iOvdh55+dS9zz429cgrV321vUdeeD6UhJedG9nxvhK0C8J9KdGOe24I+Vk54THIvwzJwsQLovRSCY7hc5p13fBaBKg9xIM8rTxW1x2JMsvL3sdfnIKXbVuI6heGCq1A9cyGz2k6EvLCY/Cc5s/wdzNCXry+w/VH2B7rCLbD/pjEXpCflRMeg/zLVCL/D6L8g9KL7V9HN7zmcewL5bG67kSUWV6dw/+LU/Cq8T9UfzXkj52ATNgfOxHywmPQHyuCurJD3WI/cdTjVnH9xPIvU4n8MoiyG+wf9pNObnjD4ugdymN13Zkos7zWC/8vTsHLti1E9TsgP+kMZMJ+0pmQFx6DfmJPtEtTyFup4m04RiwPyBvqJb4dgq/j+pnlX6YS2T2I0iMVb7Z/6znhBV9h34B4kKeVx+q6C1FmeXUN/y9Owcu2LUT1N0B+BjGwb9gyKC88Bv2sO8pHULfYT9z0+NcrRevws3LBY5B/mUril7V+QtmNijfbvy5ueEPi6B3KY3XdlSizvOx7uopT8LJtC1H9zZCfdAUy4XzUlZAXHoN+sjHKR1Bes1WqWFtA6ZrRvp7uIA/Luxs4zrDjn3H91PIvU/Xt6OKn3RBeKjvYvncnZKkgyqCOYRnE6U7g5HnleeV55XnleeV55Xmt2rzWy/P6R/BqCP6Vj6G8HfN5Ih+PqyqvvH/lfbUh+mp+PpHXV76Ped2vqrzyvpr3iYaor7x/5e3YEHnlYyjvEw1R9/m8mo+hvL7yvNLxyp9b5fuYz9F5X11VeeX9Ky9Xnlc+HiX7mOeVzzn5cSjfx3wf8zknr6+8HfP+teryyq915PuYzzn5PJHnlff7fAzldZ+PoTyvXPbV/Hwi7xN53ed1L8krPw7l9ZWPoTyvdLxy3Sfse2HhO8Pw91yo93N1i8CB7W29cqJdEO5LCfkMTqWKtcV+b5nlX6bq95mBF0Tpn9KL7XsPQpYKogzbuQeB04PAyfNKzqtLjvLK9/Gfoa+GIFee1z8jHvN5Is8r76v5fC8pV96O+T7m/Ss/dqyqcuV9Iq+vvH/l7ZjnlY+hvE80TN3n82o+hvL6yvNKxyt/bpXvYz5H5311VeWV96+8XHle+XiU7GOeVz7n5MehfB/zfcznnLy+8nbM+9eqyyu/1pHvYz7n5PNEnlfe7/MxlNd9PobyvHLZV/PzibxP5HWf170kr/w4lNdXPobyvNLxyvtEnleeV55XnleeV55Xntc/nZd9bxl8Z1g3hMN9Pxpsb+tR7yYzVKlibZNKiT4w2u9i2/d0a7/Ytu/l1n5f++6y9cHBINxb3huA4wXxeW8UIH4qbA+PQf5lSBYmXs172zZAeLh/1i9s3zckZKkgyrCPbEjgbEjgULzaeeRV4JFXE4+8KjzyauORV1OPvEo98irxyMunTzTzyKuHR17lHnn19Mir0COvth55+Yzt9h55+cyFPuOxzCMvn3Zc2yMvnz7hU/c+Y9tnH336RLFHXrmaJ3zK1RDmTPkxLXu69xmPRR55+exjrxyVy+d8wmcf7VhLnQsbqlSxtmX4XNPygLw3AscZ572DAsRPKfo82/IvU3Q+rFSxtprz7I0QXiq92r73JmSpIMrweXZvAqc3gUPxaueRV4FHXk1ytI+lHnmVeeTV1iMvn7pv75FX3o48Xmt75OXTJ5p55FXskZfP/FXukZdP3fv0VZ+6z9X85dNXffpXiUdePu3o0798xpBP/yr0yKtpjvYxV+dyPvvocz6Rq3bM1blcL4+8cnWe43OOmZ9P/DNiyGee8CmXT//q6ZHXBh55+dS9zzmAHWvtOlBP0C4I9wnXwDoEiJ+VEx6D/MtUfVv6WgOD/bN6sf3r7YZXGccOUB6r6z5EmeXVN/y/OAUv27YQ1d8sTGQVBEZHhGHLoLzwmNWPWS/fOOTbjJAXxxyl940IvhVEe6wj2A77o6O9CuL6o+VfphL5fxDlH5ReKP+wbSm7Yv3HtWsUL7wubMvNVkq0Y+ijMK7+Lf8ylcjeQZReqDxp+96XkKUClZltPKiHywqIY42EeWF7ma1SRW7WHPV0YWWDfPuB4wy7FMX1A8u/TNW3i4sf9EN4qXRq+96fkKUClZkN264/gdOfwFlVeEEfwjnKlpstoV+0cPULx3wU6RdU3rT96++G1zyOHaA8VtcbE2WW14Dw/+IUvGzbQlR/IZovQAw8X7BlUF54DM4X5qL5ApS3D+JL6b0fwZcar2y9fxpOOdEOx5ej/8XOu5Z/mUoUz0GUv1N6ofzdtqX8FOs/rp+uirys//WPwOHmd9i+fx7HO07vhDi9Y+L0TYjTl8ApJ9rhPAT9NH5eCN6Om4cs/zKVKO8FUXFI6cX2b4ATXvAWHpshHuRp5bG63oQos7w2Df8vTsHLti1E9S9E4zzEwOO8LYPywmNwnD8HjfNQXnxeys1/sD3WEWyH/dHNXqoirj9a/mUqif/X+iPlH5RebP82ccNrFse+UB6r602JMstrYPh/cQpetm0hqn8D8sdNgUz4fGVTQl54DPrjNSHf0hTyVqpY21hK14z275Sq+rpjtN/Ith/o1v48234zt/bdbPvN3drfYtsPcmu/lW2/hVv7m2z7wW7tq237IW7tp9n2W7q138m2H+rWvqttP8ytfR/bfiu39h/Z9sPd2o+07Ue4tb/Vth/p1n5P236UW/sTbfut3doPte23cWv/vW0/2q39ybb9GLf2X9n240B7zjUV235bt/YFVt7x8CAhk+Vvx7qxoH6QYm954TKLVYZ4MWUPomSH8uH5Ehw3YR9T8RrP5FVKlLnYZJxK3S/IvzxCFkrOtcDvpH1u5pHXAI+8Cj3y2sQjr0098hrokddmHnlt7pFXI4+8BnnktYVHXoNzlNcQj7y29MhrqEdewzzy2sojr+EeebXwyGuER14jPfIa5ZHX1h55+Rw7tvHIa7RHXmM88uqYg7zMNjncJ1zvGJVwvWLThOsVYxKuV0xMuN4wJOF6w4iE6wXDEq4XjLZz7WHgYBDuqbUAxrx/bID4KUWfP1n+ZUgWJl7N+dNWCA/3D19vHE7IUkGU4RgZTuAMJ3AoXmUeeTX3yKupR15tPPIq9cirmUdeTTzyKvHIq8Ajr/Ic5eXTVxt75OVT9wM98vLpqz7jsW2O9tFnPG7gkZfPGMpV3bfzyMtnnvA51vrMEz5171NfuepfPucmPu3oU/cNIU+098hrM4+8BnnktXmO8trCI6/BHnn51H2PHJVriEdejTzy8ukTAzzy2tIjL5929CmXT1/N1VzY3SMvn77q044+5cpVffn01aEeefn0VZ/5a22PvHzOv4o88vK5puBzTu7zXMHn2qOd39t17CGgXRDuE67hNwsQPysnPAb5lyFZmHiRa/iwf/je6OFueE3j2AHKY3U9giizvOy12+IUvGzbQlT/0XDBqQLVMxu+N3oEIS88Bu+NfqCkruxQt9hPHPXYPq6fWP5lKpFfBlF2g/3D13pGELJUEGV4ThxX3xSvQo+8ij3yqvDIq8Ajr/Ic5VXqkVeZR16NPfJq4pHXSI+8fMaQTzs298irqUdebT3y8hnbPv3LZwz5zKsNQfclHnn5zNE2F9rnEuF8phXC4c69YXtbL+HzLhMSPu8yJeHzKuMSPm8y3M6rRoODQbinniVhzPGqA8RPKXpOafmXIVmYeDVzyjEID/cPzynHEbJUEGX4/qFxBM44AofiVeaRV3OPvJp65NXGI69Sj7yaeeTVxCOvkR55FXrk5VP3ueqrbT3yKvDIy6d/+cw5xR55NQTdl+RoH8tzlJfP2G7skZdP3Q/0yMunr+bqHMAnr/y4zeOVH7ez51/5cTt7us+P29mL7Vwdt33qK1d9dQOPvHzqy2fO8an7dh55+Ywhn+N2ruboXJ1P+Oyjz7mvTzv61H1DyBPtPfJq5JHXcI+8fK6Tj/DIawuPvLp75DXII68eHnkN8MhrlEdeDUH3m3nktblHXoM98vKpr6098vLpqz5jKFf9Plf72BByoU+58mPHP2Ps2MYjL59zOZ/6GuqR15Yeefkca336hE995erYsbZHXj7P+Yo88vJ5TcfnOoDP9Qmf9+fgZ2zgvWFBuE/4zuOmAeJn5YTHIP8yJAsTL4jSC+yf1UvC9/+WB6g9xKPe8Wt1vS1RZnlNCP8vTsHLti1E9dcKL4ZVoHpK1X/GZltCXnjM6sfEZ5uyurJD3WI/cdRjp7h+gt9H7eiXke+jpuKHspttW0GU4fWnuPqmeBV65FXskVeFR14FHnmV5yivUo+8yjzyauyRVxOPvEZ65NXUIy+f8djWIy+f/uVTX2088vLpXz5jyGde9ekTPvNqrsa2z3j0GUPNPfLyGY8Nwb9KPPLyOQfAz3DB+TJ+hov7DmzYPtX3Rmy52RJ+j+bEAPGzcsJjkH+Zqt9nlzk7pX9KL7bvEwhZKogyvJ43gcCZQOBQvMo88mrukVdTj7zaeORV6pFXM4+8mnjkNdIjr0KPvHzqPld9ta1HXgUeefn0L585p9gjr4ag+5Ic7WN5jvLyGduNPfLyqfuBHnn59NVcnQP45JWr47ZP3fucA/jM0T7nE7nqq/lxO3t5NT8n5/HKz8mz51/5eWH2/CtX54U+9ZWrvrqBR14+9eUz5/jUfTuPvHzGkM+xI1dzdK6OaT776HPu69OOPnXfEPJEe4+8GnnktYVHXsM98urukZfP60M+9TXUI68eHnkN8MhrlEdePn1ikEdePnXvM7Z9xqPPGBrhkZfPeGwI/rWZR16be+Q12CMvn/ra2iMvn7nQZ47OVb/P1T42hLHWp1z5uck/Y+zYxiMvn/MJn/ryOSff0iMvn2OtT5/wqa9cHTvW9sjL55pCkUdePq9b+Vxn8rn+5fP+QvwMJry3NQj3pYrWTaWKtZUHiJ+VEx6D/MuQLEy8IEov1H3Stn8T3fCaBKg9xIM8rTxW15OIMstrcvh/cQpetm0hqn92eNGpAtUzG34GcxIhLzxm9WPi8/TGdWWHusV+4qjHe+P6ieVfphL5ZRBlNyp+bP8mueHdE0fvUB6LN9kNr8DaairB28oyLfy/OIUstm0hqn8d8ocpRJsKVGY27IOwrIA41ihLvKYSvKAerU1MbFwS6oLyf0OVKtbWG+cFywPydvSFqXFjy/IvU4l8PcB5zOKlyjGUH9m2FUQZXi9ztb353TZHeRV45FXikddIj7x86qvUI68yj7wae+TVJEf7WJyjclV45OUzHn3asZlHXj5jqNwjL5929OmrzT3y8ulfhR55tfDIy6ff52rO8dnH9h55reWR19oeefnUl8+5iU//ytV5oU+/z9W5XFOPvNp45NUQ5nK56vc+5yb5MY3HK1fncrmaC33O5XzmQp929KmvXJ1/beqRV67Ov4o88vIZ2z5jyKe+fI5DPmMoV3XvM3/5XJfL1bUhn/7lc+6bq3PMXB07JnrkZceOcsTblpst4fWmtQLEz8oJj0H+Zap+P31db4L9c73e1Aj8zqV86DOOcnWt3GcO88krf72Jx8vn2pzPGPJpR5/XA3zOdXJ1Hcanf/mUK1ev6+TqGoVPO/q8V8FnvsfvToVzI/zuVGoeMjkCB7a39cqJdkG4L1W0n1WqWNuhAeJn5YTHIP8yVb/PLvMzSv+UXqh712zbCqIM34cfdf8WxKF4lXnk1dwjr6YeebXxyKvUI69mHnk18chrpEdehR55+dR9rvpqW4+8Cjzy8ulfPuXyaUefcvnMqz59wqcdSzzy8qn78hzl5TNPNPbIy6fuB3rk5dNXc3U+4ZNXfg6QvbEjPwfInlz5OUD27JifA2QvT+TqHMCnvnLVVzfwyMunvnI1T7TzyMtnDOXq2JGrc99c9S+f82ifdvSp+4aQJ9p75NXII6/hHnn5XL8f4ZHXFh55dffIa5BHXj1yVC6fdvQp1wCPvHz6hE87buaR1+YeeQ32yMunvrb2yGuUR1656qv5eMxeH3PVv/LjUN7vMa9tPPLyOcf0acehHnlt6ZGXz3Hbp0/41FeuxuPaHnn5PBct8sjL53Urn+sTPtdNfN7PZNc67P2H8Fy+N8JpROA0isCB7W1ZKdGuUsXaBtr797qDgwHiC/NxQXzehQHip1Rd+yvEvwzJwsSruXdxE4SH+2f1ZPs+kJClgiiDdoRlEGcggVNBlI3PAK/SFHJWqljbZMrejPbzsT4tDygbPF9l2LZNXF+y/MtUffu5+NJmCC+VXWzfNydkqSDKsI02J3A2J3AoXmUeeW2So3IVe+S1pkdePvvYxCOvEo+8yj3yauyRl099tfXIq4VHXiM98irwyMun7ks98mqWo31s75HXWh552fMXqbkqhdM3IU5fAqecaBeE+4RzkZ4B4mflhMcg/zJVv8++5iKUXrhzEbx2kyvj9AYeefkcp3M1xzT3yKupR15tPPJqCGNFrs6bfcpV4ZGXz3mNz7muT58o8sjLp08UeuTlU18+81eunmf4tKNPuXJ17PBpR5+69xnbDemcJdf0lavjts/YzsRYa89X4PlNEO5LU8hQqWJtsc/VLP8yJAsTL4jSC+wfPlcbTMhSQZRtCX7DMogzmMCheJV65FXukVeFR17FHnk198irwCOvwhyVq5lHXk088mrvkddaHnmt7ZGXT32VeeTlMx7beuTl0+995kKfdizyyMtnzvHpEyUeefnUfdMclWukR14+fcLn3MTnuO3Tjrmav3z6l894zNUc7ZOXT/9q7JGX1b29fgfPx8YgHO45IWy/uTAOdX5pqFLF2mbg8zfLA/IeCo4zziVnBoifUnVjQCH+ZYq2W6WKtdWcuw5FeKn8xPZ9OCFLBVGG7+EdTuAMJ3AoXr088hrpkVeBR14VHnm1zdE+NvPIq4lHXj59oqlHXj59YhOPvBqCT5R55FXskVeuxrZP3fvUV1GO9rGNR14+7ejT7xt75OXT79t55OXTJ9p75OXTJ/Lzr39GjvY51vbwyKsh5MK1PfLymXM298hrA4+8fMaQT335HNOKPfLKVX35HNNy9dzKp+59xpBPffnM0fmx458xdvg8tyr2yKvQI6/8mkL2Ysin7n32sYVHXrl6PuRT96UeeeXqeqHPeU4+T/B4+ZxP5PNE9nSfq3nCzr/wOzPMVqlibYG9fjoIHkR8h4LjBfF5FwWIn1J1bawQ/zIkCxMv8tox7J/rtWNf16rMNj7Hedl7H6DthyAcSs9DI3Bg+6EROIMT4gyOiTMoIc6gmDi9E+L0JnBKiXaVKnKzpx/1/N7yhnzhewwzEfOWf5mix4FKFWurifkRCC+Vz9u+jyJkqUBlZsOxNYrAGUXgrCq8suG7FM7whDhUDi8n2nny84Gufu44lkb6OaUXjp+b3/j9C0n8qalHXqUeebXxyKvAI69mHnk18cirrUdexR55+exjRY72scQjr5EeeW3gkZdP//IZjz79y2cu9ClXmUdePv2+IfhEO4+8fPpXeY720afuizzy8un3hR555fPEPyNP+OxjC4+8fM4nclX37T3yyscQj1ePHO1jQ4ghn7r3ee7u8xwZv28U9hmvd/UgcHpE4MD2PSJw+ibE6RsTZ0hCnCExcf5peluV+1Oq6FiuVLG2/ai1UUb7Xnjt0fKAsk0BxxnroKMDxE+puvlPIf5lis6XlSrWVrPuOgXhpco3tu9TCVkqiDKf34Ep9sjL5/dNCzzyauKRV65+UzlXv//ts48+5fL5vSifvlrokZfP2Pap+7Ic7WM+f/0z8pfPPvrUfYVHXj79fgOPvHzGdq7Go88cnatjrU87+vxGXUMYhxpCH33K5TOv5uq47fMbwT7l8qmvXh55+fz2p8+5Sa6Oafl4zF4fc3XcbgjnaT59YnOPvHLV70d65JWrax3NPfLKRI6mrgng5xK41wRg+6hrD6MS4oyKiSN1LWV4QpzhMXGk7PNP01v+GmG+P5L9GZMQZ0xMnLwf5PuT74/bvQlmq1Sxtr722novcDBAfOH1dMZ1/mYB4qdU3fmeQvzLkCxMvJr7CgYgPNw/fF/BFEKWCqIM2hGWQZwpBE4FUTY+zyvPK8/LC69/2jzFIZ/bJbKanAZzIM7njveJxX4OHd8n5jh+RN4nBvuH8/lUQha8XmA27Iuuaw+5yisbvpufw+X7kwqnV0KcXjFxpPQ2ICHOAAInRu5v9HSrnZcVX7TTzF5dmm71dZuWp6zc4oFjV2zRpSeez1rekC9ee0W8U22FcXO/5V+GZHHN/VTuo+YHtu/TCFkqiDL83qFpBM40Aofi1cMjry7h73x+y/cn2/2ZkhBnSkycvB/kTn8ix5/vlrx8yePH3vDAZUsvvfi0Fq82PaNJz8YHH3rol+2+aH/mV4delHCMmWrbT3Nr38q2386tfUvbfnu39i1s+x3c2g+z7Xd0az/Ett/JqX1QY/udwdHKWG1r+75LDTeW7INt+13d2q9j2093a/+HbT/DqX3wlW0/06m9+t22nwUOVtofg24u2H73639Z1GTEymv3efWVscuatp9+3zpHXLz9gyeu8/Euh9u2s92wy2373dzaN7Ht57i1b2fb7w4OVsZqqhrZtnMBdqP47Utt+3lu7fvb9vPd2m9s2y8A7Rm6q7Tt93BrX9P/hU7tg7ds+0VQqHDf6aXbSn684vjC//z3q0X7fN/95MdGHHvXlZud9GSvQVUT3zvtizG27Z5O2Kqpbb/YrX0z234vQnb10TFnHVxx7UnnVfZ48vviEcd/tsu3o4oGvPrkAWvev+K3j786xbZdQrWN3gpt26VU2+e2/+2NGytO3m/fY2/df0DXVtOvOvnlrz95+PFrKr595+rFL9f427KwOrPPq9n2e7u1L7Lt93FrX2zb7+vWvsS2X+7Wvsy238+tfWPbfn9wsDJWU1Vh2x5AtG21kXp5nbf6Le+xev9F4/Y+5K1JVx+02oXdPqxo88Wyzfb++fVFtu2BRNs0Wz/zfp67w5u27DzyoLDQ/G4Nfhs6OPzftLPzyNVAHdu2ENU/Z4PadveHePa8vCUQKAj3tk+twHGGLdYMED+l6DUJy78MycLEq1mTaIXwcP/wmkRrQpYKogy/H6U1gdOawKF4re2RVxOPvEZ65FXgkVeZR17NPPIqzdE+NvbIK1f9q6lHXoUeebX1yMunf/nUVxuPvHz6l88YKvbIy6dP+Myr9tmgcqJdEO7tPGAdJEOlirU1ChA/Kyc8BvmXKbrPlSrWVjMPWAfhpdKL8T87P1i2dO6CuUuXj140fdbQ6XsuWbZgdiPIWtWdDWGtQK7wWKDq9h6WFaBjuN5w9P8oop0ieBcAfh1AGaUJy9POPmGfOqRoB3WhiGONiPrrIF7rEO2s7AUR7c1WTsiQbY91nClHeizsH565diBkqSDK8BkElTGoGTJXriaq9smyMJKGzZ6xbM7oRXMU2grR/1ulELENqjcqhWgBwTdAhI+3QccKVHSoRp0sxXEZs+FkDE92VkM4+WScT8arRjIuINphj2lGHMe3AXKnMmMIPApn24Q42xI4pUS7Svuj+qLL3hhy7JMbvvdb46PGTD9k3z5HPz/18/3aXNr5g3lXt7+qpVmCWa9FXXmh/lsiea3d4ZIPZa9CVP+T9WvbdQ/xTIStEZaHEbblsgXzJ8xeutfc2XvP1rkaLprWqEghkeA2Fv0/jmhHbXHGcMfEEzvRWf6+xnDKtVKNlfETHXYIqBXIFR5LkujGof9dEl26WQNOdFHJCVqlJYFrjzVSqRMRlcTwWmNUIjNbfmj+e+N7bEMemuN4bNyhOZXHphqacbsildrDC1HdEeGQkdCz67xFGsuYHwP+3vJjwKoyBhQQ7bDHRHl1HK+0/TBbhUrd/1JVXx+V9se7S4eeuHSNPfp/Xvr0sRud326tt7679MYPf1g+e8BnH350U4fvEkbXlIRZYbLJRDugSXAHwAuf3K0b/p/quqdtW4jqT29R224XMAnuHJaHkTdl+oK5s6Yvnb3VwsXLZi+bPWvsoqWzlwxZOGurvWcvXMqeEo9A/48k2lFbY8BvfcC/AHXSbHgtZMPw/2KAA+tgBdn6s0OlmA9wBRP+/k05nZWnHLW35WazTrERkr1Sxdpip2zLvwzJ4pqyN0J4uH9uKRu6M9YK5AqPZTtl9wFllCZwyoZ96pOiHfZcfKwRUX8jxGsjoh1O2VR7yAO2wx6DowimmfUJbBxFe4MoKpyQGnd9VV8POJJaEng26vqgumazUdcP9alSxdqmxo06y78MyeIadf0QHu6fW9RBT4EoUxBXWwfWhdsUIJlKUY+yXmuiHd6sxgqRzMeDwaoKDY6wX5VIHsrb4TE8mYDtbT0KZ42EOGsQONaT1wVlXVBZx4iyTqCsEpV1BWV4Pb0bkHM8Kuuu6vfZlvWI4NmT4Glst37L2jaGRoN6lKfjrAqvh8C28P8ioq59cKoQ1b0A+NUpyK9gFFequnL3SSN3lF/1Ualx1kiIswaBY20C/Rf7Tj+ir7asPyjDdt4YyIJ9ZyDRL1u2WQTPYQRPY5/OLevWw/Y3m834Y8FxzuQ9bsa3/MuQLK4ZfyzCw/2zdrb9G+eGNzlA7SEe5GnlsboeT5RZXhPD/4tT8LJtC1H9a8N4q0D1lKr/MPl4Ql54zOrH+MkVLerKDnUbpNhbvvgYji/Yd2sfiwPzzWpAnhtb1O0LzFMFRFt74ohz1cvgqsXNKFfB9th2VJy49n800cdmqr5uVge/U/n32Aic1SP6kyl7ro5w+hB9/esmYWTPcaCsgGhrH+wqRPXvAfZ8CNmTikVKz5WqrixcPVcSOJnWcyXCGe8RB+YNuAhiaDLihfVs7WT1PBGUTUbt4MOCsB4865oMjlMPhFP8LY90PvhyC7pvqXzQYhWi+hcDH3zV0QfxC22gDWC+gHJAPcD62ym6X8Up6qfq1zvgrLNkQl2ecE5B2QLnX1v/fcCz8QRaTtivrcAxfOsQ5Q+TiX5ROp2q0mNDPY9KgV2son2xENX/lNApNS5MRrJD3p2RLBPTyI7jG7a39cqJdknzCCVzupj8jhmT9oFZ7LvHgZj8EcVklI9AmfF5BFfPaxA4mdYzPkeY6hEHxgweF3ZAvLCerZ2snuGD3jugdvAhZvxAeAFqA+tDHhT/uONCaUu6b6l80GIVovpLgA82aVm3/9S4QvngVFQGdYrHhXT5cEdU38pdrKLH20JUv2XYF2pcoOIV+g0eF2z91oAnHheol6pEjQuUL1Ivh6F0ugPitRXBC+oZjwuUTmH/t0L9t/XbEzqlxgXbnlqPWA+VwfWIcagMrkfgOevGoCxqPQKvjcD1CJzvhoEy6CN4PWLdiP50BGV4vQ+u2/VDZXDdrj8q6wbKNkZlcN1uICqD63abobKeoGwY6Ktdt8MXETcKjye8vkXeCpFqXRTXg3ul4o0H0FYBwtnIIw7kNRzh9PGIA3My7k9/AsfaC8ZLJq5HWv5lqn7suqyTbYzwcP/crozAbIO1ArnCY1DTuEzieuRAUEZpAq+cwz4NTNEO6kIRxxoR9TdGvDYm2lnZCyLaQx6wHfaYAB1PdT3S8ihE9bcGo1VTNFpTWFAfeMS0sqe6swDLYOuPBTIEE2iehSn61T8Fz+kta/WxbUuapyJ4Uv0aiPqFZdgYyWDrTyZmAgWoDpaHOmb+h9d6B6aQj7ITlhWOcqn6g+1k6+8QYad+hAwwJkelkQHXGZhChl0IGYjsNnTRnsvD7KbQRj37A//HmsfXbfsRfFJtVhvGC61H4usZOFNRx7AH2Lam5/Z8p+ZRqgWzl85O0XecuYMUmI0UvcUZQx2vNcUeQ/G1pqRjKLVGTI2htu/UOmAFUYbP6UbHxDE2bRX+Dm06cemivVKZNO7gGhBi4fYqDS/7fwYvOTq7gdQlR95UCjon1grkCo9FaT6dtX3c305dDB1N8KQWv8elaJcuyTUi6o9FvMYS7azsBRHtIQ/YDnsMjpBUUyk85bD1DwRDk721C7ex/88CvzuEv6MuNCW80N0iblRZ/mUqURQHUb5EXYDjRRVOrRalOeJq68C6cGsOJFMp6lGeO4ZohzerMewlJ4KJ6WFoKRF657ZIHihD1PBBPYyIl0rgTY2pbn0xG14yinN7C1W2GdEvajkJ3/qyFcHT6O35GLe+xPF4s+ElR+rWCuixOPtRt3ZYXhPT8JqAeFGX8iyvyWl4TUK8qEtYeBmSageXUMfEkAEei3rw1tYrJ9q52qwiQuao27WMD12ATgqngjJqtLATL3wZcEdwaeBiFM9wuRhfBoQy41jn6nlbAifTesZxPM0jDlzix5enqEtEUM/WTlbP1OUl225nUIYvLVGXsHYmsCn+lkc6H7ypJd23VD5osQpR/SHAB2+NGFOifHAaKoM6xeMtdRmHskGA5E51KSXVZbd7Ii5PUfEK5RqDeNr690dcnqIuN1GzlShf3IHoF6XTnRAvarYK+4MXUCidwrgZi/pv6z8W8/IUvpQE5wycy1NxL0Hhy0xwzoDnL9QlKDxnwD7yPLpkY/vzErpk47icQF6ysbyaqfo6hJe5YJlStfakHi2qINpvGIHTPSFOdwKnnGhn+51Qj7HP/y1/X492UfNrSi94zgnbUnGEF1M7hv/vEK7xGN/8AM1nO0ABw73VK7xUx+hn/7h6tfzLkCyuel0X4eH+Yb12JGSpIMq2Ab9hGcTpSOBQvIo98trAI68yj7yaeeTVJEf76NOOPvtYkaN9LPHIa6RHXm088irwyKutR16lHnn59Amf8egzhnz6hE99NfbIq9wjL5+6L/LIy6fuCz3y8qkvn7mwqUdePvWVq7nQp7585pyGMGfy6RMFHnn51P2aHnn59Hufum/nkZdP3fvso8884XMO4FNf7T3yst8isWtM64KyDREOdc6/bgQObL9uDF4dCF5RfUz1ih5Pb6G2IuJ7RUelEC0g+AaI8PF+6FgBURfyhq/NyuDtOr0DxE+puqlbIf7St+tw79raGvyGZRBnHIFD8Sr2yKvEI6+RHnm18cirwCOvth55lXrk5dMnyjzyauKRl0+f8Kmvxh55+dRXkUdePvW1gUdePn21mUdeDcGOhR55+dSXz3GoqUdePvWVq+OQT335zPc+/ctnzvEZjz59wuecyafu1/TIy6ff+9R9O4+8fOreZx995olcnX+198gLL5PA82q8TMJ9OxVsPzYGL+p8OKqPGV4msSJuhOqNSiFaQPANEOHj+GH1dMsk+K6cx8O7cuyyiONdReTdYPguLbgcBO92g2VKxVupg+07RuB0SojTicApJ9rZfifUY1OoPygnPAb5l6n6fXZZXqLukqP0YvvnuJxVHqj6oVpA8MR33kWlFRs/xSl44TtDbf03Q9+vUPVTCn6yIW7qMqdEr7SqKzt112AcO0O+VEqM44+uONCf8IseoW5xHEfZlcKB7VM9QArveIZ3Wg9D9aGdKZ5dQDms/2loL7Pk2Dy8Qzjdneyft0ova39CVvx0VEdwJ/tXIU9Kz9bulB+MRmUdCVyKJ86NXNt1ImSI4gXt1RXVt7YoTlHf8sO2+wXYDt8xD19gQ/nP6BQyQP+BMqTynz8c/Mf+EyUrbNsVYdfUB/5TEPKknoSI8h98Ny/0H6sjamzFd1pzx1bYPmoMxy/MpmSPGsei7vamdEThTEiIM4HAyfT4MAHhDPOIQz3FSJ0CTAK/YZnFwccwDmwf9RLS7glxuhM4BQROD8ADX2qzdcxm50lwHsGYJxXGsQvkX4ZkYeLVzAOpp0GpU0H8MkjYtoIow6dv3BdSQl4dPfLaGPGi/GYSwYurrwycVk5B9SalEK2A4BsgwsenoGOpTistbyokU70KQql4IUm9508q9Cmc3glxesfE6ZsQp29MnMEJcQbHxBmUEGdQA+2PlL8NT4gzvIH2Z2hCnKExcf5peSffn9zuz6iEOKNi4kjlUan+/NPyW36cq4uTa+NcPr81vP5k8JVpsS89Wf7Sr0xLuKRSc+kp6ltiUB5qiQPq1pDr92nOCtfM8JKEUvFeqkUtb5gl4NPQEjCUF/s996o/bG/rUTh9E+L0jYmT70++P5L96ZUQp1dMnLEJccbGxJGyz4CEOANyrD/5+Mn3RzIf/NPidEpCnCkxcfLxk++PZH/yfl0XpyH4AfWdrvAU7O/bfFrTmPA2H9jW3l6Ab1W8Yw3QrnXdPnYE7fHlae4tObB91C05+FYZ2Ad8y1kPgmeAyqB8PSLkg+17pGgH5TEb/raZrWO2hLfrxn55I75dt6cbXuTturB/+DaNgYQsFUQZ1GEqnEYEToB4pZPL4+0QVsQeqF6qjxoFBN8AET7eAx1LdTuE/d+6PjQzdn2olihVUa7fUxgH84Ifp6JSXyGq/+bqf+9N+lonTF9x3qmKP/RUqWJtfeKGpeXv652qlPtHvVN1GCFLBVG2JfgNyyDOMAKH4lXqkVe5R14VHnkVe+TV3COvAo+8CnNUrmYeeTXxyKu9R15reeS1tkdePvVV5pGXz3hs65GXT7/3mQt92rHIIy+fdiz0yMunvkZ65NXUIy+f+vIZQz7nEz711cYjr3xezV5e9an7NT3y8un3PnXfziMvn7r32UefeaKxR165Ol/d1CMv/MIHeI7eEeFQ58MDI3Bge1uvnGgXhPtSReeeShVrKwgQPysnPAb5l6n6fXZZJ6D0T+mFevrdtq0gyvDyHfeWM8irH+JFLdVSaxsBap+ujx6XAq2IvVG9CSlEa0TwDRDh473RsVRLgZY3tQq+WQq5lYq3Cg7b94jA6Z8Qp39MnE4JcTrFxOmeEKd7TJyoB45xiuM+CBx1FQXiDEmIM4TAKSBw4IP6+EqJ+Q2vZl2Nrmb1AWUFRFv80Lqt/1Hr2nbXRVzNWlfVLVsXlG2EZIZXfPDw0A0cz8TVHcu/DMniOjx0Q3i4fzB1tgx/p/+IMI5SqBXIFR4LVP3MFgDJ4LGO6P91UTuXT3N3B2WUJvDHaWGfuqdoB3WhiGONiPrdEK9uRDsre0FEe8gDtsMeE6DjqT7NbXkUovr3hVFlXknRFL0Wg8KC+sAXzqzs9h5nXAfLYOs/BGQIJtA8C1P0C0dzd/Q/zASbpMB/DWSZx1rT+IrAx/2Do0NxCnm7IRls/aeADuzrSajr1VAe6hjUAWyb6n9YtwPqC/yf8sX1Uf2eafqO7W/rvxhh/06EDFYus41KIwOu0yGFDK8QMhBZc+iiPZeHWVOhDc8NcZbDVsKW6ETwSbVZbRiPtd6LtYOjA+PY/ykPMD2343nNVHvB7KWzU/QdjwgdU2A2UvRWrmjZzFaqEo2Vscdmy79M0Z5XqWJtAc6eFg/3D5+6dSNkqSDKUkVpOhxj0/D9Q9amE5cu2iuVSeMO2lSywO0VahsQx8wGP81gB2p4dolPh6gzR3gs6nTI1qNw+ifE6R8Tp1NCnE4xcbonxOkeE6djQpyOBA7mleoUYpfwdyGq/wtI7Pir1vD0HvM02yQkA7Ua05Hoj62f7t1mWJdwtWh0DGyoyzgPL0fJOo6oT60mNSPkG8eUdYKwrFFf4c7AA5KxhxzLX/oBSd7pIPRYrBXIFR4LVN3ewzI8suD78Uag/11OB6lHN8cSPKnbf8enaIc9Gx9rRNQfh3iNI9pZ2Qsi2kMesB32GKqd+X8vok1UBMTxYLPhScx4j7wmErxsZE4GxxmR0jpuZFr+ZUgW18icjPBw/3DfpxKyVBBleB1/KoEzlcCheG3skddAT7zMNj7PK88rzyvPaxXnRV07nYjK4Phpzz6oswN8hsq9fg7bD4zAGZIQZwiBE3WdHu8tDj6GcSiZbX/g2I31xn0jKGw/EfWnDyiDF8Mmr05jwjNZ2NYuxRSi+k+DZyOmrZ66j1DPtl9Y5lKAYcsY85pm5my6FXqDNZzj4HtJqfiBc7g9w9/UXCLqMSTLI50NZiAbDARllA2sPIWo/i3ABrORDWB7nD+ouKHwsI8Up6g/EMln688LZYKXESj5xqbAg/qAel6WAm8hwGsM/MH2UyHshH7XmvI7GK/Y7+LOu+P6KX72BvopXrHpQ/CCfoBXbGz7YkXbwPIrRPWXEzaP6+fYrrb+ATHt6imfkHaFusJ2pVbWqHEoyg+gvaxOKlR9m6daiYS8oK3j2LUPwR/b9fAIu1I3VEA5sV1t/aNi2tXqMhN2hbqKY1dYH9uVGr+hXa1OKlT9cbIb4kXl6KgVVsqu0AY4R9v6p0bYlVrljsrDtv7pOZCHoa7i2JW6EhDXrjgPQ7tuhcqi7lWUytEXETbHc36cF1LJR+kt4cU9fC16XAoxViPaK9Q2QMdWS8HL8jHH4LIqVrntbqoPvmCV2/pXEiqnwhTKQ6Uo25+EjxrHviiAHzXu44YX+agxlVK5jxpzh8UMuKrZRqQQIyDaK8QrII7BMspV4fVB66rU7ZBwhL4a3boIXSjOSxypmb+tb2egqWYX+MWStv6dEaNQ1CzYbDhbTyPqw5kxvk0W9mEaKoPtxqbAgaMjzPx4dLT1H4g5OlrsTIyOUEd4dNwBlBUQ9bG+dyLq7wDq4FWlnUAZDmmo42kIJ13qwP5P+Sl19k3Nxvur1P1Nd1aG/Qv6xFRURp3NUb5g62VipQT2B/tCVCyZDesmynegbipUej+BcTkV4UTlJbNF+QJcXbCrYaWAN8SpVLG2LhaHuvpsebcExxk2mwllshs1VFv+ZUgW16G6JcLD/cNDdStClgqibAvwG5ZBnFYEDsWriUdeIz3yauqRV6FHXm098ir1yMunvtp45OXTv8o88ir2yMunTxR45BV45FXukZdPn6jwyMunT5R45OUzr/qMbZ++mqt51adP+MxfPmPIp0/41Fdjj7x86quZR14+fdWnXPlxO3v68jlf9Zmjfc4BNvDIy2f+ylWf8JkncnUc8nkO47OPLTzyyufVf0b+8mnHzT3y8qmvXM05uTovLPLIy2c8+hxrfdoxV+erI3JULp95tZ1HXj7zRK7maJ9y+dR9ruYJn3PyhnBe63Pcbp6jcvk8r/VpR5/x6PMcxue6r09ePn0Cx1AQ/g99pQv4vR4oh/Xth3JKCRkZ125n2Wux+PUvkHeRI+8A8VOqrpwK8S8n8KxcZSnKKlX0duT19581+vNHPw5QeysLPobvTygm6lPXtK2u4HUQhq5mUPdwWGxbBn2kCJVBvVgZzL7rhLryFTvKF0d/kH8FUR/fKxbXFi1U/Xxq9WTvi4G88VNSUR9ChjjUU1LjI3C6J8TpTuBgXqk+oIXfF2LrPxjmBep9IRMJ+boT8tn6UU+fQHko3eAnmyB2kGJvcfAxrDcoQ3+EM9kjDrzXajTCmeoRh3qKnbrvLikOvK8KP824g0cceI9WR4Szk0cceF/ghghnZ484O4M6w0A78/+uoIz6GNt0Qg6bi2eA44xcXBinH5B/GZKFiVdzf9cMhIf7h+/vmknIUkGU7Q5+wzKIM5PAoXj19Mhr1/B3M1Xf1vhjjrsSOLtG4PSOidM3IU5fAqecaJc0RnYFdXojnBkecWDM9EU4Mz3iQD9YDeHM8YgzB9TpgnDGETKY+cDva9QeNzQXlBWgtmazT+IXovqX9KptZxcwrA9OB9hQRtgezsemE/3AeEUhhs1/80AbRj6qc31KIV7pdFfSpm5fpoOyOLqz9Y8EumuMdAf7tauqWzYflM1AZQtA2UxUthCUQR6wTIE+wGPY52B7W6+caIfHq0XgOMNeRXFiA/IvU/X77DJeLUJ4sO9mw+dui93wCi3eUgKPskNzResU4lteNsaoPDsPlcHcuBCVwXy2AJXB+F4P/IY8U/UJv4lsV9Ae+zeUbyIqg3P6yagMzsPx8xBw7oyfxYF9xvNb2+cixMds+FwM+kyBqq8XrAMY/zhWF6ThNQHxgu0XoD4sQH3YlehDBuM69jxUIq6pOLN9X0zIUkGUQbvBMoizmMCheM33yMv6vx2DrO+O7PD33ti/f5taXrCf2L/Nb/wicVt38za1bTYJf+Pzaji+U/Mh7HfziTLD//5wEboZ0V+YJ1x0B9vbelQOGoxwqFw3IwJncITM9n/44ne4BjIBlMP6O6E5kuOYNMfqH45JOO4PcuQdN+4t/3ICz8pVRpTFWdctfPjCe2+b9934ALW3suBjeG3rYKL+YKK+1VUVaJ90XddiU+u6B6EyuLZaFf6m1nUPdpQvjv4g/wqi/lBQj2MLitcET7xgvPngNdWRl127Xgra45wE5VyIcKg124kRMsP2tp7PNVhq3jUIycx92xxsPxWVTSRwbH/gvAWe4+3ehpYHnuPBOQQ+x7P1+3eobTcfnePFncvidSKuPXvHxBmeEGc4gZPptXu8TrTIIw70jeEIZ7FHHDg+43WipR5xYP7A86+phAzGZ6tQHBwEyqi4tLYpRPVfrqxttzIiDqCMsD0c32YQ/cB4R6A5kOPYRq4TwbE3SndHId3NAGWU7nAOsfVvq6xtdyzSHcTGsQ31tAiVwXEJjyVQV3hOSs154LGoeTTWG2xn9ZtwrhR7nagq/F2mEvlHzflkFcKDfTcbngtWu+HVrBOtIPAoO8B1oiqACfEtL7xOBPMsHlNhbsTzOpjPDkJlML7xOtHUNH3CaySUfDZ27LrGhZV/703sXIjORyHeFFW3DPrtrqqWxyUo/qAe8LyLWmOAx6LmXYuQPD7GNeo8Gc+7uOfJsP1iVLaIwLH9gevUMGde34aWB+ZMuIaFc6atf2Jlbbsbkc0oPVP2xPMurj17x8QZnhBnOIGT6fkQnndlaj6E512Zmg/heddBHnHgWIvnXani4FEUBweDMioO8LzL1u9dWdvuiYg4gDLC9nDetZDoB8Z7Fs27qkCbpPOuqvB3Ot09j3S3EJTFySG2fuvK2nYvMXIInEvguVUVKFuKyqpBGeQByxToAzyGfQ62t/XKiXZWv9ZeK8DxTMy7LP8yVb/PLvOuuPMg27+Vbng1865DCDzKDnDeBXUK8S0vPO+i5hRUbqxGZTCfVaEyGN943rUoTZ/wvIvyfcwL3mtMzbPwdYMvwXWDz9E8DcY5jOVla9atR41B1gZQN5m4PoXXoh3X3Gv8mroOTM3DotbFKdsvAb9hGcSJu5450yMva1fKx/A8jHuvQu+YOH0T4vQlcKKuncbxLQqH0k2m50f4PqlMzY/wPOxgjzhwTMTzsFTrwM3WrD0O82rcdWBb/6Z1atu1CHlS52N43K8C/BRRv0sKvNVDjITrDeQ8zPJKp7s2SHfUuVyU7mz9M4Du2kXoDsd2FSiLmmsdhMrgeA15wDIF+gCPYZ+D7W29cqIdHq8c5ymx52GWf5mq32eX8WolwoN9Nxuehx3ihlczDzuUwKPsAOdh1NwL8sLzMJhn8doGzI0rUBnMZ9WoDMY3noctTtOnqHnY4hS84s7DbP0+KG84zpvIvGF55edr8eZrZhsK6uEy7hxrhkde+flaLQ4+lp+v+cFxma9N8DRf2xTMOSYLzNe2z4H52o6e5mtrAd3tgnRHrW1QesXztSpQhudrUFd4HLRlSsVbN6PWVxrKuhk1Xq1K62bUuhSVG6tRGcxnVagsar7mY90s7hoXxkw1r8PXQW39/das5bkvWjeDcsH7we3Lc/LztVV/fc3alXquAc/XZhI4MyNwehMyUzh9E+L0JXAy/dwenq8t8IgDYx7P1/5p1zlTzTnOQPmNus4ZNeew9e9au7bdvyPma3Guc0bN12z989F8rQq08X2dM5XuLvQ0Xzsf6O6SCN3h2IZjI84vVaAsf50zf53zL+bhnsqzeH0N5sZqVOZ6nXNBmj7h+RqUb0EKXnHnYbb+XShvOM5jyLxheVH3t2H/X+CGG3u+ZvmXIVlc/Z+yHfU8APW8Hn5WFc7zhoJ6uCxqXkidL87wyAvnWsgbz9e4z5z1JmSmcPomxOlL4GT6fQ54vpapeSGer2VqXojna5m6zy7ufO0NNOdYCsrizDls/S3BnOPtiDUivJ6Dn2nH9bukwPsA5V3H5xbJvIufUUz1PMCHKc7l4z4PYOt3Brr7BOkOYuPYhnrC+QWOqXguB3WF7/fhnpPC9qme7bTlZkv4/Ebs+ZrlTz1L6jJeUc9JUPfwJjx/qJmvVRN4lB3gfA3qtAr8trzwfA3mWfw8AMyN+J5/mM/w2gmM7zjvjYB9wvM1yvepNS74LB9e46LGpVKijwwbNYvrg5Z/maqvbxcfpNZXqPHavBe2c/g7/BzxiNlLxy+bsWDuzG1mL18yZOGs8dP3Wjp3+oIhs2btNXvJEig0BIIvcoXlcMN17O95xHHII91LLziT90VpeOEXaMD2OAEuTsNrEuJFDW74/yJVX0774oNGMfjAQEslF35YjLr4EpXkoXPujXjB9qkWXFLx2gfxoh4gx/8XqfpyYn1F8UmVQKFc+yK5qkBZNeK1Ig2vPRAv2H4F4rUyDa/liBd1Eo7/L1L15cT6iuJj6JA0cu2H5KIWBCyvQ9Pw2g3xom7esbwOS8NrNuIF28O28P8iVV9OrK8oPoYOTyPXnkiuw0DZ4agMthuLcLgnabC91EnaWIRzuEecw0Gd1UA78/8RoAzm1nLimMWwg/+R4HgmFkws/zIkCxOvZvA/EuHh/uEFk6MIWSqIMjiuwjKIcxSBQ/Fa4JHXEag/qU7CtmhbF3MmKItzElZz4gROwrYMeVJzj8NRH6l5zEwCL0D9KibqQ36FqP6IUCbzopeScEJDxciCFLLAMdNsUQsdpap+fGUiRiz/MlXff1xi5AiEh/uHY+RIQpYKogwvWlCxeCSBQ/Fa6pEXvmiaKkameIqRH9eqbbddDsbIzh5iBM6h4sSI44Wn2DGCLzwljRFqLhsVI0cQslQQZVXgd6pYPILAoXhVe+QVN0b28BQjb4MY2TODMVIV/h83Rmz9ZR5iBM6b48RIFTieiRipCn/7ipEqhJcuRqoJWSqIspXgNyyDONUEDsXrEI+84sbIIZ5i5FEQI4fnYIwcw4wRSvZMnHtR61e9wO9UOqJ8t4Jojy+sziBw0vnIaW1peSgfMb/t+Tu+sH4z8JEzInwk6oKn1IXVAQlxBhA40hdWM3XBcwDCqfKIUwXq4Aur1R5xYK6M+6K1a1AcrABlVBzY9aJCVH8aiIPrI+IAygjbwwurM4l+YLybQoyENx6RF1Ytr3S6u8XTODMQ6O52Rg6Bc3qc46E+qlAZHJPxui+1vgqPYZ+D7W29cqKd1a+1F1y3ZNgr9oVVy79M1e+zy1wr7oOftn+Hu+HVXFilziUoO8ALq1CnEN/yirqwOhOVwdx4CCqrAmUrUVk1KMMXVmem6RO+lkbJF3WDTbZuMpvphhd5kxnsH57HVxGyULbZH/yGZRCnisCheM3wyMteY8jfZFb/WC7MhfBNZlUecapAnVybC33BmAuZDY/ntv7r7WvbfS0wF/ohB+ZCP3maC90NdPdrfi4Uta0yc6HD3PBq5kLUNWzOXIi6pv1PmAsVEPLBejD2qPUkRRwLIvAwRiOi7QFIblg2BWFw14CmEPJmcF23IG58VYW/c31dF/oALIM41QQOxSvOnCfhDYyx5+OWfyZvYJwCjuH8VuWGVxBlhwUReCvc8BpZvJUEHjXXNfm0WNW3YRX4DX2CuncL2itVzENszv2UVWl4Rd1PWYV4Vafhhe+nhO1tW7w+PyT8UJTJwxu1q1vH3gvYD9TpE/7GMQX18Ne9JKhe1AvtoX0yEXuWv68X2lN2SPWC+RIV7SNV4Heq+0ypl2bF8dmoF8RT8nBtSt1UbuoNjai3mKhHYZn/4X3P+KFBW3d4yMPouc+Eun2EuIvAb1hmNmruj8eVRYQsFE7vhDi9Y+L0TYjTl8ApJ9oFKfYWBx/DOJRuotbHXHGgP+O1gXkecaBP4rWBTK114LWBGYQMJmZ2ald7HMda1HiBH3rfFZzf7oo+JAjjAI918MV6iqjfJQXe7BBD4sV6qXQ3B+mOegAtSne2/lCgu3kRusOxHfWAK9THPFRGfawmQGUK9CHqATTqZRAN5QG0qBc8VbnhiT6ARo11cR5Ag/kMP4AG4zvO2kDcB9BsW/NwVXirMHi4apvZy6dMXzB31vSlcxctnDB78bLZS5YWAs4YHfZCKToTW41APngL0P+NUNlUVD6eqAe3qNHUxyexIT+l6Mix/H29aoB6oivqVQNLCVmoV1UcCH7DMoizlMCheC30yMv6Tf5VnvWPYZyoV3ku8ogDR1E80/unfXow1WzlHDRboa5kRM1WbP33wZn9+Wi2ArHxnfYzAT9F1O+SAu8SNNODo0/SmZ7lle4q0GVId/DMNc5VIFv/YaC7K5HuIDaObagnnF/gSI0/jwN1BXnAMgX6AI9FXbHFeqPOlhLetRB7pofvWnD0j8i7FqhVxISvvqiZ6VEzS8oOcKYHdUo9iRv1Ks+oTw/OQ2XUGQaVg+K8agD2ifOqgckEji2bA8rwJ3LnE32Gn7m39caBepMRj+mgbA4qmwvK5gP+EzrX7RuMGxzXMHZxXEM/xnEN7Z/q6fJUdzpavoWo/lMgN72D8h3lo3A+3QjJUEXUh2cn+EyWemVsFK8ZEdjVRP2qCGzqlXdYFqVSx1o5wLJlVjel4R6OeZwcaFYoW02oxYEy/FUB8E1lJ+qsMUpXlJ2oK2VVqAzmmBmojHpNDZVjcP6hXqND+SeVb+B4bPNNulVoPM7PS8MX65MaO6gxOGpFnYp/nDdg/OO8EfdTxDhvVIX/Q1+lXhmPrwZ9ieZn0EeSzs+qkYxwfKP8O9XrTIvACts3KXJbEZPn9+AqQmMQo0rVzQXWjglzQSGVC2C841xQBcoKiPrcvInjFtpmJuIVd6UHx1kxUR/yK0T1VWhX6kkhmI/wJ5WpFWnunMfGg9F7x1AOPB82v+F5REn7uv2mns6BOQf7nq2/HvDnxuFvn3kDv2KWejVt1JgT9Qlz2L6hfcI86u6Hajc8kU+YS+c1qKc4eQ3Wt7mFupMNxzP1qn4qR6T6JDuFR12FhzkiKkdSd4yku8J+DlpHgPGF45969SAV43E+s4vHDSqH4TEb1u8FcthgpBvKl6PmsSuJ+vCuHXwFDPr6yhi8FkRgU3fTrozApu6mxbIolTomqVi0usnE+UY1rAD4prITrB9HV5SdKlB9qBtu7FajMupzQ1TsVqnaPg9OMW7DflDrG9R8AI75JWjszvTV3lRjN7UGDPniue/WIHZ3QrqpUrVb1JVSnD9g/SpQB58zUefrUbwWRWBH+S+FXQXKYFuMjeW07ajYtbrJROz6PD+gdFUF6uBzfhjXOAbjXnnG8Rn3yjMcd7F/LiL6EXfchXd44Ls/qGuGUb5H3WkB4xj7HnWnBRX/UWtrOG9AH8V5owqU4bxh7Ql9FdbHawW2/vzQFgnv+CXXClYgGauADJR/43MrW78a5LaFKXJbEZPnYnCeGrVWYO2YiTl1FaiAc0E1KCsg6nPzJo5baJtUn1aFvKi7UHGcFSt6zRJ/qtXWPyBirQDmoyokO8xHUXfCRH1yA64VnIvWCqjPCZl6K5HvUev6MOdg37P1LwD+fBiab/jIG3jdsgqU4bfV2jKlov2sgmhv61H+bPNAwnPp2GsFln+Zqt9nl7WCaoQH+242T09K1KwVUOc4VQQeXCuAOqWeiIhaK8hkXou6HpJOr/jcHfYRxzPMETgPwBxRhcrmReBRa2EwR0TlyLhzFnhH705orQDGV9R1MRz/VaAs6twazxtWAFmoOY/li58EvhzksDuQbihfjprHpjtfx2uf1Pl6FK+odYpDifqHRGBDuWBbjJ0qJqlYtLrJxPkGnBfgWIxaozFbHF1RdqpA9aFuuLG7ApXB8b0KlUHfrla1fb4jxbgN+wHHbRy7qdYPV6KxG8qNzxWgL7g+NQ7jGOo31X0FcByA9R8CsfsK0g31dvEon6CemIZPQeMclurNMal4zYzApt5cc3gENpQLtsXYWE7bjopdq5tMxC6MNxy7lJ1g/Ti6ouxUgepD3XCfYD8UlVWBMrx2WA3KDgF9fiXGGn3c+wrgGj1+iwSVC6N8L92YhX2PGrOo+Md5A8Y/zhvQR6tQGbRtNZIdv5kA18drBbb+h2itwPFt2ORawRFIxsOADJR/43MrW/93kNs+SZHbipg8P4+5VmDtmIk5NYx3nAuicrDZuHkTxy31xuMA/Q95QZ3itQKro2KiPuRXiOr/FLFWAPPRYUj2uG/UwPOMalAG1wrahW/QK1f1YxeuFfyJfA/mNJwvzIZ9z9ZfG7yxr1H422feqEZlMA/guTU15lB+Rl0rgmMobmfzQMI32sVeK7D8y1T9PrusFcR9a4yPrwgYot6QT9kBrhVQb+mDvKLWCjKZ16Ce4uQ1WB+fu8M+4niGOQLnAZgjcP6oisCrBu3gXNzmiKgcGXfOAs/Pv0BvqYLxheMfxjiOf+jvVagM6hD2D/oNlcPwmA3rdwY5bADSDeXLUfPYo4j68AsQK1F/oK8fFYPXIRHYRxP1j4rAhnLBthg7VUxSsWh1k4nzDTgvwLFI2Yn64kCUrig7VaD6UDfc2MVfLKkCZTiuq0HZ4aDP2D+j5vlmw7G7kpAVzgdWtbWCLUHsTka6ofJz1FoB93wd5rAjYvCKOl+L8l8KG8oF22JsLKdtl0trBZSdonIspSvKThWqflzjGJRcK8D+6Wut4JZ/+FpBnDEf+iqsj9cKbP2ZoS0Sfl2OXCs4EskI1zPinNfb+stBbtstRW6Lu1Zg688N+WRzrQDGO84FUTnYbNy8ieMW2iZbawVLgQ2i1grwuqbvtYJ/xVwr2D/FnIO7VnAm8OeDBNYKYB7AawXUmEP5GbVWAMdQ3M7mgYTn0rHXCvAX+RzXJiK/yBe1VpDkq5yGqHMcyg5wrYA6F4G8cnGtIJ1e8bl71Ffc4p5v4PxRFYFXDdrBufi/MrRWcI2ntQLo71WoLOoLdUcCWag5DxyzYf3zQQ67EemG8uWoeayP8/UoXlFrBccQ9Y+OwIZywbYYO1VMSq8VwHkBjsWoNRqzxdEVZacKVB/qhhu7+AvAVaAMx3U1KINrYDdmaK0AzweoZxuonBAgeWH9meAY995RfH5SBcpWoDLYbkYKHJgToE1SffHp7phzaoud0N+bZfo+mnTng/jZGZi7q1AZ1DF8HgmPDfAZl9MYXxisUvVlpc6Tse8Vp6hv+RWi+k8Rc/Yof456/ovrz7APSf25CtSZjfpq678o689Ns+3PVeFvyp/xmhDlz4Gqn8OSrOcckoP+/0ED8v/Pctz/qXOJKP9Pt0ZSFf6m1kiy4f97MPz/iAhMyv9t31L5P1xPhPV/i/B/Sr9R/p/uGmGU/x+FymC7GSlwoP9Du2P/t/UL1q7ta5T/W+xM+D/UEfb/qPMms3HPdfA1ATh/j/J/fL3Wl/9PSfiF5Sj/t31N5f+WH14vbwV8Avs/FYOLwLGk17pgH45EZbDdjBQ4qebz2P9t/bYx/d9iZ8L/fZ6/pltnwPN5GBtR/o+vc/jy/y2Q/8Nn3PHa0FKCR9Rz7FHvrrD9qAKyUDFi+Rai+j3XBn1Yuy7PalW7FSDZzZaJc94oXlHxuZKovyICG8oF22JsLKdtl8Hnv4oy/VwrpSvKThWoPtQNFVtRz7hXoTLqOfaod1dQ/kk94x43duEz7h+uWZfvQWn4Yn1GvY8QYlHxfzAqg+1w3oj7rBrOG9C2OG/A632KqI+vRdv6Y0JbZPKrldi/4bXoKsADX7uz9WeC3DY+RW4rYvKcGHOc9fSumsJMv6smXd6sCn9TuQC/I4l6N0QVOIbXVK2OihV9rovfy2Lr70zM66h8VI1kh/kIP7u/gMCl8hG8Fl0dyoGf0TW/4bXo2cj3XN/FeAjw593D3z7zBn4fFswDkAf2qSg/qyDa23qUP9s8kPAZ8NjXoi3/MlW/zwy8ICr+qOd0E+bNmmvR1DohZQd4LRrqlLpeEnUtOpN5Leo9Pun0iq8Nwz7ieIY5AucBmCNw/oh6/x7MEVWgD9Uo9tO9PwfPWRYR/TB83wjnLFSM4/ivAmU4/qG/43kD1CGeN6wEslBzHssX30d0NMhh5yDdUL5cBY7hsetQoj5cB8fvD4K+fmgMXlHP10c9K0phU8/tYFmUSh2TVCxWhb8zcb4B5wU4FtNdk42jK8pOFag+1A03dleiMuo5dip24fr7OSnGbdgP6j0b1HwAjvmz0dgd9c67uO+gwe9UgHGN309DXWOAecbyxXP+y0Ds3o50Q80jk7yfAp8zUffvRvGKehdfuryBsam8gWVRKvXY+k9+PwU+54c5EN8rAuMz6j1SeI2BencK9e6kalXbZ+yf1Ltl4o678N0yF6K1giqCb5L3QGLfo+bNPsf1qHex4LyB54e4Pl4rsPUfRWsF0EcYvk6uFeBxfCWQgfJvfG5l678FctsTKXJbEZPn0zHXCqrC35mYU/scx9PlTRy30Db4/JEaS6FO8VpBVfh/saLXKfD7l239VyPWClznC9T6HZWP4FrB72itoArUg2sF73hap1Lr1LZ7H803ILZr3oiaW0Me2Kei/Iy6NxCOobidzQM2r0BfzMRageVfpur32WWtIO65e8K8WbNWQM3DKTvAtQKoU4gPn0s2m3Reg3qKk9dgfXzuDvvosh5A5Y+lEXgwR8C5+O8xzjfizlng+cYZaK0AxheOfxjjUc/J4nkDdT6Hx41U9zTBMRvWLwE5rO06dXn6fqdWFeoP9fxpFK/qCOx0z+hWIez8O7Xq1qfsFOedWnFjF68xwPEdxzX0bXh/OfbPaqIfVeAYjt0qQlY4H6DWChaqumWQR5z1ACrm8TyNmvsuImTFc99OIHY3Rrrxvc4X53w9ilfU+Vq6dT6MnV/nq1ufslOcdb6FoCzq+9hR8VmNyqBvw3EX+6evtYId0VpBNcE3yvfS3U+Dfa+K6B8V/zhvcNcDKF/HecPaE/oqrI/XCmz9rUJb2Pmn43ukyLWCw5CMcD2D8u9UzwTvAHLbyBS5jfuc8TYhH6H7t9nPgkblYLNx8yaOW2qMD9D/kBfUaapntYoVvWZp+eFz5inABlHf2cPrmjAf4TUQ6t3uVD6CawXLQznwuY75DdcKdkK+R63r27Zmw75n6x8A/HnX8LfPvIHvcaLWjKLGHMrPqOu8cAzF7WweSHguHXutwPIvU/X77LJWQMUfdb6TMG/WrBXEff8eXCugzkUgr6i1gmogP6zrI69FXQ9Jp1d87g77WIXKYI6IuoaB80fUu/phjoBz8eUo9qtU/X7EnbNUAb4T0FoBjC8c/9z1AOrcGs8bqPfJVoM6cMyG9VeCHHYa0g3ly1Hz2HTn69WoP9T5ehSvJM89YWzOO7WomMzg+yaKMv3O3XTv1LK6ivNOrbixi995R60HULEL18BOSzFuw35Ug2M4dqsJWeF8YFVbKzgPxO4N+bWCethYzvxaQd0yybWCGzK0VtAmv1bAXiu4dxVYK3gZ5LYHPK0VPJxfK6gpq0K8qghemVgreC5H1gq+j7lW8IqntYKfgD+/nl8riNryawUIL79WkJ21gu8ztFbQbBVdK/gT5LCWlXV55tcKUsdkfq2AF7s+1gqwf/paK3gFjd2wT1H3IONnBKtAWdJnEOA9GZYvnn+0r6xtt0FlXZ4wTguQ7GbjPoMQdf/jITF4LYzATrdOEXXvFV4bwHOXhvYMAn4XSNQzCHAsW4jKqOeAkjyDgP1zIdEP6pnCclU/HhYCvs+3qcu3iuAb5XvVRP0qUCfqvSN4TIHtcN6A8Y/zhvQzCJtX/r3P5WcQJlb+vTc2HlxJ8+Q+gzA05JN/BiF7zyCMrfx7T60VwHyE1zlgPqpGZS7PICyu/Pt3umcQJlfW7TfMaThfmC3VMwhLK2vbTQt/+8wb+WcQ8s8g/MU83P9Tn0GgrqFROQLnD5dnEGyOiMqRcecs8BmER8M5CxXjUc/64vjnriPgcYP7DML+lbXtjqusyzP/DELqmMw/g8CLXR/PIGD/rCb6UQWOxX0GAc8HqGueVE4IkLywftT5Sbr3qeHzk7jvU1uUAgfmBNi3ieG+ENU/o/LvvdA7wIq478qpAmVx1kGi/ATqhJob4XfrUM+gUWMDvPZ9PRobAlAP+1Kg6ssaEH2rSNGe4gXt0gX8Xg+Uw/q3Vf69t/MTqE+GXceUgzYK8IC8HX1mDOyr3aj5JJw7UXhmKyPKCmPIcv+Ae7a54Nc+TQPU3sqCj2G/LCLqjyLqW10VI9krVaxtGyp2LbYtw32HZTD+rAwmZrtOqCtfkaN8cfQH+VcQ9ceDehxbtFB1fQH6u43XGaBsIiqLeg8md10Z5yuYt+G7PfF5uK1/b2Vtuxcq6/Kk1tXhuIV9kzqfhPPWOO+bjeI1IwI73bp1nG9fYlkUIadtJz22VcMKgG8qO8H6cXRF2Yk6D8PzromgbAYqizvPw+d21Loy5Z8ziH7EfdftDMD3KLR2TM21onyviqgP4xj7HnVPCxX/OG9UgbKk68o4zqCvwvp47djWf7fy733CNR5y7RhfR1oBZKD8O+V9OZV/742NP6ikeXLv9fko5JNunuvpOlJhpq8jpcubOG6j1hOocxqoUzzvtDoqVvS9Cvj97Lb+t5V/76m1Y5iP8Lo3dc8GlY/wu/dgzMC149U7/P0bn3+Y33Dt+JdKVaffVaCMOhfBvmfrr9mhtt3vIU+feQOvHcE8AHlgn4ryswqiPRxDcTubBxK+Czb22rHlX6bq99ll7ZiKvypwDM/PHfNmzdpx3Pva4Nox1Cm1jhy1dpzJvFYFKsTJa7A+XsuFfcTxDHNEFSqDOQLnj8UReDBHVIM+2BwRlSPjzlkOAnyr0PpAFaiH4x/GeNJ1ZTxuUDkMj9mwfiXIYX2QbihfrgbHuPdIR903e1gMXlUR2OnWrTE2tW6NZVEqdUxm8J7Pokzfy07pirJTBaoPdcONXXyPS9z7WFaCPmP/rFL1+0G9b5uaD1QBvng+MJXgS917Gqj6eSjO2jH1fm2oD5wT4NoFnhPAdhNT4FBrEErVXzu29QeFek43p7bYmfB3qCPs71TOjvrmT7q1enx+Tb2nnPJ3i0ndgzwVyL47GhvmEPwDVAZlnUP0rYJob+tROIMT4gwmcDAveD44EfDC82dbf/fQz+w8aD7gy/CfOVj/lgfkvdiRd4D4KUXPWy3/cpU6nsuIsjhr1IUPX3jvbfO+Gx+Vb6Keu6PyzWCivtUVjA2GrmZEfW+KWqNejMpgnFsZqDXqpY7yxdEf5E/NM4eCehxbULwmeeJF5f4kvKY68rLr8DAPzke8qLEVruVZnTQj+jU1RTtcL9WaO8Sh+C9Esk4kZJ1I9Ju6597WKyfaBSn2Fgcfi7qWMQjJTK3BzoiQGbaPGusGof5MBmVwbWWfDrQ80CaTgTx4bLD19+lV226/Dqn7j8+toMy9VV1ZuPbsHRNneEKc4QSOT7+h7Nkb4czxiAPnB8MRznyPODC3rIZwFnnEgfmsC8JJFQfHd6g9DvNlqjjAc3Fbvw2Ig5Mi4gDfN7IY8FNE/S4p8P4VYiQca8nrCHi+nEp3Z3jKIb/2rG33b0YOgWMhnlNDfcxHZXDehL9FRJ2zUNduo9a/y4l2Vr/WXvDcJRPrs5Z/marfZ5f1WercjJpb2P5VueHVrM9WE3iUHeD6LLVuAHnZGItzDRbmRrwOCvNZ1D1L64HfECNVn+x6RbMI+coJXti3oOxc3UN+Vk54DPIvU/Vj1MW3qHNcai6ExybYlrLNJuA3LIM48wkcitdEj7zwde1szIX6JsTpS+D8U+ZCfRFOQ5kLPd2h9jjM73HHc1v/32A8fy7kmcm50MshRjbnQq8g3bnOhQ4Gunsd6Q5i49iOWl+EcxQ8F4K6wmuc1HoUtX5LrXFivcF2eLxynJvEngtZ/mUqkX/UjFfUHJEarxLO9WrmQlUEHmUHOBeivhcIeUXNhSajMpgb8XwH5jN8b3fUXGhymj5FzYUmgz6Y/xeE/+8OYuebDn//Lifwpqi6ZdBvd1W1PL5H8Qf7iteguPMB2H4+ksfHeGNlhvfJ4zWoBYTMCyJkhu3xc/LzCRw8TuOcqdal5YE5E47xOGfa+lOA3QvWTd1/nPugzHjexbVn75g4wxPiDCdwMj1PwfOuhR5xYBzgNahMzYfwvGuxRxzq++7p4qANigPqejCMg1TXg3/sUduuXUQc4DWPpYCfIup3SYFXGWIkHMfJeRdeS0mlu3U95ZBXge46M3IInEvg91TFfV4B3yNErbVQz1xFPb9PPdtl9ZtwjSb2vKsq/F2m6vfZZd5VhfBg382G513Vbng1864VBB5lBzjvqgKYEB/e12U2Ks/iMRXmxqjnuPH6FIxvPO9akKZPeN5FyVdO8MK+BWXPxBqU5V+m6seoi2+le58OXoNaRMhC2QavQS0icBYROBSv+R554TUoeP0Vz4Woa8FTI3B6x8TpmxCnL4FTTrQLUuwtDj6GcSjdZHrOhdegMjXnytYaVKrxfBoaz6k1qKjx3NbfH4znO0SM53HWoKLmQrb+rmgulMk1qFS6m+FpLrQz0N3sCN3h2I67zhQ1T8pfj4vc/tHX42CejVpfwPMdmM841+Pmp+kTngtB+ean4FUIjlFrToWo/kFhfJlYOyD8TcU5vE+1sGPdevl5WN22lO2XgN+wDOLEnTvN9MgrPw+rxcHHOPOwTM2P8Dzsn7YmRV2PNDnm7BhrUjB/4rmErf9n99p25wmsSV0suCaVSneXxpiHRenO1n8X6O4KxjwsvyZVKyc8Bvnn16RSr0lFzcNyYU2Kkg/zijsPs/XvQ3nDcd5E5g3LKz9fizdfM9tQUA+XcedYMzzyys/XanHwsfx8zQ+Oy3ztHU/ztZVgzvG+wHzt4xyYr33qab62G9DdF0h3Ufd/Qj3h+RqcR+H5GvUeywCVKRVv3Qy2b2jrZtR4taqum81HZTA34jkZzGepnqU0vzOxbhZ3jQtjpprXTUXltn5Zx1qeJWjdDMo1B2Afn19f+8esr+F7YSFvPF+bSeDMjMDpTchM4fRNiNOXwCkn2gUp9hYHH8M4lG5wnPrAibrX/p92nTPVnKMrym/Udc6oOYetXwLmHD1Cnpm8zrlhiCFxnTOV7noj3bnO1z7pVtuuX4TucGzHfe4wf50zf53zL+bhnsqzeH0t6rlD1+ucc9L0Cc/XoHxR75Cxx6LmYbb+GJQ3HOcxZN7A96VBebD/Sz8bOdkNL/LZSNg/PF9bQMiCz/HMNhTUw2VR80LqfHGGR14410LeeL5GPU87IwKnNyEzhdM3IU5fAqecaBek2FscfCzqeSs8X8vUvBDP1zI1L8TztQUecah5Tro5xwI051gIyuLMOWz9o8GcYxGac1D32mI8OF+bT/QD4y1FeReOE0nzruWF8y7W3d4pzuXjPhtp6y8EuluOdAexcWxDPeH8AsdUPJfzee8tbI/1Rp2LJHwfWuz5muVfphL5R814Rb2DinqeKeH5Q818jZo3U3aA8zXqHWKQF56vwTyLn42EuXERKoP5DK+dwPiO854I2Cc8X6N8n1rjsvWoNS5qXCol+siwUbO4Pmj5+3qfBLW+Qo3XTTR1Dn8vWzp3wdyly0fMXjp+2YwFc2duM3v5kiELZ42fvtfSudMXDJk1a6/ZS5ZAoSFQU3AclsMN17G/5xHHIY90L8fgTN7np+E1AfGC7XECXJCGF35BHDW44f+LVH057cdmGsXgAwMtlVz4wXnq4ktUkofOuTfiBdunWnBJxWsfxAu2xxcX4WIRlhPrK4pPqgQK5doXyUUlTMvr4DS89kC8Uj2kbqgqDa/liBd1Eo7/L1L15cT6iuJjqDqNXPshuapAWTXitSINr90QL9h+BeK1Mg2v2YgXbA/bwv+LVH05sb6i+Bg6JI1ceyK5VoKyQ1AZbDcW4XBP0mB7qZO0sQjnEI848OXnq4F25v9DQRnMreXEMYthB3/4cvZMLJhY/mVIFiZezeBPvZCemoDavh9OyFJBlMFxFZZBnMMJHIrXHI+8DkX9SXUS9lTHupgzQVmckzBbfyo4CXsWnYRBHR2C+kjNY2YSeAHqVzFRH/IrRPVfCmUqUfU/cnMI0Z7iDcfTqIUOHx+yhvysPPAY5F+m6vuPS4wcivBw/3CMHEbIUkGU4UULKhYPI3AoXgs98pqJ+pMqRj7wFCODQYx8lIMx8rmHGIFzqDgxkuQlSJCflQceg/x9xQg1l42KkagPc8AyfGM9FYuHEjgUr4M88oobI795ipFuIEb+zGCMWH3HjZGaGxk7/b1PEiNw3hwnRpIshkF+Vh54DPL3FSPUC+KiYuQgQpYKoqwK/IZlECfq4jjkVe2RV9wYadWpLqZrjLQEMbJ6yDOXYqQdM0Yo2TNx7kWtX/UCv1PpKOrDKr2I/lDneL1Qf1L5SOdOtDyUj5jf9vwdX1hXwEe6RvhI1AVPqQurAxLiDCBwpC+sZuqC5wCEs9QjDhxX8IXVgzziwFzZBeGkioPNURwcDMqoOLDrRYWo/vlda9sNjoiDVGuW8MLqTKIfGG+rECPhjUfkhdWq8Hc63Y3wNM4cAnS3NSOHwDk9zvFVoGwpKqsGZXjd15Yp0Ad4DPscbG/rlRPtrH6tveC6JcNesS+sWv5lqn6fXeZa1Fox9eBnJj+QStkBXliFOoX4llfUhdWZqAzmxmpUBvNZFSqD8Y0vrM5M0yd8LY2SL+oGm2zdZDbTDS/yJjPYPzyPX0rIQtlmf/AblkGcqBdKQ14zPPJaGf7O32RW/1guzIXwTWYNZS50IGMuZDY8ntv6ncF4XiUwFzo0B+ZCh3uaC5UC3R2VnwtFbavMXGilG17NXIi6hk3ZIdVcCOJbXv+EuVABIR+sB2OPWk9SxLEgAg9jNCLaHoDkhmVTEAZ3DWgKIW8G13UL4sbXqrKuC30AlkGcuGuxceY8CW9gjD0ft/wzeQPjFHAM57ck/pXKDnMi8Byv5TWyeFUEHjXXNfm0WNW3Yap70Kh7t6C9UsW86/2US9PwirqfEl8HTPdRGXw/Zaobl2HZM+H8xeThezrVrWPvBXwA1Lkv/I1jCurhr3tJUD3q5ScJX+gRO/bwx30cb5iP/LgP9cCh8c0SFe0j0Eap7jNdRPQljs9CmeL4LNem1E3lf33QK6LeAqIehWX+h/c94w/62LovgutLfSbU7SPExfcmUx8Xoh6aox7OsPUonN4JcXrHxOmbEKcvgVNOtAtS7C0OPoZxKN38Ux9Am+cRB/o+XhuYQchgYuYzdH5LPfROjRf4offLu9S2+xKd38I4gDLC9nEfQLP1v0NrA44vTIn1Yr1UuvsB6Y56AC1Kd7b+MUB3P0foDsd21AOucR9Aw/fWcR9Ao14G0VAeQIt6wdOq8AAaNdYlfQANxnectYG4D6DZtubhqrXD37UPV20ze/mU6Qvmzpq+dO6ihRNmL142e8nSQsCZGjlwhseZGL4aKtUWoP8bobLJqHw8UQ9ucV414PiKg9gzX8vf16sGqCe6ol41sJCQhXpVxYHgNyyDOAsJHIrXVI+88Ccq8q/yTI2TC5/AydQrAPBML1OvoIo70+vVufY4zIdxZyu2fi8wW9kw5Emt5uI77WcCfoqo3yUFXr8QI+FVcHKmh89iU10F2hjpDp65xrkKZOs3B7rbFOkOYuPYhnrC+QWO1AtQWaoVdFimVLxVaties0oNZwSZmOlZ/r5WqechPBwXeKbnOLOsmelRM0vKDnCmB3VKPYkb9SpP/KoBmBtTvdoH+hmVg/BMb2qaPkXN9PB4M47AsWXTQdlEVDaX6LOJuwkRcTcU9YO7QjKUwKRwpoW/C1Ef56NcB+3G8K3NyxGO5QF5O15N2DxuXKa6kgLloq5sFMaQ5cdWg3t9c97XZ+F8bGVJFbN4LIL1hxL1E445m5YDDIWwbRk1HtqyIlBmZTCrll0n1JXP8UrUpnH0R8U+LMOfouTecQR5TXbk1ULV9StqDIV5ZIfwd5zzLccYjH2+Zfn7Ot+icm/U+RalswqiDL+KdxqBM43AoXiN88hrevibsjM+3xpH4IyLwOlNyEzh9E2I05fAKSfaBSn2FgcfwziUbjJ9XofPt6Z5xIF+gM+3dvCIswOog8+3JhIymLx9dIxzhokAM9U5w/Xr1bY7LmLuAmWE7eH4MpnoB8Y7Gc1BHMcW8nwLjn1RujsV6Q7O3+LoztY/Beju9Ajd4diGYxIeR6A+pqGy/PlWbDzn8y3HN3nUnG9R65Gc8y3qTVH4fAvmWXy+RX0egMpneM4F4xufb01O0yd8vkXJl58LxZsLmW0oqIfLuPOXXT3yipqj5OdCdXHycyE3HJe50OOe5kL9wHj+lMBc6PkcmAu96Gku1Abo7r9IdxAbx3bcdWk8F4K6wuf11PoLPBZ1RxDWG76ua7aE6zax50IST8xR41XCuV7NXIh6cydlBzgXgjql5kVRc6GJqAzmRjzfgflsBiqLmgtNTNOnqLkQbAv/LyLqjgf9hXW/7FzbpvV6qbF2QnKMB2U7o7K48Ql5QP2meup9F9QHW/+HsA9mrbH/BJpnIxV97Yta+7T9KAW4tozhv/cauVpNqMWB/mI2uG4K/UWp6DmVrb8TUR/6HJ4b7gTKdkW8KH+E8wvrj5S+rIyZ0BeUIY6+qPsF4uoLxz3U13TEi5r/Qh1G6cvKmAl9QRni6AvW5+rL6oDS11zEK905zihU3/IuVnROwJ9asfVbhrmMeitPVI4fT/CGuTFAPGA/uhL9KEdlsO1fdmn992+pdR4815wHZMG+APkWovrrgPlZb6SbdG/Yxv5FrXHAdQv8tmo4ji+IwWtyBDZ179SCCGwoF75HBt+bQ803qDxgdZMwDxRReQCuV+E8QNkJ1o+jK8pO1DV3fG9c3DWneags7poTfJMU9k9q/SlVzsbxAM9nXkxxjxLkG+V7UW+coHyPWmOl4h/nDRj/OG9AH8V5A9oW5w3XO+EHh7bI5J3w2L8LFe3fqe5wnwJy29AUua2IyXM4GI8agxhVir7enjAXFFK5AMY7zgVROdhs3LyJ4xbaBl9roK6bQ53iOYHVUTFRH/LD9+ZtG3NOgO8uj7sGHnXeZ+PB6H1pKAdeEzC/4VrKNOR71NvxYM7Bvmfr7wP8eQd0jucjb+yAyqh7tKLGHMrPqLv38WeTo97Y7njfeey1FHzfedI3tse9zuPjk8uGFhF4lB3gWkq6pzdtrpLOa1BPcfIada2JuocQxzPMETgPRH1+fFoEHswRcC6+FMU+lSPjzlng+vXjaC0VxheOfxjjOP6hv+N5A9QhnjcsBLJQcx78iXNb/yCQw05EuqF8OWoeS93DugjUmYn6A319cQxecyKwqaflF0dgQ7nwG6DwE+dUTFKxaHWTifMNOC/AsUjZiXpOJUpXlJ0qUH2oG27s4ifE4PiO4xr6NnwS9cQU4zbsB7XGS80H4Jg/DY3dq8pawVkgdq/JrxXUw8Zy5tcK6pZJrhVck6G1glPzawXstYI7VoG1gudAbrvb01rBffm1gpqybK0VPJkjawVfxVwreMHTWsG3wJ9fzq8VRG35tQKEl18ryM5awVcZWis4ehVdK/gF5LCmXeryzK8VpI7J/FoBL3Z9rBVg//S1VvACGrvjrgfg5/XnEHJTMY/n04uALPj8BvItRPXXAO8c6I50Q8UP1A03fvAzz1T8RPGKWqeg3oi0NAIbyoXfwI5jGcpp22VwHCVjF8Ynjt2onGm2OLqi7FSB6kPdUPGJx2Q4Di1CZXAcwjEPfRuOu9g/qXGXureJen8HHHfx+zvi3mcbIBlhfepZLyr+56GyuPN6nDegj+K8AW2L80bNlwfBcVgfrxXY+gPCgoRvXCXXCvAXAuB7Kyj/xudWtv5YkNsGpshtRUyeg0I+6dYKrB0zMaeG8Y5zQVQONhs3b+K4jXqzNrXGBnWK1wqsjopV9BwCnzOPAjbAawUwH+F5BvWmSSof4bkL9T4lo/cF4T/4XMf8hmsF45HvUev6MOdg37P1FwF/nhj+9pk3FqIymAfwmzmpMYfyswqiPRxDcTubBxK+KTH2WgF+i33SNzlT8Ued7/h4U7Uh6ovBqd4cTemUepN51FpBJvNa1PWQdHrF5+6wjzieo65hwByB88eCCDzq/A7miKgcOYPgS70XZybg2wutFUStB8AYx/EP/R3PG6AO8bzhICALNeeBYzasvzfIYUci3VC+HDWPrSLqR30RJ+prvxSvqHWKaqJ+VQQ29ZUcLItSqWOSikWrm0ycb8B5AY5Fyk7UFzSidEXZqQLVh7rhxu5BqAyO7ziuoW8vBX0+MsW4DftBrVdS8wE45o9HY3em3+Kcauym3u0I+eK578kgdi9BuqHyM8yX3HknPmeiztejeEVdH4vyXwobygXbYmwsp21Hxa7VTSZi1+f5AaUryk4Vqn5c4xiM+0ZpHJ8wjvAaIPWuQ8o/0933EjXuwuvK+K3uUfddmA3rM2qdlfK9BUT/qPiPWlvDeQP6KM4b0LY4b+A3heP6eK3A1r8RrRU4fsmHXCvAX6+D6xmUf+NzK1v/MZDbbk6R24qYPG+LuVZg7ZiJOTWMd5wLonKw2bh5E8cttE2ce8Gor8vgOCtW9JolvOcF1n8wYq0A5iO8rgnzEV4DodboqXwE1wo+QmsFMHbhWsETKa6fQd+DOQf7nq3/KfDnp9F8w0fewOuW1JpR1JhD+VkF0R6OobidzQMJz6VjrxXgrz45rk1EfvWJOt9JmDdr1gqqCDzKDnCtIN2XzqLWCjKZ16Kuh6TTKz53h33E8QxzBM4DMEf8f3vvAm5XVd2Lr53zIAdCDhAQFMUgiiCgEAJCUZoIBCIEQlBQsUIgAaMxQQgotpUdAgIS8iA8A5J9Et5P9dra+q+1tVr78N762YetfWhre7V6+/La79qH7d9F1jjnt3/7N8ea63VOAnt9H2SfNcccY8wxxxhzzDEfi/2Ht49B5cLQR3g+MjZmwTXP/0NfjUH78tbF2P5R3725NccN6ovCas41SPA/BB82dEQ3znYy8cTEsWsFfBtgOPep5useLi9PcaOAX+vQbkMZ1mXaIZtUtmiyaWK+gXEB22IbygYEfIys2gDD8f+NULaWymJt9wYqw/Gd7Rp1G3NgrJ95+ynYdkP5w6/S2I1881yhjq9B89z6RuBF7SswvIMEPwpftH4VyWZdMvHE6MRNAn4dwLAPQ524KQLX5Q7tmwX8TQ5t5AvrMm3m0+op2zXZNGG7aG9su6qfED5GVqqfRgkeZWNlKu+t7PNGKov9MvXaZKLNrJ8qRx+7rwBz9Px1+LbA6+neWgHfBhjWPTVmKftnv4H2z34DdZT9BvYt+w3rT9RVhOdcgcEfm/WFxZ+oIwV0XeYKbiYe1wEPSr95bmXwC8C3HR/wbUMFcZ6Y4cnLFbSz303E1Gjv7As8H5w+Rf0m2y32Ded0VN4BZcq5gnb297CAR3yDBD8f+oBzBeiP1hHv6I/WUpnKHSt/hLmCZRkfM5Je28VcwVmke+jT2F+kD+uewV8J+nx29rtOv/FRKkM/gDhYpzw9U2tFOIZyPfMD5ldQF5vIFRj+kaS3zWVyBcr+1sI7zhWU9JvjuYKPCXqqHzBXgDJF+obLyxW0gX+ErcOvoZxi/BrC89wd28j2jD6C/QD6CPYfaxx66CMwFl9Gtq98ZGzMgvPzX6RcAdoX2z/aONs/6jvHDShDjhtuBl5UzINjNsKvAh+2lmSjdNmLY28R8B8DmDa1B3X9lghcax3atwr4WxzayBfWZdohm1S2aLJpYr6BcQHbouonhI+RleqnUYJH2RS13ZupDMd3tmvU7ZugzWsD4za2ow3v2HbbgleMB3a3XMHtYLsPkWyUf/ZyBUXn6+jDbo7A5c3XPP1VtJEvrMu0mU+rtyvlClQ/eT5WyUr102jSa9dsg5OZK3iooVzBmS/wXEHMmI+6ivCcKzD4pylXgDpSQNdlruBjxCPmM2Lm9Qb/RfBtzwV8W2yuwOA/vQvkCtDe2Rd4Pjh9ivpNtlvsm6nKFXw+MlfAec26cwXfjswVfKmmXMF3QJ+/Mgm5AvQDiIN1ytMzlSvAMZTrmR+oOJeOzhUY/pGkt81lcgXK/tbCO84VlPSb47kCNcdR/YC5AjUXQVy7Yq4gT648d1c5zaLzDfYfZXIF324oV/DmmnIFqO8cN6AMOW74GPCiYh4csxH+++DDfkKyUbrsxbF1zNc9XGsd2rcJ+Fsd2sgX1mXaIZuc7FwBxgVsi16OJn1iZKX6aZTgUTZFbfdjVIbjO9s16jbmwH7SUK6A44ErBV7vOxFqj5U3P8nbO8rzExULqb1GlwXohM4lXZX95r1G04/c+W9eTG20K+r7zKb30Xh6gjJRsRHveUEZ43kkHhuuBN5fQ2MD5qJ4T4baH6rmyax7oW+U8H4ygz8Q+niPJRon8oA2UVWfsQ1V9RltYzm11eAPmVx93nuq9Zl1FvWZc0JKn1tJrw+rks+ZtQvq/+tfRPp/wi6u/2ou4el/Xo6E9R/jt6nQ//88bOfvGP2/2aGp9N/aFtJ/zCci/BmO/iv5evqft0bo6f8tVIb1LgvQQf3Hfmf9N/hzIvXfaDeh/ygj1n9v3pQ+Rec6vCaA8bun/7xeW5f+/10B/fdib6X/1taQ/hs+zpe/29F/ZYPeOcaia13Yho9RGda7LEAnFM+z/hv85ZH6b7Sb0P865695eQaO59E2PP3ndY669P9/kf7jGXfODa0SONRZFc4bqfN/1g51ZlOdBxgk+GuPnKh365HdOFWMhHv6m5jzerg8+2wL+Bsc2upuDOYlEXxavQbPfw01fa61LeBVP40SPMpG2ZZ3xj10Xgx107u7QumnOuMea7t4xv26w7rxrs7By/LMu8OV76BZJdqn7N+7E4L9RuxZNfYbfAcSw78WyhH+nqwvbH2jDXUK6Lpci24Tj3gOX+k3r90Z/NPg2+4P+LahgjgfjBxna7qrZrDpu2raAh79JtttG8r4jiR1N4Rav2E7G070XJfvZTH4x0Rcp/wR38eB/qjInRtoM7gW/XsZH3xGN/2Na9HPku6VvYvxf4I+fyr7Xaff4Puw1F0H3pij9GxU1McxlOuZH6h4Bjx6LdrwjyS9bS6zFh17P11Fvzm+Fr1W0FP9gGvR6gwt4vLWopv0a949Pnly5bVhbCPbM/oI9gPoI9h/eGfc0UdgLP57ZPt59+dwzKK+8ZTiXUnzDbQvtn91N6CycY4bvPtM2sCLinlwzEb4PwIf9l2SjdJlL469UcCvBRi+P6gNZTdG4PLO168T8Dc6tJEvrMu0QzapbNFk08R8o40AgDfUTwgfIyvVT6MEj7IparttKsPx3bsrD/Pv3w2M29gOdc+GigdwzH+Wxm7vzrvYu6v4TgW0a76fRq0xoJ8J3U/xL2C7g6/rxtlOJp4Y+/F0CPkpez+Fdxdfnt9g2m0oY1tdS3+/2O6n4Dk/+sC1VIb2yffOoH1yjkHdnaLuTsI5HeunulsmdtzFu2XmUK6g7nsgvftqea9oHeO6dxcL+w3rT9RVhOdcgcHvl/WFxZ+oIwV0XeYKeBxvAw9Kv3luZfBHZDymfXxAwLcNFcR5UIYnL1dQ0zg+2PQ4nuc32W6xb2K+VYQy5VyByWg40XkKvn/Z4A+DPuBcQdl4QeXvlD/CXMGCjA/O56a/MVfwOtK9snmqhaDPx2S/6/QbXmzN+1atLEl8PVN7Aw1O6bP5AfMrqItN5AoM/0jS2+YyuYK1RA/bnj6cKyjpN8dzBSoObwt6mCtAmSJ9w+XlCpr0a14ONE+uPHfHNpbJByj/scqhhz4CY/EFZPvKR8bGLDjfOIJyBeqbJkXPyXLcgDLkuEGdk1VnEQcJfjH4sMtJNkqXq9ypxfvw1flTD5eXY1d7DbwzAMgX1mXaIZt8Id+pxfE/7qXgPeaxtss5Bhzf21SGur02mWjz5YFxG9uh1kJUPIBj/uto7MZcAX/3omg+QNk8x2lt4EXlCkJ5vg+A7bZJNia3JKknzxczX/dwefO1vDwf00a++nk+3U8xeT787gXnCmLtk20edRvH3XZDuYIfvKobr/IJnu7l7adh3Ys9Q8J+o2g+QOk6+w3rT9RVhOdcgcFvoFwB6kgBXZe5gnXE41rgQel36Ezww+DbNgd8W9FzxndF5gpq2r9d+Cyo54PTp6jfbGe/lS9YQ7hUjq0N70JntYYTnbMMnRfY5uQK0B+tJd7RH3EOZLWgq/wR5gq+SLkCtF3MFTxKuqfy+uhzWPcM/sugz09QvFGH3+A9TugHeN8f6pSnZ2qd1+CUPpsfqDiXjs4VGP6RpLfNZXIFyv7UfKei3xzPFag5juoHzBWouQji8nIFTfo1bz0kT648d1d3vigf4a1hsP9Y7dBDH9GGNnyRbF/5yNiYBfcr/HUWsygbZ/tvQ1lMPkDNrTluWAe8qJjH8A4S/FfBh32LZKN0uQ3vis7Xvfs9b47AVeXck3dfSN6dWsomG7xvYqjpO3fz7tTi+N+7UyvWdtdRmcoHKNvFHNi3AuM2tkPlK1U8gGP+o7tpruDvwXb/s58r6KHNfFq9fq6g13abzhX8Z0O5gsf6uYLCuYI9j9r5766cK5id8Zj28d5HaZxFcwX7ZHj6uYKpyxUcDH0wlbmCUzM+8nIFryLdK5srmA/6/Jrsdz9XIJ9+roDo9XMFU5MrOJVsv65cwSd201zBWeDDLibZ9HMFYZvs5wqK2W4duYKLA+M2tqNMruBVNHZ7uQLkzZtHVD2DgHsyQmcQloPtfphk004mngHiPX2KnkHw9j+ujcBV5QyCt/eqfwZB91PMGQQvV4DjXB1nEFg/Va5AnSmckfTaA+YKLqNcQd1nELx7R7wzCOw3vPzDZJ9B+BjlCkrG9I2eQXgQfNttAd9W9AzC+shcQf8MQq9M6zqDcG9krqBNvKvceZUzCJ+jXEHoDMJDpHtlzyB8HvR5jOKNOvxG/wxC/wzC88izf1+oZxDQR7AfQB/RprIyZxA+R7avfGRszIJnEN5BuYLYXKG3XjcZZxC+BD7sGyQbpcv9Mwg7n/4ZhGK2W8cZhG8Exm1sR5kzCA85uYKq+YCy+wrU+UyOff8abPdHgbW3JKlnX0HMfN3DVWVfAdNGvvr7CnQ/xewrUGv1Te0r+FFDuYJXNbyvwLuTxNtXUDUf0OS+gmlH7/x3V95XcFDGY9rHQ0drnEX3FUzP8PT3FUzdvoJZ0AecK0B/tJZ4r3tfwYkZH3n7Cl5Guld2X8HJoM+vyH7X6Tf6+wr6+wqeR579+0LdVxC7hsH+o8y+ghPJ9pWPjI1ZcF/BQc6+gqr5gCb3FcwDH3YByaa/ryBsk/19BcVst459BRcExm1sR5l9BRwPxM5jWsQvwmMek+WvfI53Z6KKhbx9DkwHfQK27YLsX177eU9kTN3kWnyd3w7Imw/yPFmt1yh9N5p589mExoYWwLEuWRny2hJtGw3UV7iwX14Lvw+HcoS/geaSKM8C/bpoBtRJAAfiLqkzi7Ct9qh4EmMnRS99RkTZYAQvv3XSb5y9/T+O37tF9Y0Xfsd6OSTgFwp4k9Uw8T47iXrOVrZrtK2M245laH/GQ2qzRyzp5m+oJH8x8kP8owJ+McAV6Yt9k25dQH03e70Myi6gsti7bjkGLLrPzPt2oMF/DGK5+2lMaycTD485SVJ8nxl/m6boPrPLHNp5eWum3Yay/j4z3U8x+8wugLLLqMy761aNiXn7zFg/LxPtiP0uzmWA988O7carYi1P9/L2mbHuxe4zY78Re2elN3esa5/ZYzTel8zxNLrP7PPg254M+Lai+8yeiYxz+/vMemVa1z6zX3Fyx+iP2sS7d9etulMyb5/Zn1PuOLTP7Auke2X3mf0V6PMXKXdch9/o7zPr7zN7Hnn27wt1nxn6iCJ33b7foRfaZ/bnZPvKR8bGLLjP7A8O3flb2Tjbf+xdt969DXXtM/s78GE/JtkoXe7vM9v59PeZFbNdb49Lm8pC+8x+HBi3sR1l9pl9gcbu3SVXMO2YiXoHHNONs51MPP1cQXe9fq6g13abzhWwftaVK7j/0G68/VzBxO9QruCwrC925VzByeDbDg/4tqK5giMzPP1cwdTlCuZCH0xlruCijI+8XMEppHtlcwXvAn0+NfvdzxXIp58rIHr9XMHU5AouItuvK1ew8dCdv3e3XMFS8GFrSDb9XEHYJvu5gmK2W0euYE1g3MZ2lMkVnFJyHtNKev1QzD6z1QIe5cHzE5QjxwRY74IAHfQJ2DbeZ2bwN0TG1Ea7CX1HGbG+5307uei+Pp4nq/tLlL4bzbz57IcO3fnb+mwpwF2adJetEDis7H1QdjmVvV/wbO1fCbxY+88DGMM7SPCbYGzYQTaC+j1AvKdPjM7jPtTzqD14LnR1BK6lDm1PXxRtdR8G85IIPq2eshWTTRO2gntH2VZUP3ln9Lw9sygrtSeY92ReCmVLqQzzsbzP83Ioex+VoW6/H9rM+rlUtOM8eMdjw3mC1xTvHgd1432fwOvpnhob0I5Z91aI9in7v5TK0P7Zb6COst/AvmW/Yf2JuorwnIsy+E9RLgp1pICuy1wU5zhWAQ9Kv3nubvBfAd/2mYBvGyqI87OR46b1YxNzNrR39gWeD06fon6T7Rb7ZgXhWiFwoUw5pjIZDQt4xDdI8F90clGXQv1VxDv6I74v/nJBV/kjzEX9HeWi0HYxF/W7pHvo09hfpA/rnsF/D/T5q5SLqsNv8DwV/QCfb1BjjtIzNRfAMZTrmR8wv4K62EQuyvCPJL1tLpOL8uL+9OFcVEm/OZ6LUnGv6gfMRaFMkT6uV6bPZPs1lFOMX4vNDbE9Xwpl7AfQR7D/uNyhFzp/8ndk+8pHxsYsKwDvTw7c+VvZ+KVJdxnaONs/6jvHDShDjhswL6ZiHhyzEf6fwIdNe303zrrvpXwftUetAXq43u/QzjvXxLTVPRfMS5KEbVLZosmmifkGxgVsi95cO31iZKX6SZ0B43zTpVDm2a73XXa2a5V7Ufrpxfnpw7b7PsErxgOmG6cD3LFJd9m5UHZY0s3PeYIfhD+R4O2cznAA3vANEvxemRww3ppJMOnvVwfoIX/4jmMErL84gAv9DbbvXQHe9wXeLV43nBcI/l4t+DP4twt4zBUZP0o2b0807VC+Zjm1x+APFO1RvsF0qqJv2Fv5BpQb+wZPRunDMr1IwKOsOBeB96MtprJjoewCKkPbOZd4OF3wcCK8Y7tGvbO6z8shC/qt/88BuF3Rro+MtOs3Beghf55dY/2idn1FgPc3FLTrNwn+diW7PiHSrk2n+nadb9fnCB5i7drqpnL4h1ndeH8OypTOch8b/OmOzr5H8IoyZPleKuDfAzCssz8HZZdSGdbjdalLoewdxMPS7G+UA8Kz7Rr8OSCHEx1dN74q6voMpetLAYB1Xa0NIjz3xeUCHmPRS7PfKhb9OcL1cwLXpfCOc2gmo+FE94HhGyT4i4TvN/7QTpcS7+8oyHusvaFN/fJ+O3+bDqJvOIdovsOhyXXT/y7O/h4OwBu+QYJfKuTFvg7tAPlaRDgNfpnjDy5Oett1LrxjHVSyv1i0S8n056gM+9h0QdmnwTUxFmH72T69tqYPy0b5VtRd6//RpNcfXkRlaBsXEx015sXqP+rQ9v268V4MZYb3eKj77uw36+x1jn4pGeIYX1SGxs/MpFc276EyrMf7ppTsecxDOSD8JUm3HAz+o5HjjfFVUZ/nK32+FABYn5dCmfL53Bfe+IQyUXkR1lnlZ7CvebwxGQ0nug8MH8c+tznjDcbalxLvFxXk/XjB+4yk12bQpqbTeIM2zuPNRQ5Nros+cjgAb/gGCX6LM968HXjnWDH9/UrCafD3OP5AjaNnwDvWQSX7d4h2KZleTGXIu+mCsk+Dq2ifb1H2ie1n+/Tamj5Fx2Lr/9Gk1x/yOSC0DY6/1ZwsVv9Rh360r8YbGm/emf1m/Xrc0S9lN5jnYBkqfUQ94fEG9cuLdc6lMpQp5ybUuIvwnHM0+E9Gjjc16fN+Ux0/mUxU/MT+UOks9jWPNyaj4UT3geHj2Pr/c8YbzBNcTLwvLsh7GXv7RmZvpoOYH+LxZrFDk+uivwiNN4aP809fdsab84B3zvep8cbgf6dgjs4bb/JydMaPkinnNJB30wVlnwZX0T5nTXWujccb9Iech0Pb4L3GKi8dq/+oQ79F4w3n6RAX6oWnj2g3B2S/WR//3NFHz87Sh2Wu9Bf1yvhR+shzHuTd08eacr8XKn3E9rM+em1Nn6K2av2p5tSePvL4rPK76ENYH1GPML/7mX274XANsJX9a3tnjoD3BWQ+rUX4jGd8h/hHiJeC9Mb3Ix1B9Lh91nd7/fS/bBqUXLtmxcoVa64/Z/XSZactveqaa1cun4aok94VK5QKYsV3raS79Vg2QO8YbgH9vVDUSwTuAcB3JJQpSRhOs0ps05GBeiiLRLybJuCPIFxHiHrG+4BTH3FgPdaYFr1Hr/lKQXuQ4P8dvObgkjDdVya9cngl/b1M0GvQ6vZ9cVjdPoTVYBAWn32AsyQAp3p0kajHj0lskHje4w07/021bzD7bT1/KNS1/bVW9irAjWvFpxCOw4gH9S/yju94/KrDU/D6ZPq8jeodCfUWRfBwpOB5VNQ3uBmiXlnZjDo8Gx30Jrj/ef83JF1tex2UKU/E66cGfwvo0IHZb5MlWqzxqOR8ftLNS1E5ny/oNC3n84nO62qk8zqA2R9+p/8dTbhYztZPJuejoOxoqvd6KEM4HOWOhvevF7QVfsORp4NHvEG3LaSDRmuQ4FeCDh5FOqhGUx59k8TXedbL4QD8q4k/gz8240nN418p2ox88TqlwR8POPcM4EwS31d67UKdemWgXW8U7VJ7QKy+GlsOp7JXQZn5cBxbBgnHqdn76UlvfxSIEuSZpxDfCGd0DytHN3oOYvhHkl4ZlomGDiN63L5y0RBKn6WCWPFdK+luPZblzUHOpb/LzEGUFzhU4DSPouJ6rsdWyO+mCfjDCJeyIPbOqj7iwHqsMape+vcBok6MBZSMzwdiLcDw12UBef1uumptP0LwMirKWK/VvOMIQUfhehXhelUkz6nVZhvkzGovWLP66uWZ2Sb05E06DguwMU3UTxxcWKcl2Ge1TZ+FAdqhQdjwDRL8xWKw8uqnT4zaYxc14fgNf11qH6tCPInDut4g30p6+3CSVDV9zg2woUaUJAeX/a1iyf2o3mSp8fucmGs/Uf/5O/8ot58XZ/Ncz+BXOzGnmht45zaOFfA4HzF+ZhIPWHemqMfzTNyn/Dri4bikVw4Iz3tlDf5DIAdvLdn4amKv7HEAwGsDuEYyIOC5L04Q8LhOZDIZJXjuF/wbcWFfsx2YjIYT3QeGb5Dgb3TsAOfpxxHvryvIu7JhNa9FmzqC5qBIk4fSoxyaSmeNTshvhObI6505qMr9IF88BzX4jY4/8PIU6cM6qPzH0aJdSqavpzLMSWA+yHAzzib2ymL72T69tqZPWV+pzma8jsrQNlj/XyfoxOo/6hDnFm8BOMOr7iw0+Fuzv03HGcbqDhL8dtDHFvkEnNXcQu24FXhpZf9aeHcb8T47iXqiwzvDP0K8FKQ3Ht7dRvS4feXm9XwyG6WCWPFdK+luPZblRXGn099l5vUfhzIlCZ7XY5s+HqjHmsvvpgn42wjXbaKe8T7g1EccWI81hq0IvfotgjZb0f8AK+K1RaR7S9IrB7akowQ9s7qPE2z6mNXdTm2anUQ974i1OsM/QryUtbrbiR63r5zVoaYglYsIq8EgLD4XAWdJAE71nqrHj0lskHj+KuTkP0/xEGrsS4gf5MHzX6OivsEpOgdWpHOgoGOafAOU8VppO+ltq5WthbL9qexG4GUxla0T7bKymxycNzs4PybK0r47/9huOPRGrcC/6TMg3rFMbxO8Wt+hB+C5trK22x06WN/gZoh6VdujeOYYA9v6/L5TipXWQ5kaDfgsnMH/7fkT9b5J9rYe6huPSs5si0Xl/BJBp2k5s03dUSOdOwCG12E3Ei6WM+933wBlG6neJihDOIwINsL7TYK2wm848nTwB2/QbQvpoNEaJPjfBR38x5I6eAeVYR/weGh8oBwQns9mGJ/DAfhQu/7VyTXcJuor3jmTf4fDe/qwLmJ9g2ta519FdEL681+kPxugTOkPn0cz+E+D/rSyccdkiRFaE+337BojOZ41KLtjWap6aKOvieBho+B5VNQ3uBmiXlXdUDzn6cbosUlX2zZBmdINPjdr8A+AbuxHuoH+03hUcuYYsKicDxR0mpYzx3eba6SzGWB4fNtCuFjO1k8m5zuhbAvVuwvKEA7Hty3w/i5BW+GPHd8OO1a3LaSDRmuQ4Nugg4eTDmJ9Twc3UxnKFH0v97XXBy3iezgAv5naZfDHZG1RuWFlr6g37MsN/ljAyblho4vtUrNlTxfvFO1SMt2S5NNGOS8M0B5OdPtDuvJGR6ZWfyjQHpapwf+MI1MlI0+mysa2iHbNFG2+i3CpTBvKOUam2P6PU/sNfr6QqYpbPk68Y+zAMaSKwxCez7crG1OxCdvYmQ7vt4n6KrfAe+XaULaeytZCGc/FboSyDVS2Dso4z4G5BR7/boayTVT2MShD3bfcwiC19W3Z+4o5eLmn7zbije/9VP8mSdx4in3VIjpN5U2YzsdrpIO4LCOv5my89aNo3gDre3PDdkU6bUGHcaFPxphobfZ7kOCvALs+mXzyesFfG94tdNrK9oy4rM/MPtD3NbFGZfhHiJeC9Fqez8X28RakDYKXUVEW6lOk80pBpyhfe2X00yfL4p++/LJrrzxn9ZUJPYP09xkBFg8muIUB1loCb4v+4/cH07sBAYu4J8v0ppLO7Ip0Zgs6Tac6ZxOd0HSnTdOdvJQyX5lh8KtgurPOme6EzA51bW0y8bBuG73Qcv/aAH+3guttketdK9r8Lofn9UCD6aa/Xxvg4Q4KVUq6YhmqcCoU+bmByjD0wL7BsiSZkIX6nOCoqH9DAFdomDS5ckh3V8Fh0luoR57WUxkOTSwHRUe5dyUHj86hFekcKuh4w35ZX6J4VlMJ9CVj5EvugDIV0vBWMYN/N/iShx1fgjzy38ovh8bJkC+5PcDfE44v4dAQ26l4xikg01W+xOCfJV/CS0Gzk7hH+RJemkB+Xk38Fx0Lsf5kjYWvJjpNL/updD/7F7UctcGho5bU8uzx147VNJU98riG8K8Ge/xCxNges1TXtO9lXLFjkMF/pcYx6PYI/gaTXptKfx8GbQ7hSsQ7g8fxj9MXdxDsegc25LfS33ZdWNP2dXL2W9nXEcRfUfvC+rH29ScF7Wtp9pvtaxTs68/IvnA5gOXKSwAIezLBboJ2x+Idorrps5hgNxJe1EmeKxje04+bwP9t2jK0ifCrf9MnRncwtc+6gylq3OaMZUaH33lH/Q2ObYF153vHapqoO1iXdcfg3wCy/MGx4TZymrUOOdv7O+E90+UlyC0Ei6l8ThPfSXXVv3k8jgo6WwjvXQ7/vEy/SdRrerl1C9HZUiMdxHUx0Qnp7k9Id++CMqW7lugaJPhB0F07e6O2w7DutqGMt1Cq9F+K/73HdfN8N8CZnN4t6hr8PQSPONKH5xb3Zn+H5hZWd5DgRzI+cW5hbbtL0EvbtlegbdgfuAx3D9E2+COhP2ZSf6C8rD9mJr2yYRu4F3hh2JMDMngJ8DHruDAttgvVxhTHQceF4U4WcIxjmpCB4VB+werNFPTYdu8mGnc5NLaIeooG+2OU2b1A33Tjvpzye0XbEvFumoC/O9DeRNC+JwfvXQKP8u/3UNlmUca+C9urtmIpn4h+7yc09qKuhGxC6dXdDu/3Eu93C97vcnhX8kP/4cUN9nfMWN8Sfxt/l8M79rFqqR9hrC4v9Z8gfCbjDG1JWRrAeRLg5O0TSmfUlVMx/YT8zEzCdq54R1/C77xYJhE8oC9UOhuK41geige1/Ub5Td5+o+LwWNvEePp7L9I5xjnHaZpF5xj/vnii3nkRvmJXnmNwznxXmGOsJzz9OcZPdZF0t+wc4w9Ad5eVnGPwVqq8OYaVmXyniXp8fKCd/X0HxL7vJ3xtoIV6kz58tTJuNUxEm3hdweBXw7j3JvqkJNY/lui1gRe11sM6cazgK9RONYax3D6e8T096bXFAush8z39N9x3lcQdYz/K5tX8YUSUDUbwsur/LT1+6fBHfpftynjhdzGxzLEC3mTF8+bZSdTz5hlAIyHaVoa6fReV4TUKxkOq00cs6ebv7pL8xcgP8Y+KsvfC7yJ9oXBtqBHX+pK49k26dRTtUPl7zt2oPHPaj0+R324DjtcTr23Ba1vwOirqI1yeH+J1G4N9nPwQH6+bnUQ9c734xHBvKYk71g+FYgLka0SUxfih9/7n/Ku+uOQPX9FKev3tgHgXsyX99QK+op0fq/wQ+xr0Q1uoDP2Q8aD8UMkx5dgY+SF+lUtiPxTbFwrXhhpxrS+Jy/yQt7aAfojjO3XEFv0Qr2d9GmK2ZyjX2AZc7O9U/MYxpirbKHCmtH+nnhhoi4qBEuIB7e98KlO54pbANUB/I8+pjfwsXZeWCFw8L0LevPyD/Y3vBgUf6W/eI2Dwvwn9/usUq+M6ffpgfM5zjTtEvec/s3NcGG6TA9cGONZttcbvzWtidY7Hwd8nXSx5SYvcn2S40q3VdqQ/21p95vI1F7x36dXLl12w/PKrl69BDUPuGJP9ba1mzUwILn14V/XH6G/ejbeB/t4o8OTRVLtnjobfTDdm98zRgueppHNcRTrHCTrK47YC/xodfuftkDyO6OCuG8xqfJOyGmqHJO68yRxgz4jzn+dO1PtLJzpmOaMVHp9081J0Jx/Wv71Pp3Y6J1Skc4Kg0/ROyxOoPWgjLLeido31108ynTy7/jHZtdp16Nm1wT8Hdv0fjl2HTiQkSfnDY+yTQriWEC6s713IcnsEHe9Sk9iLX2La49GZyvYYLrV7sQ3v3ubwxTOwjTm4LiBc6pISpYPMczuHjrezs+3Q2VCRzoZIOpPVnlsr0rk1ks7xFekcL+jMEPWqjh9twXOevz10TtLVto1QpvztouxfvqzpE+BvX53hVDtv20l3meJ5d5ZzUyvifKlgqD+Ppf5UK9Vefxr8zdCfx0f0p5JNaMcn0vX6Wl0K1BK4vF3pLAeEV2NKg9ni6E8w8spUyezT+MFv72Kf9MED1qZLWRZg/vJrjptz0uk/TQFcf9WaUOZ4HySadO8aQPiE/uZ6KW+DBNMWNNKH9WcTwXG/23vGH8NTHmxeufJ1dya6nUkS5+uwfjuAK3RSx/qHM01nZHauTuqomExdNuPFA2q3AcINiDbsGaj3gUTzh6cFFzptNvhznDZvyGkzx+8qdmTfxHADog3Tk14dQBxKxicm3by3k17e8R3rE9Y3uKbHzhOJTmhMeweNaep0ENZdlf3m00FXw5h2MY1pKhZsuv0cv6qrw1cBTGhuMxjAyTtTDH5Z1vaKK6syo8yrQzcI/tP2XUF9qtru9anBL4M+XRHRp559qIuoPV+w3oFXc0WVY/LiRusf3v07O4l5Wt+O0VHEP0K8FNSH8XhDXfaG7Ssbbxjeb0GDkP+8eIPrefEGw4Zsj2OAjfQ+L95QPIVgq8QbmwLtTJK48QHrG5zpZ8mPZ8w2Xm4HPtTu7NCp5mlJr20p+Dbxx/g5z2X1BxM9Du8P5Qj/ixBLnObs+HtjgL8kiesLrG9wTY9VbyQ6t9ZIR92oo/Kr58JvLDM6IR87Kup76wWbKtLZJOjE6vrK7HdeTLSRxk8vT450OU++P4yfd9L4qW6I8vJw3k0GbFtJ4o+7Krcbipfy7FTl108nXEXXNrD++gCu2LjM4D9FcVnJW40Wq50vZn8VY77FMTaO+NWuB+NrRJTF7Hj7+5E3/d4P/scDf9Ci+sYLv4vJHZ0u4KvFX8miGUAjIdpqx9tGKsMdb8aD2vFWMl5bFCM/xD8qyvCkU5G+GBVlC0visl1qao49VT4plHtpZ785dvisk4dQvkndxqTaup7qrRe8pw/7nPSZnejnv+kxfCb/PQQtvqDXYH8d2r2APnt1h+DVfMSAQyMR71pJWDZMY5qouzrp5m1DBG8qH4Q4bg3wmeJQa4ist0VvZrld8KPozK9IZ76g441J/K/R4XfeeuR8ohOKm75WYL0r/X1V9pvXu6ZB3PSHFDdhfV5zVbc0tpOJh32g1Q/dftAm/gz+T8Gu+CRvW7T5KsAZ0rNBQTf9Hcoz/eUk5Jm4TYNJr29Nn7cmuk2hfDHLQOnJ/g68Wm/CdTf22d4HA9rZ3985YYKHv51TrP1nB3D+zdwJnN8tiPOcAM4fz5nA+X3HNk5JuukVvTET6/MOXHXB+PSkV3cL6GH0xc3t7PdI0tvmMvm0NtELycXavlbwMirKYvZpnCLotAhXHl97JbVd3NzO/j6Q4BYGWGsJvC36j98fSO9USg5xp2p+Y7aWYWq+DmAuIPzrAMeAeMdqjvUNTtGZVZHOLEHHw3WBwGXwNwn4WQK+RtUwFl8OMOylmTXGm6cajDukGvYMEM3093qqz13DPM4UOG5w2jQg3nFX3yBoKTpvr0jn7YIORwmHZFtopgv6BbzlLeb9boaX7PlLZqpvifX8/OkOpGd8qU9Ox2Q9Xvfrv7j9lMPee16L6hsv/I5NUs0i3y7gK2afblJZD9z9mz4qM6ayHsaDynqsL8lfjPwQv8pSc9ajaAZB3XFaFJdlPW6G+p4tT5bPaIKOh8u7l9pkM5zolSL2SQZ/ROaT8LNBA0lY3ol4Ny3p9Uf8eVLENSfAu6Jt+NNnVNQ3uAZ94lBRnziS9La5TDSs7EPJRZ3Ts7q8Qz19+N6PoisCuzou1M0ZSa/+tgL/Gh1+x3KuY0WQ+6wOXHXcoayyZK+D31hmuPgd9wvW30BlNwk6ahy6mcpQbgupTN0XofwQ+++ifugGwR+vTqe/MSt37vGaZuj+Z17NNPifh2zG+ceH2xizkwrhQxmuCyl2bXInVRvKunbHFZBd+ryN2mLw7wHZXezIjsd+lQlXO8X5pJm6G6BFZUni7yBSmeCYu9MqruxFj31176xSWUXlYyreWzBo9LzP0SK9fRItU3WPm9mY8nXsz9DX8Sokjmt80kDdSeH5M2wTZ2YVf5PlNxWdRRXpLBJ0vDgxRtcVHcVzni/7CPkytZqKdZdnvzk7fQ74sl8kX4b1kUf+O2Z+YfRiv3tj8DfC/IJXZ1Sblzs8I40k6bUbHrsM/hYau0rOp+XYxad91SnpinSjs/GGf4R4KeuD81bjMbW5X/Y7S22es3rpstOWXnXNtSuX862coT2OLcKK71pJd+uxbIDerSW4s+jvhaJeInBjxlOdCfH2Jai1ejUrv1XQ5bV5de56QNDh2e2AUx9xhPaLDATqpX+vEXU8C4jR4PRpYkbT4B6xWbGWafhHiJeylqn2C6noiCNDrKv2cK6F31iGdLzoFHGtqwlX+izu4+rj6uPq45oCXN6eMp6FpQ+flUQ/2Cb+ii5cY31vgXx+RTrzBZ0Zol7ZMXnU4VllW9pJd3uKZiCxPu/TC+2f+/rxmmZo/xzP0Az+zTBD++Pju3luQ32ckarZMPaD4eC604EHKysQX8xMZ2mz6AtCKNchwIuxhPHD/XZV9lvtp25TGepCbB99m/qoDWWqj3iPo8EfDn30HZpFq3OdTC/Jocd2OByAbxN/Bv89sUqn+Ls9QC+UVXhngN7/AXp70o2aqHdGu6LezVJ6h36G9U5lgpQ/8/wF2lY7+62yrLwyq/buteEdZ06s/nCi+8DwDRL8/xN9Hqvn3K8G/++R/WqybKJf2wDA/apWvRGe+1XpgVqhV5m6GwnXjQKX2scaa8uGj21rKPM1ql/V18+RT+7XcfsDnF6/tg0e8FhZ1X5FWXG/qvhD7Z/09ADHB5OJyqx/jMrQJ3Lmui3ooB7E9Dn2j+HjPt9f9LnK4Lcj+AvtO7VNh1kG7oI1q69enqXgEnq8lFn69/oAG/uJ+gnVbdG7/ahMuU9vk1A7+3s40Skrdp8Gf7AQued+0ydmSzV2dxNJXMNf15bqPLfGqSLPzLypTDuSTo2qmj5nBdhoifoJ4WqJd+mjtjm3AYajQM+7KVGpvVoIb/h43fooZ+RQI6GaERm8itzVGp9q/0Yqw3oxp0lQjXhEM/g5kSNaTTMfOaKhjHhEU5kF7ySuWs9W2dJRgkfZqxEtdDoI6agoRs2s2tBWnlkpfWkn4fZ68lH6pfY1qL0V3izY4JqYBWN7WBe8vk2f0O0uCI/9zVEr7i3gzBPa0iaio2Y9sbqA2Y6vB9aqEW9b4DV4dWMDDuE8Kzf4xcIHGM47ctoWMwNUp27VCh6fIMV6uK/AcCcEV1Ef964zK5M+RW21nf1Wqzy8dxzHAs7itKEM1/4/Msl7sHj8VjeHtgHG8A4S/HLIGn14bjdOZeNeH6j9R+rmw5lJr7/YEoHrZoe2ujVzi0Mb+Qp9xzURfOJ3vYyWlZlsKtrKkLIV9M9sK54vTp8YWal+GiV4lE3R/WD8/dvY/WCboM2snypebMM7Hhvaglfck6nsk2fbRbP2ajzimLgNY8TJgZg4ZNdXBXCuc8advDE1Js5WKxvK93GcrbKSyvexX1T+WvkR9ovqe6AIH/oe6IZMfhVvEZb7rULfex5MdOzFe4AN/mHw3ZvnapxDBXHeFTlnqcnXDTbt6/LGJN6nin0T2m+IuNReVLaz4UTPlwwfr7ZtczJt6G/Zp6K/ZZ+6XtD1zhqkcv9ixgfHa+lvXMF6lHRPzZfR57DuGfyXQZ+fyH7X6Tf4liH1fV22nyTx9UytCvJ3ytW3qyvu+Y7e087fqyy5h969LVTlDCr6zfE97SpWUf2wT6Jlqr4Fab5qsv2al4vJkyufD8I2sj2jj2A/EBOTKXqhmOyLDcVk51JMhvbF9o82zvavbg5VcwCOG7YALyrm4VtfDP6r4MO+RbJRuuzlWNQ3p9W3j2cmvbp+dwQuL9d3j4C/26GNfGFdph2ySe/2vSbmUxgXsC16c8n0iZGV6qdRgkfZFLVdnofh+M52jbp9J7T5W4FxG9uB4zbb7gbBK8YDphu43HRe0k1TLe3gOx5nsb7BKTqzKtKZJeh4uM4TuAx+nYBv+HoVY/EwgEnf7++wxnhb9B+/Z9wDAhYf1U03BPhOkrhuUpsVGJe58PRZAjB8qTCmoXkTpurCdQ5fWJ+XwoyvPbILwqYL+gXc2xbveLjhvrkk7hbhSxIdZoaOpiFf6kqBwQhePvf4+Xv/4RdPGr8KJPYIncGrVP9iAV/xKpVNagjj61JwCOO0Ow5D3lUqJa+A2BQjP8Sv0uF8lUrR44xYtqQkLrtKBYdKs53J8jE8dZ2R2TKm8CabFxuO9xW8eH5MfaBT8c4yXue0q6i/vCGSzvkV6Zwv6DS9KZw/E9+GMkyjHHLCxHvU71Dq94rsN2+6/BpcPHlo9lttgUAe1fiDY2T6sL3yplCGuT3A3+Ggn3ycVrX5CodnTKElSa9f4PTu+DYUGntL+lSZ3uVrxdCH8bhckm70Tqypus6n2HFa3p6MUkGs+K6VdLceywbo3VqCW0B/lzlOqz4zcbPAaZanjqiq0fcmQdfeTUvCo7XalHAT8e6N9ohDLeoZDlUv/XuZqFPnRQWTdTTXLLPk8dboz0Ya/hHipaxleptD0ofbvlHwopLZPKtSSQKVSFK4NtWIa31NuNJncR9XH1cf1y6HS81A76AyHA/48/DqWEOLypA/b+aF9b3E46KKdBYJOjNEvbJj36jDs9o42E6621P0QkOszxfNhI5EXn2Cphk6KsYzIYP/TZgJXXtCN89tqG+ziiTRs07sB8PBdZvYIIly5UUKtXkU+2159lstArSpDHUhto/a1EdtKFN9xEeLDf5J6KN1NFv1joVa/SSHHtth7LFVg78VZqvesdWbA/TU7D19FgXorQd6k3BsdV+ld+hnYo7BKX/m+Qu0rXb2Wy1k8TE47+hj0SOtxkPskVaDv0/oA49FrBsh/pTcaj4Gd2uAjX1E/YTqtujdPgFchid9h9PXmGNwONUMHYPbJkTudVn69I/B7XbH4BYE2GiJ+gnhaol36ZN3DI5HFU/ESlTKi8QcoH5OqLTnYVWE5UUCKjfvHQNUUc/NATrqYHf68Ihm8L8cOaLVFEnJEQ1lxCNabObE4L1tEsrUMGvRpjI1s4k1w9hjcBypKX1pJ+H25h07Yv2KPXbkRdUvlGNHfAzOO3aEw9EGoqOiqFhdwNnT1YE1JsTbhnehNVr0ATiEh44j/JHwAYbz1py2xfg7lfVWxxHY36k1ZKWPBldRH2cofcT2x8zyvM/G5NlqO/s9mvTqGW8jxbGAw8g8vfG2eeIa3yE040M6ZxDNop9tOUPwr+jMqkhnlqDj4TpD4PL6u+GtYsbiwQCTvt/fYY3xtug/fs+4BwQsPqqb1gX4TpK4blLqrOjcUJHODZF0zqlI5xxBh7eC7JmFvhWXm9fFLJiVPFmwrkX4kkTPpkKnKpAvdcohZovZP46+/csrf/Toky2qb7zwOzZbtXv/HAFf8VREWw1NfCJVnXRTW8yMB7XFrOSplHaM/BD/qCjjLWZFT+Jg2cKSuGyLmXe6vmmfwVvMRjNbVlvMpsJ/LapIZ5Ggo0KiVuBfo8PvmI7iOW8r1stOnHiPehDaisXJbYP/50UT9V7hpCFCYQOOld6XDYxe7JcNDP5VoFO8Fet20eblDs/4zXimm/5+bYCH19IYVXLjhdyKxdNP5KeddPOvNvSoLwWoha3bHTpLKtJRW+rq3Awz6vDsjftl6aBPNZtTpzzfBr+xzOjwO6aD9Tc4dNZVpLNO0FFpIZwyqROBJrOK8dRgTL8g/hHipSA992tHasHf2n6n4GVUlHEqRMVadwo6CtfaGnHF3FT0NoGrqLxqnOoZixcS3NsCrA0IvC36j99fSO9CUz3DrUyyHeA7SeJMEutPtunnrZsvPlHTDK2bm9vgqd1jb5yod4HzPXNWO7W6sM5pI9Y3OEWHh0DMrHHW7WaBs0VlyJ93okStWAwIOsr9vhg/dMRDOtZVQ3TMJRjTBJ2ifNXo5sY3+RNc6E63lsCb5+aOonchN2d/T5bqKzpvqkjnTZF0Jqs9t1ekc7ug4+F6k8DVV+8u3Kqb2gG+kySum7D+ZKudGkEwKZE3yn+URnm8KjBmlDf4z504UW8t/OY9DYjrtqS7rA1lHyf+b0wmHh4BUS5NjICGf4R4KTsCqsgmtMMq/mzSWvjNUkGs+M6zlAF6xxuU2lSvzNkktTp3o8Cp4ribAvVQFol4N03AryNc60Q9433AqY84sB5rTIveo7XdImjz3su7IB22N6XDFC2UR97+QoZhHgz+Picltw7qqHaxNd9Ef7fh98kB+s+Al3nwRE0/EfS5feg9hwP8riMeDL4DMuANf8rzJ4F3KAOsG/obYT9KbcG/lS7eQvAfy2k797/BP+b0/1rBg/GVPgtzeGCYjwZ4eErwILzmaauvuj6w149jDfZy3EvcE2sFntBj0kg11rSXpcPWwXTsb6UBacttbB8P3VYuXxPa58gjwg0BmtMS/cxING/pM1VbV9eWo+duXcX2ld26GrLSPDoVt66GBm3lLLh+QnVb4l36pOr8hWzL9VSuX6yrSEcliRhXKCy+JPs9SPC/BQ5qz8C61TSBM3042eltnzU8CJ+3xYplqbZDerS9db6NBXn1csxIXyVHNxfkdckk83q74LXBdZVo1zlV6yrFpjWh++NbhBXftZLu1mMZe8i1BHcm/V1mWhN7R6a6+/HOQD3WbH43TcBvJlyh+6cHAvRUj2I91hhVL/37alHHs4AYDU6f0EpdHbi2CFxmmXhnYgFLOSDWMg3/CPFS1jJj74m0tt8teBkVZWvhN5YhnbsFHYVrU4241teEK30W93H1cfVx9XHt5rjUIS++mxfHT76ioumrFhSd+RXpzBd01JUFrcC/RoffMR3Fs7rrup10t0d982GLQwfrb6H24C7Hrsv63qhp4kwW6/IOUYO/D7ZxHPrGcBtRztYu5nk60LCyAnGN/GYcxjhDgDdkPxjD8ZfTMZbgw0bY13gnuNcHR1EfqGtCYr7Rthb64PXUB1gfd3+F7EbRYx0JfQZ2PfFn8MdnPKkrKNQ3PzydRDlfG6D3RqDnHdg12hX17oCm72fP01Pe/qLuuTdcape7+m5Ci+oPJ7oPQid33iL6PFbPuV8N/ozIfq3JnxxQ9EoblVnzDr4rPcD+4ouMsc9DmUjEhX0d06/qikfu18VOv6pNAsgn96vBXxDZrybLJvrVO8Sq+tU7xKrGb+xXk8lo0jtO3ki48vbnxPQr9gH7aIN/j9OvKsvt+WGDX7oL+GGUVUy/qpWA2H5lP4z9ylcB4VjHtjxZPvoDos/VTvGYQ8GhPWM1XgW0OcDG/qJ+QnVb9G7/AC7Dk77DtCqL3Jo7nOgUKIvc4NcIkSszVXu11KGyqdrtW/IgrrvbV7nUort9iw6LDahq+pwZYKMl6ieEqyXeYVnedRPeVRo4Qn+UtuChCvFMQXk+FfkbvEWgoejC8A0S/MecUciLgtOHvXXeF6D4bCi24R4qw3obA3RwdETPz6Ojwd8ROToa7SZGR5QRj473QtmAgGd53yfg7wUYzirdB2Vs0ijje4hOnutg/Vd6qmbfKhpvJ+H25s3KWL/U181minpepsTgmsiUYHtYFzxbSh+Wjac7KJvRJF9P0C75q3CeX0ofTxcwu3AIZU3UlVctKkOaaj1bZecMTtFZV5HOOkGHccXuUzH4TwofZTjVKvA6wZ/Be1++RX6UbPCOCKbdCvxrdPhd6L4F7Ks6V469iNpbVS5LB/3MJqJzV410Qj6LfUNVOmplWY1fVemgf+Jz6vfWSAd93R1Qj8dEdRvo/YIPmwJshfcFxoLo89aGf4R4KUhvfAqwlehx+3gK8IDgZVSUvRd+YxnSeUDQUbhurhGX9e3MpLev5xAdFUvd59CZE0lnbkU6cwWdGaJeVRtRsjE6W2ukgzYzl+g8UCMd1IP9ic6DNdJ5EGBeS3Q2CB7SeOB7FAd/Aso4y5U+/PVzg98Md8X8gOIp9BXII9bHWPZ+0Q6m988ZDfN/D0GdAv5I3rtiuPJk90OS3f1QFiM7g18DsvtXkh22i217G5RtpbIOlD1AZWNQhjiwLIE24DvWOaxvcDNEPR6vtsP7Av0V/eV4wz+S9La5zHi1nehh29PH5GLt21GO3viX4x8W9FQ/4JfjUaZI33CZjSk/+xCVoW8cozL0Zx0qQ/s+HH4jzlCbeAcs8sf6jfxtpjK1c3Ym/Z3+3kJl6sveM0WbOb61Ng8RnvThXTuoMwNJr1xYBmj/bKudHFz8OUys36E2dKgN94k2NGjX0XHoZNi1sjNr+w7By6gow37DMqSzQ9BRuLbViMv038Yg093j5+/89/mdPCdN4MJ2sn6nv/kgpsEecdJEnVdnv3lenf7mOAXjIda7baIsxf/sKTt/zxTtRT9RRnZY3+CUD5pHdJSv2+rQmefwbH/jwVnMgSyBcoQ/K5N7xTHpSpM/jkls94+UxB1r94Z/hqBnfI2Ispj7Uwe/suM3P/e+Hy1uUX3jhd9xbutRAT9PwJusHoP6BWR1mcoJG211f+ojVIZ5XeNB3Z/6aEn+YuSH+EcF/GkAV6QvFK4lNeFCe6sD15aSuOxe14ehPvsk5HOM6BS9ixbrh+4vtnL1r9Hhd9OIZ5THqcRz0d2wWJ/XEjYLOtYejFtwjnfBSZofnONhDMFzPIM/dP5EvQtP6m5/bCzLeaKi/Tknks6CinQWCDpN5+45T7S9RjqoGwuIzo4a6eD4zHmih2ukg/6D468tgodUZ99PdvAIlCm7vCD7d5Dgvzhvot4qxw6QR6yP49tW0Q6mdw3FQCXHNpknwrHXk921JLutUKZkxz7E4B+ZN1HvwyQ7pM22jXLaTmU4LvFYgrLimFTFPPjOi6NZbljP5FsxVorOExn+kaSSfozPJx8jetj29OFY8PFy9MbzRE8IeqofME+EMkX6hovzROhneUxF38hxHfqzR6gM7ZvzRFty2uSdlOa9RZ3s7w3zdv6b2s4Gmo8iPbsAltcb0t+WE0lxbCb7QzmMUXtUjgHfeXHXduKnjnFNzZM57io6T8b6O6hsu6Bj7elAGfrMB0/S/KDP7AA/7DMN/hfmTdTbRn2m5Kz6k+Ouov05J5LOgop0Fgg6TcdDHHc1FQ9x3NVUPMRx1yM10sGxluOujuAh1dnPkB08CmXKDjjuMvhXzJuo91nHDpBHrI9x15hoB9P7NYq7So7jMu4yXHmy+3WS3RiUxfgQg7dkTlrvNwv4EIwlOLZCeTxMZTgmIw4sS6AN+I51Dusb3AxRz+Rr/fUEvG8i7jL8I0lvm8vEXbFxkLXvyXL0xuOupwQ91Q8Yd6FMkb7h4rhLxRTKNz5OZejPHqMytG+Ou7bntInjLqX7jGsQ3qk4i9cNvgnrBn9KcVoHaKAtX3pyN5wag6wPUDZNrE9xLrpkzn1cr9U6sIrDvLy46vtr4DeWIZ3YfOYDNeKyflU6xnHYmKAz5tCZE0lnbkU6cwUdb+00RrcUHSWbpuMj3ifVVHzEcdijNdLBMZHjsFAe+N8olngMymLywAY/9rMT9f6TYgn0FTzuPwb4EgH/2gC9VuYbK+YbZBzG8URIdgMnd7dFzeU82Rn8TSC74Qynkt1Y0l0WG2s9QmU4XiMOLEugDfiOdQ7rG9wMUY/Hq5JxSnQcZvhHkt42lxmvniR62Pb04TjsqXL0xuOwpwU91Q8Yh6nYC3FxHDYGMJzbQN/4BJWhP+MYDe2b47AdOW3y4rAdAVyxcZjBH0J+o2TcJP2G4erHa3HxWvqcBnBcVjTG2lojLtO9frzW+64fr9VDp0y89maKOcrGa6+BmGOeE3PUFa+dsQvEa2fWFK9NB9m9lWSnchtKrhyvYRzF8RrKisfBonkzlV95seTN1Hi1O+XNxgBmO5Whb+SYDP0Z5828eK2OvFlsjotphuK6i6jc4JefPIHzcsqbIV8doP2Dfn7tBZNf62S/1bkGjteKnnecI3hWdOZWpDNX0Gn63B7Ha50a6XQAhuO1F9o6ZyjmuIn8m1rn9GIOg3/i1Il6tzjxWsw6pxevGfx6iteaXOcMyW5DTfHaepDdZkd2bNs4NnaorL/OufPpr3OG4zX0s5xf60BZXeuchjPUJo7X1HlHxhUbhxn8E+Q3SsYx0m8YLu9+kelJb3uaiNc62e+6vlrRIXrcPo7XdgheeI6XPqcBHJd5caGaL1Y9c+b5WsTN8VrRM2dzBM+KztyKdOYKOk3f58DxWlNxIcdrnRrpdACG47UdNdJRcU5ezPE7FHM8DGUxMYfBHwMxx+87OSLO5/CZdoZ/bYDe18jv4jhR1e8arrzzAF8PzOVjzwMY/D4guz8m2SFttm2UE/sXHFM7VIayQhxYliRxc1Ksz3JTc5GK5zei4zXDr86Slhmv1DkJtYe34vxhPF5TcbPqB4zXUKbqbADHa+hn+TwA+kbe89+BMs6doH3H3BuBbeJ4Tem+ynHhWT7OcalxabpoY4E+mhmrg4Z/JOmVdxkdVPkVNV6n1+C+JvudXYN75vI1i6+9bOWKy89efv0181ctW7z06jUrlq6cv2zZ1cuvuQaZRkJ7w3ssx4dh7PdD4j3i6OQ0pkjwvj0HF1+ggfXZAe7IwcWfzlGDG/89lPTyaRcfTIvAg4YW4usC4kstvnhOHpXzOsKF9UMJlxCuDxEurM+Li5gsYj5ZXh6ekANFvj5MfIUOU6X/PZGD6wOESx3GMlxP5uC6nnCpSTj/PZT08sny8vCk/z2Vw9dHiK/Q5pv0v6dzcF1BuNTmHcP1TA6u5YQL62Nd/Hso6eWT5eXhSf97Noevq4ivZ6DsWSrDeouITtFJGtafrEnaIqLzbI10ngUY/EZA+vdzUIa+1TssZYP/J+F9EwkTwz9CvBSkNz74f5Locfs4YfIpwcuoKONFqU8JOp8SdBSuTo24nqP2hCZhr/uZbpoPQFnMJMzg/+3NE/WOyXCq2ONZamMn6W3jA4Jei9o1LOAR3yDBz8l4Si964c98PCvqK9w4nnqJjulJr301YSOGfyTp1Z8yNvIc0eP2sY18UvAyKso4aaFs8ZOCjsL1cI24eNE0ZCPza7KRvwEbOX0XtJGFNdgIxlAxNlJy4SnaRnjhqVOOnrvw1IF3bCPPCV5GRRlvrFe2+Jygo3A9XiOuWBt5R0028vtgIxc3aCMm71gbMfhLa7ARjJtjbKRKMgzxGT/4DvHXZSPq8o8OvGMbeVzwMirKcM6EZUjHWxxHXE/ViCvWRlbXZCOfARu5ehe0kQ8VtBHFexNzL5W/OgZ+h2TUEbhGRf0OlW0VdPJ0ZO3PaH6UjqS/bf7OC+vbQUducnTEW/CcrIXVkyrSOUnQmeyF1U6NdDoAcxLReaxGOjiu8MLq4zXSQV8Ze9Ha/WQHT0CZsgP+LLTBnwZ28KBjB6GcJS6sPiDawfTGMhoVNx7JhVXDlSe7HTWNM4eD7B4t4EMwpu9QGcrjMSrDMZnzviq/iu9Y57C+wc0Q9Uy+1l+Yt2xiYdXwjyS9bS4Ta8Ue/LT2PVuO3vjCqppLqH7AhVWUKdI3XN7C6gNU1oGyp6gM/dmTVIb2zQurD+S0idfSFH/eBpup2mRWcoHW3WSmNqTz2IR1Vd/8PPzGMqSjDksrXFtrxGVrDP1NZr3vdoVYiDeZvVhioT8rEAulD4/nBv+VN03U+4tJiIX+eheIhb5TUyz0JMjuf/djIe/ZbWKhZ8rRG4+F1Bp2kVhIrWm/EGKhAcEfwqHtqXxSIt61HHpMY5qo+wvEN5ZdSDQ6gDcmB3Sh4LfBvO5ArH3tLnldXkOvkouNiXkqbmCMjscnYwPjhfCupk20A14/dBx6Jdfyphk9b28X0kv96XDS24d5F3ojDeyvkM2X3U+Zd/m5t5+S1wEfz8HF+ylDG5ex7OhTdv6b+uGXn9INY3sBZwPMIdlvtimUw/N7SQjOu9C+yoXviC9JtO0Z/routFf9ELpgfo/E1xHsox3wO7RP9HGga+9COutdEK/4KdqnalN5Cvd6B26HgFO00r9x3zNfYm+wx2U4Ujkfv6S7jUh3O/zGsvRRsb93OMP7SOKcinTmRNKZW5HOXEHHOxwZY2uKjpLNZB9Ae6hGOqiTnBvo1EinAzCcG9gqeEht5qxTJt6zrXnjBR96Pxvmt2fThwTRDjqJphd7AM3gF2c0JuNivZDslpDs1AE0T3YG/3qQ3dsd2bFto+/3DqA9RGU4NvDeOitLoA3q4JM6cGRwL5YDaDvg3e54AE2NdTEH0NCf8QG0DpTF5AawTd4BNKubHq46JPs9cbjq7OXXX7h05YplS9esWL1qyfIPXrv8mjWDgFmNHOzhO/Q3Xg0Velr09zQq20LliwUcPjFXDaDFNRH5Gv66rhrYQfS4fTzrf1jwoq6q+EX4jWVI52FBR+EaqxGX6U3/Ks/ed0xHycY7PVKWDo6iHOntqJEO2uZUfXowFK3cRtGKWsnwohWD/wOY2a+naMX79OADgC8R8K8N0NtMkR6OPlUjPcOVtwq0hWSHM9eYVSCD/zTI7h6SHdIeS7rLvE8Pqmt/Zia9suKVbhz/BsQ7b8WW5aZmSxV3LURHep3s90hSST/cXQvepwdLRpbjkZ6KLFU/YKTXAZpIn69fU37W+/TgQ1SmZhjKB8VcNYBtKnLVwJ2CjpU9CGX8idxtos2p3T1LmaYNAHcn4bgfyh6ksk9A2TbA/+YzutuGdsN2jbbLdo16zHbdgbLQ6fLQTkfDO0jwvwq+6avk75SOqp08Bq8y2Dg74Zks6vBjEbi2OrTVzOkxh7a68o55SZKwrc0AWlZmspme/YtjXhEfmGYoZy2ZoIM8PA8AeEP9pGaNnqxUP6mVMl6RG4OyrVSmrqlRPob9j7pGR+mn8jc4Hpu/yctC8zj/UA5elmdHwKsx2MuoK/tnv9GBMvYbKrujdJ39hrpqXV0Zz6tB36T4rOTKjHvVOuv3YKL1O3Sd6T+Db/vLgG8bKojz27CKsCfYaJJ0+wLrx4q+YFD5ArR39gWeD06fon6T7dZbgY/N9LCdDQt4xDdI8D+APuCTQmNQnz+prDLSRWMes4dU7jOzDC7Hw+lvnEf8kHSvA2UqTmLdM/h9IWP8rzSPqMNv8BWz6mpab8zxPmGO9V9snzDvwDueR1RZ0U7/a/IT5pPt1zoAEOPXEN58i9rJxvY8BmUdKkMfEfoku6KnVuHRR3g+Uu0YyVthv43svwNwbP9o42z/RT+zy+OG8mE8ZiP8QeDDjiLZKF324li18wd37fAKmHcqWOHqOLTVbtonHdpqNy3zkiRhm1S2aLJpYr6BcQHbouontdPOk5Xqp1GCR9kUtV2+7hrHd7ZrdRW20s9O0tsOld9Q8UAH8P5wkld7O0l3O1Tsq3K4HPueALZ7FslG+We1Usr+A+HVCR1vvu7h2u7Q9vRX0Vafn2ReEsEnfoLAaFmZyaYJ261zfqBkpfpJnRpgG4xdeWb7jF15xnGX9TPvtkpv3MUdHrz7Q60ZerqndlqgHbPuqZ0Wyv693Br7DdRR9hvqNB7bGeoqwnOuwOAvzPqi4o5fmSvgUy6Yz1D6HfpU3Urwbe8M+LahgjjfneHJyxVYPzYRU6O9sy/wfHD6FPWbbLfYNzsIl9ofoHahsp0NJzpnafj4yvIroQ84V4D+iPOasTtheK9CB8owV/BxyhWozwmlcKtI91ReH30O657B3wH6/MHsd51+o0NlKmfkjTne6Vq1LuCd3qw4l47OFfDu8JK5CXd3uJrv1HHrWfpf7OelMVeQdyLCyxU06de89ZA8ufLcHdvI9ow+gv2AOkXCPkLR60A9jMU/TravfGRszLID8J5F8w20L29djO0f9d2bW3eS7naok8dqzsUnge8CH/YYyUbpshfH5s3XOfep5useLi9P8bSAf8qhjXxhXaYdsklliyabJuYbGBewLXo5mvSJkZXqp1GCR9kUtV2+YRHHd7brDpRhDuyxwLiN7cBxm203lD9cRWN306fGeW79NPCi9hXgOIDwnwLb/RLJRt0u7unEswIeT0GzDwvdHBPC5e1peE7AP+vQRr6wLtNmPq2esl2TTRO2i/bGtqv6CeFjZKX6Sd0Y+iyVxZ5gf5rKYk+wPwVt/lJEjj52XwHm6PkWCeULPd3LG7NY99SYpeyf/Qbaf4fKUEfZb2Dfst/gmwkYnnMFBv91yhWgjlTNFTxHPD4DPCj95rmVwX8PfNsfB3zbUEGcfxqZK7B+bCKmRntnX+D54PQp6jfZbrFvOKej8g4oU84VmIyGBTziGyT47zi5AvRHzxDvHSjzbtTgOEPd6pPKfTi7QW9G0mu7mCv4Puke+jT2F+nDumfwI3Bj3z9QvFGH33icytAPcGytxhylZ2qtCMdQrmd+oOKNdtG5AsM/kvS2uUyuIPbWmIp+czxXoG7IV/2AuQJ1Sx/i8nIFTfo1lFOMX1M316ibiNme0UewH+hAGfuPxxx66CMwFjcf4fnI2JgF5+d/RrdUoX2x/aONd6gM9Z3jBpRh6NZ55cN4zEb4fcCHHUayUbrsxbHqCyr4BYgnqT2o65+KwPWUQ/vTAv5TDm3kC+sy7ZBNKls02TQx38C4gG1R9RPCx8hK9dMowaNsitruc1SmboJUtvsstJn104vz04dtV30FDOOB3S1XcAzY7jySjfLPXq6g6HwdfdhzEbi8+Zqnv4o28oV1mTbzafV2pVyB6ifPxypZqX4aTXrtmm1wMnMFrJ915Qp2vMBzBTFjPuoqwnOuwODPzfrC4s+SX5eTuYJPEo+Yz4iZ1xv8MvBt5wd8W2yuwODfluGZylwB2jv7As8Hp09Rv8l2i30zVbmCS6APvFwB5zU7UFZHruDGyFzBFYGYo2iu4GbQ5xXZ7yZzBegHOFegxhylZypXgGMo1zM/UHEuHZ0rMPwjSW+by+QKlP15uYIqX+VM/1NzHNUPmCtQcxHEtSvmCvLkynN3ldMsOt9g/1EmV3BjQ7mC+2vKFaC+c9yAMuS44ZPAi4p5cMxG+PXgw7aRbJQue3FsHfN1D5eXK/gfAv7TDm3kC+sy7ZBNTnauAOMCtkUvR5M+MbJS/TRK8CiborbLXwDG8Z3tGnUbc2DbGsoVcDzQEXiVT2gRvwjvzU/y9o7y/ETFQmqv0dYAHfQJHYAJffHpyciY2mhX1PeZTe+jyZsPdrLfKjbiPS8oYzyPxGNDB3hfW+ALg2p/qJons+4NB+B5P5nB/6qI2T197sC7qvqs9huV1We0jeXUVoP/jcnV572nWp9ZZ1GfOSek9LmV9PqwKvmc1bug/n/tRaT/39jF9V/NJTz9z8uRsP6rL5ZPpv6/o4D+P+fQVPpvbQvpP+YTEf67jv4r+XbgXdE1Qk//P0VlWG9rgA7qP/Y767/B/2Ok/hvtJvQfZcT6782b0qfoXIfXBDB+9/Sf12vr0v/5Fb+w7Om/tTWk/4aP8+X/5ei/skHvHGPRtS5swyepDOttDdAJxfOs/+Pwp0601dN/o92E/tc5f83LM3Sy32qt29N/XueoS/9fR/qPZ9w5N/SwwOGdY1dnVXZQO9SZTXUegM9sHngqtOHUbpwqRlL3Axt8HXNeD5dnn3l3YzBtdTcG85IIPq1eg+e/hpo+16pkpfpplOBRNsq2vDPu3rkSPquCuo3nxVg/1Rn3WNvFM+5fP7kb7yM5eFme3n2ESEvZ/6NUhvW8OyG8s2odKlPn/djOUFfV2hvPN07K+sLWN5r4aiXrN65Fo37z2p3Bnwu+7ZSAbxsqiPPUyHHW+rGJNZs676rJ85tst+psWov+Rlxq/YbtbDjRc12+l8XgF0IfeGvRfB+Hd+dGR9BV/gjXoldmfPAZ3fQ3rkUvJt0rexfjatDnC7LfdfqNHVSm7jrwxhylZ6OiPo6hXM/8QMUz4NFr0YZ/JOltc5m16Nj76Sr6zfG1aJUnVP2Aa9HqDC3i8taim/Rr3j0+eXLltWFsI9sz+gj2A+gj2H90HHroIzAWX0m2n3d/Dscs20U7Ury/k8Usysa9+5zY/tU5drVnjuOGJ4EXFfPgmI3w14EPu41ko3TZi2OfFvCYB3+E2qPOmXu4vPP13llRRVud22FekiRsk8oWTTZNzDcwLmBbzFuTjZGV6qdRgkfZFLVdXt/uQJl3Vx7m328LjNvYDhy32XYfEbxiPDBT0C97Bw3fqYB2jXxwG9kHIV6O+beA7T5Ksqn7fgqeMxW9n2KHQzvPbzDt/v0U3fCqn2Lup1DfcFH2yTkGdXeKlakxR+nnDtGO2HF3B+DdQLmCuu+B9O6r5b2idYzr3l0s7Dc4PmR4zhUY/GcoV4A6UjVXwOM4nrlR+s1zK4P/PfBtnw34tqGCOD8XmSuoaRwfbHocz/ObbLfYNzx/VGMpypRzBSaj4UTnKfj+ZYP/spMrKBsvqPyd8keYK/ge5QrQdjFX8NWa8lQ/AH3+A4o36vAbXmzN+1bVmKP0TO0NxDGU65kfML+CuthErmD8/oCkt81lcgWxc/eKfnM8V6DicNUPmCtAmar7e7xcQZN+zcuB5smV5+7YxjL5AOU/HnbooY/AWPx7EfON2JgF5xs3Ua4A7YvtP/acLMcNaj7H40ZoT1PonOwPwYcN/Ww3zrrv1OJ9+EXv1PJy7GqvgXcGoH+nVje86id15oT3mMfaLucYcHxnu0bdxv3lrJ95a7Jsu2qNGeMBlSsYS7rLiuYDlM1znKZiX/XdAY59R392ot6rSDZ15/li5useLm++lpfnY9r9PF83vOqnmDzfGJRxriDWPtnmUbdx3GX9rCtXcCblCpRP8HQvbz8N617sGRL2G0XzAUrX2W9Yf6KuIjznCgz+2KwvLP4seY+UzBU8QzxiPkPpd+hM8ALwbccHfNtQQZwnZngmaf924bOgng9On6J+k+1WjfEt+htxqTNgbGfDic5Zhs4LzIc+8L6zx3lN9EecA3lE0FX+CHMFyzI+eK6T/sZcwVmkeyqvjz6Hdc/grwR9Pjv7Xaff4D1OKmfkjTlKz9Q6L46hXM/8QMW5dHSuwPCPJL1tLpMrUPan5jsV/eZ4rkDNcVQ/YK5AzUUQl5craNKveesheXLlubu680X5CG8Ng/3HIw499BEYiy8j21c+MjZmwf0Kb6ZcAdoX23/RfICaW3PcoO6TVXcT8X2yq8CHrSXZKF324ti8+Tqvw6j5uoeryrkn776QvDu1lE02eN/EUNN37ubdqcXxv3en1hiUebbLd96pfICyXcyBrQ2M29gOla9U8QCO+WfR2L275ApuB9t9qJ8r6KHNfPZzBd1lY1DWdK7goYZyBQP9XEHhXMHTu0Gu4Ivg256rKVfw6X6uYLxsqnIFn99FcgXfjswVfKmmXMF3QJ+/0s8VeE8/V0D0+rmCqckVfLuhXMG/nbTz9+6WK/g++LCf9HMFPbRDNtnPFRSz3TpyBT9pKFfwJRq7sU3eHuQdVFbnGYQOwITOIOwxb6Ley+Z146z7DEKH2lP0DMKYQzsvT9Eh2v0zCN3w3t1+3hkEHMvGqAzzZXWcQWD9HBPt6MA7tt2O4DXF++sndeNV47mne3lnEDrZ76JnENhvqHsHpuoMwhHzdv5bMaZv9AzCqfN2/pv28VHzNM6iZxBen+Hpn0GYujMIJ8/b+a/KFaA/4jwH+qM6ziC8e97O33lnEObNm3jPPo39RfqEziBcMm+i3mnZ7zr9Rv8MQv8MwvPIs39fqGcQ1Bqa8hF1nEEwH+H5yI7Aq2IWPIPwGcoVeGsT6t6BqTqDcMW8iXrXz+vG2T+DELbJ/hmEYrZbxxkE1s+6ziBwPKDWPDsCb4v4RfgxeFf0PrVO9tt0NfY+te0BOugTsG0XZP/yPUw3zdv57yTdATZU9K4cNR/08iB580FeU0ffzXfrqDNoamzAte8HaWxoARzrUivp5bUl2jYaqK9wYb+8Fn4fDuUI/8i8nf9afILyLNCvi2ZAnQRwIO6SOrMI22qPiicxdlL00mdElA1G8PJbJ/3G2dv/4/i9W1TfeOF3rJdDAn6hgDdZDRPvs5Oo52xlu0bbyrjtWIb2ZzykNnvEkm7+hkryFyM/xD8q4BcDXJG+2Dfp1gXUd7NXvJNnM5Up/1s2r8z+Cv023u3J83CDf3reRL0vzOvGqfLqOG41cd+sh2urQ7uOb18yL4ng0+pN9tjmzavy1j9iZKX6Sc3DOO7aDGVbqSw2zuO5ncorK/3cKtoRe9ftVsB7LeWOVazl6Z4XWyjdU3talP2z36gzr8x2hrqK8Jw7Nvj/OW/nvxVzPDJ3zOtITwAPhfblzNv5b9rHX5uncRbd6/OHGZ68OLemdaTC+zGKriPl+U22Wy+foOY0Kr/Ddjac6L0Kho/nGn81b+e/KneM/ojz3mrPhvJHj1AZ2gzmjlvzd/7m+Uf6G3PHfzcv6Wo3+jQ1F2HdG1/3nT9R73sZzjr9BueO0A/wnkI15ig9GxX1cQzleuYHzK+UzOVG544N/0jS2+YyuWNlf2pvfkW/OZ47jt3XhrljtW8ecXm54yb9Gsopxq+pvM1o0ttGtmf0EewH0Eew/9jh0EMfgbG4+QjPR8bGLI8A3vdTfgDti+2/zrwyjxvKh/GYjfB7gQ87hGSjdNmLY/P2SHv7Zp+JwOWdqcnLWzNtlbdmXpIkbJMN7vkcanovu5KV6qdRgkfZFLVd3uOC47u3jwX3FLB+5uUQ2XYfFbyqeGCLwKv2nraSXj8Ukzt+WMCjPNgnYO6CYwKstzlAR+Ug0odzxwZ/ZCbnvJjaaDeh7ygj1nflsxG+aK6e59fqnnKl70ZT7UHeArxfQGPDgwJ/i8qQ1wdF20ZFfYNTdOZVpDNP0GFcOB/cDLg4fjb4CzI9szhoG+AtoD9XsvwNB+LeURJ3i/AliY5bDf+MJGzPI6IsJkc9+JUdv/m59/1osedv8F2Mv5kn4E1WaBsFZHWZ8hFoI8+3Bcp2UBnaufGgctQPl+QvRn6IX8WZpwFckb5QuN5WEy7l+6vg2lISl+Xh0Q9uI1xqbMVcnslkpmjXlkA9hgvl3JGOwj9GvG4WvG4W7VZ77g1uhqjXCvxrdPidt5ZxKvGscrBbHZ6xvjfWnUrtuRPKMLdy2XzND/bJncAPjw0Gf9miiXrL54fbz3Mr5HlO0s1L0f6cE0lnQUU6CwSdOvVG9eccovNgjXQwPlhAdLbVSAd9y/5EZ3uNdNCfvZbohOzgI/Mn3qO/DNkBx+IGPwB28IuOHSCPWB/H262iHUzvxoxGxbFWriNwvByS3U01+ZD/fc5EvVsK+BAcCzmmRnlsozKMmxAHliVJ7xwkfbzx2OBmiHomX+svnLs0kZ81/CNJb5vL5GfV3EzFFta+x8rRG8/Pqn1Eqh8wP6vyBojLbCxmDRZ9I+dB0Z95e5YOh99II9Qmy1fMdPibIXCxbiHvRWWP+IxPfIf4R5JeGy2jW2qOq2IhHpuwruqbk+E3liGdbYKOwrW5Rly8rj0VsdDcinTmCjovlFhoLtF5scRCn5s/8R79e+x4bvC3wHj++Qxnk7HQFzMaUxkLfYlkVzYWeh/I7iskO6TNtu3lFzFG4VgIZcU5TpWPUvlbleNkuWE9Hq9KxibRsZDhH0kq6cf4eKViRDVeVYz1xmMhtX6i+gFjIZSpiou8WOhOKkPfyPEO+rMdVObFQnfmtMmLhe6ENqR/d7K/LwDb+cv5O3/PEPQuTLrLUG/vSyZwfJvsD9s6Ru0pGg9g/W3ETx3jjfHcARjOQXWSXp47Ds9Yv0Nl2wQdHqfZZ/5gvuYHfSaO8ewzDX4+9Ps/Up91gDb7PuSZ466i/Tknks6CinQWCDpNxykcd43VSAftgHNQTcVDHHftqJEOjrUcd4XsYOAtE+/RD4bsILQe/DdnT9QbznAqO+Ccx8OALxHwrw3Q2yujUXEcl3EX51JCstubZNeBsiI+5Msgu30c2Xnx0xiVxZ5X4D1CKteizlx55/fV2S6Tb8UcTXTcZfhHkt42l4m7YuMga9/j5eiNx11qr6bqB4y7VN4JcXHchX62Q2VjUOad4+b8FNo3x12dxG8Tx12KvxkCF+sW8t5EDsrwjyS9NlpGt8aIHrePc1De3T9Yxjmo7YLOdkFH4dpWIy7OQeH6K8dCai14i0NnTiSduRXpzBV0Zoh6rcC/RoffMR0lm6ZjLs5BjdVIB21zqnJQofH8NBrPVQ7KG88N/goYzxc443lMDqoj2sH0zqZYqMkcVEh2i2qKhRaC7BY7smPbjs0zjVFZfz0umt4Lej0O/WyHytA3crwzBmVF1uO25bSJYyHkb1sA1yC8UzmnQYJfkdlXamtXZr+VneM+1X8iuA7QYb1G2byY47Br4DeWIZ3Y2OmBGnH147AJOvyuSBw2ViMdtBmOw15oOSm1Hpn6mFsjclLoPzmWMPjvv3Wi3u2TkJPaNIk5qZDs7oyIwzzZGfz/BNndXSAO6+ekJvjEd4i/n5MK56S8OGwMyqYqJ6X4Y1yxcZjBP0N+A9tZ1W8Yrn68Fhevpc9pAMdlRWOsrTXi6sdrE3T4XT9eq4dOmXjtqzXFa6sg5viDSYjX/mgXiNf+pKZ47XyQ3Z+R7Lz9nx0oG6MyjKM4XkNZIQ4sS5K4vBnWf7HlzTrwbnfPm22jsjEo45gM/VnoLGX6u4m8WWyOi2mG4rqLqNzgfwT5tR9S3gz5ehBof+S0brgO0GH9R/n282sTfbOr5Nd4Lyzi5njtAUHnAYfOHMGzojO3Ip25gs4MUa8V+Nfo8Dumo2Qz2Xvtx2qkg7Y5VeucoZhj1mkT79HfxsYcBv/DhRP1XpLhbHKd8+CMxmSsc4Zk9wqSXQfKisRrfwyym+3Ijm0bx0bv3OEYlfXXOaPpvaDXOdHPdqjMO3c4BmVF1jkfzGkTx2vIn3eHjL3z4jCDP4n8RgfwVvUbney32uvP+j/ZZyPvLEfPPRuJ7eN4rSN44Tle+pwGcFzmxYVqvri1RlzsaxE3x2tF79CYI3hWdOZWpDNX0PHO7cbolqKjZNN0XMjxWlNxIcdrnRrpdAAmNl67iGKOMSiLiTkM/jqIOd5FMYfaa8v0MF7bJtrB9C4hv4vjRFW/a7jyzkYuJdltgzLl01h2Bv9OkN0ykh3SZttGObF/GYMyjuXq3HuL9Vluai5S8T606HjN8I8klfRjfLzaQfTYLjheKzl/GI/XVNys+gHjNZQp0jdcHK+hn+Wzkegbt1MZ+rMxKutAWcw9EdgmjteU7qscl8GpHJd3nwS2sUAfzYzVQcNf130SKr+ixuu9fvrfa7Lf165ZsXLFmuvPXL5m8bWXrVxx+dnLr79m/qpli5devWbF0pXzly27evk11yDTSGhveI/l+DCM/X5IvEcceZdjFAnet+XgWkK4sD47wE4OLr4gTg1u/PdQ0sunfWxmWgQeNLQQXxcQXx2oP0a4tju40t/XES6sH0q4hHB9iHBhfV5cxGQR88ny8vCEHCjy9WHiSzlMw/VoDq4PEC6s/yjheiwH1/WES03C+e+hpJdPlpeHJ/3v8Ry+PkJ8hTbfpP89kYPrCsKlNu8YridzcC0nXOrD7vz3UNLLJ8vLw5P+91QOX1cRX+qSfTVJW0R0ik7SsP5kTdIWEZ2naqSDl5/vD/XSv5+GMvSt3iEmG/zxcvYmEiaGf4R4KUhvfPBXF9KrANTa/qzgZVSU8aKUupz9WUFH4XqwRlxPU3tCk7BfpUnYA1AWMwkz+LfAJOzXaBKGMuKPEak45gFBr0XtGhbwiG+Q4H8z4ym9kJg/cvOUqK9w43jqJTrq+JA14jN+8B3iH0l69aeMjagPEahLxa3tzwheRkVZB36HbPEZQUfhGqsRFy+ahmzkazXZyFFgI3+4C9rIn9ZgIxhDxdhIlUuQEJ/xg+8Qf102omJZz0a8D3NgGW+sV7b4tKCjcD1SI65YG/luTTayP9jI9xu0EZN3rI0Y/D/VYCMYN8fYSJVkGOIzfvAd4q/LRtQFcZ6NPCJ4GRVl/NG0oovjiOvxGnHF2sh/1WQjPzlrol7r9J2/dyUbGc54irURxXsTcy+VvzoGfodk5H1Y5RjRHjXHO4baE9KRfU7X/CgdSX/b/J0X1n8AOjLL0RFvwXOyFlZPqkjnJEFnshdWm1rwPInoPFwjHRxXeGH1kRrpoK+MvXT2CLKDR6FM2YHliwYJfj3YwVGOHYRylriw+oBoB9M7NqNRceORXFg1XHmym0OyKzvOrAbZnVDAh2BMzz5efXRd5TE576vyq+pjhqOivsHNEPVMvtZfJT9YGr2wavhHkt42l4m1Yg9+NvmBVNUPuLCqPg6PuLyF1QeoDH0jf0wZ/Rl/zBDtmxdWH8hpE6+lKf68DTZTtcms5AKtu8lMbUjnsQnrqr75efiNZUjHu1C6zsupEZetMfQ3mfW+2xViId5k9mKJhd5bIBZKHx7PDX4fGM/fPwmx0FW7QCx0dU2x0P89c6Letf1YyHt2m1joyXL0xmMhtYZdJBZSa9ovhFhoQPCHcGh7Kp+UiHcthx7TmCbq/gLxjWUXEo2iOaALBb8N5nUHYu1rd8nr8hp6lVxskQ9ilYyPo+PxydjAeCG8q2kT7YDXDw869Equ5U0zet7eLqSX+tPhpLcPQ3vQ1N4t7K+QzZfdT/lwDi5vPyWvAz6Sg4v3U4Y2LmPZ/5fFL6kffur0bpgdGcxzAPNM9pttCuXw/F4SgjNcBps+FS/0iLY9w68+2l3G9lQ/YPtQN/dIfB3BPurA7zH4vV20JUZnkacYnS3ap2pTeQr3eQeuI+AUrfRv3PfMH/Qx2N+A9aXjl3S3Eeny3mT1cSF1aE4dzjA4RWdORTpzIunMrUhnrqDjHY6MsTVFR8nmhXoA7aEa6aDuc25gq+AhtZlv0Py2A2XeeMGH3u+C+e03aX6LdoA8Yn3MDXgH0Az+W5QbGIM6VXMDhitPdn9NslMH0DzZGfyHQHZ/68iObbsDZWUPoCEOLEugDd4BNKz/YjuA1oF3u+MBNDXWVT2AhvYdkxuIPYBmddPDVYdkvycOV529/PoLl65csWzpmhWrVy1Z/sFrl1+zZhAwM3VsRZJoT4xXQ4WeFv09jcrupPLFAg6fmKsGOvC+ici3k/2u66qBDtHj9vGsf0zwoq6q+EX4jWVIZ0zQUbi21IiLP1HRv8ozTGdX+AROp0Y6HYDhSG+sRjqob7GR3kFnTLxHfxgbrRj8QRCtHJzhVNlc5BHrY6TnfYbZ4GdnNCqugstIj2exoVWgV5Hsyn6G+T8WTNR7DckOabNto5zYv6hrf1RmiFe6i2ap1aegY7LUGBE0EekZ/rqy1A8RPbYLjvRKRpbjkZ6KLFU/YKSHMlUncb2rPPmqAfSNoat9UM+UD+JIb0tOm7xIj8ebDYKOld0PZZup7BOizandvdmxu9OoHUUzJKcJmorOXdnvQWrjheTrsN8K6NabZxAdw4G4S64mvDnWLkMrKciXWtkYjODl/82ad8wPO//yAPtj4yVkszwWIfxpAr7imPMzM4BGQrStTI2HVjYEZcZDmrU8Ykk3fyVXon4mRn7K9rGMP0VZdMeRugalKK59k269UmMo+pG7s98x862SNhg93zL8dc23lO/15ltKZqOijK/ivUvQuUvQUbg21IjLxgDVzzzf2iDobHDozBE8KzpzK9KZK+jMEPVagX+NDr9jOko2Tc/reL51V410UA94vnV3jXTuBhieb20WPKR++7qIOcNmoBmaMzwIc4brndgFecT6OL7cKdrB9D5KMUjJsUXOt3i3c0h2bZIdxm8xsjP4G0B26xzZsW3jmMTjCMrjLirrz7ei6ZWeb5W8yWN8vtUR9IrMt9RNUTzfQj/L8y31eQDlzzjmQvvm+dadOW3i+Zbirx8LxcVC6cPzxCrxy3014vJilH4s1E2nHwuVo1MmFvrlmmKh2TCe/+okxEK/vgvEQr9RUyw0ALL7LZId0mbbjs1LcyyEsuJ5fdFPlaiV4AZPzEXHQpNxYk6NVxVjvfFYSN3cqfoBYyGUqYqLvFhoM5Whb+R4B/3ZVirzYqHNOW3yYiGsi38PCdiN0F6E/eYZE3WSBWFa9xAfG6HsXiqLtU/EgfINnXq/hNpg8H+dtSHNNZ64ROOclvhrXyr3ae2YDnStrID+/mbK16wlE3RQX9IH86aoL0nix1QGf4+AR53j2PAeKON4Tukjxhemj0pexmMT8kIeYuSl9gvEyovtHuV1P+FS8S/K0JOX8diEvJCHGHkhfFF5mQyUvD5BuPLmOAsJ3nAPJ9onGL5Bgv8J+AS+lcfz8RsFbvSNLcKB7bhBtGMGlWHdFO/iE3f+nqw8D8eaDwEvrAuId5Dg94T47BUkm7wbtlm/OgIe8xabqT04jncicN3p0B4T8B2HNvKFdZk284mffDRaVmayqegHhpQfwHwV+wHVTwgfIyvVT2rNvUNlsTmnh6gsNueEN0mxfqr8U8hnsz3gfOY3AnuUEK+ne96NE0r3VI5V2T/7DfV5UWVL7Dewb9lvdLK/i+6EPyrriyZ3wrN+DyZav0M73OeDb3t9wLcNFcR5XIYntdE9wUaTRK+3V/QFg8oXoL2zL+hA2YCAL+o32W6xb3itQa2bo0w5JjAZDQt4xMd7894EfeDFBLy7PDYH7s37zB5SuV+S8cE5gfQ35lJOI91Tt+OpGw35drzLQJ8X0ByvDr9xN5WpPVremKP0TO3e588meze2d+B9E7mUTva7rhvbO0QP254+nEsZK0dvPJeyXdBT/YC5lA7QRPqGy3zVZPs1lFOMX1NrTWoPIdsz+gj2A97nx+9y6KGPwFj8ErJ95SNjYxbMX/8y5VLRvtj+0cbZ/lHfOW7oQBnHDWPAi4p5+BPnBr8CfNgvkGyULntx7A4Bj/tSvdNpOyJwPejQfljA73BoI198A9QO+lvZpLJFk00T840xBAC8oX5C+BhZqX5St8DsoLJY2x2jMhzf2a5RtzvJRJt/ITBuYztUjlfFAzjmn0Zj9+6SK/gY2O79/VxBD23ms58r6C6bzFzB/Q3lCtr9XEHhXMFju0Gu4PPg256sKVfwTD9XMF42VbmCX9lFcgV/Hpkr+EJNuYK/An3+Yj9X4D39XAHR6+cKpiZX8OcN5Qqu201zBX8HPuzH/VxBD+2QTfZzBcVsd4zKyuQKftxQruALNHbH5gP4vP6Dgm9l86hPKPvQXi7+mpLBT4P7Gg44sxunsh+1/y/WfvjMs7IfD5eXp3hEwD/s0Ea+sK6yZXWGvsFxVNou2ifbrucz0ydGVqqf1A24fNMu2iePyTgObaeyDpSxzY9BGY67rJ9q3FV7m/Jul+T7O2L32baIR4RXZ72U/T9EZbFxPfsNdWub0vUx4t36E3UV4TlXYPCHZX1R8cZVmSt4hHjcATwo/ea5lcGfDL7t8IBvGyqI88gMT16uwPqxiZga7Z19geeD06eo32S7xb7hm7Vjb3BjOxtO/BiC58xzoQ84V4D+iOMMddNk0btMMFdwUcYHz3XS35grOIV0T+X10eew7hn8u0CfT81+1+k3xqgM/QDfzKnGHKVn6uY/HEO5nvmBijclRucK+Bb7HeXoubfYq/lOHTdVp/89KuipfsBcQd5N5l6uoEm/5q2H5MmV5+7YRrZnbw0DfQT7j45DbwzqYSx+Edm+8pHqJvi8m7MPolyBlw9AG2f7R33vUBnKENuHeqN8GI/ZCL8UfNgako3SZS+OfUzAe1/EQV1/LAKXl6d4XMA/5tBWX8lhXpIkbJPKFk02Tcw3MC5gW1T9hPAxslL9NErwKJuitvsIlXWgjO16DMoehjavCYzb2A6Vr1TxAI75p9DY3fQtzqGxG21X3c3Ise9HwXY3k2yUf+7Au6JxJ8+Z1Hzdw+Wtj3n6q2gjX1iXaTOfVk/Zbif73YTt1jk/ULJS/TSa9No122DsjdJsn7E3SuO4y/qZt+/FG3dxXZlvdR8TeD3d8/KsSvc6on3K/r3cGvsN1FH2G9i37DesP1FXEZ5zBQa/jXIFJb/kI3MF/PU6zGco/ea5lcH/Evi27QHfNlQQ5yORuQLrxyZiarR39gWeD06fon6T7Rb7pkO4OgIXypRzBSaj4UTnLA0fr0190skVoD/ivGbsDfcdKlNf2Ujl/oeUK0DbxVzBZ0n3VF7f6qYP657B/wno8+co3qjDb3DeUuWMvDFH6dmoqI9jKNczP1BxLh2dKzD8I0lvm8vkCpT9qflORb85nitQcxzVD5grUHMRxOXlCsaAf4Stw6956yF5cuW5O7axQ2XoI9gPqK/DsY9Q9FQuDH2E5yNjY5YO4LWv+Cgb99bF2P5R3725NccN6ovCYwCDYzbC/yX4sH8m2Shd9uLYvPn6GLVHzdc9XF6e4gkB/7hDG/nCukw7ZJPKFk02Tcw3MC5gW/RyNOkTIyvVT6MEj7IparuPUpn6mp6yXcyB/XNg3MZ2jME7tt0xwSvGA2rtsImvQfPc+gnghddCeRxA+H8H2937rG6c9mXiJInTCfUlZPy6Mfsw1ImnInB5exqeFvBPObSRL6zLtJlPq6ds12TThO2ivbHtqn5C+BhZqX4aJXiUjbrf1Psy9RNUhmOU92Xqx6HNrJ95ZwW8fQWYo+evwytf6Ole3pjFuqfGLGX/7DfQ/tlvoI6y38C+Zb/BXxxneM4VGPzBWV9Y/Ik6UkDXZa7gaeLxSeBB6TfPrQz+uIzHtI8PCfi2oYI4D83w5OUKrB+biKnR3tkXeD44fYr6TbZb7BvO6ai8A8qUcwUmo2EBj/gGCf5o6APOFaA/epJ4R3/EMYjKHSt/hLmC8zI+ZiS9tou5guNJ99Cnsb9IH9Y9g18C+nxi9rtOv/EIlaEf4NhajTlKz9RaEY6hXM/8gPkV1MUmcgWGfyTpbXOZXIGyPxwfOFdQ0m+O5wqeEfRUP2CuAGWK9A2Xlyto0q+hnGL8GsLz3B3byPaMPoL9APoI9h8PO/TQR2Asfh7ZvvKRsTELzs/fS7kCtC+2f7Rxtn/Ud44bUIYcNzwNvKiYB8dshH8n+LCVJBuly14c+6yAfwZgHqP2oK4/G4HrcYf2cwL+WYc28oV1mXbIJpUtmmyamG9gXMC2qPoJ4WNkpfpplOBRNkVt92kqw/Gd7Rp1+ylo88rAuI3twHGbbfcxwSvGA7tbruA6sN3bSDbKP3u5gqLzdfRhT0fg8uZrnv4q2sgX1mXazKfV25VyBaqfPB+rZKX6aTTptWu2wcnMFdzWUK5gzgs8VxAz5qOuIjznCgz+XsoVoI5UzRU8QzxiPiNmXm/wz4Bv2xrwbbG5AoP/xC6QK0B7Z1/g+eD0Keo32W6xb6YqV/B4ZK6A85p15wp+PzJX8FxNuYL/Bfr86UnIFaAf4FyBGnOUnqlcAY6hXM/8QMW5dHSuwPCPJL1tLpMrUPbn5QpK+s3xXIGa46h+wFyBmosgrl0xV5AnV567q5xm0fkG+48yuYLfbyhXcERNuQLUd44bUIYcNzwDvKiYB8dshP9j8GHfI9koXfbi2Drm6x4uL1fwSQH/nEMb+cK6TDtkk5OdK8C4gG3Ry9GkT4ysVD+NEjzKpqjtPkNlOL6zXaNuYw7sew3lCjgeyDvzzHGT2mPlzU/y9o7y/ETFQmqv0dYAndC5pKuy37zX6P9GxtRGu6K+z2x6H03s+SQVG/GeF5QxnkfisQHvw9iHxgbMRfGeDLU/VM2TWfdC3yjh/WQGPy1TYozZPX327oopqs9qv1FZfUbbWE5tNfgRaOsk6PPeU63PrLOoz9736Xn+WFc+579O2/l7V9L/l76I9H/2Lq7/ai7h6X9ejoT1H+O3qdD/7xbQ/6cdmkr/rW0h/cd8IsIf6+i/kq+n/3lrhJ7+P0tlWG9rgA7qP/Y767/BvzFS/412E/qPMmL99+ZN6VN0rsNrAhi/e/rP67V16f/XCui/F3sr/be2hvSf7/oy+DMd/Vc26J1jLLrWhW14hsqw3tYAnVA8z/pv8OdG6r/RbkL/65y/5uUZOJ5H2/D0n9c56tL/XyX9xzPunBsaEzjUWRXOG+2Asg61Q53ZVOcB+MzmpQsn6l2zsBunipHG4F0Tc14Pl2efXnytaCNfWJdpM59Wr8HzX0NNn2tVslL9NErwKBtlW94Z99B5MdRN7+4KpZ/qjHus7eIZ96WndePdnoO36B2ufAfNmGifsn/vToiyZ9U6xDvfgcTwvBZt8Gsz4dr6BupIAV2Xa9GPEY+PAA9Kv3ntzuDvBd92U8C3DRXEeUvkOFvTXTWDTd9Vk+c32W7V2bQW/Y241PoN29lwoue6ho/Pet8p4jrljx4h3sveudGBMlyL/qWMDz6jm/7Gtej7SffQp7G/SJ/QXYy/Avr8YPa7Tr/RoTL0A4gjNOYoPRsV9XEM5XrmByqeAY9eix7PHya9bS6zFh17P11Fvzm+Fq3yhKofcC1anaFFXN5adJN+DeUU49cQnteGsY1jVIY+gv0A+gj2H7F39WMs/ktk+2OiHdsE3hlUhnVTvBfRfAPty7vPie0f9d27w62TdLfjMeBFxTw4ZiP8F8CHfZ1ko3TZi2OfEPCYB+f7g9Q5cw/XDoe2d1ZU0VbndpiXJAnbpLJFk00T8w2MC9gW89ZkY2Sl+mmU4FE2RW2X17dxfGe77kAZ5t+/Hhi3sR3qng0VD+CYfz+N3R2AK3t31RiVoV0jH9xG9kGIl2P+vwDb/SeSTd33U/Ccqej9FB2Hdp7fYNrKbzAvSRIeW1/I91PwnN+7nwLts0NlaJ+cYxiDMp6PqDFH6Wcn6W1H7LjbAbyvoFyBWsvswLui90B699XyXtE6xnX2G9i37Dc4PmR4zhUY/E8oV4A6UkDXZa6Ax3E8c6P0m+dWBj/rrTv/fd5e3qpxDhXEOZDhycsV1DSODzY9juf5TbZb7BueP6qxFGXKuQKT0XCi8xSGj/PbM6EPOFdQNl4YE3SVP8JcwXEZH5zPTX9jruAA0r2yeaq5oM8HZb/r9BtebI04QmOO0jO1NxDHUK5nfsD8CupiE7kCwz+S9La5TK4gdu5e0W+O5wpUHK76AXMFKFN1f4+XK2jSr3k50Dy58twd21gmH6D8x5hDD30ExuLHke0rHxkbs+B8YxblCtC+2P5jz8mOUZmaz/G4EdrTFDonewr4sHNJNnXfqcX78IveqeXl2L3zYYp2/06tbnjVTzF3asXaLucYxqCM7Rp1G/eXnxsYt7Edai1ExQM45h9AY3cH4Pi7F0XzAcrmOU5Tsa/67gDHvu8A230/yabuPF/MfN3D1XFo5+X5mHY/z9cNr/opJs+H373oUNkYlHn2yTaPuo3jLutnJ+ltR5lcwZ+8pRuv8gkdeFd0Pw3rXuwZEvYbRfMBStfZb1h/oq4iPOcKDP76rC8s/ix5j5TMFTxJPGI+Q+l36EzwRvBtvxDwbUMFcd4QmSuwfpzss6CeD06fon6T7VaN8S36G3GpM2BsZ8OJzlmGzgt83MkVoD/ivOYYlHEORN3trvwR5gqeoVwB2i7mCjaT7qm8Pvoc1j2D/yTo810Ub9ThN3ZQmcoZeWOO0jO1zotjKNczP1BxLh2dKzD8I0lvm8vkCpT9qflORb85niuIvX8PcwVqLoK4vFxBk37NWw/JkyvP3dWdL8pHeGsY7D+8u/rRR2As/gzZvvKRsTEL7lf4ahazKBtn+y+aD1Bza44b1H2y6INwzEb4z4IP+z2SjdJlL47Nm6/zOoyar3u4qpx7YtpF7tRSNtngfRNyvlHnnbt5d2px/O/dqRVru3znncoHKNvFHNjvBcZtbIfKV6p4AMf8zbtpruCPwHa/288V9NBmPvu5gu6yycwVfLehXMGd/VxB4VzBv+4GuYK9zt75b9rHP64pV/Af/VzBeNlU5QqGs36d6lzBkRkfebmCvc/ubnfZXMHRoM/7ZL/7uQL59HMFRK+fK5iaXMGRZPt15Qpu3U1zBceDD1tAsunnCsI22c8VFLPdOnIFCwLjNrajTK5gbxq7OwDHtou8efMItmuVR2gJXqwd6juEHH8sBtu9nGRT9xkEb/9j02cQvL1X/TMI/t1+3hkEL1eA41wdZxBYPztJbzvUmcIZSa89dADvIsoV1H0Gwbt3hMcUrMd+w8s/TPYZhA9mfVExpm/0DMIt4NvWBHzbUEGcH4J5av8MQjeuHQJXE2cQbozMFXCeQ+XOq5xBeIRyBaEzCLeR7qFPY3+RPqEzCI+DPq+neKMOv9E/g9A/g/A88uzfF+oZBPQR7AfQR9RxBuERsn3lI2Njlh2A9zTKFcTmCr31ujEqa+IMwnPgw75IsumfQQjbZP8MQjHbreMMwhcD4za2o8wZhNucXEHVfEDZfQXqfCbHvl8F2/0WyabufQUx83UPV8ehnbc+xrT7+wq64VU/xewrUGv1Te0r+FZDuYK9G95X4N1J4u0rqJoPaHJfwT9QrmBX3FcwcM7Of9M+/ueAbyu6r+D/RuYK+vsKemVa176C/3JyBeiPmt5XcGimX3n7CobO6W532X0FrwZ9np79rtNv9PcV9PcVPI88+/eFuq8gdg2jjn0Fh5LtKx8ZG7PgvoIBZ19B1XxAk/sKjgIfdirJpr+vIGyT/X0FxWy3jn0FpwbGbWxHmX0FHA90BF7lE1rEL8KPwTuWv/I52Gaen6hYyNvnwHTQJ3SA9gXZv7z2szCTR15M3eRaPMqI9T0vR1R0PtjJfqvYiO/5VPvK8uazP5i/8/dM4MngWJdaSS+vLdG20UB9hQv75bXw+3AoR/j3Zf1v8QnKs0C/LpoBdRLAgbhL6swibKs9Kp7E2EnRS58RUTYYwctvnfQbZ2//j+P3blF944XfsV4OCfiFAt5kNUy8z06inrOV7RptK+O2Yxnan/GQ2uwRS7r5GyrJX4z8EP+ogF8McEX6Yt+kWxdQ381e8f7ezVTm+W2cj3MMWHSfGX4HJLTP7IMQy91EY1rd+8z42zRF95ltdWjn5a2Zdn+fWTe86qeYfWaboWwrlXl33aoxMW+fGevnVtGO2O/ibAW8X5rfjVfFWp7u5e0zY93bIdqn7J/9hpePjp071rXP7E4a73fFfWaPg2+7O+Dbiu4zuy8yzu3vM+uVaV37zHZAH3DuGP0R5729u27VnZJ5+8x+m3LHoX1mT5Luld1n9rugz89Q7rgOv9HfZ9bfZ/Y88uzfF+o+M/QR7Ae8u263OfRC+8x+m2xf+cjYmGUH4P3c/J2/lY2z/cfedevd21DXPrOvgQ/7Dsmmv88sbJP9fWbFbNfb4xK7z+w7gXEb21Fmn9mTNHbvLrmCfwDbTRZ14+znCnr57OcKussmM1fA+llXruCm+d14+7mCid+hXMHMrC925VzBqzMe0z7eN+DbiuYK9s/w9HMFU5creCX0wVTmCt6S8ZGXKzicdK9sruAM0Ocjs9/9XIF8+rkCotfPFUxNruAtZPt15Qo+Mn/n790tV3AO+LBLSDb9XEHYJvu5gmK2W0eu4JLAuI3tKJMrOLzkPKaV9Pohgx+Ddyz/7QIe5cHzE5QjxwRYb3OADvoEbBvvMzP490XG1Ea7CX1HGbG+K5+N8EX39fE8GfWEz3ihjI1m3nz2svk7f1uf3Q9w9yXdZZ8QOKzsISjjb61tEzxb+zvAi7V/A8AY3kGC/3kYGzaQjYwlE88A8Z4+MTo/BjAbqD0dKNseget+h7anL4o28oV1mTbzafWUrZhsmrCVDgIA3lA/IXyMrFQ/qT3BvCfzPii7n8owH9uhMvzW2kNUhrq9DdrM+nm/aMcGeMdjwwbBa4r3h2/sxvuQwOvpnhob0I5Z9z4h2qfsn/0G2j/7jQ6Usd/AvmW/Yf2JuorwnIsy+AcpF4U6UkDXZS6KcxxjwIPSb567G/ynwbdtC/i2oYI4t0eOm9aPTczZxgCAfYHng9OnqN/sZL+VL/gE4fqEwNWBdxxTmYyGBTziGyT4Z5xcFPqjMeId/RHfF/+AoKv8Eeaivka5KLRdzEV9hnQPfRr7i/Rh3TP4PwR9/izlourwGzxPRT/A5xtQpzw9U3MBg1P6bH7A/ArqYhO5KMM/kvS2uUwuyov704dzUSX95nguSsW9qh8wF4UyRfq4Xpk+k+3XUE4xfi02N8T2jD6C/QD6CPYfDzj0QudPvka2r3xkbMzyCcD7vSxmUTbO9t+BMrZ/1HeOG1CGHDdgXkzFPIZ3kOC/CT7sH0g2Spc78K7oGuBD1B61Bujh2ubQzjvXxLSRL6zLtEM2qWyxk/1uYr6BcQHbojfXTp8YWal+UmfAON8Ua7ucf8bxfYzKVO5F6acX56cP2+5DglcVD9wh8LYFXoPfALgGCEf6+6rs9yDB/0jEroZzo+DhBnjHfbpZwG8EGONnZtLrxzhXjvVuzX4rfTe4ivq+t9J3bA/rO+YFBwQ8y2aLgMe8UTv7re784rn3rVBmNGcQHpR3yvvLTuzmJ69vWb82AS7Vtx/Mfg8S/PC5O/9V+qX05XZ4xzL0ZI78zCQesO5MUc/kq/TL4Crq10ylX9ge1i9PX9KHZXOXgEcdsr4dJXiUk5WhXRrNGYQH5f18TDOnGw79Vyvwr/HK73iegLgWEz8baqSD7X4t0VkPZTiPe/m5E+9ZJgOi7srs9yDBn3TuRL1XZr9nivobqL6VvQrsbOGScH32wThGtKkM5YE+J9ROhP9goJ1HAJ8nOrkS46ui3Y0qu0PfF+PXEb6oX2ffjTa5nnCtF7jUPIBjhOFE94HhGyT446EPOFfShvobifdbC/KuxhPlR6xu2hcbMz+i4oBNRFONYaqvRkX9jQFc0wT/aLfc7wOJHg8Z3nQC85XKPw8S/Dzoq3OWaJxJgIf1AZ6HA/B3Eg8Gf7rQF88PoP5vJpwGfybgPLkgzlUBnG91Yg1lp5vgXdHxlOMJlONdVIa887i4Behzn76T6CMe1HOmmzj88piaxy+PN1a2FMart2e/pxO+gr56wOurcwW/sX213mkf47J6g0mvPno2gvJ497ka51BBnJeIMV3FKocD/qWBeCRJeuOR9GG/jD4D7fDlFJMg/Tbxb+PElcIe1VhvuKqN9a1vq7H+VoDgsV7JBuHZJ2wS8NiPHGPjeHMYlbWhjGOrWwWd2LH0VmjrFXO68W5w8Ka/30V85MV4l2W/2Q9f5/hhJUNP5mqOiHLldVTsD84pKJ2dbH3E9rM+em1Nn6LzYdZHNX4ofeQ4y9Ob9PH0EfNS76DYDnltJ91ldzr85MXcNxC8+fjhADz7fIO/3Yl77hY8ePOEewT83YLnmcQD1mXaaJcok0XUHoPfHOmPa8p57Kv0H+XG+u/JKH1YpvcKeJSVyWSU4FG+Sv/vpjKVR/JsNtY2rG4qh2PJV9edn2NfbfBjBfNznq9uKj/Xzn5Ptq7uqvm5NpTF5ucOjYgF2g7/Sh83CP5VXon7HevdkeTztUHwpeYxGxw6x1ekc7yg03QO8nhqz0anPUVzIVh/I7VnY43tUTzn5VR/i+YwyrfhHIbHO4P/S5iT/XZETrWo7t6edPPp5ZDSZwm0P0maiDn1uu1kxpwcV+J4GZMzRN3DsdNgEuKxCXmhPcfMGZXf8OSrcnRqn/kdVIb6toHo1JV//fFx+fzf4bQ3Tz84F7MLrdFNeQzAulB0jY79JdJR/pL7GP0r9ovlsgcJ/h+c2FHpgac3eXM640fpBn/7TeX5G/Qhu7TebKYylXeM1RsvV4hjtI3fXo6slXSPk6jPCB9aX9lAeFr0fk94j/VWUJs5RmLc7yP48X0NAXjDx7HI4Hk7/1W5hE05PLyfeNicw8Mm4mHcPwoePPmnjxcTTk96bbGA3Qy2CJ/xg+8Q/0ii9WN2EvW0WH5GT+lB+rAtK3tSayWeD1R2rnC1a8RlcYOKYecQnaLzIqzvzb/mVqQzV9Bpev5lbVP7warSQZuZS3TurJEO6sH+RGdLjXRwPOK9M3cIHtJx4ojzJt7juKX2MKYPn4Ew+KsWT9Q7KsOp5szII9bHcX+jaAfTOzajYf4P87gF/JE852S48mQ3h2Sn1mo82Rn8BSC7ExzZsW2rGGNm0isPjukxP8trryr/i+9Y51SOfIaox+MV5oGLzBVjbAPxjyS9bS4zXqk8N8aEfH7kvnL0xs+PqDOUqh/w/AjKVJ3/NBtTfpZzBugb76Ey9Gecp0f7Phx+I41Qmyy2nenwp+JQjN1UvoV1b7JjpU3l6LmxksoPFY2VeP/VrhorIZ8cKxXNuWL9jQ6duRXpzBV0ms7t9mOleDplYqUVNcVKPzpvot5KGu/RV8TESptEO5jeB3eBWOkakp1aT/BkZ/DfANld58iObbsfK03wie8Qfz9WCsdKKt5oMlbalNMmjpUUfyreSZ/ZSdwTE0th+wr03aGxumn464qlVFyiYilr35Zy9GanurZnVg/j2J+D32r/E/ZXXf2ncjNT1X8bytFz+0/lrOrsP7StIv2nbPNo+I1l2B4vrsT6kxVXHk10QmP8dhrj1ZoWjvG8Z8DgPw1j/CM0xsfuC1gPPHOba1rnHyh6rsnbu5w+Rffd8n4lb91a7SlvJb19UnTdGs+3fjOwbt0CvCtFXbZthN8s+DB4PkvDMHzuxeA/C2swrcB+u9C5l9A67OcA52Sfe0E58zkSrIf+wnAnBFfRJg5VNoHtYZtQe3hVrGjweXt4We8xluU7Gtm+0meRwOXxuqECr9yP2Fe839hgUS+xPayXBv9VoZeq/03mTfS/tw6vZOqtw+fJlPNd3l5kbx0+b88N+8Q7BA84Jk7WHJVzBvcCLwOCV8M7SPB/BWPwv9C4bvOlJImzWTU/wzkXn4fGudn9Ebg8X6ruk73foY18YV2mzXxavQZtS+6Tw7k225bqJ4SPkZXqp1GCR9kUnS/fS2Wx8+V7oM3/EsgtYTtibRfzUpyzUr7K073Ysco7b6Lsn/2GGuOULbHfwL5lv8F5EIbnXKPB/zflGlFHCui6zDVuJR7vAx6UfnMO0eAPgPXWaYs1zqGCOIcyPHnjrPVjE/e0ob2zL/B8cPoU9Ztst9g3MWeDUaYc15uMhgU84uOzVftAH/CdCuiP7iPeY/N3fF5JrSGkcj8+44PPW6W/cb58IOke+jT2F+nDumfwJ4I+vyz7Xaff4L2d6Ac4TlVjjtIzFZ/hGMr1zA+YX0FdbCInbvhHkt42l8lbxeaoK/rN8Zz4A4Ke6gfMiaNMkb7h8u6fbNKvoZxi/JrKk48mvW1ke0YfwX4AfQT7jzsdeugjMBY/nmxf+cjYmAXXIVfQfAPti+0fbZztH/Wd4waUIccNePe+inlwzEb4N4MPW0yyUbrsxbEPCni8Z/Buag/q+oMRuO5xaKt7RB90aKv7jZmXJAnbpLJFk00T8w2MC9gWVT953wpUslL9NErwKJuitsvfm8Dxne0adRvvpV8cGLexHThus+3eLXjFeGCy9v7VlSt4F9juBwLxdJLsGrkCL9/ezxVM8JPnY+vMFcTuQ6wjV8D6qdbfYsdd3O87JyJX4OleU7kC9hu7Uq7g57O+2JVzBZvBt320plzB2n6uYLxsqnIF651cAfqjpnMFz0XmCrbUlCv4NOjzPU6uoKzf6OcK+rmC55Fn/75QcwXoI5rOFTzXUK7gCCdXwPa/K+UKfhV82Ff7uYIe2iGb7OcKitluHbmCrzaUK+B4gPf0p8+74R3vZeE93iE+DN70JLTXKpQb+COIs1rOvqCF0LY/CbQN/YSa/3CM9yPwE3/mxDq2huvFOknS65cZ9uREy+CvgY+/WhymZTo0w2ljiuM7i8NwJws4xjFNyIDHt02inpp78pmcu4nGXQ6NLaKeonEn4USZqbMG9+WU3yvaloh30wT83YH2JoL2PTl47xJ4lK/xfBTH1HXFBkuzvZzKXkI2ofTqbof3e4n3vL2AzLuSH/oPtT+SzzKwbm0W7WyJv42/y+Ed+1h11zvCWF3en5qcv/MftT8V77FW+wCXBnAOAE7en6p05kh4x2Ox10/Ij9rXeDfVU3cIJeKd6p/1BMu5hJMFT6G/twg8IR6887Xe+b269hSeQ7aJ8Qzfbb+ReEdYviuFz2awfrcJHu/hGRAwrN8Gf4Cj3+pcIPK1NIDzIEe/ldyPgHdF70/juZG6P03xjr6H36n+Yf1mf3Sy4Cn09yaBJ8SDWncy/b4jgJNpsj6kD+t3W9B53n8fu/O3ku+tRFPt9VN78kZFfb6jyXg4EnSJv4uBfKo2LgrgPNrRz7rvY29nv5V/2OzUw/6bLmjNth//7T+Gz2xhjySsg7xffS7IacESzUuL+cl5GjzHOLtF+JJE5wh303OMr0xzflXPMfLZqPQ35rZPPX/ifcjGsO6l2W+2sdPPn6g3P4AzSar5pl87thtv7N0csWOLd6bNO/fDd2Zgn4Ti0tAZp8uy3xxDngO26X03rJ67QFv/onJKGCNyTsk7N5U+ReNYk8kowXO/hPRL5XpZb0LfQzB8fM7sIugDXrfCu2n5rMsdBXnfKHhXdoy2wXZc9/dT7dsobPeXOmOrWt+v8n0Z7/upnEfCet55VINr4g7Uybx3up39VjkMjiPVvaXK9+L50jHyveq+Zezb0Lf6Qt+FfGf2m7/Vd7WjX3njStE7/Plu5qL3oDd43nm/qT7vbH0bc94ZfSGfk1ffUEx5b5N+qXES61p+ncfJdQVzLZ7N5Y1Rxo+Xa1E5VdYlld8zHry9BunvS5JuORj87ZHxQk173uYXXQ/2vl2TPtwX3h45lMkowXO/4N+Iy1t/Ud9Pulvg57uf7nHihdg9szG8K7+r7A1t6jBnns8x62aHJtfFsWc4AB+af3aEvNifhXKvFxNOg9/h+AM1pn4c3hW9o51zryofqeYP6CMNN+OsaJ9vmeo72nn88O72986G5+VrPP1HHRol/cfx/Dai6cWxXBfphPTf8LGuftbR/7x5+UWE0+A/VzD35el/XozgxUjevTzmbxqMz8+Y6vic9d+Lz4vmeWP1H3Xov97QjRf3UyudfUf2m+9P/mpB/cJ5Q9kYVOmQ53s5P6NiV+7H0DjD8xSD/6PIeAvvhzM8VlZAn2dNtT/ntTcV33r+07tbSPlPNV6y//xWZH6Gc0t3FOQ91t7Qpn6Q2ZvpIM59eby5w6HJddGuQ+ON4eOx4e+d8QbnZiofxOONwf+fgvN1b7zJm69zPkjds6Xm8t583eAq2uf+TX9XKy9XxuMN+kP+Xk7R72rF6j/q0Dcy/a8m1w+/pwW8GO4BATlI/47DZH0yAvTt38EIPr755X/9k8+8dc4H9qX66WN9tGcF/Af/2vKv/exffP8vmsJ/25zBfTe8c9FZTeH/2h4/+NHv//aVm5rC/7fTF58x7ZfWv7Ip/Pf96NwT1h102D81hf/uLx1z1j+d/w+H5OGfmf0ehvIBqrNH9u8glA0LfIMEf2BmA6ntvJRilSFBL333WgeuFfhX8Yz82LsRAT8g4I32ngLeyvaCMvSxCIPyQlwjUI7wr8nabn0yHepY/VFBfzrRV3zju2kEv5eA30vAp+08hPwatr3oGnf6DFN9fIe0bX06ffZIevnFfjSeTK7TBbyVoU6wvuwJ7wcErj2onsHPoX7E9lj9UUEfZZEE+MZ33I9Kv0cE/PPf71kywXNZH/MLX736sf/a96n/3ZQP+x8nHP0ze7/j8HZT+Pf+8q+c99c/vurwpvDf8jf//afrf/6l/5iHP9Wj/zh/ooxtoUW0+VsgLVGvCt9v3vah22ac8NynmpLLM3t9/S2f3zb9PU3hP+U1Gw46+Hc/OKMp/EODB98/+7lLz8nDb2dAr1mz+urll6xYdcnyDy+//No1K1avuuTypZe/d/klq69eevnK5Zd86OqlV121/Grb6jedUBV1rdNFs+Lrt2+dzggL1U9ute1IJac0p1v9kkPLuBs9HeojL4Z3gOC4TlrOJoYwxmfJfjqjYjvfYvX3KFd/wNrFoR/zZPhNFoMA3wr8a7i4zGiNJJV0pOXxjvzx1lAcYnlqrHANF8TVZJ+grLBPDMbKplEZ1humsiHRhj2A3xlJr44PUhmGXrcAjqPg99HZb5NPOd804VtK2lyyXxIeTneX8PJ12b+7cnh5GPBsIc7xgC+k49MEPkutoa4OA78V7G2a8TIoeEF5Gf50WvTy7PdVV6+4buma5Reko/vCVWfY2H5aOrQzIdQf1L9pSXh8wvYoHANQXz2p3CumwW5tEe2iabCTsn+bToOZf1m1es2KK66/ZPmqD167/Nrlyy656trLVq64/JIrrl11eRZ3rVxp8dbBWZ0pjrfOqhhvnVUxjhi0+sPl6st4S9mq6cQCqLuAaBrMmQBzJsCkjxeT8XiVPmdQ2YCgr2Ibo5va/r7we7/sd8Wx7KwmxzLzuQdkf6d+y6Yjmd8693lTOSOzlMXPG8qCzE5O+6mZMDkO+1r09zT6m93VoMDDD9bDYbKiGzurqht7WfZv027MwoZ0xrj0yuWXXL186bJLM+ApdlPvreim3ltxWjhQ17QQV4G9aeHZUPdsoqlcEK9QoT28lcoGBG4OmedAnfQ5B3hoURl+0YTD/3OJdyw7D8o4G70YyjjkPR/KeEqxBMp4mnIBlE2nsrdB2QiVvR3K9qSyC6FsLyq7CMpmUNk7oGxvKnsnlM2ksndB2SiVXQxl+1AZ3tSxL5XhSav9qOw9UDaLyi6Bsv2p7FIoO4DKlkLZS6jsMig7kMouh7KDqGwZlL2UypZD2cuo7AooO5jKroQyC7vND7wCygr4gXOs/iHl6r98P0H/EOAtfU4rh3vcR2NKanYS91jdM8rRnmb1F5SrP2j1zyxXf8Dqn1Wu/oEW8rwlc47ma9UKYsWQ9yAcQ+2JSXdVWS1DfEaP22e+P/WD5kd+OilduWLN9RfsDCmW/DSiQA4R64HwHsvxMZgq0WD6nCXw8MPRYPp7ZtIb9HIij3uF33Eij+snk0hHRRKspSUjvhmxWmr4R5LeNpfR0mlELySX6Ynu49lJ1LNXK+nVrQGBk9fLhkWZ4bKIZTiAy+oOErxFZ5wcTp/TiUZsojnVlzOJd7Yr9a/h5Xesj9z29Kk4qa3cp8ozJ/H1WzyRx7ak8nwbvd8DylSi3drB/f2G1kQ9izJnEgzKeGbSK3P2B8puVEJU+RPWcaUnJtvp1L7ZSdQT7U8M/0hSyX+N+xNOVIfkYu0bKUdv3J+MCHqIE2cu6d97ijLDZTOS4QAuXARA+Pdm/44SXPqwP9lT8Kv2+6T6cjnxjrKt6k+w7dwnZcewPHteRe+xLMaeDf7lYM8fzN6pGID7Vy0cYER2GuFSC2lcT8lLtWXIoc2w2F5lT3s4PA877R/JwXUG4cL6I1QvZEfYl8p2EIfCbzg8e0GezySeFU227xCuBYQL6+9F9WYE6GD794L3MwRthd9wTBfvC9jikLV5b0F3D0F3pmjX3lRvpmgPt3lveD9T0Fb4uc34vkCbh63No4LuHoLuTNGuUaq3j2gPt3kU3u8jaCv83GZ8X6DNe1ib9xV09xB0Z4p27Uv19hPt4TZjdnw/QVvh5zbj+wJtnm5tniXo7iHozhTtmkX19hft4TbPgvf7C9oKP7cZ3xdo84i1+QBBdw9Bd6Zo1wFU7yWiPdzmA+D9SwRthZ/bjO8LtHlPa/OBgu4egu5M0a4Dqd5Boj3p70GAwdzKQYK2wm84Wk493viAPCuaimeEawVwK9pYbw/C4fHcgnenEc+KptV5aQ4ujjWw/kup3ssCdFBPXwrvXyZoK/yGo+XUQ5451lA0rc7BObg41sD6B1O9lwfoYPsPhvcvF7QVfm7/yx2e0385VlA0Fc8HB3jeS9RPAm3aqyTPPNbvFcnzXgGe9xb1k0Cb9i7JM4/Ve0fyvHeA51FRPwm0abQkzzzWjkbyPBrgeV9RPwm0ad+SPPNYuW8kz/sGeJ4l6ieBNs0qyTOPdbMieUY4HOsOEPWTQJsOIByxPPNYd4DD80CAXisHdwhHK/K3mutzPiR9Zmf/HvOekdtv/NwbP3PK/WPHLT3oJ7P/6A3nX/G7f/8vP/tL31/+xAcO2fMDjGuaoDuN+D5A8GDt8XQhEe9aAk+LYJm3AxzeXh7gLcS/0omXB/hEnl7h8G91eHdK+szO/j32+O+/etXiVbdtuPdfr/q9//7G4O/v9ZlLj/vZz87+9EOzHnr3PjvJpf87hNr+CtE+4/uVUMYr0QOi/iuT7odxMJ5XECzzhnWnRfKGMNMCvA04+LlfZjv8T8vhH+uybGcH+A/l0WYnvfwfIvCznxsMtBH92DTge1DUO4ToYtkrAnTxfch/HiDoevqobNrezxD1zR/yjqb09wiVYf5sfyrDud6+VIZj215UhjHRgVSG85IhKsP86AwqwzwSH3rBeck+VIZ5iYOpDOPNA6gM+24WleEYOUplGKe8jMowJn85lSl/q/Lre1IZ5hRfQmU4b30FlaEeDVMZ5pRnUhnmtl5KZTg/Cq15pb95jQbzwvtRGeZY9qYyjGMPojKc/5m/s3PK2P70UX6TbQ7PVKv5He6ZQPjZGVCqo7bV1eqqXLfaMWLwKp/NOe/0Ublxnsth//NuPxVPVdvlm8xI2392a4IOt5/XW722pg/LRuXb0Q8Z36NJrz8ZoTLUR5av0huMS05LutsYuzamDjadJvhvEY+oj4iD9dHgj3f0Ua0Xefqo9Bd1zvhR60t7Uplal1f6aHBN6CO2n/XRa2uSFLdV1kfU1elUhrhHiM4egk6sPuL+Ctt7UXE3/3tbwIvhHhCQod38Z2YIdtW7eWLvnmny7pbzMgSpbM8HHbZ3TC99d4kD1wr8q3hGfuzdrn53y89lCHblu1suJL2vshs1fYrc3WIx+ZXL19ihvGVL1yy95EMr1qxafs01P5MVT/Ehl2sqHnK5puL2t2kVD8nIs3jIC7vCsncfeOfsUhfyMvjNm/pxgzmbHW4e5yGaN4ZjmTrUY2VvhTIectXQplS44ta5sytuTTvCC1PQZSWJDrex3cZDWv/I7HfFc9QLKsrnmP0EfcNlG/vnZn97W9cqyvnImOEJ8Y8kldrd8sJidRY/de1mT9nG/jOXr9l5ePP0n/rTi3a6U1RhNBf7m3fv80jN9Xl119g9IvsX4WMediuIa5oDh27BO2GgMgJexsPLTnAmoSVoqiyYl3kyee5Ot5rZ9Q278rUTRwPPFWcZ11SdZZxMvDY1yzCZX7Fi+cpll6z8qfVfsua9S1dZomyKI6ozK0ZUZ+4uEVWVaGkm/OYjpSpaqripekFFmbb2C9BPHxutcSMdTxDYjXIitxXAW9Gkz6xq0pbwbdqkTR+WLb989QeuWn3N8kveu2LVGj5kurtbdBX+K2ivtGilyZ5F51ntGYCvRWULBN2KbTqjopebtl8S9mxm0byFUKXwLdBRyx1saQqH8gp8JC2Bds06LvnGK791wvVHveTE1eddd9O33vbMR/ffceR3Rw/6x2vfdN2//cVqbss0h/cZSb5nmhaQz1R7Jlt6a9ozWTtXrtnpkyzg6kcZleyvH2X0PlFRxquwQjIhJ9z+lhAe3obxCqhjUUvFy2aGeSKJj9pSwD5IHaVrCVzKp+I9jkcAXoZjftSyjZrYooxnZ7/ZR9u/s5Oop6XotASdXT1CfG32b9N+WOl+HRH27nllcW3uv6T7ru1uKnT/3t1UZdP2FV161SuLWxXTzP0ri+F3CFf/yuJeHefwCV36AsDRwJXFVae7/SuLk+6QlPmuK3d8GPDcv7K4d82oBW0MjU/YHoVjAOqrZ1cI4SbrymJL5z1/JXHWMRMXFf90br386lVLVx6TQU1xhHVOxQjrHHWvT4H6QxWtZpwuJuaUtZgWxFxSfBbAnBWAWQgwuEkhfVSkxpcVTxN8qFHsTCobFLzxSiTyhJcFY7JPbaJoURnejlpTQvOtTSY0TZdPK4e755bGorzZ6GKTLZUswBGvanSG+J5/Se8Q/0hSyU7Ho9zYjTXp6GSbhTInmF4+vXjnT7uPGjlF7NNES1rdHHWN8UkAji2NrYstCq0I8Ybq8zvmV938hdIyTVU76/n0VigtP5Dkp+UHEj/WxPKBHJ5PJ55DabyK4/05Vcd7i/ObHu+N7srVS5e9Pvs9xaP6goqj+oIXylLeLPiNJ9JCtqn6eIqX8FpF59UDVKZuDkvlYenxunJHTS4HHJH9raInHlHLLvWgrdmj/DrON6vYiOdv1dwzHVGtz7IR9ZyfupwFV6/+QPeEjwch1Qgs7+KK/mU4hvfWVnenTXAWsu3KiYzZyQTPFQfXBVUH12OI16YG191z3WJhxfF3YcUxY6i/bhH1DPTXLfrrFrvausVZgKOBdYuF/XWL/roF1u2vW3T7XHxqCLUWVg21JmvdwrJ1y1Zcvfynybnrlj+/VnHl8qsv+eC1q9esWL5qjUkCD3AZxiIaY/VL3lcsN1/hWdq9mGD276Co1wr8HTqNpGBbDt4Zosxw2v0kyK+1w+6ewd64bvnVa0wLTIYl70sdj3D3L1df9gHeMWZ4ORJPCtCwBy2HH+5b9sIcyReg3wrxofrb+hLv+j2Ayib6cs3qS65eumzFh/clLsvG61a/bHbf6peNuZQ2YAzA8wWUIMcxxkvJo557ejHIiKDLMMpLTKO/B+n9QASs0horU7FGzE0JKjZRHofljvqmcHHcxPpRtY/2EzSNt/8fNjN8yD3uEAA=",
      "custom_attributes": [
        "external",
        "private"
      ],
      "debug_symbols": "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gm5Jt6Rb0i3plnRLuiXdkm5Jt3xu1QPXOIiTuIibeIhGdGIQ6TboNug26MYsSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkySxJZsgsHcRIXcRMP0YhODGI+TLol3ZJuyJJTuImHaEQnBjEvzh+yBDiIk7iIm3iIRnRiEOk26DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26Tbptui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26XboduiGLPHCRdzEz238Co3oxCDmw8qSi4M4iYu4iXQzuhndjG5GN6eb083p5nRzujndnG5ON6eb0y3oFnQLugXdgm5Bt6Bb0C3oFnRLuiXdkm5Jt6Rb0i3plnRLuuVzwxO6Lg7iJC7iJh6iEZ0YRLoNug26DboNug26DboNug26DboNuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbptuh26Hboduh26HboxSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySxaz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C7oF3YJuQbegW9It6ZZ0S7ol3ZJuSbekW9Itnxv6Xi8O4iQu4iYeohGdGES6MUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLMEfa/f13Us9L1eXMRNPEQjOjGI+bCy5CLdJt0m3SbdKkssC43oRB4bs8SZJeh79Vk4iYv4uX3PD17oe71oxM/te4TwQt/rxXxYWXJxECdxETfxEI1It023TbdDt8qSWIWTuIif2/eM4oW+14tGrLPkFAYxHyJLgIM4iYu4iYdoRLoZ3YxuTjenm9PN6eZ0c7o53ZxuTjenW9At6BZ0C7oF3YJuQbegW9At6JZ0S7ol3ZJuSbekW9It6ZZ0y+eGvteLgziJi7iJh2hEJwaRboNug26DboNug26DboNug26DboNuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbptuh26Hboduh26Hboduh27MkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsQd/r9+z2hb5XYGXJxc8tZ+EkLuLn9j0HeaHv9aIR/9zmr9y+LGnMh1+W/H3QWjiIk/jnNr9HYqzqe208RPtwFzoxiJ/b+KZTfa+NgziJi7iJh2hEJwaRboNug26DboNug26DboNug26DboNuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbptuh26Hboduh26Hboduh26Hboduh25GN6Ob0c3oZnQzuhndjG5GN6Ob083p5nRzujndnG5ON6eb083pFnQLugXdgm5Bt6Bb0C3oFnQLuiXdkm5Jt6Rb0i3plnRLuiXdXpbs38uS/XtZsn8vS/bvZcn+vSzZv5cl+/eyZP9eluzfy5L9+9Ft0G3QbdBt0G3QbdBt0G3QbdBt0G3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt0+3Q7dDt0O3Q7dDt0K2y5Lubv6vvtTGIdDO6Gd0qS7729F19r42b+Ll9TQS7+l4bnfi5rXKrLAFWllz83FYNVllycRE/t12DVZZcNOLntr0wiPmwsmTXAVWWXJzEz+17q7yr77XxED+3g8GcGMTPzeqAKksuDuLn9n3n1a6+18ZN/Nx8FBrRiZ+b13wrSwqr77Xxc/u+yGdX32vjIn5uYYWHaMTPLbwwiPmwsmQDB3ESVy9q9b02HqL1olbfa2MQsxe1+l4bB/Fz+75VaFffa+MmHqIRnRjEfFhZcnEQ6bbotui26Lbotui26Lbotum26bbptum26bbptum26bbptul26Hboduh26FZZkqfwEI3457Z++Nkg5sMvS9b32PZdfa+Nk7iIm3iIRnRiEPOh083p5nRzulWWoFoqSy4a0V+1VJZczIeVJaiWypKLk7hetVSWXDzEOjagE4NYx1bTyR9xEL9jG3VAX5Y0buK3kqOm82VJoxM/t1FuX5YAq++18XP7ni6wq++1cRE38RCN6MQg5sPxI9Jt0O3LkvX9Bf6uvtfGQ/zcZs33y5LGIH5ua334ZUnjIH5u9TpUfa+Nm/i51ctM9b02OvFz26MwH35Z0vi57XL7sqRxET+3U4N9WdJoxM/tYLAg5sMvS1aFY/W9Nk7i53aicBPPQzz8oqgcav3rjLP6f+uMu7iIm3iIRnRiELOxuiMbB3ESF3ETD9GITgwi3QbdBt0G3QbdBt0G3QbdBt0G3QbdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023Tbd6oyri6Dqjmw0ohODmA9PuUXhIE7iIpZbFh7i5+a/QicGMR/Wq9fFQZzEz81X4SYeYrmdQicGsdxqvvXqdXEQJ3ERN/Fzi1loRCcG8XOLmtn36tU4iJ9b1EJ9r16Nm/i5ZQ1Wr14X/WG9TrkVfuNmjVv5UNcM1fG4sqZe+XDRiUHMxup4bPwb9++9X+EkLuImng9XoRH9QysMYj788qFxECfxc/ue+bur47HxEI34uVWmVsdj4+c2apJfPjQO4iSWWxnPTTxEIzoxiJ/brOl8+dA4iJP4uc2a5JcPjYdYbrvQifFwL2KNUEfxVff+/kJ/V5PirpfualJsHMRJXMRvsHo3WU2KjUZ0YhDz4VfSu17Qq0mxcRIXsdxqvnaIRiy3mpkFMR96udVJ6+WWhZ9bXRJUk2LjJh6iEf3hV7x/i1g4iJO4iJt4HmahFxqxLL75VlfgrquO6gpsnMRF3MTzsOqiLkuqe6/RiE4MYj6surg4iJO4iHSbdJt0m3SbdJt0qwo4s7BGWIU1wil0YhBrhG+7qyOvcRAncRE3scb9NqC67HZdiFWX3a7Xzeqya1zEbwSrpa5iuGhEJwYxH1YxWB1xFcPFcquDr2K4uIk17ncaVefcrrsW1TnXWEechTVCHWad4BcP0Yg1bq2DBzEf1mlfL+7VOdc4iXQLugXdgm7hxHh7EdzN5G4mdzO5m8ndrBrCFmb2FlY3HDaruuEaJ3H1XlQ3XOMhGtGJQczet+qGaxy9WdUN17iI1ltYHW7Yt+pwaxy9hdXhhoWqDrfGTTxE682qDrfGIGZvVnW4NQ4i3RbdFt0W3dbbzWoT23VRVm1ijUb8puO1OlUMF/NhFcPFQZzERdzEQyy3mk6VyMUg5sMqnIuD+LlFzbcK5+ImHuLnFnUaVeFcDOLnVtd91SbWOIjlVudDFc7FTTzEcqsTpkok6iypErk4iJNY49bOZ41be1wvPnU9WQ1hjU4M4udWt6OqIaxxECfxc6vL0OoC299Xdu/qAtt17VldYPv7Gu1dXWDnh1/Lh18NNQ7iJC7iJp4PR6ER/cMyHkHMh/NHHMRJLLcs3MRDNOLnVhec1QXWmA+/ejt17VldYI2T+Ll9n4fv6gL7e9UuPEQjOjGI+XDXuFG4iPvh90p26nqy+rIaP7e6XKy+rEYnBjEffsXb+B3brKP4ivfU5xvVl9W4iYdoRH/oNW4dkNcIVlgj1Kr7IRqxRqjD9CDmw/gRB3ESP7e6ZK1eq8bPbdVCfQXZ6A+/gvy7kCmsEWodchNrvlUBaW+h0olBzMbqnzp1VVz9U42TuHoDqn+q8RCNgzkxiHSrKrz4/b91MV19To2DWNVSFqgW4CYeohGd+M3h+5O2XX1OF6taLg7iJC7iJtZeRGEQ8+H+EQdxEhdxEw/RiHTbdNt0O3Q7dDt0O3Q7dDt0O3Q7dDt0O3QzuhndjG5GN6Ob0c3oZnQzuhndnG5ON6eb083p5nRzujndnG5Ot6Bb0C3oFnQLugXdgm5Bt6Bb0C3plnRLuiXdkm5Jt6Rb0i3pls8tfz/iIE7iIm7iIRrRiUGk26DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26LbotuiG7MkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZUh1Npz71qI6mxkU8nYiJAAE6MYgvdNN+xEGcxEXcRLoZ3YxuRjejm9PN6eZ0c7o53ZxuTjenm9PN6RZ0C7oF3YJuQbegW9At6BZ0C7ol3ZJuSbekW9It6ZZ0S7ol3bLdzu/3Iw7iJC7iJh6iEZ0YRLoNug26DboNug26DboNug26DboNuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbptuh26Hboduh26Hboduh26Hboduh26Gd0qS76PWE+1MTUu4uf2Pd/kVBtToxE/t+/O6ak2psZ8WFlycRAnsdyicBMP0YhODGI+rCy5OIiTSLegW9CtsmTX6lSWXAxiPqwsuTiIn9t3p/dUG1PjJn5u363VU21MjU6MxmpYOt+911OtSee793qqNanRiDXCKQxiPqx8+O7LnWpNapzERSw3LzxEI/rDSoLvzt6pdqPz3R471W7UeIi1vmVRNX8xiPmwav7iIE7i52a1OlXzFw/xc7Nayar5i0HMh1XzFwdxEhdxEw+RbptuVfNWO1Q1/91dPNVu1DiIk7iIm3iIRnRiEOlWNW+1WVXzFyex3OosqZq/eIjlVltYNX8xiJ+b12BV8xcH8XPzOkuq5i9u4uf23cM71W7U6MTPLWo6VfPAqvmL4/1s1fzFRfzcotyq5i8a8XPL2qyq+Yv5sGo+a1Gr5i9O4ueWtSRV8xcP8c/NfjWdr+Ybg1gr+f1stRs1DuL8ftYLF3ETz4dRaEQnfm7f/ahT7UYXv3xoHB9a4SQu4uf23Yo41W7UaMTP7btZdKrdqDEffqlhs6bzXT80TuLntvCzm3iIxp91YhA/t1Vr9mVJ4yB+bt+V+al2o8ZN/NzqharajRqd+LltDJYPvyxp/Nwq+KvdqHERP7cK0mo3ajTi51bxWo/Za8yHX5aY1bZ8WdI4iZ9bFXo9Zq/xED83rwP6sqQxiJ+b16nxZUnjIH5u3/31U4/Za9zEQzSiE4OYD78saRxEujndnG5ebrU6bkQnllvtkOfD+BE/t6zl+7KkcRE/t6zl+7Kk0Yj+tjCCmA+/LLlbmIM4iettYW7iIdrbwsqSi0H8c/OKlWokaxzE+eEpXMRN/HPzgZ81ohPjw1GYD78saRy96tVI1riIu1e9Gskajei96tVI1pgPK0tq1auRrHESv2MbwE08xDq2ms50YhC/Y5t1QF+WNA7it5KzpvNlSeMmfm6z3L4saXTi5zbriFc+3D/i57ZqsC9LGhfxc6tr+2okazTi51bX9tVI1pgPvyzxirZqJGucxM+tkqsayRoP8XOrq9dqJGsM4udWl6zVSNY4iJ+b1WBfljRu4udWV1fVSNboxM+tKqAayS5+WdL4uVltrE/iIr7rnWoOO/h/61rj4iBO4iJu4iEaseZbFhHEfJg/4iBO4iJu4rc63yevpxrJGp34uXmtZOVDYTWSNdaxASdxET+3r5PvVMuY14tEtYw15sNKgouDOImLuImHaES6DboNuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbptuh26Hboduh26Hboduh26Hboduh26Gd2MbkY3o5vRzehmdDO6Gd2Mbk43p5vTzenmdHO6Od2cbk43p1vQLegWdAu6Bd2CbkG3oFvQLeiWdEu6Jd2Sbkm3pFvSLemWdMvndn4/4iBO4iJu4iEa0YlBpBuz5DBLDrPkMEsOs+QgS06hEZ0YxHyILAEO4iQuYrlF4SEasdysMIj5EFkCHMRJXMRNPEQj0m3RbdGtsqTeFFdLXuMkfm5fh8qplrzGQ/zc6gKuHod3fw35kIWL+I3wNaCcaslrNKITg5gPKx/qYq9a8honcRHLrSZZ+XDRiOVWU698uJgPKx/q7Xq17zVO4iL+uUVdTFf7Xvxqvl8SxNdUfapR7+KXBI2DOD+s0+hLgvjVUUSNW9OJGrfcviRodGIQP7e6Mq9GvcZBnMTPbdR8v/KPUdP5yj9GFc5X/lFv+Ou5djHKIrOxOvkaB3ESF3ETP7evqfpUJ19j9GlU7XsXx484iJO4iJt4iEZ0It0G3SbdJt0m3b6aj69141SrX+Mh1gGtQicGMR9+Nd84iJO4iJt4iHRbdFvlZoX5cP+IgziJi/i5rTrir+YbjejEz+3rszn1MLuL3/VD4+e2amZfPkTdvqmH2TWW2yk8xHKr6RwnBjEf2o84iJO4iJt4iHQzuhndjG5ON6eb083p5nRzujndnG5ON6db0C3oFnQLugXdgm5Bt6Bb0C3olnRLuiXdkm5Jt6Rb0i3plnTL51a9i42DWG5euIibeIjWL0nVxtgYxHyILAEO4iQu4ibWUXxR7MgHYM03CydxETfxEI3oDysJ6p5jtRvedVg84sUjrpq/6MRvfb8/gzjVbnixav7iIL7drCbExk08RCM6MYj55oCaBw4id7NqHnOomr94iHRjzTtr3lnzzpp31ryz5t147hhX0riSxpWsmsccjCtpXEnWvLPmnTXvrHlnzTtr3lnz7tw31DyQKxlcyeC+Vc1f5Eqy5p0176x5Z807a95Z886ad9a8J/ctuZLJlUyuZHIlq+b3LAxireT3GlBNk42DOIl1bFa4iYdoRCcGMR+OH7HcvHASq+ZHoXUV1uPloj4TrsfLNebD+SO+Haq2y8ZF3MRDNKIT3w5V2+XF9SMO4iQu4iYeohHrKL7cCeQDcBC/cet2XrVdRt24q7bLxkM0ohODmA8rHy4O4rubFLh7ADSiE4OYD3H3ADiIk7iIdDO6Gd2MbkY3o5vTzenmdHO6Od2cbk43p5vTzekWdAu6Bd2CbkG3oFvQLegWdAu6Jd2Sbkm3pFvSLemWdEu6Jd3yueXvRxzESVzETTxEIzoxiHQbdBt0G3QbdBt0G3QbdBt0G3QbdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TbdDt0O3Q7dDt0Y5YksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkm+LLHfyxL7vSyx38sS+70ssd/LEvu9LLHfyxL7vSyx38sS+/3oNug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26bbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptul26Hboduh26HboduhW71C+ljyrXsvGIObDeodycRAncRE38RDpZnQzuhndnG5ON6eb083p5nR7n3oaei0vBjEf4rNQ4CCW2y5cxE0st1NoRCfWsVlhPqx3KBcHcRIXcRMP0YhOpFs+t3pkXOMgTuIibuIhGtGJQSw3/7DeoXztkVZ9mY2TuIibeIhGdGIQ8+Gk2+zuPKtHxjUuYnfnGXo4LxrxO0u8Dqh6OC/mw+rhvDiIk7iIm3iIRqTbolu9b/k+l7bqy4yv9dOqLzO+tkurvsxGJ8bDei/y9Tla9VqG1bh1V+KiEZ0YxHxYNW+1OlXzFydxETfxEI3oxHLbhfmwav7iIJZb7XHV/MVa31F4iEZ0YhA/N6/1rbsSXutbdyUuTuIi7tuHZ9VrGV4zq5q/6MQg5sOq+YuDOImLuIl0q+quqVdPZHyf1Vn1RDY6MW6bqFVP5MXqmb44iJO4iJt4iEZ0It0G3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt3qTmSlRvVENubDutNQqVE9kY3z9t5a9UQ2buIh1rjfqVx9jgHj6plO/L+LuInnttYa+hwvOrE6fcuieqaB1TN9cRAncRE38RCN6ES6Gd2qYr+bUFa9i/E9XcCqdzG+pwtY9S42BjEfVhV+D1i06keMqFWvervoxCDmw6q3i7W+tXxVbxcXcRMP0YhODGK5ffVW/YiNgziJn9v3AAOrfsSL9WL5fSZs1VjYOIn1a6twE7tt2NBYeNGJ8bBu5yWwRqjpoPE4C43oxLhtw1bNgher8fhiNR5H4SQu4iYeohGdGMR8WI3HF+m26VYvi9/H5FYNgJH4f79tqWqpBsDGQZzEvxHye5CDVVNf/mrVv8K5+BVO4yBO4iLuD2up7RCN6MQg5kP/EQex3GrVfRE38RDLrfbYnVhuXzFUU1/+6uBjEw/RiE4MYj7MH3EQJ5Fu2a3hVk19jUbs1nCrpr7Gbg23auqzuuCspr7GSVzETTxEIzoxiPlw0G3Q7avC/BoOrNr38ms4sGrfy6/hwKp97+L3Atg4iDXCKawRatwZxHy4fsRBnMRvfUetztrEQzSiE4OYD/ePWG67cBIXcRPLLQuN+Ll9zcRWLXmN+fCrzcbPbdbqfLXZuIibeIhGdGIQ82HV8UW6Wbdw27ZF3MRu4bZtRnRitd57YT5Eoz9wECdxETfxEI3oRLo53aLWrPai6njWqVF1PPEDTgxiPqyKnXVAX23mqhP8q81GJwYxG6t1rvFb3+/xJFatc42LuImHaEQnBrHm+21Ltc41DuIkltsq3MQa9yu9anzL7yM+q8a3xk08RCM6MYj5sCr24iDSbfWfQVg1vjUeYv8ZhFXjW2MQv52vN3jV+NY4iJO4iJt4iEZ0YhDpduhWtVkvwtX4lnVNUI1v+X3wZ9X41pgPqwovfiPs2pZ6hfwa8q2a2RqDmA/rFfLiIH7ru2v56hXy4iYeohGdGMR8GOVWZ18M4iQuYrnVDlUVXiy3LHRiEPNhvZqeWp16Nb04iYu4iYdoRCcGMRur262x/zzIqtutcRH7z4Osut0ajVh/1HIKg5gP69X04iBO4iJu4iEakW6DbvUaW7f+qpkt6xZdNbPlwQ8Y0YnxsCq2LkaqQS3rsqMa1BqN6MQg5sN6Na07OdWg1jiJi7iJh2hEJ5ZbbUu9mgLr1fTiIJZb7XFV7MUadxU6MYj5sCr24iDWuLW+VccX6yhqJev692K51XSqui+WWy11VTewqrvuEFUrWmO5ZeEifm51O6Ra0Ro/t7rVU61ojZ9b3cmpVrSLVd11H7xa0Ro/t7rjUq1ojeVWB1TVfbHc6oCqui+WWx1QVTewqrvuE1QrWmO51QFVdV/83OqOQLWiNdY1QR1QXStfDGI2Vita4yB+bhcXcRPLbRca0YlBzIf1enxxECdxETeRboNudQVd75qrFS3rNkC1omVd71QrWuMhGtGJnO/kfBfnuzjfxfkuzndxvovzXZzv4uosui26Vc3jgKq6cUCb892cb1X3xXxY1X2R8z2c7+F8D+d7ON/D+R7O93C+h/M1ro7RzehW1Y0DqjrGARnn65xv1fHFSeRuOufrnK9zvs75OufrnG9wvsH5BucbXJ2gW9CtKhYHVLWJA0rONznf5NmXPPuSu5nczXrlrXcS1TIGjPfHqxbvj1ct8MerwEWscbPwG6HuGwX+IBU4iJP4jfD9xarVd482HuL3MWO9Ma/msMYg5sP6wPbiIE7iIm7iIdJt0q2qMGs6VW91c6savrJuWFXDV6MR/WG9xtYlSrV2ZV2MVGtX4yEa0YlBrPWtmVW9XRzESVzETTxEI5bbKQxiPqx6u/jn9veBXe1hfUlo8yqexVv4CJuwC4dwkuvLQpuH8BQW3+rYGLVU1bFx0Yjf1tb9A3R/XcyH1bFRNy7Q/XVxEhdxEw/RiE4MYj5MuiXdEqtXp1pilWrlE6uEn8nH1dX1eAhjnCjGOFkcwkkeP+EhPIVrtatAq2fr8RE2YRcO4STXFwc3w9eLp/AS3sLwncUmDN9ahxnC8K3fXfCt9cEfltch4g/LgYu4iYdoRCcGMR++Pyw3NHFdpFt9h/Dv+9scqy6ux0fYhF04hJNcXyXcPISnMHxr/c8WPsIm7MJBRqV/T6m1RKVfduEQTjIq/TLmWfuFSr+Mn6+9i5/wEMbP13rGEt7C3/6tGrKK9aITv/1bGC8fVrFe/Pav7tKgveriIm7iIRrRiUHMi472qouDOIm12t/9LP+hor97UP5DRX93k/yHir48hKcwxqkxUaHfIvgPFQpGhV4ewlN4Cddqfzdf/IcKvWzCLhzCSUaFXh7C8N3FS3gLH2H4ZrELl++udatv+/7t+vn6uu/mITyFl/AWPsIm7MIhLL7VLXVqS6tb6uIkfqfYd0fE0S118RC/U2zXwVXn5cUg5sPqvLw4iJO4iJt4iHQzuqGWd51ReHX+bjR59UD9ce2gH2ETdjJqHAeOWsYxopYvH2ETduEQrtU+debnT3gIT+ElvIWPsAlj/rUOeL2+nI8HXq8vw3cXTzKqtY59oFovL+EtjPmcYh7vQBWDUcWXMb4VT+EljPG9+MjvmrALi+8U3yW+qOLLU3gJb2HxXeKFCv1uY/lAhV6ewjWm1fqgQi8fYROu8Q3jh3CS8Xp6uXy/9icfeN38bj35wOvmZRPG+LW/eN28nGT7CQ/hKbyE4Vv7jtffyybswiGcZNTs5SGMMesccPxurS1ei8Go08tDeAov4Zqz15qjfi+bsAuHcJJRv5eHcPl67RHq9/IWPsIm7MLBvUP9Fk/U7+UhjHM4i+2t28S19+UQTjJeqb+bfj4H12qixi8fYcy5fHGNfTmEsVbfeTIn92jOITyFxXeK7xRf1P5lFw5hnhtzie8Sr8WrjnlfncEuHMI4luLNq465l/AWxv6CTdiFsVa1/ptXO/P8hIew+B7xPeKL2r9swi4cwuJr4oW69lor1PVlE64xvxuvPlHXl5OMur5c4393UX3iuvryEt7C5Rt1TqL2o84r1D4YtX8Z49f5htq/vIS38BE2YReGb+07ah+M2r88hKfwEt7CRxhjfufAwuvvdwPMF2r58hY+wibswjXn7zaYL9Q4GDV+eQhP4SW8hY9w+X53pXyh9i+HcJJR+5eH8Hx7t1D7l7fwEUbtfPm2UNdYN7ymX57CSxjHMotlrVDjl5OM1/csX7y+X57CWKtdLHu0ZY+27NEW3y2+W3xR+5eHsJwbR86NI75HvFDXv2K8pl8ewlMYx3KKcZes1tlcOISxv19WLNT45SGMtar1v3fJ6ndR45ePsPi6+Lr4epLjJzyEp7D4hnihrrOOHXUNRl1f/sYcvzrnq66bl/AWPsV1btdrerMLh3AWf+dktWj98SpewlsY4+9iE3bhEE5y1X7zEIbvKV7CW/gIm7ALh3CSJ8b0YvxuFLtwCCd5/YSHcM35u4vv1d31eAsfYRN24RBOctX++O4HenV5PZ7CS3gLH2Hj3m0XDuEko96/O+Je7Vy9bucIm7AL41jqXDJZK5vCSxhzLl87wiaMtarzxGSPTPbIZY9cfF18XXx9Cx9hOTdczg0X3xCv+ryqYqYeodZ4iEbEcdT5WB8xVyTV09IaJxEbW7+I4r58hLFI+HnnrwYxG9H2dXEQJ3ERN/EQjehEWqCIvxvJflDEl7dwzf+74eoHRXzZhUO4Nvm7ser1YLTHQ3gKl+/3SCQ/KPSvf9APCv1yCGP87+Q6KPTLQ3gKL+EtfIThe4pdOISTjEK/PISn8BLGmLXmB79ba3uG8BRewlv4CNec6zbqQUFfDuEk14t58xCewku4fFftEQr9sgm7cAgnGYWOvUOhX57CSxj1ksXBdfMko6AvD2EcS51LIWsVJuzCmHP5RpLzJ4y1qvMkZY9S9ihlj1J8U3xTfPFifjkfV9/Y4yE8hbcw1v8U41isOMl4Ab88hKfwEt7C534s7tUi1ujEIObDas6+OIiT2E0Obij579MJN5T85RBOMkq+7qYbSv7yFF7CW/gIm7DfvgRHv9nFfFifhV8cxElcxE08xHhHvOVoEAaXh/AUlqM5cjRHjubI0dwwAIdwko0HZDwg4wEZD8h4QMYDqtazi1w+4/KhOaWO2OVoUOqXt/ARlqNxORqXo3E5mpBzIuScCDknggcUPKDgAQUPKHhAwQMKng/J5UsuH7pX6ohTjiblDE85w1PO8OTR+O8nPISn8BLewkf4HdBtMgMG8R3QbTIDDuIkLuImVqOmFwYxH1YSXMShZHF3gDq6zC4asdbp63x2RxJcTjKS4Ot4dnSa4Ver0+ziItJx0XHR8fWcur+eU/fXc+r1gLRGum1a4Kq9PpNzvOBfDmHM/3sxcdT+5SE8hWuf6xMpR+1fPsImDN/aHLzg1ydYjhf8y1MY49f88YJ/+QibsAuHcJLxgl+fEjle8C9P4SW8hY+wCTsZFV6fplTL2R/X2uIF/7IJu3AIJxkv+PUJluMF//IUXsJb+AibsAvDt/YItV4cqPXLQ3gKL+H99i5Q65dN2IWxL9+FTOAFv9Yt8IJ/eQsfYRyLFXOtAhf1l4cwxi9fXNRf3sIYP4pNfteFQ1h8l/gu8cUr/+UlvIWPsPgu8aqqxlLVK/vFRdxEjJfF/ccUjjY34PkRa7L1UV2guC8v4ZpsfTyHVrf7q0Z0Ih0PHY2ONoiTuIibSDejBYq4PiJEA1vzFMb88fNb+AibcG1yfTwXeCm/nGS8lF+Gb52AKPT6yClQ6JdNGOPXyYVCv5xkFPrlITyFlzB8a6NR6JdN2IVDOB+j1a15CNeY9bEd2ttGfZSG9rbLuIK/PISn8BKuOdfHZ2hvazZhFw7hJKPQLw9h+J7iJbyFj7AJu3C8vUN722UU+uUhjH1ZxcZ1wzv2yyGcZLxjr4/P0K521wq34C4fYYxfvngxvxzCGP87T9Cudn/3yB4d2aMjvkd8j/jixfyyC8u5ceTcMPE18aqqnnWK1ZX6RScGEeMVVx953QCoB4o1bmJNNsAm7MI12fosrnrf7q/GjziIdAw6Bh3jEI3oxCDSLWmBIq7PAxNFfNmEMf86wVHEl7M5fijiy7XJ39V+/PBqfXkJb2H4WjHG9+Iko9AvY/wonsJLeAsfYRN2YfhmcZJR6JeH8BRewlv4CNeY32d0gU638X1uFuh0a97CR9iEXbjmnLXmKGgwCvryEJ7CS3gLH2H41h6h0C+HcJJR6JeH8OTeodAvb+EjjH1ZH6OIsW64Ur88hZcwjqXOJZO1whX55STjxTzLFy/ml6cwxq/zxGWPXPbIZY9cfF18XXzxYn55CMu5EXJuhPiGeFVVj1rmeud9cRAnEePV+Vh/ODJqmepu+8UgfpOd34dwgea25iE8i0fx6l+tp3k1HqIRnRjEfFjvuS8O4iTSbdCiinh+H/4FmuQuz58w5r+Lp/AS3sKn+BSbsAuHMHxrPgvje/ES3sIYP4pN2IVDOMn7JzyE4ZvFS3gLH2ETduEQTnIV8Ry17/WqPEetbRVucwgnuQq6eQjXnEetuS3hLXyETdiFQzjJDt/aIx/CU3gJb+EjbNw7d+EQTnJgX1bx5rrFETZhF8ax1LmUslY5hZcwxi/fPMImjPHrPEnZo+QeoRmueQhP4SW8hY+wCbswfdEk1/xVdcVJ9cg1HqIRMd53PlYjXD0MJ6oPrnESa7Lfh3CBLrjmI1yTnTV4/SXn/dUg5sNFx0XHRce6v3ZxEw/RiHRbtEART/AS3sKY/y42YRcO4drk74O3QEdc8xCewvC1YozvxS4cwhj/O7kmCv3yEJ7CS3gLH2H41kaj0C+HcJJR6JeH8BRewjXmqn2vV+W5am1RuJen8BLewke45rxqzVHQl0M4yfkTHsJTeAnDt/YIhX7ZhF04hPPxQqHX3i0U+uUpvISxL6s43rqhI+4yCvryEMaxWDHXCp1vzS6M8csXL+ZgvJhfxvhRzD1C51vzFhbfKb5TfPFifjnJ6yc8hMV3iRdewL+b+oGOuPndmw90xF3GC/jlITyFl/AWPvexalENcY1ODGI+xLPJgIM4iec+czKq+a3RiTiYOkgUPBgFf3kIT+ElvIWPsAm7sPia+Lr4uvi6+Lr4uvi6+Lr4uvjiUYF13uJRgYX1GM+LgwjPKpD3BMFY7wmCsd4TBAP9cvO7qRjol7uMNLiMA6qdwVME61fxFEHgJtIx6Zh0xFMEgdm48RRB4CBO4iZiYaw4hJOMBPg+8Qj0xTVP4SWMDcniI2zCLly+39/IxEYCfHflYyMBLi/hGv+7kx0bCXDZhF04hJOMBLgM31U8hZfwFj7CJuzCQUYCfJ9sBPrf5qm1xav8ZRcO4STjVf4y5lxrjlf5y0t4Cx9hE3bhEIZv7RHC4PIQnsJLeAsf7h3C4LILB/kGQJ2fKHSsGwr98hE24RrT6lwKWSu8+l+ewjW+lS9e/S8f4Rrf6jwJ2aOQPQrZoxTfFN8UX7z6X97Ccm6knBspvkmvg1f270ZxHLyyfx9AxMEl/OUjbMIuHMJJrkeLfrc6ox6R1jiJi7iJh2hEf1hP3P7ujUd1yzVO4rqP0Y3znuob5z3VN857qm+c91TfOO+pvnHeU33jvKf6xnlP9Y3znuobZ9Ft0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt0+3Q7dCtLgC+++NRHXaNOCu8+AjbfTx0VH9dYxBxSnyxgO665nKsDaunAF9cxE3E6fZFAjrlptdUv9f4k3UGfy/xjYv4jVG3MKtjrtGI3xrV/bNqo2vMh/Vc/ouDOImLuImHaES6Bd1Q6N8nMIEeuek1eRQ0VhEFfdmF4zF64eb36U2g/21+n8CEoYgvm7ALh3CS8QL+feoR6ItrnsJLeAsfYRN2Yfie4iTj0v7yEC7fOlENL+yXy/f7kCIML+yXTdiFQzjJeGG/PISn8BIW33qEYt0aqr65RifGh7U/9QhFYD1C8eL4sDazHqF4cRE38RCN6MQg5sN6hOJFuh26objrljsa42bVIBrjZl3bGur48hCewhgnijFO7Tiu18Go5ctDeAov4Vrtur2PVrhmE3bhEE4yXt4vD2H41pmPl/fLW/gIw7d2Hy/vYLxEV8IYKvryEcbv1tqioi9/27bxI9mIp6ldHESMbcUYw4trjCzMh/UExIvfGHXZXO1rjYv4nWh1TV7PSGs0ohODmA/njziIk7iIdJt0Q43Why3VujZWfdZQvWt/PIqX8BY+wlH8ndHVlPbHtXp7Ci/hLXyETdiLa+V3CCe5Lribh/AUXsJbGL6z2IRdOIThW7tvP2H41qbbFF7CW/gIm7ALh3CS/ScsvvXU4XqJqo62xk389rzyvdrZGp34nWH1olhPXbv4VXHjIE7iIm7iIRrRiXQLutUl+Bp1BlYdr7pTjWa2NfAzLhzC+RhNa6teENCctir70ZzW7MIhnOR6ZW6u1a47+Whga17CW/gIm7ALhzB8v81CY1vzEJ7C8M3iLVw3vb8TE49eq/MjcNscOImLuImHaEQnBjEfbrrVa+ypOdRr7MVF/E6VehtbDWyNRvT7MPaorrbGfFivsRcHcRIXcRMP0Yh0O3Sr3rU6GdGlVuciutRwmlU/y0UnxkN/HwxXWxo+N62utEYjOjGI71PaakhLnCvVtHJxEhdxEw/RiE4stzqn8PF2IT7eBg5iudUe18MSL35u9VFOdaY1GtGJ1e1Tq1N/YVZYTWmNgziJi7iJh2hEJwbxO3fqUqna2BoH8Tt36hqoetgaN/Hch7FHNbA1OjGI+bBepC8O4iQu4ibSbdKtPhSrT5fqIWv1FPiofrR6yHvUQ9YaD9GINUId0O6Gp6hOtMZNPEQjOrEanmZhPqyO04uDOImLuImHWPOtbcFD/4FBzIfVbbpqj6tiL9a4p7BmVgdfjyy9OIiTuIibeIhGdGIQ6VYvnlY7VC+eFyfx23nDz27iIdp9GHtUm1ljEPNh/oiDOImLuImHSLdst/zhof9RWH27v8Lq2x2Fh2hEf1j9Jd9d+qymsWrszeoZazxEIzoxiNVnbB/WB9EXB3ESF3ETD9GI5TYLg5gP69X0Yrl54SSWWxZu4iEasf7Io1YHf+QBzIf4Iw/gIE7iIm7iIRqRbvVqmnXE9WoKrFfTi9+5k3VA9Wp6cRH3fRh7VhtZoxGdGMR8aD/iIE7iItLN6Favsaf2our41KlRdXzqB6qOL27iIfZfCWU1hNVfzmT1gzUu4iYeohG/9bWqi3o1vZgP69X04iBO4iJuYrnVtuCh/0AnBrHcvj2uBrLGukqc4C18hE3YhUO4rk6/NogcuCq+XFen3yts4iFrzfDdxVsYvqfYhOFrxSEM32+f0FfWDN8onsLwzeItXL7fi1air6y5fFcdY70Xbi7fVcdY96uay3fVMeI98uXyXXWMeI98Gb51jMuE4VvHiPfOl+Fbx7h/wvCtY8R76svre9ByDVnfNHvxEI3oxCDCsVYJ76YvD+FyrOxDN1rzFj7CJuzCIZxkvJu+PITF18QX75rrFQVdZ6teG9B1tnYdF94dX57CS3gLy/xd5u8yf5f5u8w/ZP4h8w+Zf8j8Q9YtxDfEN5LHiPfFOMaU+afMH++XL5uwC8v8k/NHB1rzEJ7CS3gLH2ETduEQFl8kRh0jHs2GY8Sj2TBndJ41h3CS509Y5j9l/lPmP2X+U+Y/Zf5T5j9l/lPmv2Tdlvgu8UUC4BhR6TjGJfPfMv89hKfwEt7CGN+KTfir9grv6klrzIf1pNSLGNuLMUYU1xg1XD3/9GI+rOefViJX01njJH75VBFfHWeNh2hEJwYxH9Y3z18cxEmkm9PtVvCXZGg5W3UphJazVVcRaDlrXsJbuMapSw20kK26lEALWfMUXsJb+AjXatd1CFrImkM4H6OFrHkIT+ElDN9VfIRN2IXhG8VJxmt+XZWgzax5Ci/hLXyETdiFQzjJU3zrawmqkKr7rHERvz2v6qrWs0YjfmdYlWX1nTXmw/oe+YuDOImLuImHaES6LbqhvuvqDA1my2ryqGOreaKOL7twkPH6/L2PTDxCbVntOF6HL5uwC4dwkvE6/H0GnOgpa57CS3gLH2ETdmH4nuIk43X78hAuX6/dx+v25fL1Wge8bl8uX8fvlq/X+tQXFeAEry8qANYXFVwcxElcxE08RCM6kW5BNySGVzUhMS5P4SW8hY+wCbtwCOfjjcT4PgnOjcS4PIWX8BY+ZFT695llop2seQsfYRN24Zrn96dricesXcZr7/c5aKI9rDmE8fPfuYr2sOYh/O1fBUZ1hzVu4rd/VX/VGtboxNq/Ouj67gFgfffAxUGcxEXcxEM0ohPptumGK+6oHURFZ00eFZ01T1T05RBOMio3a+VRoVmrjQq97MIhnGRU6OVa7bpbgIekNS/hLXyETdiFQxi+X1qiSax5CE9h+Nbu4/X68ue7f7VudWW9f/h5Fw7hJFe1Ng/hKbyEt/ARFt/6woIK2nrOWmM21nPW/OvcyXrOWuMk1glthZt4iEZ0YhDzYX290MVBnES6DboNrN53RuGparveR+KpavtXPzOn8BLewhinjmthnCwewlN4CW/hI1yr/f01T+Lpac0hnOS67m4ewlN4CcO3NmsfYRN2YfjO4iTXV71XrFafV6MRnYgxdnGS7Sc8hKfwEt7CR9iEXVh8TXxdfF18XXxdfF18XXxdfF18XXwdvnWuBXzr3IkhPIWX8BY+wibswiGc5BTfuq+Ora376hcX8btbiXO67qtfNOJ3bxQFUE0oF7OxHrzWOIiTuIibeIhGdOJzQ4/Z/v4+LdFLtr+P8RK9ZPv786xEL1mzCwcZFV/3AdEbtuveH3rDmk3YhUM4yUiCet+G3rDmKbyEt/ARNmEXhu8oTjKS4PIQhm+tG5LgMnyj+AibsAuHcJLPT3gIT+ElLL7405FaNvzpCNCJ357XfdfqLLtYd98vfmcYNrDuvl9cxE08RCM6MYj5sL4k+yLdnG7IhLpLi16yXXdg0Uu2664resmah/AUrnHqrquhlutOq6GWwajly0N4Ci/hWu26A4u+smYTduEQzsd4kFrzEIbvKl7CW/gIwzeKXRi+3xo6qvvyFK7x6wM5R9VfrvHrvamj6i+7cI1fb7Kr/awZr/+Xh/AUXsJb+AibsAuL7xTfJb5LfJf4LvFd4rvEd4nvEt8lvkt8t/hu8UVK1D0GdLk1b+EjbMIu/PVE11tcNLDhdEYDW/MWPsIY8hTzlEejWvMQxpSteAlvYUy5TlVcJtzfdeEQFl8XXxdfn8JLeAsfYfF18UIM1G1KRwxcXsI15qn1RDxcNmEXrvHr5iCeyXYZsXF5CJdv3RxEu9qut/poV2t2YYxf+4V4KMaz15qH8BRewlsYvqfYhF04hJM8fsJDeApjTC/G735rixa15iE8hZfwFq4517txPHut2YVDOMko/ctDeAqXb72Zx7PXmo+wCbtwCOfbu0DpXx7CUxi1k8VY/1o3vPhfTjJe/C/jWGaxrBVq/LIJY87li7cIl5OM2q/bhfjO0fu7Jntkskcmvia+Jr6o/cshLOeGy7nh4uvihbquSwA8jq05hJOMS4C6LRio8brGwePYmo8w9teKXTiEsVa1/qhx/C5q/PIUFt8U3xTfNGEXDmFe8OJxbM1TGOdqFJuwC9eY9XqBx7RdRl1fHsI1/vdHMInHtDVv4SNcvt/fJiUex7a95obavzyEMf4uXsJb+AibsAuHMHy/fcfj2JqH8BRewlv4CBsZdf39IU7icWy7bpvicWzNR9iEXTiEa85Ra44avzyEp/AS3sJH2ITLN2qPUPuXk4zavzyEp/Di3qH2Lx9hE0btfPmGbxi964bX9MtLeAvjWOpcclkr1DgYNX4Zcy5fvL5fXsJYqzpPQvYoZI9C9ijEN8Q3xRe1f3kKy7mRcm6k+Obz+r7RGfe0rhgqpoqlAgd0IHAjKSFCRYpAsX9/D/SJoWKqwLo5xNYBjgpToTMYOoOhM5g/FUPFVLFU6AymmqLgAwuCim8xVNTQ303xTywVW8VRUT7fjfFPuIpQkSKQD9+N5k/AZ0FsFUcFfDaEqwgVKQI50WKomCowA5whyIoWR4WpcBWhIkUgMVpgaJwueM1PLDxCoEWKwMt+i6FiqvgO4fywJRURTxwVpsJVhIoUUQHyxCiBbawIeWKp2CqOClPhssEIkhYpAlHSAgWI8xpBcVcUVwktXEWowMHVyYfHv91FRF/fE1sFDmFBmApXgUXcELKNaO97YqjQGQydwdAZIFBamApXESp0BlNN0auDFb1tfC1MhavAwdWpfFv2UD+3Z6/FUoHzwCCOClOBRXSI0AFSxP6p0BlsncHWGaAboMVRYSpchc7gqOnBSY5FPFvFUVEHN34QriJUpIhKijMGxFAxVSwVNYOBU9ngg82yUJEiHD44Hh8qpoqlYqs4KkwFZoAzBIHSIkUgUFoMFVPFUrFVYGicLokBsPA5VSwVW8VRYSrqECa2pGLjiaRAb98TQ8VUsVRsFTWDOSBMhasIFSli/FQMbjD6/55YKrYKFGBCJFcUjX9PDBVTBQ5uQsgiosvviVCBQ8AM1k/FUIFF3BCyjXNtFUeFzmDpDJbOYKWI/VMxVEwVOoOtprd3yCBSBGKjxVCBgzsQr7HoE6bCVeA8uAOkCMRGCywifuf2F12xVGwVOgPTGZjOwEJFirh9RlcMFToDV1MkxcQiIilapAgkxULJIClaTBVLRZ0hC4WBS48WpsJV1AwWTmUEysKZiEBpsVTAB+coAqWFqXAVoSIp0IL4BGZwIKaKpWKrOCpMhasIEUiK5RAYICBMhasIFSkCsdGiDmH/IKaKpWKrOCpMhasIFTWDXduIx9s9MVRMFUvFVnG4wQuB0sJVhAhkyEyIJSu6t4qjwlTg4Orkw/e89iKeoWKqwCFgBrgOaXFUYBFxVh3dxqPbeHQbTWdgOgPTGeA6pMVWoSeS6YlkOgNTUyTFwUTR8tRiqzgqcHA4ldHedCDip2KowHlgEEvFVoFFxP7g7wd6AFcRKnQGqTNInQF7mT+xVGwVR4XOIMUUvYdnB8RUsVTUwZ0fxFFhKlxFnSFnQKQIXHq0GCpqBmdCwGdBmApXAZ8NkSIQKC2GiqliqdgqMAMsFQKlhasIFSkCgdJiqJgqMLRDYAAsPMKhxVAxVSwVW0UdgmFLEBstXEWoSBEIlBZDxVRRMzBsIwKlxVFhKlxFqEjZYARKi6FiqkABJoTLiuK9TIsUgfcyLXBwOPlcFxHvWFqYChwCZoDrkBYpAtchhrMqdBtDtzF0G0NnEDqD0BngOqRFqNATKfVESp1BqikuPQynJS49cNW5cenRIikOLj1aDBVTxVKBv5UJiKPCVLiKUJEi8HcQLYYK+CwInIkOYSpcRajAkWI0BEqLoWKqWCq2iqMCR7ohXEWoSBH3b5uuGCqmiqViq3BZkKVHity5ArnTYqjQI916pFuPdOuR3ty5wlWECj3So0d69EiPHunRIz16pOeo0LU+utb3rxyxIKZHinRpsVRsFXqkpkdqeqSmR2p6VrmeVa5nleuRuh6p65G6HqnrkboeqetZ5brWoWt9/yQSCxJ6pKH1E1o/ofUTeqShR5p6pKlHmnpWpZ5VqWdV6pGmHmnqkaYeacqR2u+nYqiYKpYKu3+U/rELh3CS7zfqJkT/wfrHW/gIfwcy8IYEfZ1PhIosUa+Q+A7d+/v1mIXmKSzeU7yneL8v1fzYhUM4yUt8l3jhu3rwJuR+eW4LV4EDwsLi+3quwBf2tBgqZokDsVRsFUcFZmAQ8MHu3K/VvGKogA+O536z5hVbxVFhKlxFqMAMcErcL968YqiYKpaKreKoMBH4Jh9cTN+v0sXF9P0u3RZHhalwFaGiDgEXxvcbdVsMFVPFUrFVHBWmAjPANt7v47wiRdxv5LxiqJgqlmwwvuerxVFhKrBzFYD3G3axovcrdlssFVsFDs4gZBEd3+Z1BXKiBXwcYqpYKuATEEcHMBWuQmcwdAZTZ8Dv6vzEVLFUbBU6g6mmeC4L1hAPZrk8hZcwhk0Ivw+W+TiEk4y8wLsPtH0+MVXU3PG2wvENnff3j7AJi/cW7y3e78s7Px7CU3gJi+8RL8QC3nHc7+NtMVTggPA7iIUWW8VRUacDLuTv1/K2CBUp4n6pJ87b++2dOO3u13decVTAByfk/QbPK0JFirhf4nnFUDFVYAY4Je4XfF5xVJgKVxEqUsT9ms8ramjHKYLv+XMsPJKgRVLcL+ZtMVRMFXUIviG2iqPCVLiKUJEi7rd+XoEZHIipYqnYKo4KU+HcYDwN8YkUgfRogZ1bEIcrer/Ht4WrCBU4uDr57nf23kXE1wO22Crggxncr/y8wlXAJyB0G7du49Zt3DqDrTPYOgN+J+gnTIWrCBU6g6OmlRO4E4xv+W02YRfGsBB4zNoPPIWXcM09rjgqTEXNPbAx9VSn/v0k46ltl8XbxdvF+31J6MdH2IRdWHxDvBALgRVDLLQ4KnBAqA/EQotQkSIQC+j0ul//22KqWCowA5y391tCcdrdrwm9Iinut/2iZ+p+3W+LqWKp2CqOClOBGSREqEgR96tErxgqpoqlYquoodGOdb/9F+1Y9+t/WywVW8VRYSrqENAwcb8EuEWKwNcAtxgqpoqlYqvADA6EqXAVoSJF3O8YvWLIBiM9WiwVWwV2bkGkrOj9GtErhoqpAgdnELqIeC/SIlTABzO4Xy16xVABH5xVpttouo2m22g6A9MZmM6A3z36J+6Xj16hJ5LrieQ6A1dTPJcVm4AHs4LxZNbLQxjD4jTGc1ixfngQ62UX/uY+0b+GDtUW+NKSFqMENgaPZMXv45msl7eweKd4p3i/LyP9OJsHHv/YPISn8Bb2mtyECBUpAl96UP1nA22rT0wVS8UucSCOClPhKjADzO1+G6lDTBVLBXwC4qgwFa4iVKQIfN1BC8wgIaaKpWKrOCpMhasIEfhCo+q9GmhOrS99/ISpcBWhIkXga41a1CEMbAm+2KjFUrFVHBWmwlWECswA23i/x/SKoWKqWCq2iiMbjK85auEqQgS+OqEaJsfvflspVvR+XekVR4WpwMHh5AtdRHwjQoupAj6Ywf0K0yuOCvjgrArdxtBtDN3G1BmkziB1BvyO009sFXoipZ5IqTNIMR18Fvsnloqt4qjAHd+EqLuqWMTBJ7J/Yqio+7rfH7p8YqnYKurOcr0TGPcJlD2AqwgVOoOpM5g6g/t09iuWiq3iqNAZTDXFZ7iORcRnuC2WChzchjgqTIWrqNvmjrXGhzFX4MOYFkMFZoC54SOXes8z0Jz6hKuAT0CkCHzU22KomCqWiq0CM8AZgo96W7iKUJEi8FFvi6FiqqihA6cLPksJLDw+S2kxVEwVS8VWUYcQ2BJ81NvCVYSKFIGPelsMFVMFZoBtxKcsLY4KU+EqQkXKBuNTlhZDxVSBnVsQLiuKj3pbJMVtW22BgzMIWcTbnNrCVMDHIUJFikCHSL2lGbc59Q4wpoqlQmcwdAZDZ4CPeluECjmRbg9rC53BVFMkBV6M7sMpW4SKFIGmkHofNeb9GpcNsVUcFXUI9Rcz4zantggVdQiJ/UG3+x2AX//yialCZ7B1BltnwO+A+YSrCBUp4ugMjpoiKRKLiKRo4SpwcPd3UgSSosVQUWdIvSsbaFt9Yqs4KjADnMoIlMSZiEBpMVTAB+coAqXFVnFUmApXESowA5whCJQWQ8VUsVRsFUeFiaiksB9Ol7rAMLwRQHPqE0eFqXAVoSJL1JagOfWJoWKqWCq2iqPCVGAGByJUpIjxUzFUTBWLG4ynZT5xVJgK7FzVNtpW74qibfWJpWKrwMEZhCwimlNbrJ8K+GAGa6pYKuATEEcHMBWuQmewdAZbZ7CHiqliqdgqdAZbTQ+GTogauv6sZaBt9YmlYqs4KkyFq6jL8LtzeC9zBd7LtBgqpoqlYqs4KuIf+Kroj5OMB+9cLpONBeAXNX9iqdgqjgpT4SpCRYrA+50WOoPQGYTOIHQGoTMInUHoDEJnEDqD1Bng/Q5e6NHa+sRSsVVgq1E8+BpIvJjiCZtX4BGbT+CUmhBTxVKBU2pBHB3AVLiKUKEzGDoD3E1pMVUsFVuFzmCoaV2eGN6To7X1iakCB2cQW8VRYSpQLw4RKlIE4qgFZhAQ8MFEETotTEX51J8zDXzt8xMpAqHTYqiYKpaKmkH9bdNAB+wTpsJVhIoUgWxqMVRgaJwuBwNg4U+KsJ+KoWKqWCpwCNgSOypMhasIFSnCfyqGCswA2+hLxVZxVJgKVxGywZ4i4qdiqMA5eiBMVjRcRahIEbiKQaiim7UXEVcxLY4K+GAGuIppESrKpz54GuhzvQOgz/WJqWKp2CqOClPhKkKFnEjoc31CTe83zhqEqXAVoQIHV6cyGlgn3hqigfWJraIOof7QaaCB9QlXUYdQf+Ay0MDaA+C+a4uhQmewdAZLZ4D7ri1MhasIFTqDraZIioVFRFK0MBU4OKwbkqJFikBStKgzZMEHVzEtloqtAjMICPgkRIpAoLQon41zFIHSYqnYKo4KU+EqagYbZwgC5QoESouhYqpYKraKowJD43QJDICFRzi02CqOClPhKnAI2BLExhWIjRZDxVSxVGwVRwVmgG1EoLQIFUmBZtQnhorJDUYz6hNbxVGBc7RyFD2od0XxaNEnpoqlAgcXELKIaEN9IkXgOmRjBrgOaTFVlE/9YdDAU0nfAEeFqdAZTJ3B1BngOqTFUDFVLBU6g6WmuPSoPr6BllSrhraBltQnpoqlYqs4KkwFsgoLgo94WqQIfMTTYqiYKpaKreLPJwznRH01fXOSvzR5jKPECfFFRlQ72Kie08cmXLt0sHrIixYpAnlxYPLlRf/+FxePl7B4u3i7eLsLh3CS4ycsviFeSI9zhasIFTgg1AfSo8VQMVXg3EAVID1aHBWmomZQ/YsDDym16l8caEZ9Yqoon+oXHGhGfeKoMBWuIlSkCERJdXYNtKk+MVUsFVvFUWEqXATSA+chukwN+4Mu0ydMhasIFSkCGVFthQOPJn1iqlgqtoqjwlS4CswgIVIEoqTFUDFVLBVbNhhR0sJUuAqco/UqgqeV9orioqPFVnFU1NBID/Sn9iLioqPFUFE++PQO/alPbBXlg0/I0J/6BtBtNN1G0xm4zsB1BrjoaLFU6InkeiK5zsDV9MsJ/EHcqI7Uxzg0nK64GGlxVJgKVxEqUgTiBJ/q4WmmT0wVmAGmiThpcVRgBhvCVYSK/I6tTrZqaH08hKfwEt7CR9iEXTjIo8af4CmMo3OIreKoMBWuIlSkCFyn4ONDPBn1iamiZlBdkAMPR33iqMAMAsJVhIpa39rgekLq4yE8hZfwFj7CJuzCQUa+4FM6NLI+sVTg+LD2yJcWpqKOL+7QoaJWGB9o4rGpTwwVmMGBWCq2iqPCVLiKUIEZ1FmPB6s+MVRMFUvFVvGtM960VtcrnrEyqusVj9YY1fX6eAhP4SW8hY/wt48TK/xdxzwO4SR/1zF4SsuoLxp/PIWX8BY+wibswkFG/uCjWHS+PrFUYO1wriN/WpgK7B4KDPnTonYPH12iJ/aJoaJmgA810RP7xFZxVJgKVxEqMINaYvTEPjFUTBVLxVbxN4ON19Hqj914Ha6ntNYDbb9P4H/CQ3gKL+EtfITt4wC7cAgn+cuffS4P4Sm8hLfwETZhFw7ylvMn91SxVMj5k/uoMBVy/uQOFXr+HD1/jp4/R8+fo+fP0fPn6Plz9Pw5ev4cPX+Onj+m54/p+WN6/pieP6bnj8n5Y3L+mJw/LuePy/njcv64nD8u54/L+eNy/ricPy7nj8v5E3L+hJw/IedPyPkTcv6EnD8h50/I+RNy/iB/8IkqHvf6xFKxVWD3NoSpcBWh4ju+es2c1VD7eAhP4SW8hY+wCTv5hotDDBVTxVKxVRwV3wF6fX480Vn7RKhIEXUJ5PV560TP7RNTxSqBWdcl0BNHBWZwIDADg8AMMNGZItZPxVAxVSwVGCBK7J8KDJAQU0UNUJ/4znog7Ir7H46wCbtwCCe5UsQH1rKywgdW7MuK+tKzj104hL+REr/85cTjITyFl/AWhjH2oN5DPVF7UJ/7TTTMPpEiHIeBffsCob7C7mOTRXNXESpSRH2o4wP7Xh/qPDFV6H7U+6YnjgqdQegMEkNj33OqWCpq6IkVr0B4wlS4ilCRFPV97aO+UfcTQ8VUsVRgBg5xVJgKzCAhagbrmqaIyownhoqpYqnYKo4KU1EzqGvdibbaJzCDOlvQVvvEUDFVYAY4OGRGi6PCVLiKUJEikBktMIOAmCpwHmBFF2ZwxVFhKlxFiEDO1IcgEw23T0wVZVqfYUw8J/aJo6JMN5a3rmaeKNONRayrmRbnpwIzOBBTxVKxVRwVpsJVYAY4e0+KsJ+KoWKqWCowA5xiN5CwBjeQ7o+lCP+pGCqmiqViqziMfnTsPuEqQgVmgIneFLtiqJgqloqt4qgwFS4isaI4lRFpLaaKpWKrKJ+Dkw+R1sJVhIqkQPvuEzWDuj8/8dTZJ5aKrQIzOBCmwlVgBgaRIhBpLTCDgMAMEqJmYJgoIq3FUWEqXEWI+IILAV0PoG1cxE08RHuI3Kh7rBPtt0+Eir9DnVipL0IaB3ESF3ETMXadMGif9bo9PusRsIjb6qRtXMTvMuH+7CEa0YlBzIcoecNwKPkWtTmG3UXJt9gqMHusGQq73m5MdM4+8c0fh4iyNpwCKOsWR4WpcBXx1s65+sHVD65+cPWDq4+CvUteN2V7yVGwhlMSBdui1sNxeqFgW9QxOM6Hr2D3HcuITgxiNla7bCPGnhA1U7//5bt5czGI+XDUHSPgIE7iIm7iIcJvQ7iKOuvrpvTEQ1xb4IqhBWZvEBjNIVzFN/8BTC4fOl6fGCqmCrgExFZxVBi3CR2vT4QKncHWGWydwdYZbJ3B1hlsncHWGWydwdYZbJ3B0RkcncHRGeBCoMXu+kJb7K0VtMU+4SpCRYrAa3VgZijpFkPFV1r4ja+kGzfxEI3oxCDmwyrki4NIt6Bb0C3oFnTDq3FgZeqzmCdSBMo+cKaj7FvUkgdWGWXfYqs4KkyFqwgVmEEVBFpXnxgqMIMDsVRsFZhBQJgKV/G9DAxgPvyCo3EQJ3ERMXZC1DHg/SQ6VB1vW9Gh+sRUsVTUMdQdnYkO1SdMhasIFd+Zg8kgPOpOz0R/6hNTBfwNYqs4KuCPZUN4tID/NU0RCI8W9UYfOImLuImHaMRv7Phhdav4A3d28OzVwP0bPHv1iaPCVHgJLEKV/xMpoi4JnhgqvhtjGOu7IGjcxO/FDxP8blQ0OjGI+bBucF6EH05pnyqWClOB2WPX4qfiu6uH1aublhcXESuHbY2jwlTUyo37O6GivPGOB12pT9SR4H0Avq0+cNsG/aqBmzPoVw3cnEG/6hOm4nvph+WXIY3ZiH7UwPsjdJ1GNWpPdJ0G7peg6zTwphldpzHvAHUk1eU80WgauCtSXz9PsVX8+dj9DSP6w0qEqKbdiRbTwCVYtZjiyr8aTBtrrvUZ3ER7aeByHO2lT6SI9VNRq457LmgvfWKp2CqOClPhKkLEhg8WdWM0HEK9rsfCoqKAEZxoFX1iqJgqjgqMhuVGmV6BMsVlPNo+A+8K0MIZC4toKcJ/KjADrBtKrcVSscXHj/4XU+EqQkXK6qA8WwwVU4WuAUrxHjZKsYWuDgrunmsoONxDQj9n4LYR+jmfOCpMhasIFUmBfs5AXKOf84mpomaA0EE/ZyDw0M8ZyE9DqeJ9AJo7b7nYLdUrUgRKdV+xVGwVX5E50Ij+EKWKe0Ro3gzc4qnmzXP//0PEXO8v11w31gSl2iJFoFRb1GptLBBKtcVSsVUcFabCVYQIlCpiEr2agXceaMIMvPNBq2XgjRRaLZ9YKraKL/+wHPXF7xedGMR8WF/8fnEQJ3ERN5FuRjejm9HN6OZ0c7o53ZxuTjenm9PN6eZ0c7oF3YJuXz3jHXZ1XjY6MYj58HtBbRzESVzETaRb0i3plnTL51Z9l42DOImLuImHaEQnBpFug26DbhMnXkIsFVvFUWEqXEWoSBGoRNyUQ3tk4M4ZmiADr9/oR4w7t3pj+4SpKFPsdT1BE+8kqzXx4vfi1ziIk7iIm3iIRnQi3Q7d6uYVen0nmhADN6KqCdEvOjGI+fCrnMZBnMRF3MRDpJvTzenmdAu6Bd2CbkG377oVdxiqD7HRiJ8btvorrcZ8iBfIu1x4GbT7X2pncWMCnYRPhIqkwLMxnxgqpoqlYqs4KkyFqwgVmEGdqXg25hNDxVSxVGwVR4WpcBWhQmcwdQZTZzB1BlNnMHUGX1HHRSM6MYj58CvlRow9IXAMC+IbZQODmA+/d66Bn/1eMBsncRE38RCxMhUC6AYM3AZEN+ATSwWO3yGOClPhKkJFisAlcYuhYqpYKnQGpjMwzCAhXEWoqBncDcAFdouaAe4wBS6w71LhAhs3bgIX2C2OipoBbgPhu9mfqBnglg6+nT1wQ+Y+NhM4iJO4iJt4iDU2bumgLzBwrwZ9gXF/DBfVLbaKOgbcbEFf4BOuIlQkBbr/op7TMdHjF7gngx6/QEcMevyeCBUpAsnQYqiYKpaKrQIzCAhT4Sowg4RIEUiGFkPFN4PEDR48OPOJreLbHUymHt5/0Yl/3neJ6sn9wHog98VBnMRF/M4FHMh3kd1oRK8JDYhQkSLqDtgTS4WVmBCuAqMtiBRxfiq+lbuDVaQ0L+EtfIRN2IVDOMkVJc3ia+Jr4mvia+Jr4mvia+Jr4uvi6+Lr4uvi6+Lr4uvi61hr1JaHihQRWGucDvXW/ImpAnuKkyK2is8/cfsLX/3+hKsIFSmi7p8lbpmhI/CJmgHun6EjMHH/DB2BeM7nREfgE6YCM8AhZKjIJxa+K77WY+Gr4pun8BLewkcYDl5i4EgCAkeSEEvFVnFU1JHUrbmF1r8nQkWKqMx5og7lgL8J1N3Lhca/rFsmC41/Oe9PHRWfy8CR3b/fBn+/sTDUfXQV2IQxXSwvYqNFikBstBgqpoqlAhPGGu2jwlQEZ3z/0rL4/qEluI4KP48/s7y8hMuubjYtdAM+YSrqgBdWq+LliTrghdWugHliqPj8FzYOX8F6eQsfYRN24RBOMr579fIQFl8XXxdfF18XXxdfF18X3xDfEN8Q3xDfEN8QXyTLwqmJZGkRKrDaOFWQLC2Gijq9Fk4DJEuLreKowAxQ0EiWhXPkfgsROB+P+x1E4LKve4ELfYVPLBVbxVFhKlxFqEgRdRH0hM5g6AyGzgBfpLbAR9iEXTiEk4wHdV4ewrXxBl7CWxgHPiBMhasIFTjwKkc0Ez4xVGwVGA07hJiqW6ELj+VsgZhqMVRgNIfAaAERKlIErm5aDBVTRW3KwaYghVocFabCVYSKFIEUaoEZYOFtqlgqtgrMAAtvpgIzwPJaqEgReNge1h3P2rs8hZfwFj7CcMCZhauX+19w9XKwTbh6abFVHBU4EuwmMqZFqEgRyJgWNQPDwiJjWiwVW8VRYSpqBobjwdVLi6RAr98TmMGBmCqWCszAITCDgDAVmEFChIqaQd2SWej1e2KomCqWiq3iqDAVriJU6AymzmDqDKbOYOoMps5g6gymzmDqDKbOYOoMls5g6QyWzmDpDJbOYOkMls5g6QyWzmDpDLbOYOsMts5g6wy2zmDrDLbOYOsMts5g6wyOzgDJVje5Fh4J+sRSsVXUDHDuIdguu3AIJxmhdnkIT+EljAOcEDiMyhH0Mz6Bw0B1+VSxVGwVR4WpcBF46+WoyNBtCV0URFQLU+EqsC0GkSIQUS2GCj0xUmeQemKknhipJ0bqiZF6YiCiMDc8FvSJoWKqWJwbHgv6xFEhM8BjQZ8IFXJqLo2opRG1NKLWkFNzja3iqDAVLnMboUJ2YWlELY2opRG1NKKWRtTSiFoaUUsjat2Iwtym7sLSXVi6C0t34UaUQ2wVmEFAmApXESpQohgaEdViqJgqloqt4qgwFYiICREijpQZGiuzbsguNFY+sVRsFXryIZZa6NYf3fqjW28/FUOFbr3p1ptuvenWm2696dabnv6mp7/ryYfgqk8AFh46+sRRgeXFuiG4ArPGVVeLFIFIazFUTBVLxVZxVMAHJx8i7QpEWouhAj44+RBpLbaKowLXfThsRFqLUJEU6Nx8YqiYKpYKvJNxCFcRKlIEgqtu869936gFxFZxVJRP3ctfeJroE6GifOou/0IXZw8wh4qpQmcwdQZTZ3Dfs13hKkKFvC/aS2ew1BS5g/dsaNB8wlXg4BZEikDu1EcLC48WfWKqqIOrW+MLjxZ94qjA8mJuyJ0WoSJFIIQS24gQajFVLBVfm/Pvh836oub7g2WIUJEivqj5/pYZYqiYKpaKreKoMBWYAVbUQkWK8J+KoWKqWCq2CgyNLQkMgIWPqWKp2CqOClOBQ8CWRKhIEflTMVRMFUvFVoEZYBvTVLiKUJEU9QRSisENro5PiqViq8A56hDJFa1Hi1IMFVNFDY07xtXm2YtYjZ4UoaJ8BmYwfyqGivKpe/yr2kPfAHOrOCp0BlNnMHUGM0Wsn4qhYqrQGSw1XbwDfu5XWBffb7AGf7WMzxHO/T5a8BKuwxpY2H1UmIo6rP6dUJEi7jfGgYfwFF7CW/gIm7ALh3CSTXxNfE18TXxNfE18TXxNfE18TXxdfF18XXxdfF18HYuNMnBT4Sqw2Pd3UkTgLA6IoWKqqHMIn7schFGLmgE+bDkIoxY1g4nTCGHUIkXgKeooFjxE/fIUXsJb+AjDoU41Q6TgExVDpOAzEUOktNgqjgocSUK4ilCRIpA8LWoG+PTEkDwtloqt4qgwFTUD3D02ZFKLFIFMaoEZ4HiQSS2WCswAs0Ym4U65IZNa1AxwL9qQSS1qBrhGMWRSi6FiqlgqtoqjwlS4ilChM9g6g60z2DqDrTPYOoOtM9g6g60z2DqDrTM4OoOjMzg6g6MzODqDozM4OoOjMzg6g6MzMJ2B6QxMZ2A6A9MZmM7AdAa4Sqpm7mW4SmqRInCV1KLugONswR3wy0t4Cx9hE3bhEE4yYgsfeRjCCZ9lGMKpBQ4DlYJwapEicKXUYqiYKpYK+KC6UrbFf7IojohqMVUsFdiWgDgqTIWrCDXVGYyfiqFiqlgqtoqjwmSiw1WECjkxfOoaIKKqo305IqpFzQAf4TgiqsVRYSpqBucOHSpSBCKqxVAxVSwVWwVmsCFMRXDrHamEj14cqdRiqJgqlmzj1q3fuvVbt37r1t9UuiJFaCq5ppJrKrmmkmsquaaSayq5ppJrKjmypxqylyN7WiwVWF6sG7LnYNbInhauIlSkCGRPi6Fiqlgq4IOTD9dOLUJFisC1Ez7Mclw7tZgqlgpcceCw77XTFabCVYSKFIF4ajFUTBXVw4MzrO4FNbtwtW5hB+pGEBg90M04xgUxVSwV1T5k4CNswnWA+FAvkFctUgS+3fsHHsJTeAlv4SNswi4cwkme4jvFV9qM0PLcLL5TfKf4TvGd4jvFd4nvEt8lvkt8kUv40DOQSy1MBdqVsD23XekKrDY2BSHVYqgof/wK3vld3sJH2ISdjBDC57KBqMFHsYGowaevgahpYSpcRZ03uK0fuAC6AhdALYaKqaJmgM/IAiHU4qj4jga1hJbp5hCuHiwsN77Y9/IQnsJLeAsfYRN24RAW3xBf5BE+5AvkET6WC+RRi63iqDAVriJUpAjkUYuhQmeAyyV86BK4sdTiqMAMcDy4sdQiVGAGdRolLrFaDBVbRTX4ODiEk4zvAr48hKfwEt7COI6EMBWuIlSkCFwmtRgqpopaSXwQlLhManFU1AzqCRcrcZnUIlTUuVR7lPh6m8tDeAov4S0M7wVhKlwFvA0iRSCIWtTR40ObxNVSi6UCR4/1x9VSC1OBGeA0QBzd/1IPGznAQ6xfTqwj0qdFqEgRSJ8WQ0VNH/fZE+nTYqs4KjADTBKXQC1CBWaAA8MlUIuhAjPA6YNLoBZbxVHxzWDgRn31XX9PDixRl0ADN7aru5piqlgqdgksb0XOvSio7urvMYIQ8MEMKnKeSBH5U1EzwGtjdVdTLBVbRc0Ad2uroXreF6tqqJ73Pmg1VE/c8NzVUD1xD25XRzXFVLFUbBVHhamoGdTTC3Y1XD8xeLLuH967tZgqloqt4qgo07p3tqv7miJU1GHXxcKu7muKoWKqWCq2iqPCVLiKUKEzWDqDhRlgS9ZUsVRsFUeFqagZLKx1RdMTKaKi6YmaQXXw7mrpplgqagYLs65oQtfsrpZuCszgQIQKzAATPT8VQ8VUsVRsFUeFqXAVoUJnYDoD0xmYzsB0BqYzMJ2B6QxMZ2A6A9MZuM7AdQauM3CdgesMXGfgOgPXGbjOwHUGoTMInUHoDEJnEDqD0BmEziB0BqEzCJ1B6gxSZ5A6g9QZpM4AybeQB2kqXEWo+C4R6vJ7j/uge/AQnsJLeAsfYRN28sABBgRi7Qocxv2xo8JUuIpQkSIQay1queqm9x5TtmVMWZQxQ0WKQES1qG2pG+V7IKJaLBVbhZwYY+kMlqsIFXJijP1TMVRMmduNqCu2iqPCZG6IqBahQmegETU0ooZG1NCIGhpRQyNqHDk1x9FdOLoLR3cBEXXnZroLprugETU0ooZG1NCIGhpRQyNqaEQN1/PgRtQVuguuu+B6HiCiWuguaEQNjaihETU0ooZG1NCIGhpRQyNqhJ4HobsQuguhuxC6C4iouhe4ByKqBXZhQSwVW8VRgTXA3BBRLUJFUkxcqbUYKqaKpQIzcIijopJqgZNBMRFVdad1V4c4xVSxVMhmz3FUmApXESpSxPypkM3Gk2KfWCq2iqPCVLiKUCGn27zxlhBLxVZRPgfrhng7mDXirUWoSBGItxZDxVSxVGwVeAuOXcAN8xYp4vxUDBVTBXxwUiDEWhwVONIN4SpCBY60LvsmQqzFUDFVLBVbxVFhKlxFqNAZuM7AdQauM3CdgesMXGfgOgPXGbjOwHUGCLGDUwwhdrDwCLEWS8VWcVSYClcRKlIEQqyFzqBaFDbmWS0KzVv4u9C5wVL33ptd+LsDtXEC1AUWGG3lzUN4Ci/hLXyETdiFQ1h8kVn1KcdeSKZ6cs5eSKZ6xPBeSKYWoSJFIH8MQyNl6rb0XkiZFq4iVKQIXF61qN2o28l7IX9aLBVbxVFhKlxFqMAMqpIX8qfFUDFVYAYBsVXUXx1idetGebMLh3CScWVlV5S5Y2twZdViqdgq6vAxEWSSY77IpBahIkUgk1oMFVPFUrFVHBU6AyTPPTZkheOsQVa0CBX10X+VEZqzm4fwFF7CW/gIm7ALh7D4pvim+Kb4pvim+Kb4pvim+Kb4Jn3Rot08hKfwEt7CR9iEXRgLfUWKwOVOC5wEDjFVfOb1GcpGN3fzETZheNTJuREbdZ97oy27bhtvdGU3H+FvpLoZvPd9ch84hL/lC7jdJ2yCh/AUXsJb+AibsAuHsPhu8UVI1O33vfFOq/9LnfL30PBOq0WKQB60wGgHAqNhj1DcLUJFikBxtxgqajfw9hvd1U9sFUeFqXAVoSJF4ILj7hYuOFpMFUsFZoAzBRccV+B6of4CYKO7+omlogZILDyuF1p8hzBhU5cLzSGcZLytSWwH3rzk/S81EqZV712aQ/gbCbcW0SHdPIQ/h3pC60Z7dPMWPsIm7MIhnOQq7eYhLL5DfHFFUH9gsNEgPeoDiY0Gafw14kaD9BNTxVJRs/3hUOt1f1bD90az8xNDxVSxVGwVtSj1GcSu5+FSuIpQkSL2T8VQMVXgeBJiqzgqTAVmsCFCBWZQRVidzt93kkAcFabCVYSKFGE/FUPFVLFU6Ayq2PHOuJqeH7vwZ7/vzye56rz588alcDU9P17CW/gIm7ALh3CS8X0al8U3xDewstgaVPrAOYRSr8+KdjUuUwwVU0WNNrCdqPaBasmkqEfuUgwVU8VSUbtRPd4b7ctPmApXESpSBCq/xVCBGSyIpWKrOCowg4BwFTUDfKiF9uUWlRhPDBU1A3wmhfblJ7aKo8JUuIpQkSKQMi2GCp1BpQyuU9C93HyEP3tcvqB1uTmEP29cLKFvuXkIT+ElvIWPsAm7cAiL7xHfg5XFDiJTJk41ZAo+KkPj8RMpApnSAqNhOQyj4bjNVYSKFOE/FUNF7QY+Xqs2Yoqt4qgwFa4iVKSIwAywOjFUTBVLBWaAMwVZ0gI+FQXoGZ64d1aP+aU4KkyFqwgVSYE+4yeGiqliqfhmcC4fYRP+7KtLc6PHuDnJlSK4d4MG4+YpvIS38BE2YRcO4SRP8Z3ii3zA/Wh0CE+8lUaH8MQNXHQIt0AKtBgqajTcw3ZcN+DmNFp/n0gRuG5oMVRMFbUbuGuE1t8njgpT4SpCRYo4PxWYwYCYKpaKrQIzwFmAXGiBGQREqEgRyIUWNQPcAUZT8BNLxVZxVJgKVxEqUgSypIXOAN/4g8PBV/5c3sKfPTon0Crc7MKfN958oU/4Mr755/IQnsJLeAsfYRN2YfEN8cVVCO55OzIF96IdmYI7zo5MaREqkgLtvjcIAtcaqPjAtUYLVxEqUgSuNVpgNxJiqlgqtoqjwlS4ilCBGdTqBK41WgwVU0XNoJq3dyBLWpQP7nEGsqRFikCWtBgqpgr4LIitoo4Ut0/R1fsEZoCJIn9aYAbYLORPC8wAC4/8aYEZBMRWgRlgEZE/Lf5/be+2I12Pm2neSx3XwdKGlNS30hg0atyegYGC3XC7GxgYfe8ToXct8f0yKxjMWEofuPh8fwapLZc2lDRT0FAg8D8XzBRgzRFRvwtmCrDi0+F/LpgpwGIg4oEXzBRgyQ/xwAuQAmQb/ucCpADZhv+5AClAtuF/LkAKkG34nwuQAmQb/ueCOcZC3qb7ueRh8nQ+l5xIziRjUo3iwyjmAmHAfB7lglHMBZ1hEGAUc0FiyAyFoTIIA6egcwowI8KqDIJ8T1+EIN/TmSLId4EyNIbOQPlBkO+CxJAZCkNlEAZlaAydgVOQOAXnckgFqGUbwb5nFhDsu2AQwBddkBg4P5nzkzk/mfOTOT+Z85M5P5nzUzg/hUu0cAoKpwC+6Mw2PM6Z7cr5qZwfeJwLCkNl4PxUzk/l/FTOT+X8COdHOD/C+RHOj3CJCqdAOAXwK2e24T3ObCvnRzk/KgzKwC1EuYVg9IKxBeJ5FzzzM+84qQjnveRCciUZNqYjG6cvGICHpoLVthmwu+RC8jMsGmtoM1p3yUry08I4dXaSh8nTOVxyIjmTXEiuJAvJSjLZHcuuICQX2RcE3ua5oCsIvM1zgVYQeLugMXQCjE/mEqcgojbP0GxBRO0CZWgMnWEQoOfPxU9BRO2CzFAYKoMwKENjQAoqYBCg51+QGJAClCh6/gXPFKDuBRG1C5ShMXSGQVAPhsSQGQoDp2C+MjiPqMkMqF1yI7k/ZRTG01Nc8tNRLHn2BlTMfJn4kgvJlWQhWUluJHeSh8l6kEx2lewqShYNV1F+qBpF+aFFtoMhMWQGaENxNGhDvtsg6AdDYsgMhWHWRkJ3m2OFBcrQGDrDIJiOYkFiQApQOqMwVAZhQArQUkZjQApQOth6ASTsvcxYf0nYfJkroTJDW8uM1JcZ2rrkSrKQrCQ3kjvJw2S8WHrKiWSym8huQsmfIAzK0Bg6wyDIB0NiyAyFYaZgLtPKvNfYQBkaQ2cYBPAfczNNEO66oDMMAviPCxLDTHVGpcJ/nCD4DWpYEkNmwG86oDIIw7OWr580kjvJz1rOaEWz819yIvlZy2cKn4OJJVeShWQluZHcSR4mt4PkRDLZbWS3oTZQ0fASc11UEFpa5rKmILR0QWYoDFNbQdWgxxfYQY+/IDFkhsJQGWZtFJQievwFjaEzDAOEiS5IDJkBKSiAyiAMyoAUdEBnmCmYS2yCCNJS8Zs54liQGQpDZRAGZWgMnWEQZE7Bs/eXuegpM4B0yYXkZ7M8k//s+UtWkp/Nci64ygwdXfIw+TkEWXIiOZNcSK4kC8lKMtktZBf+Yca5CaJCy1zJlHk78PMxc4AyNIZOAM9RoRr+QVA28A8XKENj6AyDYK5YlHmduCD2c0FmKAyVQRiUoTEgP2iRGFecgHHFBYkBKUBLaYUAvf8sEPT+CyqDMCBtqJLOZQC/cEFiQAoEUBgqA8oAFTy4FgbXwuBaGJSCchwMiSEzFIbKIAzKQEYLOvxcDxWEXy4oDFA9AMKgDI1h2tHTziBAh78gMcwUzJhPQchmmeuUgpDNBY0BdgpgEJSDITFkhsJQGZCCClCGxtAZBgGGCBckhswA1QqAAhQ8xgsXJIbMUBgqA7KAKoE/uKAxdIZBAH9wQWLIDDMFDdUIf3CBMChDY+gMgyoY/uCCxJAZ0EY7oFGJYtJxwSDAcOKCqbqh8XUuRLiNC5QBWUAKMLW4YBDAoTS0qsHVOLgaB1fj4BQMTsHgFMChXNAZqCHV42BIDIWBxkr1HEGc0BkGAUYQ7QQaK9VUGYQB7eCExtAZUIizfmqm0VrNiSEzcAoypyBzCuBQLmgMnYHGi7VwCgobhadoKER4igsaAzI3AIMAnuKCxDDtzFV4QdzmgsogDDMF8wZvQdxmmeGdgrjNBYkBdgqgMFQGYVCGxtAZkAK0EDiUCxJDZigMlUEYlACeoqO5YHzQUfBwDhcIgzI0hs6ALKBK4DYuSAyZoTBUBmFQhpkCrCAi2nPBIIBDuSAxZIZCFQyHcoEwKAPa6PSjZwQoShQhoAsKQ2WYqmeIqyDc8yxExHteALdxAbKQAZmhMEw7WB6VJKxAGRoDpyBxCjKnAA7lgsxQGCoDpyCzUXiK44TEkBkKAzJXAVjDRC2UzkCrZogNLVgiRmzogsyAQkT9nGuYpwJhUAZOQeUUVE6BHAyJITMUBk6BsFF4ioECgae4IDEgcwNQGCqDMMyIzbm5IGeo6AWdYRAgWhTLvWdYKJZFz7jQC4QBdtBGERp6QWcYBIgOvSAxZAakAC2kVwZhUIbG0BkGwTgYoBrNZUABCn50hmGAONIFiSEzIAsDUBmEQRkaQ2cYBOlgmCnA+i3iSBcUhsogDMrQrIIRR7pgEOSDAW20A8RKFAGiCxpDZ5iqsWiMMNCrEEthqAzIAlJQlKExTDszYlYQDHopqFyNlauxcgoqp6ByCqowKENj6AycAmGj2BuFF8P1tAuUoTEgc7Mp4xLac9cLl9AuKAxoB1CA+PILlAGFeP6mswLaXTvjRy/gFDROQeMUtMogDMrQGDgFnY3CU2DzAIGhC4QBmUOXgae4oDMMAngKrJvjatoFmaEwzBRkNGU4lIyWCIdywTBAMGmdMcGCYNIFmaEwVAZhUAakoAI6wyCAQ7kgMWSGwlAZoHpWCYJDK1bccefsgsJQGYRBGZCFAegMg6AcDIkhMxSGyjBTMM8ACe6cXdAYOsMggEO5IFEFw6FcUBgqA9poBwwqUTkYEkNmmKqxgYAg0qsQpTF0BmQBKdCDITFMO1hwRxDppUC5GpWrUTkFyilQTgHGISdgHHIBN6TGDalxChobxdADE3YEiVbMXBEluiAxZIbCUBmEATEmaDtnjNYJnWEQjIMhMWSGwmAxQIJI0lpQ23AoFwyDDodyAXLaAMjpCYWhMgiDMjQG5FQAg+CM3johMWSGwlAZhEEZLDpIEGN65RR+54LMUBg4p5lzmjmnmXMKv3PBIIDfuYBzWjinhXNaOKeFc1o4p4g+vYDLunBZnxFfKJDKOYV3uUAYlIFzWjmnlXMqnFPhViXcqoRblXBOhXMqnFPhnArnVDinyq1KuayVy/qMBUOBKOdUG0Nn4P7TOKeNc9o4p41z2rhVNW5VjVtV45w2zmnjnHbOaeecds5p51bVuaw7lzU8EjZpcJ3sBfBIFyQG5LQDLBpdznjSCxoDSnQAhsE4PdIJs0SxxXnGk0LBGU96QWUQBmVoDJ1hEFA8vIwzHv4ETkFio5gMYZ8VwaULBgGcELZ1EVy6IDMUhtlcsEuK4NIFytAYkIJZpwghrdhZRQjpgsIAO8gPhjgXKENj6AyDAEOcC5CCDsgMhaEyCIMyNIZOAO+CbTxEjVZBwWOIc0Fj6AyDAEOcC2YWsLOKSNMFhaEyCIMyNIbOgBSgGuFdLkgMmaEwVAahCoZ3uaAxdAIMfuaxKsFlsVeJYohzgTAoAzKHxje4EDEzuiAzwA5SgJnRBcIAO2hVg6txcDUOq0bF/bALEkNmKAyVQRiUoTGwUXiKWYiKW2AXVAZhgOoOsFNrekamXpAYkIUBKAyVAae0D4CygsbQGTgFhVNQOAUlMxSGyiAMnILCRuEpFIUIT3FBYcAJ9PM3wqAMjWG2kLm7rLjE9QIMVy5IDEiBAGBHAcrQGGCnAQYBHMoFiSEzFIbKgBSghcChXNAYOsMggEO5IDFkhqm6oblgZtRQ8HAOFySGzFAYKgPuKUCVwG1c0Bg6wyCAQ7kgMWQGpADVCIdygTAoQ2PoDMMqGBGpCxJDZkDNZUCzEk1YXblgEGB15QJkTgBUiAguXaAMsIMUYBxywSDAOGRuwCqCSy8FOTMUBk5B5hRkTgHGIRd0BmpIuJl1AaegsFF4ihnaqYhBXdAZBgGGHu0EnAYfgMogDMjCCY2hM8wsdNSPHKRAEkNm4BQIp0A4BecJ/xMaQ2cYBMopUDYKT9FRiPAUFzSGmbm5I63pvBIEcN4JckJimC1kzpkUN6YuqAzCgBSgKcOhdLREOJQLEgPsoI3CoVxQGYRBGRpDZ0AK0ELgUC5IDJmhMFQGYVADRLLWue+siFetcwtYEa+6QBiUoTF0hpmFueuriFddkBgyQ2GoDMKgDEhBBXSGQQCHckFiyAzFKhg3ni4QBmVAzU0/muEpzhLFXOaCwlAZkDkBcCFixnIC3MYFsIMUYBxyQWGAnQbgaqxcjZWrsXIKKqdAOAUYh1yQGbghCTck4RQIG4WnSKgFrIdckBkKA1SjKeNsXEIhYpfngkEAtzF3lxVxqgsyw9OOHKgf7PJcCoRBGTgFjVPQOAVYD7kgMWSGwsAp6Gx0ego5UIjTUyxIDHkCuswoDJVBGHQCynoOPRZ0hmGAEFiZh4gUga4yN0YVga4LhAF2GqAxdIZBgItDLkgMmQEp6IDKIAzK0Bg6wyDAFSIXTNVz31kR6CpzC1gR6LpgEMwBxoLEkBlmFuauryLQdYEwKENj6AyDoB4MSAGqsWaGwlAZhEEZGlVw7QyDQA4G1FwGCJWoKENj6AzIHBqfciFqYagMsIMUqDI0BthBq1KuxsbV2LgaG6egcQoap6AJgzJwQ2rckBqnoLNReAo4rnLeTXaCMjQGqEZTxsop3AYCXRcUBmRhAIRBGWYWMuzgjP6lYBgg0HVBYsgMhaEyCIMyNAZKAUJgF8z6ySdUBmGYmZs70ooQ2AWdYRDAU8zdZUUI7ILMUBiQAgHAjgI6wyCAQ5l7h1rhUC7IDIWhMgiDMiAFHdAZBgEcygWJITMUhsowVc99Z0WgqxQUPJzDBYWhMgiDMswsFFQJ3MYFg2COQxYkhsxQGCoDUoBqhEO5oDF0hkEAh3JBogqGQ7mgMFQG1FwGDCrRfjAkhsyAzKHxdS7E3hg6A+wgBRiHXJAYYAetanA1Dq7GwdU4OAWDUzA4BRiHAHAh6oLEkBkKgzBAdQdA9XRpCIFdkBgyQ2GoDMLwzByufVWEwC7oDIPgvCv1hMSQGQrDtIPs4PL0U+4kz2xWFAC8yQWJITMUhsogDMrQGDoDp6ByCiqnoHIKKqegcgoqp6ByCiqnoHIKzvuSZ9uX877kExJDZkAKMgAFrYDG0BmQ0+kzEDO7IDEgp6jD8yZlKDhvUj5BGDgFyilQTsF5kzLgvEn5hMSQGTgFjY1ieFJRIHA6J8DpXIDMNUBmKAyVAdWINgp3dEFj6AxIAfoYnM7c/HlAYagM0w72RwRO54LG0BmGAaJpFyQGpCADCkNlEAZlaAydYRCcdyVWABQIoDF0hkFwXox4QmJAFhqgMFQGYVCGxtAZBgH8DjaZcKnqgsxQGCqDMKhVMKJpF3SGQXC6GgVUKlE4lAuUoTFA9Wx8iIy9ChGjmAsKw7SDDTDEzC5QhmkHm0yImV0KuBqVq1E5BcopUE4BRjEXCAM3JOWGpJyCxkYxPMHmAsJkBdtcCJNdoAyNoTMMAjiUC6avwuo3rlldUBgqgzAoQ2PoBHjKBbstiJldUBjq9SKCqr3WoGqvNajaaw2q9lqDqr3WoM1ea9BmrzVos9catNlrDdrstQZt9lqDNnutQZu91qAzfnbJZDeR3UR2E9lNZDeR3UR2E9lNZDeR3UR2M9nNZDeTXYxnsO+CiNsFaFLnnykDKrQAOsMggNPBJiYibhc8E4D+NgNul1xJFpLRbKf3QeSszMO2OiNn8daFzsDZJVeSn5ra+WMluZH8LEJsk83I2kt+DlaWnEjOJBeSK8lCspLcSCa7QnbhUbAliKBZmQdoFUGzchYx/MYFnWEQYI6DPUVEw8ppB67igsbQGQYBXMUFszbOUsTY44LCUBmEQRkaQ2dACqZDQJzsgsSQGZACtBSMSi6YKcB2GCJoFzSGzjAMEEG7IDFkhsJQGYThmQKs7yKA9pI7yU/zWNRD9OwlJ5KftrFojNDZS64kC8lKciO5kzxMxpPop5xIJruZ7MJrYBMHUbGCrUFExQqG+oiKXZAZCgO0NQC0zcaB+1UXJIbMUBgqw6wN7Bwh9nVBY+gMgwBrrhckhsyAFKC2MDq5QBiUASlAS8Ho5AQMLrBlh6DWBcoABSh4OIkL5hlDyOddI5ATyZlk2EB1wEFgSwzBqZh9Izb1khPJODYFuZBcScY5UshKciO5kzxMxkngU04kZ5ILyZVksjvILjo9tvoQiirYzEIoqmKxF6GoC4RBGcaE2R8QVqrYFsIFpgsqgzAoQ2PoEwQwCGanXZAYMkNhqAzCgBQkQGPoDIOgIAUKSAxIQQcUhsogDMrQGDrDIKgHQ2LgFEwHgSAwhKVespA8zaMwpnO45E7ytI2KmZ7hkhPJmeRCciVZSFaSG8mdZLKrZFdRsmi40zcodjYQkqoJLXL6hgWDYDqHBVMb9qQQXqrYHkJ46YLOMAj6wZAYZqFgRwhRqAsqgzAoQ2PoDINgIAUonZEYMkNhQArQUoYwYGvk2aTbefHpbFDtODdaTigMlUEYlKExdIZBcO66nMApQChIg1xIriQjCgOyktxIRnQh5GEyQkBOOZGcSS4kV5KFZCW5kUx2M9k9n5waAIQPJAB28jOgMXSGQVAtHKIhshShAA2RpQsaQ2cYBHIwIBgBJY0QsQsKQ2UQBmVoDJ0BKSgTzsCPExJDZkAKUMO4LvkCBKkdAGVoDJ0BQWoo0fPhmBMSQ2YoDJVBGJShMXQGTsH0Mg3ZmU7mkjPJT/MNjWh6mEsWkp+2Gwp5updL7iQPk6dvueREcia5kFxJFpLJ7jC7CETFC0EtwafMLc2G2FM8/dMSfMoFytAI4DnmTmFLyYIWG2JPFwiDMjSGzjBrY279NMSeLkgMmaEwVAZhUAakAKVzPix1wiA4H5Y6ASnIgMwAO9MVIKgU7/M0XGy6IDMUhsogDMrQGDrDIBBOASYWp5xJLiRjngtZSFaSsdwIuZM8TD5XOyEnkjPJheRKspCsJJNdJbvwDwWJO5+PQhuCF5iTg4Z40gWNoRMg/KuiOrsdR2iIGl2gDI2hMwwCHIerSDWCOi7IDIWhMgiDMjQGpADtG0EdAASXLkgMSIECCgNS0AHCoAyNAQflDsAgOA/KnZAYMkNhqAzCoAyNgVMwfUlHdqYrueRE8tP8XB5oCDm95Ery0/ZcT2iIN73kRnIneZg8HcglJ5IzyYXkSjLZLWQXoxBBDcKnzCNhDRGnePqnIeJ0gTAogx3dbIgePXs8okcXVAZhUIbGgNoYgEGAscYFiSEzFIbKIAxIAUrnfFjqhM4wCDDWULQU+JIL5pg9nyAMytAYOsMgwLwlo7Iwb7lgzhow8ECQ6QKkAHWKecsFSAFqDvOWC5ACZA7zlhMwb8GnG7GoC5ACVBbmLRcgBejWmLdcgBSg4EdjwKQS2R7DALGoii8vrmNdgAltBhQGTGkLQBgwqa2AxoAUCGAQJKRAAYkBKWiAwvBMwTh/LyQryY3kTvIwGWspc22o4b7WBZkB6wgoF6ylXCAMytAYOsMgwFrKBYkhM3AKCqcAKyb4OiJYVfFxQ7CqVpQ/1kUuKAyVQRg4P5XzUzk/lfMjnB/h/AjnRzg/wvkRLlHhFAinAMshZ7axHnJmWzk/yvnBSskFjaEzcH4a56dxfhrnp3F+GuencX4a56dxfhqXaOMUdE4BfNGZbXicM9ud89M5P/A4J8DjXMAtZHB+BudncH4G52dwfgbnZ3B+BuUHYawLEkNmKAxq2cYVrWe2EZ96ZqGmxJAZCkNlEAbYEUBj6M8nIpCapwe55KcHWXIiGTYUAE0NMDWd/2GYPO9sv+SpCX8/72y/5EJyfcpI3byz/ZKV5EZyJ3mYXA+SE8mZ5EIy2a1k9/QJ02MiLFUx2ENYqmJQhLDUBZVBGLD8ikpWaEMdaWYoDJVBGJQBq7woafT8CwYBev4FiSEzFIbKgBSg0aLnX9AYOgNSgBpGz78AKRiAzFAYKoMwKENj6AyDAN7iAk7B01vgPYY2Q1SXXEl+tg58/2d86pIbyc9WiXHFDE495RmbuuREcia5kFxJFpKV5EZyJ5nswmtguIkgVNXzv8zymyvwDUGoCzrDIMAoYu4iNNypqjPmoiHUdEFj6AyDAGOFC2ZtzBiKhmjTBYWhMgiDMjSGzoAUzNpCtOmCxJAZkIIBqAwzBQ2lg/HFBTMF7VQwU9BQbvNxKbj7GWy65ERyJrmQXEkWkpXkRnInmewq2YU3wuodYk8XFIbKIAzK0Bg6wyCAN7oAKUAFwRtdUBgqgzAoAfxHRyuH/7hAGJShMXSGmeqOooL/uAC/QQ1jfHDBMECAqGINAAGiCzLDs5bxgZnxoUsWkp+1jA/KDA5dcid51vJsnfOe1SUnkjPJheRKspCsJDeSO8lkN5NdzDWwvIHYUO3nf5nlN5A1eIkLBgG8xAVT27xjuiHOU2cUQUOc54LOMAjQ4y9IDLM2MJHCrakLKoMwKENj6AyDADOKgdrCuOKCzFAYkAK0FIwrLkAKUKJzRtGO8zedYRDMucaCxJAZCkNlEAZl4BTMR6bwuZ+3rl7yfGTqkp/Ncsbttnnl6pILybM7IL9NSFaSG8md5GFyP0hOJGeSC8lkt5Nd7KwcaITYQjnQ17GHcqCisYlyQWUQBmibxYHbUxv2RnF76oLCUBmEQRlmbcyDkg23py4YBHPOsSAxZIbCUBmQAgUoQ2PoDEjBbCkzEtRghpQKZCW5kdxJhqbZixHUuSAxZIbCUBmEQRkaQ2fgFFROQeUUVE5B5RRUTkHlFFROQeUUVE5B5RQIUpABSAGKSjJDYagMwqAMjaEzDAJ4mAs4BU8Pk+DV5jWsS64kPxsAfPwMJ11yI/nZAPBRmLGkl/z0LUtOJGeSC8mVZCFZSW4kk91GdrFri+kuAkgbtqoRQNrm0diGANIFnWEQwI9g8RbBoA3rtQgGXdAYOsMwQDDoglkbWMlFMOiCwlAZhEEZGkNnQApm6SAgdEFiyAxIgQAqA1LQAMrQGDrDIICHuSAxZIbCUBk4BThYVyA3kjvJM9YchTG90iUnkueZAlTMdEmXXEkWkpXkRnIneZg8fdElJ5LJbiW78DZYfkcAacO6OgJIG5bSEUC6IDMUhqkNk2dchNowS8ZFqAsSQ2YoDJVh1gbW1RFNuqAxdIZB0A6GxJAZkAKUTqsMwqAMSAFaSusMSAGKFx7jgsIw7WC3GBGnC6YdLCIi5nRBZ5h2sLyIsNMFiSEzFIbKIAzK0Bg6A6UAl6cuSAyZoTBUBmFQhsbQGTgFiVOQOAWJUwD/g2kxolwXCIMyNIZOMI+3oEoRvXp2BUSvLhAGZYDm2eARo3q2fsSoLsgMyIEAKoMwIAcKaKygM1CfRYzqAk5B5RTUwlAZhEEZOAWVjcK5YKUZYagLKgMyNwDK0Bg6w7SDmTWiURckhswwU4CZNgJVGxY6Eai6oDPADuoUbueCxJAZCkNlEAakAEUFt3NBZxgECDu7IDFkhsIA1Wgu8CeYviE2dUFmKAyVQRiQBVQJ/MkFnWEs6Lg7dUFiyAyFYaZgroN2xLMuUIbG0BkGAfzJrOCOeNYFmaEwoI12QF8l2hGvegEGKhckhql6HjnriE1FIXYEpy5oDMgCUoCJ0glwKBdMO3ORtyN09VJQCkNl4BQUTkHhFMChXDAI6sGQGDgFlY3CU2SUAWZAFwwCjFYuQOYqAGM6ZFuEQRnQDgTQGQYB3IaifuA2TgVwGxcUBk6BcgqUU6CNoTMMgnYwcAoaG4WnUBQiPMUFnQGZQ5eBp7ggMWQGxIqiY2DocoEwKAPiRVE/Z0AqEnpGpJ6QGWAHbfQMSj1BGJShMXSGYYCQ1TbX6jvuTl2QGQpDZRAGZWgE8BTzZGJH/GqbK+Ad8asLlKExdIZBALcxQ4I74lcXZIbCUBmEQRkaw0zBvGu0I371AjiUCxJDZigM1SoYka0LlKExoI1OP4ow16tEMfS4oDIIw1Q9jzZ2BLNehQi3cUFiQBaQAoxDLqgM005HqxKuRuFqFK5G4RQop0A5BXAoFxQGbkjKDUk5BcpG4SmOEzJDYagMyByaMtzGgVqA2zgBbuMCtAMBZIbCgEJE/XRhBcrQGDgFnVMwOAUjMWSGwlAZOAWDjCK8tc3djI7w1gWZAZkbgMogDMow7czlpI7w1gWDAEOPC2YK5rJZRxBrm+tjHUGsC5QBdgqgMwwCOJQLEkNmKAxIQQUIgzI0hs4wCOBQLkgMUK0AKEDBwzmcgAHGBYkhMxQGZAFVArdxgTI0hs4wCOBQLkgMMyj3QDVOh7KgMgiDMjSGThUMh3ICHMoFiQFtFO0anuIsUQw9LugMg2AOPfqBxte4EOE2LhAGZAEpaI2hM8yw5gOtqnM1dq7GztXYOQWdU9A5BXAoFzQGbkidG9LgFAw2iuixs0QRPXZBY+gMyNxsymdUKvrPGZV6QWVAOxCAMjQGFKICBilIB0Ni4BQkTkHiFCB25AJlaAydgVOQ2Shi3vFhQdDpAmVA5gagMwwCRL5fMEPf585UR9DpgsJQGWYK5v5Tx92pfa6IdtydesF0KAtgB/mpmaEwVAZhUIbGgBSghdRBIAdDYsgMhaEyCANUo7koFKDgtTBUBmFQhsaALKBKdBDAbVyQGDJDYagMwjBTkFGNcCgXdIZBMB3KgsSQqYJ7YagMwoA2Ov0owlGvEh2JITMUhqkak1UEnV6FODrDMEDQacfkDkGnCzLDtDMD+jvuTl0KhEEZGkNn4BSkgyExZIbCwClIbPSMMpteDHenLkgMmQGZqwCLP+uV4s96pfizjrtTe4YCuI0LEgMKEb85489OqAzCwCkonILCKSiDoB4MiSEzcAoqG4WnyChEeIoT4CkuQOYGIDMUhsowW8jc/um4VXVBY+gMMwVz+6cjsLUXtEQ4lAsqA+ygjcKhXNAYOsMggEO5IDEgBWghcCgXVAZhUIbG0BkGATxFQZV0KEDBwzlc0BkGAdzGBYkBWUCVwG1cUBmEQRkaQ2cYBrg7tc9tpo67UxdkhsJQGYRBrYIFDuWCzjAI4EPm3mPH3alniSJsdYEyNIapem6BddyQehYiwlYXFAZkASnAOOQCZZh25r5OR0DrUkDViIDWBZyCwikonAKMQy4QBmVoDJyCykbhKQQJRdzaBcKgDMjcbMq4/RSR5V0kMWQGtAMBVAZhQCGifnDe5VLQGQaBcgqUU6CcAoqU70KR8l0oUr4LRcr3Mzb1AjYKT1FRiPAUF1QGZA5dBp7igsbQGXBEEx0DQ48LEkNmwDFNNGU4FOwiIFB1QWeAHdQpHMoFiSEzFIbKIAxIAYoKDuWCzjAMEPa6IDFkhsIA1bO5KAYYWPdXOIcLMkNhqAzCgCwMQGPoDIMAB3kvSAyZoTDMFGCbCPeiLlCGxtAZBsF5pDcDEkNmKAxoox3QqUQxlzkBbuOCxDBVY58J4a5XIWLGckFjQBaQAoxDTsA45AIchy4ArkbhahSuRuEUCKdAOAUYh1wwCJQbknJDUk6BslEMPbBnhAtPO0adiqHHCRh6XJAYMkNhqAw4rQWj52m6ExpDZxgE52m6ExJDZoAd1AIcCkaQuP10QWcYBHAo2CZCzOuCzFAYKoMwKANyikZxnrM7wU7G9XYcDIkhMxSGyiAM3QoE0bBnThENuyAxZAbKKaJhFwiDMjSGzjAIMuc0c04z5zRzTjPnNHNOszI0Birrdp7VRYEUzim8ywWVQRg4p4VzWjinhXNaD4bEkBk4p5VzWjmnlXNaOaeVc1q5VQmXtXBZn6d4USDCORVlaAydgXOqnFPlnCrnVLlVKbcq5ValnFPlnCrnVDmnjXPaOKeNW1Xjsm5c1rjRBB8JXL+6YBDgqasLnnbwCnfHJau4sKEjRnaBMrT5mwHoDIMAL+RhwtHOp7+hAHedXFAYOAWDUzA4BfQoeEdc7YJhgLjaBYmhMOhMaAI0hs4wM4eyRsDsgsSQGcqECqgMwqAMSMH8/vTz6W8FJIbMADvIz/n09wnCoAyNoTMMAjy5ieFKPx8FPyEzFIbKIAzK0Ajwdh7G17hcFa8id1yuukAZGkNnGAR4IQ9jZcTGLsgMhaEyCIMyNAakANV4PgoOOB8FPyExZIbCUKmC8TLnBcrQGFBz0yf287VvlOj52vcJlUEYkDk0vsaFiCc3L0gMsIMUnE9/n1AZYAetqnM1dq7GztXYOQWDUzA4BfQoeO/no+AncEMa3JAGp4DeAe/jvBUpAzJDYagMUN0B0yPBBSDO9QLcfXQBsjAAmaEwzCxgwjHOp79PBcrQGDgFiVOQOQX0KHjHba4LCkNl4BRkNgpPgXkJQmAXZIaZOT1/UxmEQRlmC8FwHyGwCwYBHuO8ACkQAOwoQBiUAXYaoDMMgvPp7xMSQ2YoDEgBWsj5KPgJytAYOsMgOB8FPyExTNWI40KgK15F7gh0vQBPbl6QGDJDYZhZQEwWAl0XKENj6AyD4HwU/ITEgBSgGs9HwU+oDMKgDI2hUwXDoZwAh3JBYkDNoW+fr32jRM/Xvk/oDGPBQAgsXuEeCHRFIQ4Eui4QBthRQGPoDLDTJqSDFKTEkBk4BYlTkDgF9Cj4OG9vvaAzDILMKchsFJ5iLhgPhMAuaAydAaoBuFdxbncMBLouqAzIwgnK0BhmFjrq53z6G/8FtzRekBg4BZVTUDkF9Cj4OG98vaAxdAZOgbBReIqOQoSnuEAZZuZmLNtACOyCQQBPccFsITNEbCAEdkFhqAxIAZry+fQ3WuL59DfgfPr7BNhBGz2f/j6hMFQGYVCGxoAUoIWcj4IDzkfBT0gMmaEwVAZhmKoHmgsGGAMFD+dwQWUQBmVoDDMLA1UCtwFI59PfJySGzFAYKoMwIAUV0Bg6wyA4HwU/ITFkq2Dc9LqgMggDai5POF/7PgCJITMUBmROAFSICHRdMAgwDhlIwfn09wmZAXYaoLICYVAGTkHhFBROAT0KPtL5KPgJmaEwcAoqGz3vhkYtnHdDn5AYMgNUd8D0SAmFeN4AfUJnQBamE0Kg64LE8LSDV7hHOm+AhoLzBugThIFToJwC5RTQo+CP8ezBkBgyA6egsVE8MHGgEPECzQl4geaCNAFdBi/QXFAYKoNMQFnjBZoLGkNnQAqQtvPpb7TE8+nvEyoD7KCNnk9/n9AYOsMwyOfT3yckBqSgAwpDZRAGZWgMnWEQ4PW7Gcc1EOiKV5EHAl0XdIZBgNfvLkgMMwszJmsg0HVBZRAGZWgMnWEQnI+CV0BiyAyFoTIIg1oFZ7x+d0FnGAR4k2YGX458vvaNEj1f+z5BGRoDMjcbHwJdr0LEPdAXFAbYQQrOp79PUAbYQasSrkbhalSuRuUUKKdAOQX0KPjI56PgJ3BDUm5IyilobJTenRjnza4XCIMyYPUYTZnenRiZ3p0Y5/2tF2CNeAAqgzDMVWrMF877Wy8FnWEQDE7B4BQMTsH57sQJlUEYlIFTMMgoQmA7BvUIgV1QGWbm5hRunCGwFzSGzjCX4OdEbSAEdkFiyAxIAdKG7RvMjBDouqAzwM5so7iEdUFiyAyFoTIIA1LQAY2hMwwCbBtfkBgyQ2GYqjF9OQNdMRE4A10vyAyFoTIIw8wCpghnoOsFnWEQYNv4gsSQGQoDUoBqxI7NBcrQGDrDIMCOzVnB2LG5IDMUBtRcBnQqUWwbn4Bt4wsSAzKHxte4EBFtckFjgB2kANEmJyDa5ALYQavqXI2dq7FzNXZOQecUdE4Bto0vGASDG9LghjQ4BYONwlPgY3Teu3rBMDjvXb0AqjtgeiQMper52tUJyoAsDEBnGARwG5gvnDeyngrohaxR6YWsUROnIHEKEqeAXsga9Xwh64RBcL6QdQKnILNReAoM6hECu6AzzMxhCneGwF6QGDLDbCGYqCEEdoEwKANSMJsyAl07ZkYIdF2QGWCnASqDMChDY+gMgwAOBTOWMx72gsxQGCqDMChDI5ieYmD6gkDXgYkAAl0XKENj6AyDYLqNcdZ2SwyZoTBUBmFQhsaAFKAa2yDoB0NiyAyFoVIFw6FcoAyNATWHvj0ylegoDJVBGJA5NL5BhYhA1wWJAXYUUBgqA+w0gLKCxtAZOAWJU5A4BSkzFIbKIAycgsRGM1R3AFQPQGGoDMKgDI2hM8xhOGoOIbALEkNmKAyVQRiU4WknITu42OiUE8nTSEUB4D3NCyqDMChDY+gMgwDvaV6QGDgFwikQToFwCoRTIJwC4RQIp0A5BcopwHwHH3qEyS6oDMIwqxqTOUTG4unRgYtaFySG2aQw+UHM7ILKMJvUPCwzEDO7FDSGzsAp6JyCzinAasoFhaEyCAOnoLPROTwZmJMjTHZBYUDmBCAMytAYZn/BhBZhsicgTHZBYkAKGgB2OkAZGgPsDMAggNO5IDFkhsJQGWYK5jmpgWjaBY2hMwyCOYpZkBgyA1RnABTMgkcw7ILEkBkKQ2VAFgSgDI2hMwyCejAkhsyAFKAaa2UQBmVoDJ1hUAXLwZAYMgNqrgIalah0hkGgBwMyh8anXIgYxVygDLCDFGAUc8EgwCgGe1GImb0UNK7GxtXYOAWNU9A4BRjFXNAZuCF1bkidU9DZ6PnyN+r0fPn7hM4wCOZ8ZxQ05fN9b1Tj+b73CcIwszAPTQ0Ewy7oDDML87DMQDDsqQDBsAsyQ2GoDMKgDI2hMwyCxClIbBSeYh7BGoh/XdAYkDkBDAJ4igsSw2whBXYwirmgMggDUtAAsDNbIu6KXZAYYGcACkNlEAZlaAydYaZghi0OxL8uSAyZoTBUBmFQAniKiuYiUICCh3O4QBiUoTF0BmQBVQK3cUFiyAyFoTIIgzIgBahGOJQLBgEcygWJITMUqmA4lAuEQRlQc9OPIpb1KlHMdy4oDJUBmUPj61yIfRDAbVwAO0gBxiEXFAbYQasaXI2Dq3FwNQ5OwaAUIJZ1QWLIDIWhMggDGUUs65gBgAOxrGNGwg3Esi4oDJVBGJShMUxfhdVvXP56AbZ4LkgMmaEwVAZheNpJMwpsnLe8noBrXi9IDMhpBsj8LwJQhsYwK0tQiHAbJ8BtXIAShR1c7HoqwM2uF1QGTkHlFFROQe0Mg0AOhsTAKRA2CociJ3SGQQCHMuM4B2JZF2SGwoDm0gHCoAyNASlAncJtKNoo3MYFhWHaUbQ3uI0LlKExdIZBgHHIBUgBWgi8ywWFoTIIgzI0hk4Ah3I2S7iNs37gNi5oDJ1hGOBq1wXIQgNkhsJQGYRBGRpDZ0AKZjUi5HVBYsgMhaEyiFUwQl4XNIZOgBHKDDweiGU9SxSxrAuEQRmgejY+BLZehYhxyAWZYdrBhh4CWxcIw7SDTTMEti4FnYGrsXIKKqegcgowDrmgMgiDMnAKKhvFjAWbJYhlXVAZhAGZK4DG0BkGwXQox1nb06EsyAyFoTIIgzI0AoxDsIuIkNcFmaEwIKcoEDiUC5ShMfR5Vf5pdBA8HYpBYsgMhaEyCANKFI0cw5UTMFy5IDFkhsKA/KAHw4c8dx7zgVjW8YyifEJiyAxT23Of7AmVYZbbc/foCcrQGGZ+nsFiTxgE8CEXJIbMUBgqA1JQAMrQGDrDIIBDuWDW3AHVcCjPcnuCMCgD7FRAZxgEcDUXJAbkVACFoTIIA3KKFMDVXNAZkAJUI1zNBYlhpmCgTuFqLqgMSIECZgoGKhiuZqDcsIYyUKLwOydgZnQB7KAM4HcuEAZlgB2UAYYrZ1PGcOWCzFAYhOHZnfulbRDMtywWpAnI9nzNYkFhqAzCoAyNoTMMAoxDLigMlUEYUFSoeoxDLugMg2Agp6jGkRgyQ2GoDMKgDI2hG8z41zQDPZ6QGZDTDqgMwqAMyOkAdIZBAFdzQWLIDDOnTQGVQRiUoTF0hkEwr6VfkBgyw8NOOY4DoAyNoTOMCSje+f7ngsSQGZDTAqgMwqAMjaEzDIJ6MJRpNAMqgzAoQ2PoDA876L8zYvYSk4nZxGJiNfFhFV+2GT97ic3EbuJY4tPdXCJyhOwp0l0BjaEzzPJRKIB/uSAxZIbCUBmEQRkaQ2fgFHROQecUdE5B5xR0TkHnFHROQUdbRIceB0NiyAwoUXSAURmEQRkaQ2cYBjNQ1gApaIDMUBgqA1LQAcrQGDrDsKqfF8caJIbMUBgqgzAoA7W3GU/7gAFIDJlh2kkHYNpJCSAMytAYZk5TBgwCeJ4LEsNMQUJCC1KAKimVQRiUoTF0hkFQD4bEkBk4BU+f1JCyp0e6RDXx6RsEYjdxLHF6ogIxmZhNLCZWE8VENbGZ2E0cS1SzpmZNUY5os/BDCRUOP5RR4fM5wAvme4ALEsPUllF584m/I8NO6wyDoB8MiSEzzLLPKLleGYRBGRpDZxgE8DYXIAVos/A2FxSGyoAUoF3A21yAFKB7w9sUFBW8DaDA21yQGDJDYagMwqAMjaEzPFKAMfoMtb3EZOLDNsZeM8j2EquJD6uYDMzA20tsJnYTxxKfHucSk4nZxGJiNdGsZbMGT1KQIPiLUgAorQqoDMKgDNA2K6+g75cGKAyVQRiUoTGg7JHqOgjkYEgMmaEwVAZhQAoE0Bg6wyCYzwsfFdWuiWGmoKJEMYK5oDIIgzI0hs4wCOBTKgoePuWCzFAYKoMwKENjeKQA08IZenuKTx90icnEbGIxEbpRqfAjdfbvAj9yAUZH+DPMii4oDJVBGJShMXSGYVDhLeoAzLKSA1AZhEEZGkNnGAQYm0gCJIbMUBiQggwQBmVoDJ1hEGDUcgFSUABIQQUUhsogDMrQGLrVac1U27UcDIkhMxSGyiAMykBeqGJsckFiyAzIqQDIC1X2QvX0QiegRKEAXuiCxIASxW+E/GCVyiAMnALhFAin4PRCAHihCxJDZuAUKBuFexEUItzLCXAvF0zViqYM93JBYagM046iKcO9XNAYOsNMgaKNYjCjaKMYzFxQGWAHjQ+u5oLG0BkGAZzQBYkBKUALwWDmgsogDMrQGDrDMBD4HXgkgXfRDmgMnWEQwLtckBhmFtoBKAyVQRiUoTF0hkEA79ISIDFkhsJQGYRBrYIF3uWCzjAI4FBkACqVKNzGBcrQGJC52fikciHCbVxQGJAFpADDmguUAYVYAVyNlatRuBqFUyCcAuEUwKFcIAzckIQbknAKlI3CU2A6IloZhEEZkDk05UZzE2mJITOgHSigMggDChH1w7Mj4dmR8OxIeHYkPDsSnh3JOTs6oTIIgzJwCjobhafAwpfAU1xQGaZqbOoIPMUFjaEzTDvY4VFMey5IDJlhpgBbNwqHgp0XhUO5oDPAzmyjCodyQWLIDIWhMggDUiCAxtAZBgEcygWJITMUBqiezUUx2ugdkBgyQ2GoDMIws4BpnsJtXNAZBgHGIRckhsxQGGYKMFtUOJQLlKExdIZBAIdyVjAcygWZoTCgAw5ApxLF0OMEuI0LEgMyh8anXIhwGxc0BmQBKcA45AQ4lAtQiGhVjauxcTU2rsbGKWicgsYpgEO5YBB0bkidG1LnFHQ2Ck+BjS3F0AObRwq3cQKGHhckhsoAbSheOIcLoG0abXAB2F+ZQa6PVYoD0BkGwezoCTsV8y5Yg8xQyM7s6Ou/CIMyNIY5A5MTBgF2ay5IDFQGDeMDZLthfHABlc6MeE3zcvYnID8ZgPwUQGGoDMKgDI2hM6BEZ7OcEa8GiQEpQNoqUoDMVaQAWahIAcq6zjltPf+sMXQCmeWWToAdtIPZtxNWoWdgrIEwKENj6AyDYLqAhMXqGRhrkBmQAtSCIgUoN0UKUDqKFKB0dOYUi6wN+8cXDALs4pwlil2cCyoD7Jy/UQbkFEXVOsMgmC4gYcl2RskaZIaZUwyLZpSsgTAoQ2OYKcC66oyfXTAOhsSQGQpDZRAG2JnNpWOX+DgBv2kAYVAGpLoDOgNSPcutw7tckBhmqrGuOgNjDSqDMChDY+gMMwVY35yBsQaJITMUhsogVDoZdjJgEJSDITHATgEUhsogDLPXw3V27AVf0BkGAfaCL0gMmaEwoEQroDF0hkEgyKkAEkNmKAzP3tgwxJl3wRooQ2PoDIPg6XcMEgNKFJUF73KBMiCnaMraGQZBQ07RrltiQE7RlFthqAwzBVgX7vA7FzSGzjAI4HcuSAwzBRXVCL9zQWUQBmVoDLOsMc+aF8OmhnnwDKZ9ALI912EXVAZhUIbG0BlmnWL9YIbZGiSGzIAUFEBlEAZlaAydYRCkgyExTDtYlRrwSPUEZWgMnWEQwCNdkBhQpzAKj3RBZRCGmVM9oTF0hkEwx0gLEkNmKAyVATmtgM4wCDASwlhsYCR0QWZAThVQGZDTBlCGxoAUdMAggK+6IDFkhsJQGZCCAVCGxtAZBgHGSBegrJFq5Val3KqUW5Vyq1JuVcqtqnGratyqGreqxq2qcatq3Koat6rGrapxq2rcqjq3qs6tqnOr6tyqurWqNCMQH9ub5f886C//5T//gtp/zgVQ9VNqS+pLGpAevyvP36G3yfHg+mTU+3OFGZU+pbKkuiRZki5p2nsmEFU8pXFJqNznIi5Gv1PKS4KNR23jszQlWZIuqS2pL2lcEip2SmlJeUnLRls22rLRlo22bLRlAx+K58IfvgXPsCIMQJ93+GL0+ZQw9JzSTMFzjRaDzimVJdUlyZJ0SW1JfUnjkua9nZeYTMwmFhOriWLiMpUw7JwB9Rhazjh5DCxnWDqcOET87Bl4DgcOEWl8BnajOc07pOC6ISYTs4nT2rzpCC4bopio9rfNxG6iWcOQcv4MA0qI2cRif1tNFBPV/raZ2E00a9XyVi1v1axVy1u1vFWzVi1v1fJWzRo66hTF8iZmTawkxfImZk2sJMXyJmZNrCTF8qZmTa0k1fKmZk2tJNXyht46r29Cd4XYTTRrzUoSXXbe3oo+C7GYiLw9GyK6LUQ1sZkIa882iUEiXpM/TEzrbzE8hFhMNGsYGOJnamIzsdvfjiUOswZnADGbaNaGWRtmbZi1YdaGWRvLGkIKEwLhk4nZxGJ/W00U+wM1sZnY7W/NWjJryawls5bMWjJr8CVz7RO+BGIz0awlswZfMpcL4UsgZhOntTmxgS+Za7rwJRCntbnOCl8CcVqb66XwJXO1FL5krkfCl0DMJsLaM5vwJXM9Db4EIqw9UwZfAhHWnsOb6UvyXFacviTPOeb0JaeYTSxTfKZ3+pI8F9KmL8lzsWz6klNsU3wmcvqSUxxLFFh7Jl2SidlEWHvmosPaM+ldTFQTm4mw9sxbH0sch4nJRHiuZy5GMbGaKCaqic3EbuK4xHJ+Fqc4c/FcekMg2ymKiWrizMVz/Q0BbKc4ljjb+iliWDGeYjaxmFhNFBPVxGZiNxEDiPEYhslzGJaRkGedj0sqx5LSkvKSkOP80KBzYGcDxEb8PHDVlgQrT+cLK3PkDenxu06/q+tvZP3NU0pLyksqS6pLkiXpJaG1zxSOD4ewz5r5TyhPMz5Hl9SW1Jc0Lgk9fEqzQp+RKOjfU5rV+QxIQe+ekiwJNp61BhvPonq2i/9EaaQZNZSXVJZUlyRLgrJnraXPxvGPX/793/7pb//xL//2r//tP/79n//5qeT6h//5l//yX//zL//jb//+z//6H3/5L//6v/7+97/+5X//7e//a/7R//wff/vX+b//8bd/f/zXR0/453/974//fSj8f/7l7//8lP7PX+3Xx+uf4sb0+evnfc9LwWNoGVVR9Lm4MlWUx04RqSh/qMiOinIlogwxBY8+FVSg6SqDx27mUvBwBH8oqK8VpPlsztTwqJn+UoV45fBcZz7LoZWXKryi7LIKovfxsiibU6H52TZRoaVYKh4D4z9U9Lu14WZjmIajv8xGcnSIlqtCHqLp0PyniuTV6fN7fdap5JcqnHbV2lWlj0Vsy4e0sIb5jjY0aHqtwWmaeW4xo0Yfk7+lo37JhtM057XUSMRorxOhTpXOpSpU6aMwrXGrflYf7XV9eK2iHZeveYjjpYrhebzn/v/p8Wp6pSIfd+s0p9t1mvPdOn2G7bzS8Hy55FTxWCG2j0cpOZ6RuYdwZkTSy4w4jTP39fk4XirwXcXQ1ShSeVmj7b7v9nTUnK+M1KzOd3C4n6G8ugiVxmMQ94eO4hVHv2pEDyENJd4wSloNozR52TCK0zzHfB0HOuRgh/FnOoqTjtyO1UtaJofxgzppV2evVdrLOilO+0zzTXPUyWMjhHT0P3U47vMxTOzm+6rQNzH/OdAqbUPr6Hdbh58XPXQlQ2W8zEv1Bp5z2fJ0HDTUeawt/Kkj3W0fbisNukC/PEa1sePgIdPX8qjeB7Yd6wPbqDy+6vA86dxxPMujW2sv/c/2UdXrMetDXzO10286PG+aVwMpz/S/1NG9cWy5vOnz2cjXOjxvmuvquX945B5vIEFXKOm+K5R8t6n7FTuuwqiF3NjXAhWvkWrp6zNZXzcOkfsVK3q7Yt3iGGue9BiWvm6j0jcUx7hfHHrcLw53ELa6/fPJldfJcNqozPBkjMMSfZ6+dVkvHUPLGg0eTjqcVqq60qEtvXaDrlN/DAgvJY9dEx5hf3HI6mjRvHqtlqyvdXhDmBlViYaaqOf/SEezYVCnUfo3HcObCq+vXHv8n5Vq+nOI3JyG2ur6QDXJ8lqH402L9VvyYo9e9KcGz5fObYWzy9Ek8psOZ2gq+fosSDk+0zDWQCzJSw1u6yrlqtXHEtzrFtrUmzvVlRHVD3W0ZpPylj/T0W1i34/XOvw+246++uxj6ealln57+uSmo6W1jPcY5ZbXA8LutNLH9EKu6n3I7Xjxze+3J1Cu5+jDPpOUhm85kfueo+t9z9HbXc/R+33P0cddz+FqCHkOv4XOV6rOFjrkdX8b+W5P8VqXpFzWiCHXz3p9n8+4Iy+9jtdT6+GNO4pNnXjV+zFN/VOH3u1tbirq2sd4DOmOl6lwlyvaaubP53deLlcMb1AqZaw1UvboX3TMwzWvXcdaU6v9DyUjrkTqSonUURwl+f66yTzmcq+1+6XaV/vQnD6rGS2mw60Zb+5z9FUziddvvjZ2NyHdBurkkL8nxPGnqYz1wa5/tNUvOxPH8LarlhMppbfPlESLJPkbHMF2lvJvtrNy2Ibs0T/zADhedy5H1fa6er1tp/l06fJFeYxXLtFLSJI1xy5Op5kHnV5vtzTbpeDx2OP7+acSp7E2XZlpjVdwf6Kk69ok6Mozsa9KvP2ncDvzdm5i7czvvpXGucnped5mw2PcUm0/Th0l1f3oLUfSGlfw1xKR299v1xWt3bCH1D7reWWtFpbHmt3rBp9vb+G7yahr0P5Y5iqvk1HchSlbRCmFW7v+QMl8dAPVcvTDUeKt47a1vvV8ZuTl/CF5+1Hz2u5TBy2gFvlJOpqlg7Y9vqfD9attdZmDF9q+psTrMjktd5Z5kf5bl3F3pB6bpTTlVnnRaZK3JYWn7k8PINVJyXBbybBW8nqSmbxNqehMNXm7UtGp6jy3cm+uOo+x3J2sJm9bKjZb9VWEpqv+91vW6tBjAOx8Nb1dqTRf8jlbCH2tvsaOeLtSxVZDDieQproL/mnFn+RWqfN++fKK5xOP+bwb+t3zDN3LTSXXteZsYSg1Of5Zdsyu5Pbsyncj8zaEa0ZSXrsRb3fqsaNTbU3VWvwYP9DRVg1rE0eHt1Y175I9M0ODzcee7BclTokMc/GPfczqKPHW/XX138firr52Z94Olcja7Rfp9MX6wThRV5zQY6DmjBO9LapHTku1vXoq2C8NXt1V1UINLTspqd52bLJooUFKylclct+lebsIQZembYNL077Fpbkdp6Y1fP5zOvHnYmBy96mibd7bqAq2edmw55a8jabweKTV2+ORJhvGI+4+UWw84qqIjUfajnFiGxvqxdutCtZLTxvqxdutCtaLqyJWL94QALdGoPM/ZkavhwDedtVjXXXNrtpwporuflW0hXgbVvEW0u+3kLGhhYzjdgtxVQRbiHveZX0esgxnMWF4g9Wa2/LsVB7fvt2j3v92e/tFwW+3u2kV/XaP9vvf7nl28ey+VV+PV72Fq8cHlaIAjtJeqsnHBhc/z3ne7cD5uL0UkI8NSwHzIOq9Duyr2ODi8wp6KX+Mm7+4+NmUXjd6C7orHGX2rV76jhayYRCQ0+1BQE4bBgE53R4E+CpiLcSbfrda1j4Nh9uOryUq7p7iWoPn8J0vGtygqBWV8Bj8025R/ZoMdxWg2Uxz6EslfnmkNZ5pSp+Jb+XhOdVm/r11Soh8PbDkfb6PFexBsQ3fVaT7s7vsnZyKzu6ytxwRm9356Yg6kCwbHEjW2w7EO2kTdiDetlXQgbgqQg7Eb2TBtbf5Ebm79pbLjpZa7rfUsqOllh0ttdxvqWVHSy33W2rZ0FK9g6hr44xj9r95VPcMVXC2m+uO9lE3rFPlenudKtcN61S53l6n8lXE2of72dZiARrDayFuKFCxk2mUkm9KvA2rcDPzDlKFm5m3XRVuZt52VbCZSd3QzLyxXbCZuSo2fDCD8/bsbVb9YN6+Y8k864ZzKllvH1TJuuGkStbbR1V8FRtmZSo0lCkvZyHeVlXVNaeqfND/2+hf3UPUK97ssXNN08Mvjczbq8L74ecIkXaJ8/iyCOEdqHoMDlbESuVFiK93JzTXr65osYc4Xi7f+cOIFcqbDo4C+Org3UNV0SUVd6sq2nm9rapw5/U2q4Kd19tnCnfe1m53XldFzMG7Q4C5SnE6+Oa0kH5saCF9xxCg7xgC9PtDgL5jCNDvDwH6/SGA78zs/HClcwnfnFnvG6a77umo2HTX/c4ca3+nHuLM3Ue6/53xTliFvzOjbPjOeLtV4e9M37FiPjacBMzj9lHAPDacBczj9mFAX0Ww83p7KnRgJNPh26/NrBwb1gDKsWENoBy31wDKsWENoBy31wB8FbHK9bt/zDOXY0MQYEm3gwD9dEQbWdrw+S/p9ue/pA2f/5Juf/59FRs8yB+7svrag3hno2S++I28HBSK8CU0w/90D1nXRh5HfTlFLP79flfddroz7FuHcU9XrZhoGRxU8aU48o5mmu8307yjmeb7zTTfb6beeCr8ocsbRjElb9j3L+X2vn8pG/b9S7m97++rCPog71tpF+VIKa/3hkvZcFdFKbqjctv9yu07Knfcr9zxuz03+oGp+Zc/MPOJ1rNeqEy/zg2Lt0sV/MB4u1TBD0zd0Uzr/WZadzTTer+Z1vGrPqgmu2ireK1DdsykZMdMSu7PpGTHTEruz6TkftS/e82wrGuGVV9eHO3diGJ3mlc+K/vtNlpvb+oxCV9jmFT4jLn8QAnv2JXsKHEP/oXuVy/qrvhHLlh3VcRu4y7eOargddzF6/qx+7iLtzUVvWQ9XivNqZVo86jlwzaW1q2Uj3H960O7pflXqoTeZSje3lT0dm8/O6LrRhR1s+PtTbW11fYQqcF/OTngK+l5BXT2Ohwler/zejtLwc7rqQh2Xu8cVbTzentTwc7r7UyFO2+4VpzO6zaPsYKX2+A7z782D3drKvZKQvG2lYJ16x2jCtdtu1+33kHq6DXhrpLorfreEajwtfrj/r3pvg9a9/S2Pj50ZD0NcyDt9Rno4p6jkmpX/9D21tfLbnznbrdBl9GcQdXY4FLHfZc67rvUcd+l1uO2S63HDpc6NrhUv3msuwceedaXzaMe9XbzqIfcbR6uiljzqO7xqWjz6Pebx7jfPOK18nHzsHnycfTPhsvVTh08Euy0MW9XKvhqVk0b2mm6307T/XaaNrTTdL+dph3tNN1vp29ax90VjMee2tJwyOuX3aq3J6V5HdDTWl5/9qu3KzXSimznEdnXr/6b8mhWHv3DMo29SFbds1P1sC16Oiv0TUe/32vdTalYr/VUBHttuf82Wi23H0er3rGpcK8N14rTa93WYZfkZl6G/ZEOWYuGWcrLJ9JqceNI122fMnR8qGNdv+Tq8HtLaGpa/Yv+Qi293n4EsFY3vD/0eF51b/mLvJ7npyLY3+rtByartxulaS1baKJq/dbf4kr0QyV1HUTRStPj70rG7Xpx82LP2KT+aV7yamL66PmfKlndRfP4tGrKuqBT+W7cb0q8DanR14rB4Jb2dQ3FVxJczfGVpLUwPR4V9aGSvMb8g7dhfqYkuK5UvWNT0XWl6k1hgo+Uueloa6tvNM2v0xFXMj5VstziQ5TPlKTHeNnGqUf31LhVvHYvR6Vp3Q8bm12BnEU/VbJOlD6UOB0w/gV/PUt1n6Oy9cfmzOzc0X/o2djqbU+FJ+2uknKsbeGSu6MkdillbtXJzYaZf7s/82/3Z/5tw8y/3Z/5tx0z/7Zh5u+3DjXP3OtHOsq8zfDMzGif6jhu6yg2tCr0+f6ZDrVXJfprHV3vz4d8HbH5kJuXao2sar+v48M2VvL6SJXaX9ete2hKlV5O83qdl5Amq4E8PhOvE1LuV66vY0PltmR5cTquuwNyrFCw9OcFDj8qVDuK1p1WNm7fnl7d2/2GPfQxmjMV8dJR19ph1eIUh/vNXtEgtfD+55dvtnhHpoLrfuKdmAp+s+Wod7/ZrorYN1uO+3v9ctze65ej3/9mx2ulObWSb6/7+Tpi637iX8kXcmNvWnpozU7S/Vaa7rfSpLfX7MTdl4qsDfmpCPYVb1sq2Fe8g1LR5RhfSXBK6SsJzpB9JcGFIV9JcGHoTZnEFobelEnw7Xpvrh5/vL7fXRjy0xFcGPqBkvGpktjCkKskvjD0pp3E1nR+4JxfDu3EPTcVWo5xR1S12qgslQ+XUqq9qlGdpRRxH7UKxhyLd+YpGnPsZ2es17UkHa/D9KVuCKGWmn85O49hxlpxS9XLTv3NliZ1jd1FhjrJcE/6rLkMPdKXv5w1FO/oVNAruqlYkRQ8k/meCu/l07SGmTXzPfRxFenoxW6Q6nJ8pmSsaftD5vCUHymxh60Th+r9pFCbPXnuVK23TL5BxWPWPuwL0dPLrPhKgjXjKwnWzBsloZrxe67SVKSP1z3X26WKvhUqejuE2k/HWIds0vhj76D+REml9ZDyoZLW7clwngt8UyIbPjPuY1TBz4ybnejLluI+R6XtWFN4bWm8rGJfSeh5THGv+As+jynuOarg85jSNhxMlR3PUcn956hkx3NUcv85Krn/HJXfQoIvH4q3VxV8+dDXEXv5UPqG29fFu+Evevu6eDf8RS89Eu8gVezSI79Ego8eiPsgVTgz7X5mNlzxKX3D7Skybt+eImPD7Skybt+e4quI+ZAdD5bJkB31ovfrpe2ol36/Xvqv+vbok3Z6bLjkX3dc8Kc7LvjT+xf86Y4L/vT+BX96/4I///MQvH1djy2vpmna8Gqapg2vpmm6/Wqapg2vpmm6/Wqar2KDFwm+mqZpw6tpmvqOFrLh+6/59vdf84bvv+bb339fRbCFuEUaejVN891X0zRveDVN84ZX0/zyiL2apnnDq2labr+apmXDBEJ3vEWl99+i0h1vUemOt6j0/ltUuuMtKr3/FpXef4vKb2TBebvWDa+mad3RUuv9lrrjVSytO1pqvd9S646WWu+31Lqhpd5+NU1lx4Rqxz1/uuOeP71/z5/uuOdP79/zp/fv+fM/28FX01Q2vJqmuuHVNNUNT6aobriMWvX2ZdTzkafbzUxvX0btq9jwwYzO23XLq2mqG+7V17bh1TRtt19N07bh1TRtt19N81VsmJXFXk3TtuHVNG33X03TtuHVNG0bXk3TvuHVNH8YEXs1TfuGV9N0x5aK9g2vpmm//Wqa9g2vpmm//WqaryLm4GXDq2k6NryapmPHEGDsGAKM+0OAsWMIMO4PAcb9IUDb8Gqajg2vpum4/Wqa/50JvprWjvuvprVjw6tp7djwalo7Nrya5tdvsPO2Y8Nd/+24fdd/Ozbc9d+O23f9+yqCnXfDq2ktbVgDaGnDGkBLt9cAWtqwBtDS7TUAX0Woct90/5hnbmnDq2kt3341zU9HtJHteI6q3X+Oqu14jqrdf46qZfldDxJ81Kbl+6+m+Z/u4Ktprdx+Na2V26+mtbKjmZb7zbTsaKblfjMtct8Xbng1rZUdo5iyYd+/1dv7/q1u2Pdv9fa+v68i6IM2vJrW6oZX09qO56ja/eeo2o7nqNr956ja/eeo/J4b/cBI/uUPTPDVtCa3X01rcvvVtCY7mqncb6ayo5nK/WYq41d9UPTVtKY7ZlK6Yyal92dSumMmpfdnUno/PNW9176tDar6+LjTB+YHJ9SqnQurjzp6qaR5+1PRE2rN3Z/acRD6UZhplWvzbvxzlVjllFo/VGINXuUYHyopq/8+9qteP43V/KePorXTfrt2ZAUhPTbWvey8CaheUQQy0qujf++UrAOvD5miqr4o8eLDVdcR0ccS4etT983bqKrZLlb4I4D4y539zduoSmN9wfORXt4Q17x9qtgdYs3bpcp5nVLLudWXq7Ktu5eqDQvufMh8tfJP1KRqB3gfXaC9VOM22VZWlh6zUqfJeqeqgleItuH62NB1ZM3frYpc9OSqiF301LydquAVS83bqopdsdS8XabodWTxWnl9Hdmb1hG6QtTVEbxC9J2O47aO2A2R3dup+uNaNPmsTINXmb7REbrKtB/uCZPQbZdvdISuifPzUteZ+8e0Lr1OR/vtdISuVI3r+LDPBa9U7WnDlapvGnuwgaRfrpjYdajd26WKXof6JiGh61C7d54qNpTp3mmq6HWobjpi16G+HagqDVTri4Fq905TRUe7rpLYdUb+MLWt9e6H+Lqx5/tXqfd8+yp1V0VsHNTz/avUe759lXrPG65Sj9eK55PdScz6ZqcxXo8dSt7gCr1ZTDC2xFdii2YPMX2mJB12QU1151NeSqTYJYT6+aSM7swaQz+elFkU0mOCJo4aL0tlWLkk/bBc5jsHp5I/rlgt8Ulz0MN3fzp0mBvoH3WdxxrCarLJ+XrX2/P/7u1WhT+adUORulW7rjJ81HL5sMmnw254e+zlfbwOkYRGRe3jnpPyQYMrp+e4r0uvB8zpPMOXS2be3Lu19qye9269urGueyeropd3uUqCtyu6Z/ejd6I191HFZEtv5dP7v4LxTN3btxIta1tCaWT0pXrdq7soJjrTPaI/u/+rrfOqj4Wv1/sj3b8GcIOSpLbyrbQb8DMlba3BPxZZsqPEPQSwOl7Vz1SMdRUZD+B/pCIdtLKq4ijxJjVV7SbgQVss4wdlOuwKwJG9dubtj9rlbNL7h/eqqd2rpjTb/KKj+zs96/k9Gl7l9PXuLu9WtWzXZ+f6+qhZb+V+/3fvVUh0sULitfev9167F+eULLZy9vpgVHfjZ2LZ8W9Vs0eVhd3qD1RoXjEamutnKkIZGW2DX3aVRF2qe65qh5KwX3aVRP1yl9t+2VMR9Mv+PC/ol3u/75fdMg36Zf/4bbT3j3S307y5EiXS+30Vod7/RkUsIxt6v68k2nHHbysJ935XSbD3j+O42/tdFbHe76qI9v7hHauI9n63TMO93ztVoXSROE3f85e8uHfvrxXJyg8af7urSjZMqcZxe0rlX98R7byyYUo1UvplJdHO6yuJdt50e0rlqgh23rRhSjXS/SmVX6Y7Ou9Yj5oNeX2zynBPVSU7VZXpEa5vnXfHBdHDvbsv1nndM/PRzusqifa7LL+sJNx5XSXRzuvtWwU7r6ci2Hk9FeHOW9L9zuuWabTzevHiedhGz+j5dff1TlfVYz08V/94Saj+5GKkaPctt+f//p1G0e7rKon2vDJ+WUm4+7pKot3XvYAv1n09FcHu66kId19vzyrafd0y3dF9H/vw65LXNF5fajK8I1a1r8sV6qBnSb9137Gj+8pxu/uOHd137Oi+Un5ZSbj7ukqi3dc/aRXqvp6KYPcV3dB9vV4T7b5umUa7r3uPV1mbiak02o34cwV/eCet6gqPqnwSQFtchaydbw7D+ZmKFRchfLXyT1TMNxOwJULXxHysQj5UofZmzodloass9NOyaCsj7dOyYBUflgU/7vhhWbRVFu3TsugrI/3TsmAVH5ZFXy6jt09TsS5C7/3DVMw1QXjQT8uCVXyaivVA3XBcjn/nXzDUzVcSPDo0/H2lYR9H8ZR4K6na/oET/nqS2c9MMD7NVRIN/vNTEgz+e3OFWWgjxVUR20jxVUQGlP4dWcEBpa8kOhYc+ZeVhAeUY8M26hi3t1FdFcEB5diwjTrG/W1Uv0yDA0r/ArPgLOzhJ27vo/qXj0V7TdqwfvnITf1tLdF+80ZLsOM8tLS7PcfXEes6vo5o30mH90pVsPO8KdjwdMy9AcwOIuZB+flyQcsjP951VcluEk/88o5+VeI2FDr1QkWb2lclTv/Rut4QlfKhinW8Qnv/VMW6CeR4mYo3l6qt4BA5/phGfE2GN+mXdUasat2iZLxSEr5nrhyH08q8japU7b3qWvrr7HgXAOqxDjVponjo70q8pvpo5OuYR5Kjb1HDNz3oT1ZUhhWLc2Ote++drWWM9HIw/8hNvzsh8O+si35Cy5aPX0m/rSX+CS1pxye01Puf0FLvf0JL3fEJLfdjAd4UbPgT6m3AHeUfu+ovcXzpcC8FrHZ3dX7Vh9NR3ZuB1okgfnT+6z0N7j164cF0vR3L59+BF/UEte/ow1V/W0vcE7hawp6gjvuewNMR9QSejrgnkLzBE7gFG/QEbwplDVBG/rhg1y0no8n9ynF0+H2nrGcfH79LHyrJdod9ObxS3bB35StJqdi5wNo/TEpKq3ZS6vKpFhqxlfFxWsROOgodhvmpFrUT6X18nCPrPiV7OVK975dU7/sl1R1+SX+92ZY1oU1F2qeFEvRLro6gXwpWjqvDHYIG8+LqCOYlOBT2fKw7U4n6WH/OFPWxbUdjbVt8bNviY9sWH9u2+Ni2xce2LT62b/CxfYOP7Vt8bP/1Zhv2sX2Dj+0bfGzf4GPdlfJgXlwdwbwEV+w9H+tuqER9rL+1E/WxY0djHVt87NjiY8cWHzu2+NixxceOHT42Hfd9rKsj6GNdHWEfm45fb7ZRH+sXSswv+TpifilaOU0+24SPZcVXEcpJNJrAc7DHjoWCY8dCQUobWqqrJOxg32gJOlhfS9TB+lqiDvaNlqCDfZOjqIPNGxxs3uBg8xYHm3+92YYdbN7gYPMGB5tvO9g3cXDrdPRjE+Llg6K+Crt0lu+s+UlgYfCKtTdKYlfw+ScRYh8cuV2z0fMQbsVuWDV5c2Ym+sGpZUPP9ZTEPzi+lugHx9US/uC4WsIfHF9L9IPj5yj6wZHj/gdHjvsfHNlwB8ZDy6832/AHxy2U4AfH1RH84AQrx3Nt7knNmIN1VcQcbPC8qOdgdYeD1S0OVne0VN3iYHWLg9UtDla3OFjd4mB1i4NtGxxs2+Bg2xYH23692YYdbNvgYNsGB9vuO1j3JouYg3VVxBxs8D4Nz8G6N51EHax/50rUwfYdLbVvcbB9i4PtWxxs3+Jg+xYH27c42LHBwY4NDnZscbDj15tt2MGODQ52bHCw476DTbdDK3wVMQebbgdW+PfARR2s7Nj0yxsuHPSVhB3sGy1BB+triTpYX0vUwb7REnSwb3IUdLA53Xewro6gg3V1hB1sTr/ebKMO1i+UmIP1dcQcbLRyPNd23M6KryLmYI/bGfFvyY06WP++3qiDzTtaat7iYPMWB5u3ONi8xcHmLQ42b3GwZYODLRscbNniYMuvN9uwgy0bHGzZ4GDLBr9Ubm/6+SpCm37ei3UlrTeiSuHDofVr5XrHuQJvEPkX7oeq1VcRqtXotf+OCv9BhuDH5s3TENGPTd1w6tBVEv/Y+FqiH5vadnxsXC3hj42vJfqx8XMU/djI/cOyro7ox0Z2HJbN8uvNNvyxkfvHN3wdwY+N3F5lePNgTeRj80ZF5GPz5mmmdeuUKj3lOb7Wrbo3Xud13vYh00UgXx80eujxAqL6uhY5jcRPAcqXQvEe8g4+R+SpCD5H5KqIPUfk3SGQo88R7biIILf821rCh5h9LdFDzLnJfQ/d5L6HbrLDQ7e+wUO3Hc8SuetY0SsAcr//LpG3BBW+1jiVHe2+19/WEu89fcd9Wrnfv0/L1RHtPX3HfVp5bLhPyy/YaO/xJm3RFwof+bn/GFa9/6pXvf+qV92QkR2vetW2owOP8dta4m5gbHif4DEduv1Aga8j6AZcHWE3UA7Z4AbGjkcKvLP/4Y9o2fCsljvui/aeLYPHsuNdLV9LuPeUHS9rPbTcXyQo99/W8nXEe8+G17XeFGz0SlfvMtbgGwGPP3PHBJFHAnwdsVcC3ugIPRPg64i9ExDXIZ/qCL0U8EZH6KkAX0fsrYC4jk/LI/ZawBsdoecCfB2x9wLiOj4tj9iLAW90hJ4M8HXE3gyI6/g4HaFXA5p/lXPs1QBfSfDVgMcSr7fxGXw24KHFewcudk2om53guwGukui7AX5Kgu8GNPcLEZqq+SpCU7U3KkKXNuYd17fmHWstRY7f1hIfbLpawoNN79BWdLDp6YgONt1XoMKDTe8caHiw6RZsdLBZ+o6pmtx/daNu2C3wlYTbvebf1hLvPbpjt6Do/d0CV0e09+iO3YKiG3YL/IINT9UcJeH3A0rzbi4Ovh9Q/G2l2PsBxTu5FXs/wFcRej/gjYrI+wHepbjR9wOKd7N89P2AHyh5+X7Am1YWfD+guC9FBd8PKN7GVvT9gOI+wBV+P+Anal6/H/BmtSX2foB3ViL4fkDxDrQFJway49Zw2XFreOnjt7XEP6F9y17B2LBXMDbsFYwtewVjw16BX7A73g+oqSwHmbS83jIs3ntcsfcDirfzEXw/QHc8xlU3PMalOx7j0h2PcdUtj3HVLY9x1S2PcdUNj3HVDY9x1S2PcdUdj3HVHY9xiXdGPvdVKOWoNPBL9Wt+vAl6X/4kdQovrn8G8umxpR9716YG9y+PDf3YVxLugan/tpZ4P3a1hPtxTvf7sacj2o89HfF+7C0chvuxW7DhELodS0o1t9u9J29YUvKVhNt9OX5bS7z3lB0LsrXcX5B1dUR7T9mxIFvLhgVZv2B3fAUfM3xdk30Kq//6FXSV1MO2/w/Nzqe0/roW7bIWlXqzDOlPdIy1W6Ujtw912OLWkNc63AYbO77h64gd34h2HO+soOvXomeYfQ8bPFZW64YbYF0l4WNlb7QEj5X5WqLHynwt0WNlb7QEj5W9yVHwWFmV+xcX1+AVqvJpOuLfDPn1Zhs9Vlbv3277RkfQL92/3/bNkDqYF1dHMC/Bob3nY48dF/EcOy7iqTue43KVxH2sbvGxusXH6hYfq1t8rG7xsW2Dj20bfGzb4mPbrzfbsI9tG3xs2+Bj2wYfu+GFo7rhhaO64YUj3fHCkW7xsTue43KVxH1s3+Jj+xYf27f42L7Fx/YtPnZs8LFjg48dW3zs+PVmG/axY4OPHRt87LjvY/3N3lhefB2xvEQ3nT0fKzseOZIdjxzJjue4XCVhH/tGS9DH+lqiPtbXEvWxb7QEfeybHAV9rKT7PtbVEfSxro6wj5X068026mP9Qon5JV9HzC9FK8f1bSr3fazKfR8bjI11X5zfsB77Jog66mN3vMjlKon72LzFx+YtPjZv8bF5i4/NW3xs2eBjywYfW7b42PLrzTbsY8sGH1s2+NiywcfK/T0vX0fQx8rtPS//cFXUx+YdT/vIjj0v2bLnJVv2vGTLnpds2fOSLXtesmXPSzbsecmGPS/Zsucl8uvNNuxjN+x5yYY9L7m/5/Xm8GnkKsU3KiJXKfqneYOPdb5REnus8821IMFvzv23OMLXk3h7gO7tMdE9QP8em+g3Z8e7XK6S+Den7bgr3tcS/ua0HXfFv9ES/ea0HXfFS79/V7yrI/rN6Tvuipf+6802/M3p9++K93UEvznBynF927FhffrYsD593F6f9u+3i/rYuuOKdNnxNJerJO5jxxYfO7b42LHFx44tPnbs8LF63Pexetz3sa6OsI/V49ebbdTH6v1Xgt7oiPkl3fBOUL3/Hke9/R7Hm5tqg5fO9/vRHtEbc70SdS80jnp6/2rloKfXtOEIrask7OnfaAl6el9L1NP7WqKe/o2WoKd/k6Oop8/3T367OqKePu84+a3515tt2NPn+yNQX0fQ0+fbI9A3d+kHfWy7vxMZvdPffXBow07km8cfoj627GisZYuPLVt8bNniY8sWH1u2+NiyxcfWDT62bvCxdYuPrb/ebMM+tm7wsXWDj623feybJ2liDw7Vu6PprreXpn0VsXfl9P77TW1D4LSvJOzmdzzQ5SqJu3nZ8a6cryXs5mXHu3JvtETdvOx4V071/pXxGmz68mk64m5ef73Zht38fa/0RkfQzW/wS/6bf8MuWn5eU7zU6A+UPH44TAmVyZfj3tr8pPSDkvKZlpqeN1ehmeT06uC5v2MeLRM/ziNcJn1LmfTbZeJdEDKG2PXinYYDWn6ixBrs6Pm1Ev8KimPdHfaQ6avxIzWxixJ8FaF7Et6oiFyT4B6MjtbMGyWxmqn+fbPRmnHVxGrGVxGqmTcqQjVTnVgVLfYMRqGuW/QnSvK60vShpL1UUtw35eq65iTXZCNx/fLepnq3GOJc0zm0oTuCvivxArTWjaa9WDoeu8k/0NHXKwVdk6fDOx9zrGezc6K6qd8y4/Sarpdb7RR88y0hzdv4KGnNs8qjWF/W7w/qpr2sG7+RlPWV+OOlgx/pkLwugXo4vpdtxI1qkmHzxkGvzP5QybqZzlNSvPfEY421dKedDXukdvQ/IrTyD5Tksrxzlk+V2Cxp8I3EP1OS1F4q6fJpdtb1XI+c5ddKvGcYR7PHD5u+/mL9QMn4VMmwofx4/dF7UybVykTUKVjXzXd7IYQm5d86jvc0F78z9NIvFm8I3kZbV4oPdozlq2NM7kXCdMV6dbxAPu5/s5p7dWHsm+XqCH6zWi73v1luQH30m+XtaoW/WfG6aU7duK1krBvw02PW5lRwv/2teJeStdySD55kfVXiXWpXVg3Xw6ud4t5wGXtsyE/JvGwVKaF7or+nxCuSR4M9rMH2z8o1p7SGJalXp1xlQ7l6Mf1D+mpqLTmt3t1kC5Wr6197WlHfPfXy0r/6X63gtPGNkti00VUSnzam5u8m7dETvELR1xG7QvGNjtAViu4xhWZ7OP21hx33Z46t9g1fYW9BLfoV9nREv8KSNnyFvSdTol9h74he/Cscrpv2WRuJTRxdFdF5o7e4H543+kpCYwH/lc1IS/VGetFZo6sjOFVzdURnannDRC2sY3yoIzhN2/KJcUs1OhPPG9YV8oZlhfzLeYkuKuT7LdXz7NGWGtcxPtQRa6mSdrRUv1RjqxL+CCK4KOHdTBhalPC2nuqx2vpjRMMXfX8dGnoPcpW8vnSl8GjoJzrKihAopb8eGrqHtEIbel55lGG76QcV6T8oD3fZ2a7Il0S9/xhftTgTq6LrCfaifBT2ixb3FpVQiXgTXnvV9rHlYpvpX8rD1bBGl/yA3VcN/nUlK0ooCd9p/+UOeFdHzTagy+WljtTch69G7rpmu3mMVyXqTZjbmmI+FkcoYuPRUsI6HsVwUHZoPJWPr/mR+z3X1RHsuaPdbqfeyTl7xP0h9lca+u2W3u+29NLut3RXR7Sld+8wVrSle68dPNromgFles8spx/oEHt8XeS1Dr+3tLbim6RT5Mq33tK9m2KDvcXXEest/bjv1eMlksrLEqnVnWoPm2pbeeSPdfT7Omj58JsOb+c7rZnD42c0pus1riNrXTq0fahjBTbkosdrHW47LfYicNEPddjoI5d2Xwe9ffRVhxfMp8faNdODHzb9okPG/bp1dQTr1tcRq1vvBtPHMhaNCtMGHfKhjrXD9BDbZzqaLdU1yZ/p6Gsz5bGb8WF5tLb8eqO9lM919A/zclzto/T0Yfvo68myx88+rNteu+kYn6ZjtY+un9bteiTsIY4P+1yzMYhXt+5K7rHWtgt9K3+o4zAd9b6OXD71QXZYIvcP01GsPGTcT4fnC2WDX5cNfl02+PW6wa/XDX69bvDrdYNfr/f9uvcUshx97XwcQz8af0gZV3k8RGcc5I5P1xim8M50/jb78EokusPWxZ2sr+DbRydWLyleuKq0S0uTQYsP/asSdybUbSbE233tqxJvuGyBLg/nmB0lbqGIPXfYmlcorpZhRTte17I7L9O0Kjlpdmeq/iPgkWg1PyFLxTMh3UtIdRft13J7GlQ9X3qge8IprXfVa3qdEE+H2MPqwjX8VYf35o2oeRPt+pkOi4Z6bsu+1OFXTS3rYJ/W+rGW1f0e8nhdJv326nC/vTrcvTXZ1Okw0DhehqZ0L3popLU9/dhta5/pyGucOHLuH60Nl3WI7iHTmPdHddsoeqFJGk7n9Q5IRde7XB3B9a5+/Op6158lkj8v125ayoc9r9mS5kOm8eL32vHCmqO14+qI1o7+bu38USLt+Lh2GmlJL7V4Ozwxj+ZqiO0CeDl5LMiu8N2eHN+cupeS2J6Ir+PhFu1r05RW4H+mpa0gpIes6VMt5ukbr7L8oK31bEOSXpw+7B4s6nVNGx/y6B9pecwbV3gXH2LLX0avYR0pf6ZDVrxqFqqbn+h4pD+vgTjPcb6OxN1TX8Etb1eJPDbRrjFW7hzT8BMlZQXOSKFI1W9KxnF/e9XXEXPR47i9vfqmQNYcVmoSr0CGt5q/wgj1oJWj71rcAN61LKi0Svp18vkmIXZ+lCfTP8yOXffxmC+lj7WsDVvlQK8fa+lLC00/vzd7b8WkrtVjqa6ScvcT6qsIfUPdrES30n0l0b304R7pCe6lJ3fT91hx7/XPrtO+JiXf90iujqBHyrfvo/BOGT/80VpuaZn7Xo/rUFv4abm81PHIixtwEQz3Grlv+PZ5SjStfkMjm+8JKceO7HjHrcLZcZOSlpdOvIGc0te25t0mUWyJkFxa0x+kY54yP0d7PGH7mo6yIXbMVTLs8rDxxzbBVwftK1nFOtoxPlZSlhLejPqmxL21pC4nzfGnz3H5n0q84euxPjj5oc9R4kaOr0/56Byr8KMy6Vawg9ZMvykZtfy2lj8OCHIQyNdS8bVYKEnONPn7B1rUX6KzFbr8qRZbYE+Pr+GnWuo6ZPRwb+Jp2fAGkV+4Rdf8/LH3/zop4g5RYieV5P6ITe6P2GTHiE22jNjch6qivnpUd0EqdFR/yIZDgkPuHxJ0dQQPCc4A+rtbmEPvHxIcuuOQYLxuvEOCXiMJntQf6m4rxU7qe9cHZV0++iHSoODr+XhXSbNo3Ufr/0xJ+KS+m5J5wdi1puUp8Ub2x7CB30Pmy6p+oibVat+/ylEmP1STqqmpzklut2TKsOJN+mHxRp9YG7cP/bvdJ3qXgqsjeJXC8I5iBa9SGO5TVdGrFNyUREvVrd3YK3xvmutR6L5IHpj/rNUnK5XHYsfHfTDZiZn0p8//yTBH1kiJA81/NlJaq33kl76peDMUXulIpX08oK7rfMZj2JR2DMs9Lf7MaQ2FR6cAje9znrFhdWtsWN0a9Xd1BNfs/UJdreRRvuoV6v3NA1dHmjeio43o4bVXV4uuTZmkZXyqpYttrsrHaRnrAE0+jvShlvDShZ8WC/dKrb/O0SOh9f4k/Y2W4CT9jZbgJP2hZcPd2G8K12I+ekofF0vMYb8rlpjD/kEVeQ7be30nttKcD+8NrOhK80NL3bDSnJypXJM1KG6aeD9Q4kp6qusGqpLrh0pk1XGXP/YkvtZxuh+65Sdk3cXehWMmvyXE2/uKJeSNjtDnNB/eplXwK+Ylo+u6jafz2x/fqte78TC41OaqiC21uTuS0aU2/6bC2FLbo2L6hqW22m4vteWj3L8V86Hk9q2Yvo7YUls+yv1bMfMMyLi31JaPsuFWzB/UjbPU5jaS2FLbIyEbLsX0Ng/CS22ukuhSm/+mQ3CpzU1JdKlNji1Lba6a+FLbGzXRpbY6Niy1uUqiS221314Uct+mDi61uTpiS2358C5xii21PXTk+0ttfkqipTo2LLX5zTW81OarCS+1vVETXWpzhzmxpTZ/pBRaajv0/jzH2/aKz3O8fa94cKy3TJ3X0d3y8Ns0hm0/UNJWKFoZfEbtq5KU7n/R0+1gfV9FbDDt5iQ6mPaLIzqYbjsiDbM7LadY/dReV2929zXtINOoPKGuP1FSyUuXD5W0bvdt8TD2e8nKjj7cNtzpltwLnrTZG1ra0utK9paX21pmeHx2xmdFWy07j9GjV7T92FG0fUfAofuWgK77ELOqOk3fUyLry5W11ZdKHvmpW0pFNpSKuoE5dm/3Q06vXn5L2neMzLO/pGuHgRtfnle+loo7d7JqbtWZCY4dywVjw3LB2LBcMHYsF4wNywVjy3LBuL9c8K6VrAXQ3LzJiqekpGZ3k432sZLjvpImFjCvrxt9OlJw+UM+LNhCEdmPAeSnStQWlvvhZOf+m1rvlATvRnezU9c3vfCmzPeUtF9PifXAxzbcBiWfdsDH3kFbSvrrZu8PrNVufG7ZcUtv2n20oaTfrp6WrBs7XsndvXu0Iproi+Or/aQMu6/MaSkptdurOe5WVXg1x01JcDXnzUipqI2U5OV+l7tskaihPLX0j7QEd7zcp0uD2yr+/Cs4Tkr59puDvo7gOCnldn+c5J7SCo6TUh4bxknxunEWYdxGEtxWcUOVotsq3iU/4W0VV0l0W0Xbhm0VNyXRbRXtW7ZV3kzeovshbpai+yGukuh+iOp9Xy/390NcHcH9kOReLxf8glbZ8QWt9X6ptg37IX5zDe+H+GrC+yFv1ET3Q94s+9lhSX19h0r2z0c9VoE6aZGPtESDU3ecdy7uU4rJXpcsTtiwd8V80zXNaC2/DpN9FIk391K7OkE5rPRLQqKHLekM6uOff6CkrSDZxzLX8VJJns8L/a6Whws+rK31T7W0ZuGtI3tanHJp6+a9xhs9P9JB7zpK/1BHmmFq5weZut8/0KLuOmgktPVNwQ7bRxjZaW/etZfSV6FIp3WYMeI6VJPt9dJEcnzNTTtub/aK+9y0PVOVaT+jZvmakHzbE4g78UrWSh4yfwe/nut1r1jNYmtkvH92fM2P3M5P81Y+ZL2X+ZgC6kcqbLP3IdbPVIQy4u0yhV20qyTsXH9fS9xFu1rCLtrb8oq6aE9H1EW7W29hF93bBhftFmzQReecdriBcdztPdnbGY25AV9FyA28URHLSLvvBnwl4Q7sH7neoSXuBlwtYTfg3coUdQOejqgbGGODG8jeFWJhN+AWbNgNuB3YltgoHZK/qvCObJe17Fj/uEi7fslOzRsmXPm4PeHKVTZ0Y1dJtAPmdPy2lnA39rVEu3FO9ydcro5gN3Z1xLtx2jDh8gt2Rzce6xTSHzfIf+vG3uuzktZtrZLp9Oq3btzKjm6cbw/KsxdVF+7Gbcd3NHsbKnu0xLuxH/gY7cbeKCXajT0d0W7s3rIY7sbeOaJwN34T2xrrxm7g/7DtnUGHtr93ZO+YVz3WE0iPHZr8uiN7xxjiHbncXibI7hM30Y4sW7qgtzy9R0u8I7tawh25pvsd2dMR7cg17ejI7lZTtCO7BbujIz924teRijSS05G9k1G1r+dY6sMzvO7IfUtH9jIU7Mh9R0fuWzqy5N/WEu/Iknd0ZG9xONqRPR3RjuwuUoc7srfmHu7I/nG+YEd2ozbK2pF8bMTSTsaXxf/snfWqK2KqUgU/2swPdMjaAueYnB/qWEESwm9V/UiHrhu2/7hn/2Md8qmOVR76cXnoKg/9uDzsxvH2cXmwjk/Lg193+7Q87GmY9nF59JWX/nF5sI5Py6MvD9Lbx+lol0Ps/dN0jPU86/i4PFjHx+lYB96G54OauxwVC4PzleS1rfuY2r2OYMvZ36Ea9tEUV4u3DGvnhv6426r+IDvB6DVXSTQ00E9JMDQwe9Hbwc0YV0VsM6bfH2yOvmGwObbM90b6bS3xwebYsSebx/09WVdHdLA5duzJ5rFhT9Yv2OBgsxw79kDKcXtPthwb9kB8JdF2X47y21rCvcfXEu09xbs9Ith7XB3B3uPqCPeectx/9OBNwYanau71dnaWMQ/Kz/jyPS/e3Q8lrTsKHos4PNr6qsRtKHRGhor262Hv4t1hqOtCDeVLOX6kYp3CUHoY8Ycqro7TjpepKN5BLDmyvbj+x7ziazK8FQFZx8oqX8pxQ8l4qcRvZWuYVR5u2Gll7mmuajdh1NJfZ8e7vlCPdQBKE9/J8U2J11T5Zo8kR9+ihu5E/Va47mqLvdZaqd98WW1xi5YWOUZ6Pagv7o0CoYlByRtWO8uWncNSjt/WEv+Elh1hBKXcDyNwdUQ/oWVHGEEpG8II/IINf0K9N0OO8o9d9degwFLcc96r99C13l9XTEt1H31dh4Yyr5p8edPX23qMD6br7bjtUjZMRcuWrceyJSzJ1RL3BK6WsCfw7jCMegJPR9QT1L7DE7h3B0Y9gX9sL+gJ/EJZA5SRPy7YdVfKaHK/chwdft8p6y62x+/Sh0ry2ot96PNKdcfGlqsk2QvDj2FX/zApKa3aSfzC8A+10IitjI/TInYYUuiMzU+1qB1cp7PeP82RdZ+SvRzp/f1YV0fUL+mO/diiv95sy5rQpiLt00IJ+iVXR9AvBSvH1eEOQYN5cXUE8xIcCns+1p2pRH2sP2eK+ti2o7G2LT62bfGxbYuPbVt8bNviY9sWH9s3+Ni+wcf2LT62/3qzDfvYvsHH9g0+tm/wse5KeTAvro5gXoIr9p6PdTdUoj7W39qJ+tixo7GOLT52bPGxY4uPHVt87NjiY8cOH1uP+z7W1RH0sa6OsI+dr2H9brON+li/UGJ+ydcR80vRymny6V5+LC++jlheojEFno6xYa3gTfBJ0MfWtKGxukrCPvaNlqCP9bVEfayvJepj32gJ+tg3OYr62LzBx+YNPjZv8bH515tt2MfmDT42b/Cx+b6P9UPi1hlr4XfmfhRVZ9fV8m04P4kxDF7E9kZJ7K6+N4cVgt8cuV+30UMTbt1uWDt5c7om+s2pGy4mcJXEvzm+lug3x9US/ua4WsLfHF9L9Jvj5yj6zan379NwdUS/OXXHfRpVfr3Zhr85bqEEvzmujuA3J1g5rm9zT3YGfayrI+hjgydMPR2yw8fKFh+rOxqrbvGxusXH6hYfq1t8rG7xsbrFx+oGH6sbfKxu8bHt15tt2MfqBh+rG3ysbvCx7jUYQR/r6gj62OB1HJ4O97aUqI/1722J+ti+o7H2LT62b/GxfYuP7Vt8bN/iY/sWH9s3+Ni+wcf2LT52/HqzDfvYvsHH9g0+tm/wsel+nIWvI+hj0+04C/9iuaiPrTv2AGXHJYaukrCPfaMl6GN9LVEf62uJ+tg3WoI+9k2Ogj5Wjvs+1tUR9LGujrCPlfTrzTbqY/1CifklX0fML0Urx9PhX64ay4uvI5aX6CWvrp9uG3ysfxtw1MfmHY01b/GxeYuPzVt8bN7iY/MWH5u3+Ni8wcfmDT42b/Gx5debbdjH5g0+Nm/wsXmDXyq39wB9FaE9QPdtxrSeliqFj4t+u13SfV9nNXd6UeNrKvr9mBNfR/B702/HnPiPNgS/N28eoYh+b+qGo4iukvj3xtcS/d64WsLfG1dL+Hvja4l+b/wcRb83cv8Erasj+r2RHSdoRX692Ya/N3J/rcHXEfzeyO21hjdP40S+N29URL43b96BWldSqdIroF/fgZovGbysW83rEO5DpttBvr6d9NDjhUj1dbVyGomfEPzzdLP7xFbw4SNXRezhI719TZD7CFT44aO240yytPTbWsInm30t0ZPN0u5fsuXqiHrotuOSrXnxxm0P3XY8fHTseNlR+v2Hj44NLzvmLddjSf91LfHe03dcsiX9/iVbro5o7+k7LtmSvuGSLb9gw/cCeKE40dcQZdy+VcN95CB4U2W5/2xYuf9sWNnxbFjZ8WyYbLnv0tUSdwNjx/sG8zLpm27A1RF0A66OsBvQY8P7Bn7BRt2AjA0fUd3wWpcXUBTuPbrjOQDd8lqXbnmtS7e81qUbXuvSDa916ZbXunTHa1265bUu97LY4KMCmtwxQehRAVdH8FEBX0fsUQFXR/BRgbAO+VRH7FEBX0fsUQFXR/BRgbCOT8sj+KiAryP2qICrI/ioQFjHp+URfFTA1xF7VMDVEXxUIKzj43TEHhUY7hWXwUcFXCXRRwXUu7cw/KiAejtbwUcF3OxEHxXwL0cPPirgpiT4qEBJt9c7fRWhqdobFaGbHNOOO13Tjjtd1X0pcIuW+GDT1RIebHpnuKKDTU9HdLDpPhsVHmx6uxbhwaZbsNFHBbzz2PGpmnd5W/Qe1LSh95Qd6/yqv64l3nt0x26B6v3dAldHtPfojt0C1Q27BX7Bhqdq3nMA0UcF1DvyHn1UQP1tpdijAuqd4oo9KuCrCD0q8EZF5FEB917m4KMC6p01ij4q8AMlrx8V8FtZ8FEBbd7nIviogHobW9FHBdR9niv8qMBP1DiPCvirLbFHBbwTE8FHBdS7zS74qEDdcZV43bHKr/3XtcQ/oX3LXsHYsFcwNuwVjC17BWPDXoFfsDseFaipLAeZtLzeMlTvla7YowLq7XwEHxVwJynRwXTb8EKX7HihS3aE3rQtIQhtywtdbcsLXW3DC11twwtdbcsLXW3HC11txwtdyb1Dv69CKUelgV/6+uKmd4Ar9eVPUqfw4vpnIF9yw0PC/dhbygmG0HmRHeEQur5jMail9tta4v3Y1RLux/m43489HdF+nI8d/dg7uxHux27BhkPodiwptax3e09OG5aUfCXhdp/Hb2uJ9568Y0G2lfsLsq6OaO8pOxZkW9mwIOsX7I6vYClrO6QUCqv/+hV0ldTDtv8Pzc6n1Nvx2qPlMetdi0q9WYb0JzrG2q3SkduHOmxxa4ijw2uwseMbvo7Y8Y1ox3GPpm04VvbGwwaPlbW64U5YV0n4WNkbLcFjZb6W6LEyX0v0WNkbLcFjZW9yFDxW1uT+VcYteKOqfJqO+DdDfr3ZRo+VtQ3X3bYN1922Ddfd+kPqYF5cHcG8BIf27tHdcd/HvpkDRn3sjje6XCVxH6tbfKxu8bG6xcfqFh+rW3xs2+Bj2wYf27b42PbrzTbsY9sGH9s2+Ni2wcduePaobXj2qG149kh2PHskO648azve6HKVxH1s3+Jj+xYf27f42L7Fx/YtPnZs8LFjg48dW3zs+PVmG/axY4OPHRt87LjvY/3N3lhefB2xvEQ3nT0fW3c8kVx3PHvUd7zR5SoJ+9g3WoI+1tcS9bG+lqiPfaMl6GPf5CjoY3u672NdHUEf6+oI+9iefr3ZRn2sXygxv+TriPmlaOW4vk3vX/Pl6wj62GBsrPsM/Yb12DdB1FEfu+ONLldJ3MfmLT42b/GxeYuPzVt8bN7iY8sGH1s2+NiyxceWX2+2YR9bNvjYssHHlg0+Vu7vefk6gj5Wbu95+Yeroj427Xjmp+/Y8+pb9rz6lj2vvmXPq2/Z8+pb9rz6lj2vvmHPq2/Y8+pb9ry6/HqzDfvYDXtefcOeV7+/5/Xm8GnkKsU3KkJX97qneaPPd/pKgs936oYnOXTDkxy64UkO9/aYaJyFf49N9Juz440uV0n8m9N2XBfvawl/c9qO6+LfaIl+c9qO6+J7u39dvKsj+s1pO66L7/3Xm234m9PuXxfv6wh+c4KV4/qlY8P69LFhffq4vT7t328X9bFlx5McfccbXa6SuI8dW3zs2OJjxxYfO7b42LHFx44NPnZs8LFjh48dx68327CP3fBUUN/wVFDf8FRQuf8kR7n/JId/U23w0vl+P9ojemOup8M9TRj19P7VykFPP9KGI7SukrCnf6Ml6Ol9LVFP72uJevo3WoKe/k2Ogp5+5Psnv10dQU/v6oh7+vzrzTbq6f1CifklX0fML0Urx/Vt7f5OpK8j6GPb7Z1I/8mFaNRy2xFRN8qOxlq2+NiyxceWLT62bPGxZYuPLVt8bN3gY+sGH1u3+Nj668027GPrBh9bN/jYetvHvnmSJvTgkN5fJU96f23a1xF8Wk7vP+FUN4ymfSVhT7/jjS5XSdzTy46n5XwtYU8vO56We6Ml6ullx9NyQ+/fGj+CTV8+TUfc0+uvN9uwp9/gl8YGvzQ2+CXvDheVddE63QiVU/mBijqWivpahbdMEEyFqyKUCi8S/bGi0i/v+kfX/XIdoqtjxodDh47ymY5uXn4c8pGOx9dh3XN55Nd5Se5SZTnW67Dl6OVDLbFbCd7oCN1K8E5H5FYCt2bauvDoeVv6Z7X7h476oY5sOsrresnDWyMseVztvZRUX5THGx1lfe5K6e21jv67Ompaeak5fVa361bI5znJD+tl3cia2/jQg3A6PtXR19j7IX6qY40efB23Py7j/relu+s0Oa3PZH7tO97oWPcbPcTxQod7nWuoLFwNobLwbsiVltZFT41uaUr5iOvo69056SV9qGN9JR+ifqhDLB30dvnPdNg0t8uH6RirdcmjpX1aHsN0vK4X96ZusUs1hULKPtfRP9Oha3Bcld7u+JmO9ZxJbU4bU/9htOuL0Fp6fTVaObyotCqrpT4yRqsYWn6SktAlbY+UeBcfhy5paxteaGsbHmh75KX/tpboFW1vtASvaHsMo28vqvo6YlNtX0d0qv3Qcn9R9U3BBq9o827qjnfi3O534jcpCXbiPO524r7h4vG+pfuV/Nta4p3Y1RLuxPfPaPk6op14xxmth5a+oRO7BRvsxN7XXI6lQ478epRVDm9XQ/J6qkIyjxn7VyXedKKtktVGq9ZflPi50TVm5DWRf5CbuiM38ru5SetVlYf42ahR5hku6Ci5fabDXnd5iBt0aPpQR1+1y+9//EzHeljwoe7TMl2bEQ9RP9RRTEetTku9f77yjY7QWnfYsTo6+oarNfqGmzXKIWODa/aURHfg3mmJ7cC90RLcgXujJbgD905LbAfuXY5iO3Dl0NvvF/g6oiMK3fB+wUPLrzfb4A7cm0IJeiXV+14pWDmujvuxeW90BPNyPzavbTiA1/IOD9t2NNW2xcO2LR62bfGwbYuHbVs8bNviYfsGD9s3eNi+xcP2X2+2YQ/bN3jYvsHD3j/JIM5cq8xrT7G/2Dot//T6oY7+mY5+XPVS+PX0n+lYC0iPn8mHOmo3HePTdKzXODu9V/AzHWvR5iE66XBjn1e9PD4c9TMd5cj21Sqf6jhMR72vI3+Yjjzs65n7h+koVh4y7qdDX7d1/xbDWN2+uU4xVLdvdITqNqwjf5iOYN366YjVbTgdXt0eno66RopZeD/8yxuAKd2OYHmjIxR98tDRf1dHLILFLdOyPpW5tMMpU28WIMspK32jviwpusmoFgTDY5h/kIxyf4E0eftYwQVSNzeSV0N9LDC+zI2vYy1MZtHXJZK6d4F3lrpciMjxoZZgMJ6vIxaM90ZHJBjP29+IBdS4GkIBNeV2UE+5HdQj3rR9yBplj55e7m76OmyUPXp+qeOxz+Y9aXccK37kIdNc92d6gm3U1xFro290hJ6x8gK08wowGpkCjB5f4R/oKBa+Ju2lDvcRq2Ab8XVE24huaiO6oY3ohjait9uI4wBqWw6AI52kRxXImolJo++kHlEFutrGo0A+UrAaeU8UvCbhMrBwwHHoSwUlubPJ1axK4zH61/GCO2uxAZQ2T0csHb281OE9hlSub8rgTbvvhdHvZiRUpUoxyKnJl0R4JwBrujJSeRf0iw4vEeVKROOt2O+JyHcT4esQq9PHGIwmPCl91eJd17eGxeWwjv7lrWRfRdJ2lUhqR/ES4g0kS7e56OD5W/mJlprWTLL+MbP+mRY7yVCLq8Url7Z84MNbZ6dc2rGjXFwt4XLxtWwpl3kWDuUyaFH6Zw33Dy0tf65lffdH/7gTzR0slMtR1atp92lsC3t5yDpeD6re6LFovIc8xNPjrdj3YSXMbUblJ1osuDCpyIda+gpe6dwHvunwa2m1mHx0r8X0sqeWfD3xWvJCQOO15GoJ15KnJVxL3metWoxR5WHC91ry3kysduJRSv5ciy1uuP3a1SLr3ECW8XFadD0LnZWGYD/WYmMw2lb8qRY7k6rj4zqaL9FDC6+D/ViLBfxSfN1PtViO2vg4Ld2+sr2mz7WstttFPtbS17e6j/KplrFGqnnUG1pWuQz5uB8N60fj435Usk2Fcv+0dEtdMSXlMSj6VIuky78UqcenI8RqZyIrh+//cGy35jUPLZ+PnKNp8bXE0uJOFdcRjcTrD+FpXkpHtQgZDp5I4fnqo9+t7yHPV+OT7rVOx9HH4d/3tc3YOVq3fVld8zai1BaSOBD7RyrWFFMpRuGHKo415y4fFEQ6lkt9VCUXhcYb1Loc/7E0RSqOL+sw2dvHmtenokZL/SQZD+22RclLSuXrmqm3epvVjvsrRVwVDSckzZfKUKSdNgn+QXm4a1ut2gjLvpjtmxIv2qqtPajHyjkPR8ZXLc60qdW1sd94T+0faPE2XdeyZU1OgFLOGx78fmzZuw4sGOHna4nGw+USe7pHPtURjmXLGy4UDGfHiyDzKzl6UM29szx8xCx7W47h6un3y8TTEa9i70xWvIq9gg0eMXM95HL2j3Wu7nhI70xWOkqxranHwMh85PEjNbLa20OmoVkL76g8vg66djN4QPI9Q2+WuWypgVbQD/mqxfOzj502ixcUaizfi8VbV3o4v7rGSIXWNOPFkuBxTh9ZaK71tWA8JY859VKSG3la+dr2vTfSqtIVBabi+ImKteYhtKvwIxXS7CKN/KGKFc2lx3ilwi3PJmt88phRq1Oe7X55tvvl2e6XZ/vN8hxrjfshq9M+/XeMosNX74a52uVY+2f6evj60OK5xNzt8AJvoP1gEMyl8tBRnFJx7/9r2UZZfGTgWySEG8XQbI3wueP0uZq10PIYX9Bdb9/VeIsbqSwHzaGD34b23qrEmI0aw4rcDmdQ3rz7J7ot2XdelSjyEy1NbazVXS3eun9ZK9Op8rUPP9NSdXk3SeJpkQ0jpXCG6Kqhf5AUt6JHXTPjo3sVHb2HgsYW/yAtY0sVjS3lMnZU9IYXtN4UbrE74Er3Ctf3Ls3Gf433xb95F2+rqazJeuUAJT1+lpRmjq6n4STFWzh4NLp1C8tjDFlfD0W9Q9zhoei71NS1ldf+2G/6pmZ4/ZEWDwqtfcYjwB7fQ2u6j1UEef1tdO/aK+s9Sa18j0P/lh3PSdHWL3nu+nUR0nvZMr5A5N6BGlwgGrpjgWi0HQtEblrC6xjuI1bRdYx5YuXmOoarI7wGUY4dDtctlOAaxJsOJGsX4LGzP153oHK4t7qYV+FIsZS+FYvXWI61nZAPvgyljc/cSqKBpXxLSfc682FHdEt/mZIy1z+d4elYoxZ2k9+0JDfEi57MpcsJc64/0UJjn0oHF/+BFj+eerX+w02Kez9hXbctSnd2R30t89VIaNHSP9ey5op88+MPtVCO1NuTf5OWZssJx+flspYDasvHhhy1nD7V0tYkrzY+LftTLZaWITtyNPRTLZ1ic2v9XEu2FYq0IUfdiyB9k5YVzF9HGp9rWTU9im7I0SjtQy1yrCVxOcQrF3drq9ZqM7TK5+e/RuCV4q4LjDWh6Tx1/Rr35muRYhM9ftzmR1ra2k5tvTk6/NK128aS66Xc6wJ/Urq6pXR1S+nqhtJ1tzHtHgwORfj+hfUOb4bnIsXbKQvORUrdcTNO8d4QCs9FfC3RzepS71+W6eqIzyK8rbLoLCKanSafVnJ0klfk2DHJk/sXEkd1uGUiOy41LrIhHsEv2OhE0Z9AyJriZdGPpyFyUOR1d7R4R8XGeigmHXS4Y3ydsnp3uoXDgopu8bS6wdPqFk+rWzytbnEIKjscwoarCMuWqwiLbrjc2C+UcGf2OlCy/ZTHjmJzelB3I1hW/fDM4ZsS7+o8WeGfMmgwebSvOrxGO9Y9c/mgK/x+puXxU1sFLunztJCW/HFaLMT54AWFz9PCgfU/TMu67TwfvLHzeVq6W7ru0zorZJmW9r7r6GmHy/b2zKIuu294GvOhZcMLuw8tG4a1fcuwtu8Y1vYNzzG/qSCLLP/zZbxvWsaOINm5JXy3gsaGga3b8O3Kp/RxuYbHB2PL+GBsGB+MLeODsWN8MH5/fNDbunN10ILI1097PXxHe/lZCgh79oAvOrz1kGzrIZnWOFP/QUL6CsD8Y8k2/0jHOhfW+Rv4Ix1DbdpCm2T/QIn37lbV9XJB/ePk3viqZcdxhnrcP85Qjx3HGWracZzBT0vUL9W042GXmm4/YuzrCPulmjbEgfmFsskvWZi655dcJXy1Hd8X+M25JTckIVsl59eXUpZ5YP1lN7TY3cbzn2/uzTs19vjW2k2O4+VJwIcS99lceny3lA+VpBVV/byw4VMlgyJDvZS4bxrbnRvqZsf7rA+7g2HU/pmSfNgtqkf2UuI02dAFl+/SUW0Cpk7deJtiO9KRLE4w9fphoablku4oWa31hhL+fGWnjbi7YcW+GI8B/IdK7BKfPyJKbyiRT5VYvHqt9WMla0+uytiQnc+VNMtO7/eVyPGpEkmmhN/C/arEfcYr1of9dKzul8TrOVXv+xLXy6/4/6yeT6t9g5d375eOenm57139dAS9vH9A6346ol7+jZK0QUnQy9e+wct7h6zCXt5VEvXycSXyqZKgl3+jJOblw9n5XEnQy0eVuF7eVRL18nrfu/rpCHp57b/r5duK58q8kvQtHe3Y0PlcJdHOF1cinyoJdr43SmKdL5ydz5UEO19Uidv5XCXRzucdywo2ej8dwc7X0/3O583G84pqe3z4nOr191GCs3F3Syc6Tut1wzit3/etfjqC47Tefzcd0XHaGyVpg5LgOM1VEh2nuafBop8KV0n0UxFXIp8qCX4q3iiJfSrC2flcSfBTEVXifir8U4OxT4Uc9+dab04vhj4VctxfFfC9fGw2LseGNVc5Nqy5ynHbu75JR8zLSzp+Nx1BL/9OSdqgJOblfSVBLy9pw5qrryTo5X+gRD5VEvPy75SEvHw8O58riXn5sBLPy/tKol4+3/aub9IR9PJZf9fLB2fj4u1nhTufqyTa+eJK5FMlwc73Rkms84Wz87mSYOeLKnE7n6sk2vlKu935/HQEO1+5vSrghy5otUvR0+v4B6lpQ+iCeId+oqEL4h3JioYuiLehFQ1d8JUEQxfeKImFLoh3rCu6WCI7NrVkx6aW3N/Ukh2bWnJ/U0t2bGrJjk0t2bGpJTs2tWTHppbs2NSSHZtasmNTS3ZsasmOTS3ZsaklOza1ZMemltzf1JIdm1pyf1PrjZcPLpa4mwRRL+8+7RD18u2+d/XTEfTyrf5uOqJe/o2StEFJ0Mu7SqJe3r+tMOjl/csKg14+rkQ+VRL08m+UxLx8ODufKwl6+agS18u7SqJe/v621pt0BL38OH7Xy0cXS7wr2sKdz1US7XxxJfKpkmDne6Mk1vnC2flcSbDzRZW4nc9VEux8etwOGXiTjljn06Pc73z1fuiCHhsOEuiOTS3dsaml9ze1dMemlt7f1NIdm1q6Y1NLd2xq6Y5NLd2xqaU7NrV0x6aW7tjU0h2bWrpjU0t3bGrpjk0t3bGppfc3tXTHppbe39R64+Vjs3HNG9ZcXSVhL3//mNabdAS9fMm/m46ol88b1lzfKAl6+bxhzVXLhjVXX0nUy5cNa65vlAS9fNmw5hrPzudKgl6+bFhz9ZVEvfz9Y1pv0hH08rX/rpcPzsZVNhwk8JVEO59sOEjwRkmw88mGgwTx7HyuJNj5ZMNBAl9JtPPJ7ZCBN+kIdj69vSrghy5w5+vObXGukm6XUHbqwT9Ukrop+TQlY7WRwve8fVPi34Zp78oLhT/88E5NXbd8ZKVX2H+oZdjdJ8N7IEDdZ73WrSWP3kyv6n1R4W1Y9Lzum+uZb4pLXxPiPccleVWy5GrZqflHSta7eFIoO9+VeBe5rP436Em7n5XICivpJbslIjtKRHaUSLtZIu77HI9iWFc6FeW4ofE1HZ537cc1t5D+x7MN9Qda2ljPE7Sh6WMt636ch5b8oZZ+1EtLT0f5OC3rxZGeUne0+FfwJXuzNCUaKn1t+91tcOtRDMm9fqajrAvApFT9rMXVRJeIFafFeVtbtaznPh9K+PJ8/YEWsfGJCN93+iMtj3bbrcXpx1pWJfcjfa5lvZHW/7h79ZsW9yBMuMV5D3lFW5yrY0eLa2sA2Rvd3vq9xXnPeJVqDfcht9cPRKt3N+EPinZsKNpxt2jdCVwqNoNL7eUTUb6OdZ3t84Hn8ZGO3OyF2SIvdZR2uE93H/YAeOZ3R8sPtJSxbjp9zEdp8nXUr1rcezD7SkuiN3P1W1LcPfPV7jNfn/f1Zdh2uDfEBx8Mbf7dhMEHQ5t7N2H0wdDmPyYWzZGfFrG23/KnOYo+O9rShscN/CoKPjsa7oiVPqjfOmLy7i1ubc19eq6vG3/ybtSMPVzqJ6SLvVFFs8pvCfFuJtQyVlK0pvH62VJfjZT1LPJDHsdrNV6WJK9nIyQ7L1fPkw2v67nQM9pWui3/REldz7A+l84cJd5CZF2RCVlqeu3ivG2vpuvW+9ayOg4heyWrsh7LUnrWo/wkJdGnNOY75i+1RK+kbd7WV/BK2uY9kxW+krZ5m1/hK2n9tESvpG3FGyREr6Rt5f4d8a6O8JW0rWy4I94vlOiVtG+8ir2C4TgE9/tTq32UJTvfn+q22vU0Yc6tOgNB9y0nXcPr52Ez06L6YX54nP8tP+67Bi2Tv66O13ff2moz7OZs+5o/V9PtNfB2iKPGm46lQifE2mvPX93B7YpWGLkdjqes3sjpWMcAH5v9xRnEeVoeO+urdJXmQT/U0tT8U/eGpZJ3DG59LdHhupejqvZOAp/ULN+ai5uWtDYIHpPuj3MUHq7LDp/rVnRfd28/RC9D/iDMPq2V3nL9NghT9ynvw96OPBL5l29PUDb38a60ImVK4lXkLx7zTcEMGxL+8TjA91a3Zdqrdce0132pKtwbfS3UG3PaocXt0165/KB0ZUefdrWE+7S3wRXu025zCU7B331gWxL7wNIWyDeP6R0Ai06g3ySl2be+03LY96R406JHN1oztFyKM4X2dsv6Yw6ylthzoRj072rc1NQ1/X1MTnlh7ZsabxmKJjX8pL30H6XFnot+DPKoK31Li3e94WMJ/ioYHUILHfGRarNXiB9fP2cJ1rsS5bHTfdArNaJOdurNvfN4big84ntuvEVcey7nsebfX23xuglRayWPRB1OQvqOlW1PS3xl233DK7qyPdKGlW3vdE38I+Rtle3REh8ojC0DhbHlEz+2fFZ3vOTlF+6OlW3uiN3xb907ExZd2e7eRYfBD7OfkODKdve2uuIr276a8Mq2m6XoynY/2v2VbV9JcGW7u9sxwZXt7m0vhVe2e0q3V7b9lERXtrv3DFd4Zbt722XBle3unbcJr2zPd7Zur2z7aYmubHdvwyy8st2917yCK9uujvDKds8bZmR+oURXtt94lfsr2703+yjn1wPBnmXHSnB3n/OKrgRHc1Q43O97jvqGtfru7ZhF1+rfFktwZbuXdH9lu5e8YWW7l7JhZdvVEl7Z9rVEV7Z70Q1D5DdagkNkN0fhlW0/LdFVMF9LdLje6w6f61Z0dGX7zSAstrLda92yst29dbDwyrZfMNGV7TeeIThh7f6Vd8EJa3fX6sO90dcSXNmOa3H79JZ9Az8t4T7tagn3adnwaK3fXKIr228+sNGV7S73Q8PeJSW4st29rbP4ynb3ds7iK9tvUhNd2e5a7q9sv0lLdGW7e7s7t1e2tZTLdWshR/dYx/w//+f/euDf/ulf/v2//f3f/ulv//Ev//av//P5yzSeI7fnHCYfT+kZxZPTkvKSylN6xpDkuiRZki6pTen5i76kaeP5VSnHkqaN5xHGkpc0bTw/qGXaePrbIkvSJbUlTRvyKLUyLqkeS0pLytcvalnSslGXjarrF21Jy0ZdNuS4fiFpScuGLBtS1y9kScuGLBvS1y/GJemyocuG5usXWpa0bOiyoausdJWVLhu6bLRVVm2VVVs22rLRVlm1VVZt2WjLRltl1VZZ9WWjLxt9lVVfZdWXjb5s9FVWfZVVXzb6sjFWWY1VVmPZGMvGWGU1VlmNZWMsG2OV1Vhl9RhfmZhMXMWVjmJiNVFMVPtZM7GbaNbSKraUkolmLZm1VO1nYqJZS2YtdfvZKr+UzVo2a3kVYcrFRLOWzVpW+1kz0axls1asJIuVZDFrxawVK8liJVnMWjFrxUqyWElWs1bNWrWSrFaS1axVs1atJKuVZDVr1ayJlaRYSYpZE7MmVpJiJSlmTcza6SLkKY4lnk5iislEWNOnWEysJoqJaj9rJpo1NWunu3j+7PQXUzRrzaydLmP+TEw0a82snW5j/mwssZu1btZO1/H82ek7pmjWulk73cf8WTPRrHWzNqwkh5XkMGvDrA0ryWElOczaMGvDSnKskszHYWIycZVkPoqJ1UQxUe1nzcRuollLqyRzSiaatWTWUrWfiYlmLZm11O1nqyRzNmvZrOVVkjkXE81aNmtZ7WfNRLOWzVqxkixWksWsFbNWrCSLlWQxa8WsFSvJYiVZzVo1a9VKslpJVrNWzVq1kqxWktWsVbMmVpJiJSlmTcyaWEmKlaSYNTFrYiUpVpJq1tSsqZWkWkmqWVOzplaSaiWpZk3NWrOSbFaSzaw1s9asJJuVZDNrzaw1K8lmJdnNWjdrpy/pT7GYWE0UE2FtPMVmYjdxLPH0Jc+fnb5kimZtmLXTl8yfiYlmbZi105fMn41LLMdhYjIxXz8rpy+ZYjVRTFT7WTOxm2jWTl/y/NnpS6Zo1pJZS9V+JiaatWTWUrefrZIs2axls5ZXSZZcTDRr2axltZ81E81aNmvFSrJYSRazVsxasZIsVpLFrBWzVqwki5VkNWvVrFUryWolWc1aNWvVSrJaSVazVs2aWEmKlaSYNTFrYiUpVpJi1sSsiZWkWEmqWVOzplaSaiWpZk3NmlpJqpWkmjU1a81KsllJNrPWzFqzkmxWks2sNbPWrCSblWQ3a92sdSvJbiXZzVo3a91KsltJdrPWzdqwkhxWksOsDbM2rCSHleQwa8OsDSvJsUqyHoeJycRVkvUoJlYTxcRp7blaUuFLIHYTxxLhS56LRRW+BGI2sZhY7WdiollLZg2+BD8bS8xmLZs1+JL5M/gSiGYtmzX4EvysmWjWslmDL5k/gy+BaNaKWYMvwc/ERLNWzFqxkixWktWsVbNWrSSrlWQ1a9WsVSvJaiVZzVo1a2IlKVaSYtbErImVpFhJilkTsyZWkmIlqWZNzZpaSaqVpJo1NWtqJalWkmrW1Kw1K8lmJdnMWjNrzUqyWUk2s9bMWrOSbFaS3ax1s9atJLuVZDdr3ax1K8luJdnNWjdrw0pyWEkOszbM2rCSHFaSw6wNszasJMcqSTkOE5OJqyTlKCZWE8VEtZ81E7uJZi2tkpSUTDRryaylaj8TE81aMmup289WSUo2a9ms5VWSkouJZi2btaz2s2aiWctmDb7kGVst8CUQs4nFxGqimKgmNhO7iWOJ1axVs1bNWjVr1axVs1bNWjVr1axVsyZmTcyamDUxa2LWxKyJWROzJmZNzJqaNTVratbUrKlZU7OmZk3Nmpo1NWvNrDWz1sxaM2vNrDWz1sxaM2vNrDWz1s1aN2vdrHWz1s1aN2vdrHWz1s1aN2vDrA2zNszaMGvDrA2zNszaMGvDrI1lTY/DxGRiNrGYWE0UE9XEZmI30awls5bMWjJryawls5bMWjJryazBl/S5pD+WCF/yDM5X+JJntJ7Cl0Cc1p47vjp9STnmz8RENbGZ2KfYnuJY4vQl5RlCqdOXnGI2sZhYTRQT1cRmYjdxLLGatWrWqlmrZq2atWrWqlmrZq2atWrWxKyJWROzJmZNzNr0JeW5JazTl5xiM7GbOJY4fckpJhOzicXEaqJZU7OmZk3Nmpq1ZtaaWWtmrZm1ZtaaWWtmrZm1ZtaaWetmrZu16UvKc+lEpy85xWritPa8KlKnLznFZmI3cVp7nlPT6UvKM2BEpy85xWzitPaMR9fpS05RTJzWngeqdPqSU+wmwlp/7nnB2niKycRs4rT2PEDSpi8pff5MTJzWxvzbZuK09oyqa9OX1GcvbNOXnGIyMZtYTKwmiolqYjOxm2jWslnLZi2btWzWslnLZi2btWzWslnLZq2YtWLWilkrZq2YtWLWilkrZq2YtWLWqlmrZq2atWrWqlmrZq2atWrWqlmrZk3MmsCaPMVs4rT2jBZs05ecopioJjYTu4ljidOXnGIyMZto1tSsqVlTs6ZmTc2amrVm1ppZa2atmbVm1ppZa2atmbVm1ppZ62atm7Vu1rpZ62atm7Vu1rpZ62atm7Vh1oZZG2ZtmLVh1oZZG2ZtmLVh1say1o/DxGRiNrGYWE0UE9XEZmI30awls5bMWjJryawls5bMWjJryawls5bMWjZr2axls5bNWjZr2axls5bNWjZr2awVs1bMWjFrxawVs1bMWjFrxawVs1bMWjVr1axVs1bNWjVr1axVs1bNWjVr1ayJWROzJmbNfEk3X9LNl3TzJd18STdf0s2XdPMl3XxJN1/SzZd08yXdfEk3X9LNl3TzJd18STdf0s2XdPMl3XxJN1/SzZd08yXdfEk3X9LNl3TzJd18STdf0s2XdPMl3XxJN1/SzZd08yXdfEk3X9LNl3TzJd18STdf0s2XdPMl3XxJN1/SzZcM8yXDfMkwXzLMlwzzJcN8yTBfMsyXDPMlw3zJMF8yzJcM8yXDfMkwXzLMlwzzJcN8yTBfMsyXDPMlw3zJMF8yzJcM8yXDfMkwXzLMlwzzJcN8yTBfMsyXDPMlw3zJMF8yzJcM8yXDfMkwXzLMlwzzJcN8yTBfMsyXDPMlw3zJMF8yzJcM8yXDfMkwXzJOX9Kf4rT2PAAx4EsgVhPFxGktzyCoZuK09rw0bsCXPM+gDPgSiMnEae0ZVD3gSyBOa2WGVImJauK09gxRHPAlEKe1Z5zggC+BmEyc1p73Kw34EojT2jOkeMCXPOMGB3wJxGltxnDBl0Cc1p47xQO+BGIycVp7bmUM+BKI09ozLnjAl0BUE6e158RmwJdAnNaec5wBXwJxWnvOLwZ8CcRi4rT2nEkM+BKI09rzRPqAL3meSRrwJRDHJaYDzuS5fPCQE8nT4POo+UMuJFeSp80xI9bgUk75aVUOxMJ1kofJ063Ic4D8kBPJecozbdOzyDHTM13LJT/tynNK/pCV5Gk3zTRM93LJw+TpYOTZLR5yInnazTMN08dcciV52s0zbdPNXPK0m2fapqO55Gn3efApHdPVXHIiedp9niN9yIXkabdOu9PfXLKS3EieduvMy/Q5pzydjtSZnul1RGZZTbdzyYXkaRdBhtPzXPK0K9DZSO4kT7sy8zXdzyVPuzrLajqgSy4kT7s60zl90CVPu22mbXqh+djIQ+4kT7ttlsN0RJc87baZhumKLrmQPO32WebTG13ytIu+MP3RJXeSp90x0zZd0iVPuwPhm5nkp109Zt+ZbumShWSd8myr0zNdcp/yLKvpmxR9YTqnS04kP+0q+sX0T5c87aIvTA91yUrytIt+MZ3UJU+76AvTTV1yInnaRb+YnuqSp130i+mrtMz0TGd1ydNuQYBrJ3nafX4EEoJrLzmRPO3OPoX42kuedp9fgoQI20tWkqfd2UcQZHvJ0+7sFwizveRp97njkhBoe8mF5Gn3eWggIdb2kqddRbjutPuM9E8It30s9E15mDz9lc4+gojbS84kF5Jhd+Y9C8lK8lofTQi81YaY4WHy9FeXnEjOJBfTM/2Vzj6F+NtLVpIbyZ1k5HeWeT1ITiRnkgvJlWQhWUluJHeSya6QXSG7QnaF7ArZFbIrZFfIrpBdIbtKdpXsKtlVsqtkV8mukt3pr3T6MQToXvIwefqrS05Wj9NfaYdcSJ52+2zD8FenrPRbalfwVx1B5cNk+KtTTiTD7mzz8FenXEkWkpXkRnInGXZnv4C/OuVEcia5kFxJhq3ZT+GjTrmTPJaMoF3kC1G7l5xJtr6DwN1LRh7HlJXkRnInedp9Xk6UEL57yYnkTHIheeZxfrMQw3vJ0+4c4yGK95I7ycNk+Kgx8w4fdcqZ5EIy7OqUhWQluZHcSR4mwy/NMScCeS+5kFxJFktzoTzCL6FMpl9qB+Rh8vRLl5xIziQXkuuUZ3lOv3TJSnIjGfmadQpfdMqJ5Ewy1aPA1syLCMlKciMZecTBjGGyHiQnktfGWEJs7yVPu2nW6fRFl6wkT7tppnn6opbx22Hy9EUtz7RNX3TJmWSyO31RyzhCMu3Obz0CfeedLAmRvq3O9E9f1AS/HSZPX3TJieRpF6dVpi+65EqykKwkN5I7ybA7y2QcJCeSye4gu4PsDrI7yO4guwN2Zx8ZY8kIAL7ktP4eIcCXXEiuJAvJSrKVMwKBL5nsJrKbYLdPOZNcSK4kw+6YspI87SqOBnWSh8nTL11yIjmTXEiG3WPKQrKS3EjuJA+Ty0FyIjlb+kshuZJM+S1ktyC/swzho055mAwfdcqJ5Ewy8tumXEkWkpVk2J3pqWS3kl0hu0J2hexKIZnsCtkVsgt/dcrTbpvlIGRXya6SXSW7SvlVsqtkV8ku/NXzGHRCEPElD5Phr045kTztzrknIonbHN8ilPiSheRpd47BEE3cOn7bSR4mw0fNMQnCiNv8DiKO+JIryULy1Dm/HYgaPmX4olN+6u8HjsXlKU+70xddcp3y1Dl90SUrySvoIiFQuM9vIiKFoecMFZ5jGMQKX/9u+hEtPG9wSggXxrcA8cLX3/Qp9yk/89XxN9Pn9PmNQMzwJc98lWlr+pxLriQLyTNfz9cGEiKHL7mTPEyePueSE8mwO/ObC8mVZKG/J7uZ7Gaym8luIbvT5/T5HUQg8SUXkiv9PdktZLeQ3UJ2C9mtsDt11kQy2a1kd/qcXmcdTZ9zyUpyI3nand8URBaf8vQ5fc7fEVt8yZnkQnIlWUhGfnGQs5HcSR4m60FyIjmTXCydWkkWkpVksjt9Tp8+H9HGpzx9ziUnkjPJheRpd45nEHN8yUpyIxl2cXSV7Hay28luJ7ud7PZKMtntZLeT3d5Jht1ZDoPsDrI7yO4gu4PyO8juILuD7A7YnT5kjCUjGPmSE8mZZNgdU55259oOIpIvWUluJHeSp13FEeBpdz60+L//9u//8rf/++///D//8l/+83k1w//613+6rmF44H/8f//j+i//97//y9///i//73/7H//+b//0z//9f/37Pz+vbHj+t78c88qGx///r4+Vu5yeVzqk89//a34uuD/+8bEM/X/99S8F/1Ly819qfvzL/NljXvn4zjz+/5j/lPBXVedf9ae+/NT3/PXjp/a7R+GKPv9zWSl4jPHz/Kd6peDxbfjrY6Bw/eYxHvvrY1x12Xl8Ff76GEI9fyGXjfpQu/5e8l+lPf+zWi7HX3N9/lMzs/WveTz/qa9/evSwMv9p+GlPVnwPx1yn4pSu3zzWMB9azt88nFqV+d/d8njeqvH/Aw==",
      "is_unconstrained": false,
      "name": "redeem_private",
      "verification_key": "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"
    },
    {
      "abi": {
        "error_types": {
          "12037992570023391496": {
            "error_kind": "string",
            "string": "NotAnOwner"
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14924807131364042204": {
            "error_kind": "string",
            "string": "HashlockNotMatch"
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "2175217314894115242": {
            "error_kind": "string",
            "string": "Function redeem_public can only be called internally"
          },
          "2369193878689457446": {
            "error_kind": "string",
            "string": "HTLCNotExists"
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4493654309393309420": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          }
        },
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "ownership_key",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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CyooACInUSkOKicpKiQCACoAADTWJQAAPlktDiUiLQ4pIS0LJiUtAiUDJwAEBBglAAA9my0IBScAIicCKQAqKRQqLQ4oKi0OJyYAIhRRJS0KJRQjAAAYahwKIRQAACoIFCUvCgAlABQtCyIlLQIlAycABAQYJQAAPZstCAUmACImAicAKichKC0OFCgtDiYiACIhURQtChQhIwAAF+MtCwgmLQsUJy0LIigtCyUpDCohKCokAgAqAAA1fCMAADXSACInAisAKishLC0LLCoAIiYCLAAqLCEtLQstKwAqKissLQInAycABAQFJQAAPZstCAUqACIqAisAKishLS0OLC0tDiYILQ4qFC0OKCItDiklIwAANdIAIiFRJi0KJiEjAAAXCS0LCCYtCxQnLQsiKC0LJSkMKiEoKiQCACoAADYCIwAANlgAIicCKwAqKyEsLQssKgAiJgIsACosIS0tCy0rACoqKywtAicDJwAEBAUlAAA9my0IBSoAIioCKwAqKyEtLQ4sLS0OJggtDioULQ4oIi0OKSUjAAA2WAAiIVEmLQomISMAABZjLQsIJi0LFCctCyIoLQslKQwqISgqJAIAKgAANogjAAA23gAiJwIrACorISwtCywqACImAiwAKiwhLS0LLSsAKiorLC0CJwMnAAQEBSUAAD2bLQgFKgAiKgIrACorIS0tDiwtLQ4mCC0OKhQtDigiLQ4pJSMAADbeACIhUSYtCiYhIwAAFXgtCxIcGCocJB8AIgICIQAqIQMiLQsiHBwKHCEGACofIRwOKh8cIiQCACIAADcfJQAAPlktDhwSACIDURwtChwDIwAAFEAtCwccGCocJB8AIgICIQAqIQMiLQsiHBwKHCEGACofIRwOKh8cIiQCACIAADdkJQAAPlktDhwHACIDURwtChwDIwAAFCUtCyIlGColJCYAIhwCJwAqJwcoLQsoJRwKJScGAComJyUOKiYlKCQCACgAADepJQAAPlktDiUiACIHUSUtCiUHIwAADgMtCyElGColJCYAIhwCJwAqJwcoLQsoJRwKJScGAComJyUOKiYlKCQCACgAADfuJQAAPlktDiUhACIHUSUtCiUHIwAADegtCxwiACIiAiYAKiYHJy0LJyQcCiQiACcCJgEALQgBJCcCJwQFAAgBJwEnAyQEAQAiJAInJwIoBARDA6IAIgBP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",
      "custom_attributes": [
        "external",
        "internal",
        "public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "redeem_public"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15711892660910782274": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16216212843441549037": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "2014890719615096298": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 40 limbs"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "4648451262681811962": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "7555607922535724711": {
            "error_kind": "string",
            "string": "Preimage mismatch"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7864183510978589985": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 20
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9460929337190338452": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          },
          "9589626482238399944": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "anchor_block_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "sponge_blob_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "note_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 32,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 8,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "log",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "fields",
                                          "type": {
                                            "kind": "array",
                                            "length": 18,
                                            "type": {
                                              "kind": "field"
                                            }
                                          }
                                        },
                                        {
                                          "name": "length",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::log::Log"
                                    }
                                  },
                                  {
                                    "name": "note_hash_counter",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::side_effect::counted::Counted"
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray"
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "anchor_block_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "field"
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "sponge_blob_hash",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "private"
      ],
      "debug_symbols": "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oFvSLemWdEu6Jd2Sbkm3pFvSLZ9b9cA1DuIkLuImHqIRnRhEug26DboNujFLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkkSW7MJBnMRF3MRDNKITg5gPk25Jt6QbsuQUbuIhGtGJQcyL84csAQ7iJC7iJh6iEZ0YRLoNug26DboNug26DboNug26DboNuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbptuh26HbohS7xwETfxcxu/QiM6MYj5sLLk4iBO4iJuIt2MbkY3o5vRzenmdHO6Od2cbk43p5vTzenmdAu6Bd2CbkG3oFvQLegWdAu6Bd2Sbkm3pFvSLemWdEu6Jd2Sbvnc8ISui4M4iYu4iYdoRCcGkW6DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26bboduh26Hboduh27MksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksUsWcySxSxZzJLFLFnMksUsWcySxSxZzJLFLFnMksUsWcySxSxZzJLFLFnMksUsWcyShSxZhYM4iYu4iYdoRCcGMR8uui26LbohS3bhJh6iEZ0YxHyILAEO4iTSbdNt023TbdNt023T7dDt0O3Q7dDt0O3Q7dDt0O3Q7dDN6GZ0M7oZ3YxuRjejm9HN6GZ0c7o53ZxuTjenm9PN6eZ0c7o53YJuQbegW9At6BZ0C7oF3YJuQbekW9It6ZZ0S7ol3ZJuSbekWz63/fsRB3ESF3ETD9GITiw3K8yHyBJguWXhJC7iJh6iEZ0YxHyILAHSbdJt0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RbdNt023TbdNt023TbdNt023TbdPt0O3Q7dDt0O3Q7dDt0O3Q7dDt0M3oZnQzuhndjG5GN6Ob0c3oZnRzujndnG5ON6eb083p5nRzujndgm5Bt6Bb0C3oFnQLugXdgm5Bt6Rb0i3plnRLuiXdkm5Jt6RbPrfz+xEHcRIXcRMP0YhODCLdBt2YJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFnizBJnljizxJkl1Yr69zFI4SEa0YlBzIeVJRcHcRIXkW6DboNulSXf923MakxtzIeVJRcHcRIXcRMP0Yh0m3SbdFt0W3RbdFt0W3RbdKssmafQiUHMh5UlFwdxEhdxEw+Rbptum26bboduh26Hboduh26Hboduh26HboduRjejm9HN6GZ0M7oZ3YxuRjejm9PN6eZ0c7o53ZxuTjenm9PN6RZ0C7oF3YJuQbegW9At6BZ0C7ol3ZJuSbekW9It6ZZ0S7ol3fK5Vatr4yBO4iJu4iEa0YlBpNug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26IbsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJgliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWYK+1+mFh2hEJwYxHyJLgIM4iYtIt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt023Q7dDt0O3Q7dDt0O3Q7dDt0O3Qzejm9HN6GZ0M7oZ3YxuRjejm9HN6eZ0c7o53ZxuyJIsNKITP7f6fi/0vQIrSy4O4iQu4iYeohGdSLegW9It6ZZ0S7ol3ZJuSbekW9It222h7/XiIE7iIm7iIRrRiUGk26DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26bboduh26Hboduh26Hboduh26HboZvRzehmdDO6Gd2MbkY3o5vRzejmdHO6Od2cbk43p5vTzenmdHO6Bd2CbkG3oFvQLegWdAu6Bd2Cbkm3pFvSLemWdEu6Jd2Sbkk3ZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWoO/1+07dhb7Xi/kQWWKFgziJi7iJh2hEJwYxHxrdjG7Ikl/hIm7iIRrRiUHMh8gS4CDSzenmdHO6Od2cbk43p1vQLegWdAu6Bd2CbkG3oFvQLeiWdEu6Jd2Sbkm3pFvSLemWdMvnhr7Xi4M4iYu4iYdoRCcGkW6DboNug26DboNulSX7FBrRiZ/btsJ8WFlysdy8cBIXcRMP0YhODGI+RJYA6bbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26Xboduh26Hboduh26Hboduh26HboZnQzuhndjG5GN6Ob0c3oZnQzujndnG5ON6eb083p5nRzujndnG5Bt6Bb0C3oFnQLugXdgm5Bt6Bb0i3plnRLuiXdkm5Jt6Rb0i2fG/peLw7iJC7iJh6iEZ0YRLoNug264d7rLlzETTxEIzoxiPkQ916Bg0i3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt023Q7dDt0O3Q7dDt0O3Q7dDt0O3Qzejm9HN6GZ0M7oZ3YxuRjejm9HN6eZ0c7o53ZxuTjenm9PN6eZ0C7oF3YJuQbegW9At6BZ0C7oF3ZJuSbekW9It6ZZ0S7ol3ZJu+dzQ93pxECfxczujcBMP8XM7+FknBvFzO9/lAfpeLw7iJC7iJh6iEZ0YRLpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26bboduh26Hboduh26Hboduh26HboduhndjG5GN6Ob0c3oZnQzuhndjG5ON6eb083p5nRzujndnG5ON6db0C3oFnQLugXdgm5Bt6Bb0C3olnRLuiXdkm5Jt6Rb0i3plnTL54a+14uDOImLuImHaEQnBpFuzBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixB3+v3dR0Lfa8XF3ETD9GITgxiPqwsuUi3SbdJt0m3yhLLQiM6kcfGLHFmCfpefRZO4iJ+bt/zgxf6Xi8a8XP7HiG80Pd6MR9WllwcxElcxE08RCPSbdNt0+3QrbIkVuEkLuLn9j2jeKHv9aIR6yw5hUHMh8gS4CBO4iJu4iEakW5GN6Ob083p5nRzujndnG5ON6eb083pFnQLugXdgm5Bt6Bb0C3oFnQLuiXdkm5Jt6Rb0i3plnRLuiXd8rmh7/XiIE7iIm7iIRrRiUGk26DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26bboduh26Hboduh26HboRuzJJglwSwJZkkwS4JZEsySYJYEsySYJcEsCWZJMEuCWRLMkmCWBLMkmCXBLAlmSTBL0Pf6Pbt9oe8VWFly8XPLWTiJi/i5fc9BXuh7vWjEP7f5K7cvSxrz4Zclfx+0Fg7iJP65ze+RGKv6XhsP0T7chU4M4uc2vulU32vjIE7iIm7iIRrRiUGk26DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26bboduh26Hboduh26Hboduh26HboZvRzehmdDO6Gd2MbkY3o5vRzejmdHO6Od2cbk43p5vTzenmdHO6Bd2CbkG3oFvQLegWdAu6Bd2Cbkm3pFvSLemWdEu6Jd2Sbkm3lyX797Jk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GvPhlyVmtS1fljRO4udWhV6P2Ws8xM/N64C+LGkM4ufmdWp8WdI4iJ/bd3/91GP2GjfxEI3oxCDmwy9LGgeRbk43p5uXW62OG9GJ5VY75PkwfsTPLWv5vixpXMTPLWv5vixpNKK/LYwg5sMvS+4W5iBO4npbmJt4iPa2sLLkYhD/3LxipRrJGgdxfngKF3ET/9x84GeN6MT4cBTmwy9LGkevejWSNS7i7lWvRrJGI3qvejWSNebDypJa9Woka5zE79gGcBMPsY6tpjOdGMTv2GYd0JcljYP4reSs6XxZ0riJn9ssty9LGp34uc064pUP94/4ua0a7MuSxkX83OravhrJGo34udW1fTWSNebDL0u8oq0ayRon8XOr5KpGssZD/Nzq6rUayRqD+LnVJWs1kjUO4udmNdiXJY2b+LnV1VU1kjU68XOrCqhGsotfljR+blYb65O4iO96p5rDDv7futa4OIiTuIibeIhGrPmWRQQxH+aPOIiTuIib+K3O98nrqUayRid+bl4rWflQWI1kjXVswElcxM/t6+Q71TLm9SJRLWON+bCS4OIgTuIibuIhGpFug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26bboduh26Hboduh26Hboduh26HboduRjejm9HN6GZ0M7oZ3YxuRjejm9PN6eZ0c7o53ZxuTjenm9PN6RZ0C7oF3YJuQbegW9At6BZ0C7ol3ZJuSbekW9It6ZZ0S7ol3fK5nd+POIiTuIibeIhGdGIQ6cYsOcySwyw5zJLDLDnIklNoRCcGMR8iS4CDOImLWG5ReIhGLDcrDGI+RJYAB3ESF3ETD9GIdFt0W3SrLKk3xdWS1ziJn9vXoXKqJa/xED+3uoCrx+HdX0M+ZOEifiN8DSinWvIajejEIObDyoe62KuWvMZJXMRyq0lWPlw0YrnV1CsfLubDyod6u17te42TuIh/blEX09W+F7+a75cE8TVVn2rUu/glQeMgzg/rNPqSIH51FFHj1nSixi23LwkanRjEz62uzKtRr3EQJ/FzGzXfr/xj1HS+8o9RhfOVf9Qb/nquXYyyyGysTr7GQZzERdzEz+1rqj7VydcYfRpV+97F8SMO4iQu4iYeohGdSLdBt0m3SbdJt6/m42vdONXq13iI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",
      "is_unconstrained": false,
      "name": "refund_private",
      "verification_key": "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"
    },
    {
      "abi": {
        "error_types": {
          "13455385521185560676": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17487453435310197877": {
            "error_kind": "string",
            "string": "Function refund_public can only be called internally"
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "4493654309393309420": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "459713770342432051": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "5029608433027800177": {
            "error_kind": "string",
            "string": "NotPassedTimelock"
          }
        },
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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BwgcCgYHBhwKHzcGBCoHITgEKjcsIQAqOCEsBCo1IiEEKjYtIgAqISItBCoHJCEEKjcuIgAqISIkBCoHJSEEKjcUIgAqISIUBCoHJiEEKjcWIgAqISIWBCoHJyEEKjcYIgAqISIYBCoHKCEEKjcaIgAqISIaBCoHKSEEKjccBwAqIQccHAoGBwUcCh8hBQQqByoiBCohHgcAKiIHHhwKBgcCHAofBgIEKgcrHwQqBiAHACofBwYtCAEHJwIfBBgACAEfAScDBwQBACIHAh8nAiAEFwAqIB8gLQofIQ4qICEiJAIAIgAAEostDgQhACIhAiEjAAAScC0IAR8AAAECAS0OBx8cCjQHAC0IASAAAAECAScCIQABLQ4hIC0IASInAiUEIQAIASUBJwMiBAEAIiICJS0KJSYtDgMmACImAiYtDgMmACImAiYtDgMmACImAiYtDgMmACImAiYtDgMmACImAiYtDgImACImAiYtDgMmACImAiYtDgMmACImAiYtDgMmACImAiYtDgMmACImAiYtDgMmACImAiYtDgMmACImAiYtDgMmACImAiYtDgMmACImAiYtDgMmACImAiYtDgMmACImAiYtDgMmACImAiYtDgMmACImAiYtDgMmACImAiYtDgMmACImAiYtDgMmACImAiYtDgMmACImAiYtDgMmACImAiYtDgMmACImAiYtDgMmACImAiYtDgMmACImAiYtDgMmACImAiYtDgMmACImAiYtDgMmACImAiYtDgMmACImAiYtDgMmACImAiYtDgMmJwIlBCEnAiYEIC0KDTIjAAAT+QwqMiUnJAIAJwAAIw8jAAAUCy0LICcEKjAnIAAqByAnLQgBBwAAAQIBLQ4hBy0IASAnAigEIQAIASgBJwMgBAEAIiACKC0KKCktDgMpACIpAiktDgMpACIpAiktDgMpACIpAiktDgMpACIpAiktDgMpACIpAiktDgMpACIpAiktDgIpACIpAiktDgMpACIpAiktDgMpACIpAiktDgMpACIpAiktDgMpACIpAiktDgMpACIpAiktDgMpACIpAiktDgMpACIpAiktDgMpACIpAiktDgMpACIpAiktDgMpACIpAiktDgMpACIpAiktDgMpACIpAiktDgMpACIpAiktDgMpACIpAiktDgMpACIpAiktDgMpACIpAiktDgMpACIp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Ei0LDhMtCxIUACIUAhQtDhQSLQgBFCcCFQQFAAgBFQEnAxQEAQAiEgIVJwIWBAQAIhQCFz8PABUAFy0CEQMnAAQEBCUAACnfLQgFEgAqEg0VLQ4QFS0OEgstDhQILQ4NDC0OEw4jAAAgDgAqBg0QLQoQBiMAABwuLQsLEi0LCBMtCwwULQsOFQwqERQWJAIAFgAAID4jAAAglAAiEwIXACoXERgtCxgWACISAhgAKhgRGS0LGRcAKhYXGC0CEwMnAAQEBSUAACnfLQgFFgAiFgIXACoXERktDhgZLQ4SCy0OFggtDhQMLQ4VDiMAACCUACoRDRItChIRIwAAH4sAKiANBwAiBgIMACoMIA4tCw4ILQsfDAwqBwkOJAIADgAAIMslAAAqiy0CDAMnAAQEGCUAACnfLQgFDgAiDgIQACoQBxItDggSACoHCwgOKgcIDCQCAAwAACECJQAAKnkAIhECEAAqECASLQsSDAwqCAkQJAIAEAAAISIlAAAqiy0CDgMnAAQEGCUAACnfLQgFEAAiEAISACoSCBMtDgwTLQ4QHy0KByAjAAAbTC0LIigEKigoKQIqJiAoDiogJiokAgAqAAAhbyUAACqdDCooJiokAgAqAAAhgSUAACqLACInAisAKisoLi0LLiocCiooAAQqKQwqBCooKisCKiEoKgQqKikoACorKCktDikiACogDSgtCiggIwAAGbctCyIoBCooKCkCKiYgKA4qICYqJAIAKgAAId8lAAAqnQwqKCYqJAIAKgAAIfElAAAqiwAiJwIrACorKC4tCy4qHAoqKAAEKikMKgQqKCorAiohKCoEKiopKAAqKygpLQ4pIgAqIA0oLQooICMAABhFLQsnKQQqKSkqAiomICkOKiAmKyQCACsAACJPJQAAKp0MKikmKyQCACsAACJhJQAAKosAIigCLgAqLikwLQswKxwKKykABCoqDCsEKikrLgIqISkrBCorKikAKi4pKi0OKicAKiANKS0KKSAjAAAW2C0LBygEKigoKQIqJiIoDioiJiokAgAqAAAivyUAACqdDCooJiokAgAqAAAi0SUAACqLACIgAisAKisoLi0LLiocCiooAAQqKQwqBCooKisCKiEoKgQqKikoACorKCktDikHACoiDSgtCigiIwAAFWYtCyAnBConJygCKiYyJw4qMiYpJAIAKQAA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",
      "custom_attributes": [
        "external",
        "internal",
        "public"
      ],
      "debug_symbols": "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",
      "is_unconstrained": true,
      "name": "refund_public"
    },
    {
      "abi": {
        "error_types": {
          "10791800398362570014": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "11021520179822076911": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "12469291177396340830": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12913276134398371456": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "13450089406971132036": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 144
          },
          "14067204867181196045": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 75
          },
          "14990209321349310352": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "15764276373176857197": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "16431471497789672479": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16792019527863081935": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 77
          },
          "17154023812102399658": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 128
          },
          "17803644318014042523": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 58
          },
          "1998584279744703196": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3080037330898348111": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 132
          },
          "344423948968719440": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 98
          },
          "361444214588792908": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "4261968856572588300": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "4440399188109668273": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "7564993426627941149": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 48
          },
          "7995966536718645961": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ],
            "length": 61
          },
          "8992688621799713766": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9791669845391776238": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "9885968605480832328": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "9921926525851912681": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 98
          },
          "992401946138144806": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          }
        },
        "parameters": [],
        "return_type": null
      },
      "bytecode": "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",
      "custom_attributes": [
        "external",
        "utility"
      ],
      "debug_symbols": "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PI94HvE84nnk88jnkc8jn0c+j3we+TzyeeTzyOdxnsd5Hud5nOdxnsd5Hud5nOdxnsdpj2qOujQezUfr0X5kj/xRPMpHz2M8j/E8xvMYz2M8j/E8xvMYz2M8j/E85vOYz2M+j/k85vOYz2M+j/k85vOYz2M9j/U81vNYz2M9j/U81vNYz2M9j/U89vPYz2M/j/089vPYz2M/j/089vPYz8Oehz0Pex72POx5vDq3V+f26txendurc3t1bq/O7dW5vTq3V+f26txendurc3t1bq/O7dW5vTq3V+f26txendurc3t1bq/O7dW5vTq3V+f26txenVe/VVjRfmSP/FE8ykenqeocNB7NR8/jPI/zPM7zOM/jPI/THtWAdWk8mo/Wo/3IHvmjePTnkaPoNNX34kDj0Xy0Hu1H9sgfxaPn8dV5fiteTVmXxqP5aD3aj+yRP4pH+eh5rOexnsd6Hl+d5y7aj+yRP4pH+eg01RdHQePRfPQ89vPYz2M/j/089vPYz8Oehz0Pex72POx52POw52HPw56HPQ9/Hv48/Hn48/Dn4c/Dn4c/j/oyau2w+j5qUX0lFfR5eNF8tB59Hllkj/zRn8ep3fTV+aXT9NX5iaLxaD768zg1ylfnl+yRf1/e/BUGMYnn4VfrjYM4iYu4iUak26Hbodspt++oquWrcRDLbRcu4iYa0YlBTOJ5OH7EQaTboNug2yg3K3RiEJN4HuIrs8BBnMRF3ES6TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum26Gd2MbkY3o5vRzehmdDO6Gd2Mbk43p5vTzenmdHO6Od2cbk43p1vQLegWdAu6Bd2CbkG3oFvQLeiWdEu6Jd2Sbkm3pFvSLemWdEu6Hboduh26Hboduh26Hboduh26neeWvx9xECdxETfRiE4MYhLpNug26DbohizJwk00ohODmMTzEFkCHMRJpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26ab0c3oZnQzuhndjG5GN6Ob0c3o5nRzujndnG5ON6eb083p5nRzugXdgm5Bt6Bb0C3oFnQLugXdgm5Jt6Rb0i3plnRLuiXdkm5Jt6Tboduh26Hboduh26Hboduh26HbeW7n9yMO4iQu4iYa0YlBTCLdBt0G3QbdmCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCXVIjjGKBzESVzETTSiE4OYxPPw0O3Q7dCtsmTMwk00ohODmMRzcVYnYeMgTuIibqIRnRjEJNJt0G3QbdBt0G3QbdBt0G3QbdBt0G3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdNt023TbdNt083oZnSrLBm7cBE3sdyi0IlBTOJ5WFlycRAncRE3kW5ON6eb083pFnQLugXdgm5Bt6Bb0C3oFnQLuiXdkm5Jt6Rb0i3plnRLuiXdkm6Hboduh26Hboduh26Hboduh27nuY3fjziIk7iIm2hEJwYxiXQbdBt0G3QbdBt0G3QbdBt0G3QbdJt0m3SbdJt0m3SbdJt0m3SbdJt0W3RbdFt0W3RbdFt0W3RbdFt0W3TbdNt023TbdNt023TbdNt023TbdDO6Gd2MbkY3oxuzZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDFLFrNkMUsWs2QxSxazZDFLFrNkMUsWs2QxSxazZDFLFrNkMUsWs2QxSxazZDFLFrOkOjHH92DSWa2YjZO4iJtoRCcGMYnn4aLbotuiW2XJHIWbaEQnBjGJ52FlycVBnES6bbptum26bbptum26Gd2MbkY3o5vRzehmdDO6Gd2Mbk43p5vTzenmdHO6Od2cbk43p1vQLegWdAu6Bd2CbkG3oFvQLeiWdEu6Jd2Sbkm3pFvSLemWdEu6Hboduh26Hboduh26Hboduh26nedWnZ2NgziJi7iJRnRiEMttFZ6HlSUXy80LJ3ERN9GITgxiEs9DZAmQbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbptuRjejm9HN6GZ0M7oZ3YxuRjejm9PN6eZ0c7o53ZxuTjenm9PN6RZ0C7oF3YJuQbegW9At6BZ0C7ol3ZJuSbekW9It6ZZ0S7ol3ZJuh26Hboduh26Hboduh26Hbodu57nZ70ccxElcxE00ohODmES6DboxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizJJglwSwJZkkwS9D3Ok+hEZ0YxCSeh8gS4CBO4iLSbdBt0K2y5Pu5j4m+14vnYWXJxUGcxEXcRCM6kW6TbpNui26Lbotui26LbotulSVrFgYxiedhZcnFQZzERdxEI9Jt023TbdPN6GZ0M7oZ3YxuRjejm9HN6GZ0c7o53ZxuTjenm9PN6eZ0c7o53YJuQbegW9At6BZ0C7oF3YJuQbekW9It6ZZ0S7ol3ZJuSbekW9Lt0O3Q7dDt0O3Q7dDt0O3Q7dDtPDf0vV4cxElcxE00ohODmES6DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26LbotujFLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWbJYZYcZslhlhxmyWGWHGbJYZYcZslhlhxmyWGWHGbJYZYcZgn6XtcuNKITg5jE8xBZAhzESVxEuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum26Gd2MbkY3o5vRzehmdDO6Gd2Mbk43p5vTzenmdHO6Od2cbk43p1vQLegWdAu6Bd2QJV7oxCCWWxaeh8gS4CBO4iJuohGdGES6Jd0O3Q7dDt0O3Q7dDt0O3Q7dDt1Ouy30vV4cxElcxE00ohODmES6DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26bboZ3YxuRjejm9HN6GZ0M7oZ3YxuTjenm9PN6eZ0c7o53ZxuTjenW9At6BZ0C7oF3YJuQbegW9At6JZ0S7ol3ZJuSbekW9It6ZZ0S7oduh26Hboduh26Hboduh26HboxSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrMEfa/fT/ou9L1ePA8rS/YqHMRJXMRNNKITg5jE89Dp5nRDlkThIm6iEZ0YxCSeh8gS4CDSLegWdAu6Bd2CbkG3oFvSLemWdEu6Jd2Sbkm3pFvSLel26Hboduh26Hboduh26Hboduh2nhv6Xi8O4iQu4iYa0YlBTCLdBt0G3QbdBt0G3SpLbBY6MYifm63C87Cy5GLtyV04iYu4iUZ0YhCTeB5Wllyk26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptumm9HN6GZ0M7oZ3YxuRjejm9HN6OZ0c7o53ZxuTjenm9PN6eZ0c7oF3YJuQbegW9At6BZ0C7oF3YJuSbekW9It6ZZ0S7ol3ZJuSbek26Hboduh26Hboduh26Hboduh23lu6Hu9OIiTuIibaEQnBjGJdBt0G3RDlozCRdxEIzoxiEk8D3FdAhxEuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbptuhndjG5GN6Ob0c3oZnQzuhndjG5ON6eb083p5nRzujndnG5ON6db0C3oFnQLugXdgm5Bt6Bb0C3olnRLuiXdkm5Jt6Rb0i3plnRLuh26Hboduh26Hboduh26Hbodup3nhr7Xi4M4iZ+bZeEmGvFzc/zbICbxc/Pv8gB9rxcHcRIXcRON6MQgJpFuk26TbpNuk26TbpNuk26TbpNuk26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbptuRjejm9HN6GZ0M7oZ3YxuRjejm9PN6eZ0c7o53ZxuTjenm9PN6RZ0C7oF3YJuQbegW9At6BZ0C7ol3ZJuSbekW9It6ZZ0S7ol3ZJuh26Hboduh26Hboduh26Hbodu57mh7/Xi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",
      "is_unconstrained": true,
      "name": "sync_private_state"
    }
  ],
  "name": "Train",
  "noir_version": "1.0.0-beta.14+82ec52a8c755d30ce655a2005834186a4acfa0c7-aztec",
  "outputs": {
    "globals": {
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Train"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "contracts_private",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "contracts_public",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "hashlock_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::add_lock_private_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::add_lock_private_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::add_lock_public_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::add_lock_public_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "src_asset",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 90
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::commit_private_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::commit_private_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "src_asset",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 90
                    }
                  },
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::commit_public_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::commit_public_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "Train::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "key",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::get_htlc_public_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "hashlock_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "hashlock_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "secret_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "secret_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "ownership_hash_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "ownership_hash_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "claimed",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::HTLC_Public"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::get_htlc_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::is_contract_initialized_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::is_contract_initialized_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "hashlock_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "ownership_hash_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "ownership_hash_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "src_asset",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 90
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::lock_private_solver_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::lock_private_solver_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "ownership_hash",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "src_asset",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 90
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::lock_public_solver_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::lock_public_solver_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "message_ciphertext",
                    "type": {
                      "fields": [
                        {
                          "name": "storage",
                          "type": {
                            "kind": "array",
                            "length": 17,
                            "type": {
                              "kind": "field"
                            }
                          }
                        },
                        {
                          "name": "len",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::collections::bounded_vec::BoundedVec"
                    }
                  },
                  {
                    "name": "message_context",
                    "type": {
                      "fields": [
                        {
                          "name": "tx_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "unique_note_hashes_in_tx",
                          "type": {
                            "fields": [
                              {
                                "name": "storage",
                                "type": {
                                  "kind": "array",
                                  "length": 64,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              },
                              {
                                "name": "len",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "std::collections::bounded_vec::BoundedVec"
                          }
                        },
                        {
                          "name": "first_nullifier_in_tx",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "recipient",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::messages::processing::message_context::MessageContext"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::process_message_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::process_message_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "secret_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "ownership_key_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "ownership_key_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::redeem_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::redeem_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "ownership_key",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::redeem_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::redeem_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::refund_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::refund_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::refund_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::refund_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "Train::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::sync_private_state_abi"
        }
      ]
    }
  },
  "transpiled": true
}