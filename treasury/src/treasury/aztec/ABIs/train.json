{
  "transpiled": true,
  "noir_version": "1.0.0-beta.7+0000000000000000000000000000000000000000",
  "name": "Train",
  "functions": [
    {
      "name": "add_lock_private_user",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock_high",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "hashlock_low",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::include_by_timestamp::IncludeByTimestamp",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                          "fields": [
                            {
                              "name": "recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "content",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17476367995570638746": {
            "error_kind": "string",
            "string": "NoAllowance"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "vb3driQ9cp57L3Osg2Iwfhi+FWNDGMtjY4DByBhLBjYE3/uuDJLxRner2Lmq1rdP3I9H34oni5kRmUkyyf/403//y3/79//5z3/9+//41//9p//yX//jT//tH3/929/++j//+W//+i9//re//uvfn//rf/zpcf0/jcaf/kv7p+e/Pv/tj/VvW//S+revf3n9K+tfXf/a+nfF6yser3i84vGKxyser3i84vGKxyser3i84smKJyuerHiy4smKJyuerHiy4smKJyuerni64umKpyuerni64umKpyuerni64tmKZyuerXi24tmKZyuerXi24tmKZyveWPHGijdWvLHijRVvrHhjxRsr3ljxxornz3hy/dvWv7T+7etfXv/K+lfXv7b+Hetfj3/p8Vj/tvXvM55e//b1L69/Zf2r619b/z7j+fXvdXz9Ce2xoW2gDX0Db7h+tV2gG2zD2HBFHk+gx4a24YrcLugbeMMzMl0K0g22YWzwBVfSTGgbaEPfwBt25L4j9x2578h9R+YdmXdk3pF5R+YdmXdk3pF5R+YdmXdk2ZFlR5Yd+coluk7mlUwTZINusA1jgy+4UmpC20AbdmTdkXVH1h1Zd2TdkXVHth3ZdmTbkW1Hth3ZdmTbkW1Hth3ZduSxI48deezIY0ceO/LYkceOPHbksSOPHdl3ZN+RfUf2Hdl3ZN+RfUf2Hdl3ZF+R++OxoW2gDX0Db5ANusE2jA07ctuR247cduQrB2lcwBtkg26wDWODL7hycELbQBt2ZNqRaUemHfnKwd4vGBt8wZWDE9oG2tA38AbZoBt25L4j9x2Zd+QrB7teQBv6Bt4gG3SDbRgbfMGVgxN2ZNmRZUeWHfnKQX5coBtsw9jgC64cnNA20Ia+gTfsyLoj646sO7LuyLYj245sO7LtyLYj245sO7LtyLYj2448duSxI48deezIY0ceO/LYkceOPHbksSP7juw7su/IviP7juw7su/IviP7juwrMj8eG9oG2tA38AbZoBtsw9iwI7cdue3IbUduO3LbkduO3HbktiO3HbntyLQj045MOzLtyLQj045MOzLtyLQj047cd+S+I/cdue/IfUfuO3LfkfuO3HfkviPzjsw7Mu/IvCPzjsw7Mu/IvCPzjsw7suzIsiPLjiw7suzIOwd55yDvHOTIQbrAF0QOBrQNtKFv4A2yQTfYhh1Z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",
      "brillig_names": [
        "discover_new_messages",
        "get_note_internal",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "directive_integer_quotient",
        "directive_invert"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "add_lock_public_user",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "2722406262643068352": {
            "error_kind": "string",
            "string": "HashlockAlreadySet"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16870384257694633552": {
            "error_kind": "string",
            "string": "Function add_lock_public_user can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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Ui0CAAAtCjAcBCosHAsAKh0LHBwKLgsAJwIdAEgnAiEEKy0IACstCgUsLQodLQAIACEAJQAAGlItAgAALQosHgQqCx4dACocHQsnAhwAaCcCHgQrLQgAKy0KBSwtChwtAAgAHgAlAAAaUi0CAAAtCiwdBCoKHRwAKgscChwKKgsAJwIcAHAnAh4EIS0IACEtCgUiLQocIwAIAB4AJQAAGlItAgAALQoiHQQqCx0FACoKBQstCAEFJwIKBBgACAEKAScDBQQBACIFAgotCgocLQ4LHAAiHAIcLgyARwAcACIcAhwuDIBHABwAIhwCHC4MgEcAHAAiHAIcLgyARwAcACIcAhwuDIBHABwAIhwCHC4MgEcAHAAiHAIcLgyARwAcACIcAhwuDIBHABwAIhwCHC4MgEcAHAAiHAIcLgyARwAcACIcAhwuDIBHABwAIhwCHC4MgEcAHAAiHAIcLgyARwAcACIcAhwuDIBHABwAIhwCHC4MgEcAHAAiHAIcLgyARwAcACIcAhwuDIBHABwAIhwCHC4MgEcAHAAiHAIcLgyARwAcACIcAhwuDIBHABwAIhwCHC4MgEcAHAAiHAIcLgyARwAcLQ4FCRwKHwUAHAoSCgAcChYLABwKGBIAHAoaFgAcChsYABwKERoAHAoOEQAcCgQOAC0IAQQnAhsEDAAIARsBJwMEBAEAIgQCGy0KGxwtDgYcACIcAhwtDgUcACIcAhwtDiAcACIcAhwtDgocACIcAhwtDgscACIcAhwtDhIcACIcAhwtDhYcACIcAhwtDhgcACIcAhwtDhocACIcAhwtDhEcACIcAhwtDg4cHAoZBQAcCggGABwKDAgAHAoTCgAcChQLABwKFQwAHAoPDgAcCgMPAC0IAQMnAhEEDAAIAREBJwMDBAEAIgMCES0KERItDgcSACISAhItDgUSACISAhItDhASACISAhItDgYSACISAhItDggSACISAhItDgoSACISAhItDgsSACISAhItDgwSACISAhItDg4SACISAhItDg8SACISAhIuDIBKABIuCIBFABcjAAANqw0iABeATgAFJAIABQAAEg4jAAANwC0LCQQtCwQFACIFAgUtDgUELQgBBScCBwQEAAgBBwEnAwUEAQAiBQIHLQoHCS4MgEcACQAiCQIJLgyARwAJACIJAgkuDIBHAAkrAgAHAAAAAAAAAAAXAAAAAAAAAAAtCAEJJwIKBAUACAEKAScDCQQBACIJAgotCgoLLgyARwALACILAgsuDIBHAAsAIgsCCy4MgEcACwAiCwILLQ4HCy0IAQcAAAECAS0OBQctCAEFAAABAgEtDgkFLQgBCQAAAQIBLgyARQAJLQgBCgAAAQIBLgyARAAKLQsECwAiCwILLQ4LBC4IgEUAAyMAAA6vDSIAA4BPAAskAgALAAARxCMAAA7EJwIMBBAtCAAQLQoHES0KBRItCgkTLQoKFAAIAAwAJQAAG1YtAgAALQoRCy0IAQUnAgcEGQAIAQcBJwMFBAEAIgUCBycCCQQYACoJBwktCgcKDCoKCQwWCgwMJAIADAAADzYuDIBHAAoAIgoCCiMAAA8VLQgBBwAAAQIBLQ4FBy4IgEUAAyMAAA9ODSIAA4BPAAUkAgAFAAARdyMAAA9jLQsHBCcCBQQYLgIABIADKACABAQAGSUAABvKLgiABQAJACoJBQotDgsKLQ4JBy4IgEUAAyMAAA+cDCoDBQQkAgAEAAARSCMAAA+uLQsCBAAiBAIELQ4EAikCAAIAwdTnki0IAQQnAgUEBgAIAQUBJwMEBAEAIgQCBS0KBQctDgIHACIHAgctDgEHACIHAgctDgYHACIHAgctDggHACIHAgctDg8HLQgBAScCAgQGAAgBAgEnAwEEAQAiAQICLQoCBS4MgEcABQAiBQIFLgyARwAFACIFAgUuDIBHAAUAIgUCBS4MgEcABQAiBQIFLgyARwAFLQgBAgAAAQIBLQ4BAi4IgEUAAyMAABBuDSIAA4BNAAEkAgABAAAQ+yMAABCDLQsCAScCBAQFBiIEAgInAgYEAwAqBAYFLQgBAwAIAQUBJwMDBAEAIgMCBS0OBAUAIgUCBS0OBAUnAgYEAwAqAwYFACIBAgYuAgAGgAMuAgAFgAQuAgAEgAUlAAABcQAiAwIFLQsFBCcCBgQCACoFBgE3CwABAAQmACIEAgUAKgUDBi0LBgEtCwIFLgIABYADKACABAQABiUAABvKLgiABQAGACIGAgcAKgcDCC0OAQgtDgYCASIAA4BJAAEtCgEDIwAAEG4cCgMEAAAqDQQHACIJAgoAKgoDCy0LCwQwCgAEAAcBIgADgEkABC0KBAMjAAAPnAAiBAIJACoJAwotCwoFLQsHCS4CAAmAAygAgAQEABklAAAbyi4IgAUACgAiCgIMACoMAw4tDgUOLQ4KBwEiAAOASQAFLQoFAyMAAA9OACIEAgwAKgwDDi0LDgsnAgwEEC0IABAtCgcRLQoFEi0KCRMtCgoULQoLFQAIAAwAJQAAHFgtAgAAASIAA4BJAAstCgsDIwAADq8BIgAXgEkABQAiBAIKACoKFwstCwsHLQsJCg0iAAWATwALJAIACwAAEj0lAAAdfC4CAAqAAygAgAQEABglAAAbyi4IgAUACwAiCwIMACoMBQ4tDgcOASIABYBOAAcOKgUHCiQCAAoAABJ9JQAAEyAAIgMCDAAqDBcOLQsOCg0iAAeATwAMJAIADAAAEqAlAAAdfC4CAAuAAygAgAQEABglAAAbyi4IgAUADAAiDAIOACoOBxAtDgoQLQ4MCS0KBRcjAAANqygAgAQEeAANAAAAgASAAyQAgAMAABL7KgEAAQX3ofOvpa3UyjwEAgEmKgEAAQW+Hj//PqT2+jwEAgEmKgEAAQXqH6UZaDsOUDwEAgEmKgEAAQVFp8pxGUHkFTwEAgEmKgEAAQUHKoPuEPeQ8DwEAgEmJQAAEtMcCgIFACsCAAYAAAAAAAAAAAEAAAAAAAAAAAQqBQYHLQgBBScCBgQEAAgBBgEnAwUEAQAiBQIGLQoGCC4MgEcACAAiCAIILgyARwAIACIIAgguDIBHAAgtCAEGJwIIBAUACAEIAScDBgQBACIGAggtCggJLgyARwAJACIJAgkuDIBHAAkAIgkCCS4MgEcACQAiCQIJLQ4HCS0IAQcAAAECAS0OBQctCAEFAAABAgEtDgYFLQgBBgAAAQIBLgyARQAGLQgBCAAAAQIBLgyARAAILQsBCQAiCQIJLQ4JAS4IgEUABCMAABQxDSIABIBLAAkkAgAJAAAUsSMAABRGJAIAAwAAFFMjAAAUhScCAQQJLQgACS0KBwotCgULLQoGDC0KCA0uCIBKAA4ACAABACUAABxYLQIAACMAABSFJwICBAktCAAJLQoHCi0KBQstCgYMLQoIDQAIAAIAJQAAG1YtAgAALQoKASYMKgQCCSQCAAkAABTDIwAAFQEAIgECCgAqCgQLLQsLCScCCgQLLQgACy0KBwwtCgUNLQoGDi0KCA8tCgkQAAgACgAlAAAcWC0CAAAjAAAVAQEiAASASQAJLQoJBCMAABQxKgEAAQUC3G4ngHYSnTwEAgEmJQAAEtMtCAEGJwIHBBgACAEHAScDBgQBACIGAgcnAggEFwAqCAcILQoHCQwqCQgKFgoKCiQCAAoAABVwLgyARwAJACIJAgkjAAAVTy0IAQcAAAECAS0OBgcuCIBFAAUjAAAViA0iAAWATwABJAIAAQAAFaIjAAAVnS0LBwEmHAoFAQAAKgQBAi8KAAIAAS0LBwIuAgACgAMoAIAEBAAYJQAAG8ouCIAFAAMAIgMCBgAqBgUILQ4BCC0OAwcBIgAFgEkAAS0KAQUjAAAViCUAABLTLQgBBgAAAQIBLQ4EBi4IgEUABSMAABYODSIABYBPAAMkAgADAAAWKCMAABYjLQsGASYtCwEDLQsCBA0iAASATwAHJAIABwAAFkUlAAAdfAAiAwIIACoIBAktCwkHASIABIBJAAgOKgQICSQCAAkAABZtJQAAEyAtDgMBLQ4IAi0LBgMuAgADgAMoAIAEBAAYJQAAG8ouCIAFAAQAIgQCCAAqCAUJLQ4HCS0OBAYBIgAFgEkAAy0KAwUjAAAWDiUAABLTASIAAoBOAAQOKgIEBSQCAAUAABbTJQAAEyANKIBPAAQABQsiAAWARAAEJAIABAAAFvAlAAAdji0IAQQnAgUEDAAIAQUBJwMEBAEAIgQCBScCBgQLACoGBQYtCgUHDCoHBggWCggIJAIACAAAFzcuDIBHAAcAIgcCByMAABcWLQgBBQAAAQIBLQ4EBS4IgEUAAyMAABdPDSIAA4BOAAQkAgAEAAAXaSMAABdkLQsFASYAKgMCBA4qAwQGJAIABgAAF4AlAAATIA0iAASATwAGJAIABgAAF5UlAAAdfAAiAQIHACoHBAgtCwgGLQsFBC4CAASAAygAgAQEAAwlAAAbyi4IgAUABwAiBwIIACoIAwktDgYJLQ4HBQEiAAOASQAELQoEAyMAABdPJQAAEtMBIgABgEkAAy0LAwIBIgABgEsABC0LBAMcCgMFBhwKBQQAHAoEAwYBIgABgEMABS0LBQQBIgABgEwABi0LBgUcCgUHBhwKBwYAHAoGBQYBIgABgE0ABy0LBwYcCgYIBhwKCAcAHAoHBgYnAgcEBgAqAQcJLQsJCBwKCAkGHAoJBwAcCgcIBicCBwQHACoBBwotCwoJHAoJCgYcCgoHABwKBwkGJwIHBAgAKgEHCy0LCwocCgoLBhwKCwcAHAoHCgYnAgcECQAqAQcMLQsMCxwKCwwGHAoMBwAcCgcLBicCBwQKACoBBw0tCw0MHAoMDQUcCg0HABwKBwwFASIAAYBOAA0tCw0HHAoHDQIcCg0BABwKAQcCLQoHDS0KCQctCgsJLQoNCy0KAgEtCgMCLQoEAy0KBQQtCgYFLQoIBi0KCggtCgwKJioBAAEFVUVPBQl2Kjo8BAIBJioBAAEFJcfuEmsjjcA8BAIBJiUAABLTLQgBAwAAAQIBLgyARgADLQgBBAAAAQIBLgyARgAEJwIFBBAnAgYCCC4IgEUAAiMAABmJDCoCBQckAgAHAAAaCiMAABmbLQoFAiMAABmkDSIAAoBQAAUkAgAFAAAZwiMAABm5LQsDAS0LBAImLQsEBRgqBQYHACIBAggAKggCCS0LCQUcCgUIBgAqBwgFDioHBQkkAgAJAAAZ9SUAABMgLQ4FBAEiAAKASQAFLQoFAiMAABmkLQsDBxgqBwYIACIBAgkAKgkCCi0LCgccCgcJBgAqCAkHDioIBwokAgAKAAAaPSUAABMgLQ4HAwEiAAKASQAHLQoHAiMAABmJJQAAEtMtCAEEAAABAgEuDIBKAAQnAgYEAicCBwEBLQgBBScCCAQhAAgBCAEnAwUEAQAiBQIIJwIJBCBDA6oAAgAGAAkABwAIJwIKBCAuAgAIgAMuAgAKgAQlAAAdoCcCAgQhLgiASQADIwAAGsAMKgMCBiQCAAYAABrXIwAAGtItCwQBJi0LBAYEKgYGBwMogFAAAwAGDyIAA4BQAAgkAgAIAAAa/SUAAB4gDSIABoBQAAgkAgAIAAAbEiUAAB18ACIFAgkAKgkGCi0LCggcCggGAAQqBwEIBCoGCAkDKIBKAAYACAQqCAcGACoJBgctDgcEASIAA4BJAAYtCgYDIwAAGsAlAAAS0y0LBAULIgAFgEQABiQCAAYAABt4JwIHBAA8BgcBJwIFBAYtCAAGLQoBBy0KAggtCgMJLQoECgAIAAUAJQAAHjItAgAALQsBBS0LAgYtCwMHLQ4FAS0OBgItDgcDLgyASAAEASIABoBJAAItCwIBJi4BgAOABgsAgAYAAoAHJACABwAAG+UjAAAb8C4AgAOABSMAABxXLgAAAYAFAQAAAYAEAAEBAIADgASACS4AgAOACi4AgAWACwsAgAqACYAMJACADAAAHEMuAYAKgAguBIAIgAsBAIAKAAKACgEAgAsAAoALIwAAHBIoAYAFBAABAwCABgACgAYjAAAcVyYlAAAS0y0LBAYLIgAGgEQAByQCAAcAABx6JwIIBAA8BggBLQsDBgsiAAaAQwAHJAIABwAAHQ0jAAAcky0LAwYtCwEHLQsCCC0LBAkNIgAGgEMACiQCAAoAABy4JQAAHXwuAgAHgAMoAIAEBAAEJQAAG8ouCIAFAAoAIgoCCwAqCwYMLQ4FDAEiAAaASQAFDioGBQckAgAHAAAc+CUAABMgLQ4KAS0OCAItDgUDLQ4JBCMAAB17JwIGBActCAAHLQoBCC0KAgktCgMKLQoECwAIAAYAJQAAHjItAgAALQsBBi0LAgctCwQILgIABoADKACABAQABCUAABvKLgiABQAJASIACYBJAAotDgUKLQ4JAS0OBwIuDIBJAAMtDggEIwAAHXsmKgEAAQXFa8RaDhAAAjwEAgEmKgEAAQX0LuWEu/Qh0TwEAgEmKACABgQAAgcAgASABoAFLgCABIAIKACACQQAAA0AgAmABYAKFwCACoAKJACACgAAHh8DAIAIAAKACAEAgAOACYALLgGAC4AGAQCAA4AIgAsuAYALgAcBAIADgAmACy4EgAeACwEAgAOACIALLgSABoALAQCACQACgAkjAAAdvCYqAQABBSiGkrBH3P1DPAQCASYlAAAS0y4IgEUABSMAAB5CDSIABYBDAAYkAgAGAAAerSMAAB5XLQsCBS0LBQYAIgYCBi0OBgUtCAEGJwIHBAUACAEHAScDBgQBACIFAgcnAggEBAAiBgIJPw8ABwAJLQsBBS0LAwctCwQILQ4FAS0OBgItDgcDLQ4IBCYtCwMGDCoFBgckAgAHAAAewyMAAB8vLQsCBgAiBgIIACoIBQktCwkHLQsBCAAiCAIKACoKBQstCwsJACoHCQotCwMHLQsECS4CAAaAAygAgAQEAAUlAAAbyi4IgAUACwAiCwIMACoMBQ0tDgoNLQ4IAS0OCwItDgcDLQ4JBCMAAB8vASIABYBJAAYtCgYFIwAAHkI=",
      "debug_symbols": "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",
      "brillig_names": [
        "add_lock_public_user"
      ]
    },
    {
      "name": "commit_private_user",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "src_receiver",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "src_asset",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 90
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::include_by_timestamp::IncludeByTimestamp",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                          "fields": [
                            {
                              "name": "recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "content",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6418028854678020178": {
            "error_kind": "string",
            "string": "FundsNotSent"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc8s8t8xzyzy3zHPLPLfMc88898xzzzz3zHPPPPfMc88898xzzzz3zHPPPPfMc88898xzzzz3zHPPPPfMc88898xzzzz3zHPPPPfM8yj+qh6kSZbkSTWpTYo871SSKImTUoNTg1ODUyPyvAa1SZHnnUoSJXGSJGmSJXlSakhqaGpoamhqaGpoamhqaGpoamhqaGpYalhqWGpYalhqWGpYalhqWGpYanhqeGp4anhqeGp4anhqeGp4anhq1NSoqVFTo6ZGTY2aGjU1amrU1Kip0VKjpUZLjZYaLTVaarTUaKnRUuPO80b/cH/yeyWVpIdGkyBOkiRNsiRPqklt0p3ng0pSapTUKKlRUqOkRkmNkholNSg1KDUoNSg1KDUoNSg1KDUoNSg1ODU4NTg1ODU4NTg1ODU4NTg1ODUkNSQ1JDUkNSQ1JDUkNSQ1JDUkNTQ1NDU0NTQ1NDU0NTQ1NDU0NTQ1LDUsNSw1LDUsNSw1LDUsNSw1LDU8NTw1PDU8NTw1PDU8NTw1PDU8NWpq1NSoqVFTo6ZGTY2aGjU1amrU1Gip0VKjpUZLjZYaLTVaarTUaKnRpkYUqw0qSZTESZKkSZbkSTUpNTLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLP28xzumae0zXznK6Z53TNPKdr5jldM8/pmnlO18xzumae03WlRkmNkholNUpqlNQoqVFSo6RGSY2SGpQalBqUGpQalBqUGpQalBqUGpQanBqcGpwanBqcGpwanBqcGpwanBqSGpIakhqSGpIakhqSGpIakhqSGpoamhqaGpoamhqaGpoamhqaGpoalhqWGpYalhqWGpYalhqWGpYalhqeGpHnHkRJnCRJmmRJnlST2qTI806pEXnOQZwkSZpkSZ5Uk9qkyPNOJSk1Wmq01Gip0VKjpUZLjTY1oh5uUEmiJE6SJE2yJE+qSalRUqOkRkmNkholNUpqlNQoqVFSo6QGpQalBqUGpQalBqUGpQalBqUGpQanBqcGpwZPjaga6gvuRGvEqjz3mT8aO5CADBSgAg3owApsibFe0ECoEdQIagQ1ghpBjaBGUCOoMdQYagw1hhpDjaHGUGOoMdQYagI1gZpATaAmUBOoCdQEagI1gZpCTaGmUFOoKdQUago1hZpCTaFmUDOoGdQMarG01xV3WazuNdCADqzAlhiLfV0eWIAEZGCoxf0ba38NvNXGElMOrMCWGEuBDSxAAjJQgAqEWoVahVqFWiwUViiwAAnIQAEqMNQk0IEVGGp360Tp0cQCJCADBXirUQk0oAMr8Faj+8iiCGliAcaha2AE48D4s/jXMIV7nSGKwqKJBGSgABV4x+VQC1MYWIEtMUyB4xjCFAbeavd6PxRFRhMFqEADOvBWu5ckoSg1GhimMLAAbzWJ5gtTGHirSRxkmMJAAzow1EI4TKFjmMLAAiQgA281jcMJUxhoQAfeahoHGabQMUxhYKhJIAEZ6MAIFmcR2a1xE0RKj3+NI4uDjJQeaEAHVuB9ZBbHGyk9sAAJyEAB3moWBxkpPdCBFRhqceiR0gMLMNTiyCKlBwow1OL+jZS2FnireTRqpPTANjGqjCYWIAFvtbvOjKLSaKICDejACmyJkdIDC5CAUCtQK1ArUOvLBt5nLH3hwI4FSEAGSmIkpLdABd4S9QrEoQsOXXDokSI1GipSZCABGShABRrQgRXYEg1qBjWDmkHNoGZQM6jFE7LeKRKlOY+h1MCIoIECVKABHViBLTESZ2ABEhBqFWoVahVqFWoVahVqDWoNag1qDWoNag1qDWoNag1qLdWibGdiARKQgQJUoAEdWIFQK1ArUCtQK1ArUCtQK1ArUCtQK1AjqBHUCGoENYIaQY2gRlAjqBHUGGoMNYYaQ42hxlBjqDHUGGoMNYGaQE2gJlATqAnUBGoCNYGaQE2hplBTqCnUFGoKNYWaQk2hplAzqBnUDGoGNYOaQc2gZlAzqBnUHGoONYcavEThJQovUXiJwksUXqLwEoWXKLxE4SUKL1F4icJLFF6i8BKFlyi8ROElCi9ReInCSxReovAShZcovEThJQovMXiJwUsMXmLwEoOXGLzE4CUGLzF4icFLDF5i8BKDlxi8xOAlBi8xeInBSwxeYvASg5cYvMTgJQYvMXiJwUsMXmLwEoOXGLzE4CUGLzF4icFLDF5i8BKDlxi8xOAlBi8xeInBSwxeYvASg5cYvMTgJQYvMXiJwUsMXmLwEoOXGLzE4CUGLzF4icFLDF5i8BKDlxi8xOAlBi8xeInBSwxeYvASg5cYvMTgJQYvMXiJwUsMXmLwEoOXGLzE4CUGLzF4icFLDF5i8BKDlxi8xOAlBi8xeInBSwxeYvASg5cYvMTgJQYvMXiJwUsMXmLwEoeXOLzE4SUOL3F4icNLHF7i8BKHlzi8xOElDi9xeInDSxxe4vASh5c4vMThJQ4vcXiJw0scXuLwEoeXOLzE4SUOL3F4icNLHF7i8BKHlzi8xOElDi9xeInDSxxe4vASh5c4vMThJQ4vcXiJw0scXuLwEoeXOLzE4SUOL3F4icNLHF7i8BKHlzi8xOElDi9xeInDSxxe4vASh5c4vMThJQ4vcXiJw0scXuLwEoeXOLzE4SUOL3F4icNLHF7i8BKHlzi8xOElDi9xeInDSxxe4vASh5c4vMThJQ4vcXiJw0scXuLwEoeXOLzE4SUOL6nwkgovqfCSCi+p8JIKL6nwkgovqfCSCi+p8JIKL6nwkgovqfCSCi+p8JIKL6nwkgovqfCS2hPSA1tiT8iOcTgtkIAMFKACDejACmyJPSE7Qk2hFgkZsy1RXTRRgQZ0YAXeajFvFzVGEwuQgKFWAwWowFCLI4uEHFiBDzWKIfyoNppYgATkG0ug3UiBDqzAlhhbAlwSGHHjasa2AJcFMlCACgy1OOPYIGBgBbbE2CbginOL/QFiAD5qjChG0qPIiGLMPKqMqPQ/M6ADK7BNjFKjiQUYajWQgbdaDIlHvdFEAzqwAlti7CFAFliABGRgqMXhxG4CAw0YanFksafAwJYY+wrwFXirxfB5FCBNZKAAFWjAWy2G2qMMaWJL7Pt9dCxAAjJQgAo0INQYagw1gZpAre8DooEMFGDcJS3QgA6swJYY+4IMDLVo3743SEcGClCBBnRgBbbE2CtkINQMagY1g1rsEcJxkLFLyMCWGKYwsAAJyEABKtCAUHOoOdQq1CrUKtQq1CrUKtQq1CrUKtQq1BrUGtQa1BrUGtQa1BrUGtQa1NpU4yhcmliABGSgABVoQAdWINQK1ArUCtQK1ArUCtQK1ArUCtQK1AhqBDWCGkGNoEZQI6gR1AhqBDWGGkONocZQY6gx1BhqDDWGGkNNoCZQE6gJ1ARqAjWBmkBNoCZQU6gp1BRqCjWFmkJNoaZQU6gp1AxqBjWDmkHNoGZQM6gZ1AxqBjWHmkPNoeZQc6g51BxqDrXwkthOJOqgBoaXDCxAAjIwJCzQgA6swJbYDaRjARKQgQKEWoNag1qDWku1cl3AAiQgAwWoQAM6sAKhVqBWoFagVqBWoFagVqBWoFagVqBGUCOoEdQIagQ1ghpBjaBGUCOoMdQYagw1hhpDjaHGUGOoMdQYagI1gZpATaAmUBOoCdQEagI1gZpCTaGmUFOoKdQUago1hZpCTaFmUDOoGdQMagY1g5pBzaBmUDOoOdQcag41h5pDzaHmUHOoOdQcahVqFWoVahVqFWrwkgIvKfCSWHnsMWcd2BLDSwaGXUkgARkoQAUa8FaTUAsvGdgmxipkjznrwAIkIAMFqMBQa4EOrMCWGF4ysAAJyEABKhBqBWoFagVq4SXSt0QrQAIyUIAKvNXuGheOcsOJFXir3XUr3LcsHFiABLzjKgdGBAlsieEPAyNCXKHwh4EMvI/33niC+yaFAw3owFDrG8G1xPCHgQUYcaP5Iufv0hjuWxIObImR8xISkfMDCchAASrQgA4MtWjfyPmOkfMDC5CADBSgAg3oQKg51CrUKtQq1CrUIuctrnFk98AKbImR3QMLkIAMRNzI7oEGhFqDWku1vqHhwAIkIAMFqEADOrACoVagVqBWoFagVqBWoFagVqBWoFagRlAjqBHUCGoENYIaQY2gRlAjqDHUGGoMNYYaQ42hxlBjqDHUGGoCNYGaQE2gJlATqAnUBGoCNYGaQk2hplBTqCnUFGoKNYWaQk2hZlAzqBnUDGoGNYOaQc2gZlAzqDnUHGoONYeaQ82h5lBzqDnUHGoVahVqFWoVanCNqDycCDV4CcNLGF7C8BKGlzC8hOElDC9heAnDSxhewvAShpcIvETgJQIvEXiJwEsEXiLwEoGXCLxE4CUCLxF4icBLBF4i8BKBlwi8ROAlAi8ReInASwReIvASgZcIvETgJQIvEXiJwEsEXiLwEoGXCLxE4CUCLxF4icBLBF4i8BKBlwi8ROAlAi8ReInASwReIvASgZcIvETgJQIvEXiJwEsEXiLwEoGXCLxE4CUCLxF4icBLBF4i8BKBlwi8ROAlAi8ReInASwReIvASgZcIvETgJQIvEXiJwEsEXiLwEoGXCLxE4CUCLxF4icBLBF4i8BKBl0j3Eglsid1LOhYgARkoQAUa0IFQa6mm1wUsQAIyUIAKNKADQ+J+xdZuIB0LkIAMFKACDejACoQaQY2gRlAjqBHUCGoENYIaQY2gxlBjqDHUGGoMNYYaQ42hxlBjqAnUBGoCNYGaQE2gJlATqAnUBGoKNYWaQk2hplBTqCnUFGoKNYWaQc2gZlAzqBnUDGoGNYOaQc2g5lBzqDnUHGoONYeaQ82h5lBzqFWoVahVqFWoVahVqFWoVahVqFWoNag1qDWoNag1qDWoNag1qDWotVSz6wIWIAEZKEAFGtCBFQg1eInBSwxeYvAS616igaFWAw3owApsid1LOhYgARkoQKgR1AhqBDWCGkOte0kLJCADBahAA4aaBd5q3rElhpcMLEACMlCACjSgA6EmUFOoKdQUago1hZpCTaGmUFOoKdQMagY1g1q4xr0oLkdV5WNEI7Alhj/cX3twVFVOJCADBajA+3hr3H3hDwMrsCWGP9Q4svCHgQQMtTje8IeBCgy1uHfCHwZWYEsMf6hxl4QTtDjjcIKBCjTgHfderImjfpJaJFk4wf0BPUf95GNMJPA+i7sehqN+ku7KF476yYkCVGCotUAHVmBLvJ2A78oXjqJJvr9Y5Sia5CsO505/vgtbOIom+YrDudP/MTwS6MAKbIl3+k8sQALeaiWO4U7/iTZvrqiUnFiBLTFyfmABEpCBAlQg1BhqHCcUTcItUS5gnFA0lBCQgQJUoAEdWIEtUS8g1BRqGmpxvCpABRrQgRV4q1G0+p3zEwuQgLfaXb/DUSk5UYG3GsWRWTqMWwWmw0Sl5MQCJCADBahAA0LNoeZQq1CrUKtQq1CrUKtQq1CrUKtQq1BrUGtQa1BrUGtQa1BrUGtQa1BrqRaVkhMLkIAMFKACDejACoRagVqBWhjI/Q00R6XkxLhL+i8o0IAOvO9JaoEtMQxkYAESkIECVOCtdtd+cawTNzHO7b6ra5/giN/tExwd77jcf0GACjSgAyuwJYZr3IVZHOWcEwkYahIoQAWGGgU6sAJzKqP2XkfHAiQgAwWoQAM6MCdOonCzT/9E4ebEOIu48uEPAxVoQAdWYEv0aDMPLEAChloNFKACQy1uLndgBeZ0VS/nHFiABGSgABVoQAfm5FisEsdR2xE1nBMZKMD7LKKKI2o4JzqwAqOQ974ArddMdyxAAjJQgAo0oCf21RA63mcR87FRrTmRgQJUoAHjLGpgBbbEyPmBodYCCcjAW+3+sp+jWnOiAW+1mLOMak2OOzWqNfn+Wp+jWnNiARKQgQIMNQs0oAMrsCWGEwwsQAIyUIBQE6gJ1ARqArV4f4i50KjWnEjAWy2G0qJac6ICDejACrzVopcU1ZoTC5CAoeaBAlRgqMWFDX/wkAh/GNgSwx8GFiABGShABd5qHvdD+MPAUIs71VtivYAFGGpx6JWBAlSgAR1YgS2xhVpcoXCNgaEWrROuMVCACjRg7asicdRt8r24gETd5sQCJCADb4XbCCTqNica0IEV2BKjp3F3syTqNicSkIGhVgMVaMBQa4EV2BLDP1oJvNXuHpdE3Sa3OJzwj4ECVKABPbEXWAWVJEriJEnSSZHAd89OonByogMrsCVGAg8sQAIyUIBQU6gp1BRqCjWDmkHNoGZQM6gZ1AxqBjWDmkHNoeZQc6g51BxqDjWHmkPNoeZQq1CrUKtQq1CrUKtQq1CrUKtQq1BrUGtQa1BrUGtQa1BrUGtQa1BrqRY1lBMLkIAMFKACDejACoRagVqBWoFagVqBWoFagVqBWoFagRpBjaBGUCOoEdQIagQ1ghpBjaDGUGOoMdQYagw1hhpDjaHGUGOoCdQEagI1gZpADV5S4CUFXlLgJQVeUuAlBV5S4CUFXlLgJQVeUuAlBV5S4CUFXlLgJQVeUuAlBV5S4CUFXlLgJQVeUuAlBV5S4CUFXlLgJQVeUuAlBV5S4CUFXlLgJQVeUuAlBV5S4CUFXlLgJQVeUuAlBV5S4CUFXlLgJQVeUuAlBV5S4CUFXlLgJQVeUuAlBV5C8BKClxC8hOAlBC8heAnBSwheQvASgpcQvITgJQQvIXgJwUsIXkLwEoKXELyE4CUELyF4CcFLCF5C8BKClxC8hOAlBC8heAnBSwheQvASgpcQvITgJQQvIXgJwUsIXkLwEoKXELyE4CUELyF4CcFLCF5C8BKClxC8hOAlBC8heAnBSwheQvASgpcQvITgJQQvIXgJwUsIXkLwEoKXELyE4CUELyF4CcFLCF5C8BKClxC8hOAlBC8heAnBSwheQvASgpcQvITgJQQvIXgJwUsIXkLwEoKXELyE4CUELyF4CcFLCF5C8BKClxC8hOAlDC9heAnDSxhewvAShpcwvIThJQwvYXgJw0sYXsLwEoaXMLyE4SUML2F4CcNLGF7C8BKGlzC8hOElDC9heAnDSxhewvAShpcwvIThJQwvYXgJw0sYXsLwEoaXMLyE4SUML2F4CcNLGF7C8BKGlzC8hOElDC9heAnDSxhewvAShpcwvIThJQwvYXgJw0sYXsLwEoaXMLyE4SUML2F4CcNLGF7C8BKGlzC8hOElDC9heAnDSxhewvAShpcwvIThJQwvYXgJw0sYXsLwEoaXMLyE4SUML2F4CcNLGF7C8BKGlzC8hOElDC9heAnDS6Qneg1siT3RO8ZYbRAlcZIkaZIleVJNapOicKFTalBqUGpQalBqUGpQalBq3Gkt99oDEsWTEwuQbqRABsqNEeFO64kGdGAFtkS5gAVIQAZCTaAmUBOoSajFBZOWqBewAAnIwFDzQAUaMGbkg2pSmxTFCp1KEiVFxI5xpC3wPtIS7X0n6cQCJOB9pCWuwp2kExVoQAfGfElQm1RDiwMLkIChFe1aBajA0IpWqQ68z6zESdaW2C5gzD4EURInSZImWVJEvJstyhofuRF4H+k9MSxR1jhRgQa8jzRGwmKNyYkt8c7piQUYY8dBnCRJMSgeZEmeVJPapHhodwoRCSQgAw0Yhxl/Fgk7MKYmgiiJk6JFPFCBBowWiTaNbB14S3E0b2TrwPtgORoysvWe8ZOoVJS4QFGpKL1RIlsHGtCBFdgSI1sHFmCoxfFGtt7zahKVisJxvHdeisRB3okpEgd5Z+bAOzUnFiABGSjACBanGYnaMRJ1YAESkIGSGDkn0VCRcwMJyMD4s7iEkXMS1zpyrsfypJrUJkW+dSpJlMRJkqRJqdFSo6VGmxpRLTioJFESJ0mSJlmSJ9Wk1CjRIBYY1hykSZbkSTWpTaIrqSRREielBqUGpQalBqUGpQanBqcGpwanBqcGpwanBqdG5No9+ShRyTeRgXegexZRopJP7nlIiUo+ued5JWr25J4klKjDk/u7RYk6PNH43XiuDXTgfXIWzR/50zHyZ2ABEpCBAlTgrWZxbvfr6sQKDLU4t0gli8OJVBp4x/X43XjmDTSgAyv+rCVGBg4sQKhVqEUGDjRgHHpQTWqTIu86lSRKuoPftR4SJXoTFVgnRtmd3NODEmV3cs8JSpTdTRSgAg3owAq8j/WeNJQou5tYgKGmgQwUYKhZoAEdWIEtMXJwYAESkIECDDUPNKADQ60GtsTIxoEFGGotkIECvNVqXIDIyYEOrMBbrcYVikfkwAIk4K0WU5BRjDdRgaEWZxyPyIEV2BLjETmwAAnIwFCLhorEj4nJKLCTuxRUosBuIgEZeB9ZzFxGKd3ECmyJ8VyMOcoopZtIwIgbt1EkaPSuojxuYCTowAIkIAMFqMA43jjjyNWBFdgSIzWjAxeFcBMFqMCIG80Xz8WBFdgmRiHcxAIk4ENNo5MVJW8THViB7cb7louSt4kFSEAGClCBlkgRjAILkIAMdGAFtkRGMEYwRjCOYBwoQAUa0IEV2BLlAhZgqEkgA2+1OOE73QZZkifVpDbpzrRBJYmSQkQDBahAAzqwAluiXcACjLgWGBE88I4QrXrnXqc79QaVJEripIhYAxVoQAdWYEus0cxxG9do0bhLqwHjHT+oJrVJ8YjsVJIo6T7Q6LVGFdpEBRrQgXVi1JtpdGGjskzv+mSJyrJ4FYrCskGedP95/702KXKtU0miJE4KEQtUoAFbYiRX9JOjdGyiAO8Icez3w26QJ9WkNikSr1OceA0kIAMFqEADOrACW2Lk3UCoCdQi76JXHkVjExV4q1FcqEi9gXFDx1lE8kV3N4rGNEYromhsIgFDLYQjAQeGWguMRgzhSMBo48i/Tm1SZF+nkkRJcVVKYFyCOOjIvehkRwnYxAK8A0QvP0rAJgpQgQaMuHGCkWrR7Y2yLo1ub5R1TVSgAR1YgS2xXcACDLVouEjDgQK81aJ3EmVdEx1YgZFIjzbTKPGaWIAPtfu9X6PCa5Ak3VItyJI8qSa1SZGvnUKEAgnIQAF6YjwPbxfSqNaaGBEkkIECfByp9V+1JE+qSW3SnbKDShIlcZIkpQanBqcGpwanhqSGpIakhqSGpIakhqSGpEZk6D0GoVEVNjAydGA0mQcSkIHRZHGBIkMHhhtH+0eGDqzAlhhJOvBW0ziySNOBt5rGVYkHp8aRRfbeZagaVWETHRhqcZCR0x0jpwfeTRi/eqf0IE6SJE2ypIhYb4xs7rdoZHO/0yObByrQgPeRWpx2ZPPAlhjZPLAA70ONw49ktmiWSOZ+YJHMA0MsjvFO27tfpVG1ddc5au78qbnzp+bOnxq1WXr3WTVqswZGNg4sQAIyUIAKNKADoVagRlAjqEXq3l1ojdqsiQJUoAEd2GYb3Dk7qCQ94rf4vdgDtJMkRfBoonjEDnRgBbbEeMQOjFPRQALGqUigABVofRtcLXPbXy1z218tc9tfLXPbXy1z218tc9tfLXPbXy1z218tc9tfLZoamhqaGpoalhqWGpYalhqWGpYalhqRq/dwgEbV1cSWGLnab9t4/g4kIAOj0eICxvP37vhrmfv/apn7/2qZ+/9qlFzpXYOsUXI1sQAJyEABKtCADqxAqDWoNajFZsBx4rEZcCdJ0iRL8qSa1AZFqdWgkkRJnBTnUwIVaEAHVmBLDFsYWIAEZGCoUaACDdgSI9WrBEYEDRSgAg0YxxvnFu/WA1tivF0PLEACMlCACjQg1BhqDDWBmkBNoBa5f4/maJROTQy1FmhAB8br0hXYEuPhPbAACchAASowXs3iYsXDe2AFtsR4eMcTI0qnJhKQgQIMtRpoQAdWYEsMQxh4P7yvuEvi6T2QgQK8H+BXCMcTfKAD71etK+6d2xPsConbEyYWIAEZKEAFGtCBFQi1BrUGtQa1BrUGtQa1BrUGtQa1lmpROjWxAAnIQAEq0IAOrECoFagVqBWoFagVqBWoFagVqBWoFagR1AhqBDWCGkGNoEZQI6gR1AhqDDWGGkONocZQY6gx1BhqDDWGmkBNoCZQE6gJ1KIXcA/uaJROTbzV7sEdjdKpiS3x9pKJt9o9/qJROjWRgQJUoAEdWIGhdlt8lE5NpPkMiHqpiQIMCQs0YEjEGVsFtkQPiTj5MJCBBLxPiOKMw0AGKtCADqzAlhgGMrAACQi12yriTSYKowbVpPuN9TbcqIoaVJIiYkcGClCBBnRgHH+0bJhEYKxiN/EWkyBK4iRJ0iRL8qSa1Cbd3jAoNUpqlNQoqVFSo6RGSY2SGiU1KDUoNSg1wg7uYSqNaquJCoyOVP9dB0avrf9CS4xXi4HRa6uBBAw1DRRgqFmgAR14n5YHtUm3GQwqSZTESRGxY1zdOJBI7ntATaOAaiIBGRjjCSVQgQZ0YAXGwEWcYCT3wAIkIAMFGGpxDJHnAx1YgbfaPUylUXI1sQBvtRgVipIriyGOKLmaqEADOrACW2Lk+cACJCDUKtQq1CrUKtQq1CrUGtQa1BrUGtQa1BrUGtQa1BrUWqrF6nMTC5CADBSgAg3owAqEWoFagVqBWoFagVqBWoFagVqBWoEaQY2gRlAjqBHUCGoENYIaQY2gxlBjqDHUwhnukgKN8q6JoeaBBnRgBd5q93fpGuVdEwuQgAwUoAINeKvds2Ma5V0Dw0Bi4C5quiYSkIEhwYEKNKAD6/SoqPQaGAYysAAJyEABKtCAd9xosnCKTiXpETTGmqLga5AkxfFLoAEdWIEtMUxi4K0UxxEe0YmToqnijgiHGGjA+wWhB6pJbdJtD4NKEiVxkiRpkiWlRkuNNjWiRmxQSaIkTpIkTbIkT4oWs8CWGGYwMO6vGkjAGKy9AgWowBivLYEOrMCWGGYwsAAJyMBQo0AFGtCBoRanGWbQMcxgYAESMNQ0UIAKvNsxGuf2gkE1qU26jWBQSaIkTpIkTUoNSQ1JDUkNTQ1NDU0NTQ1NjTAB6xjN1gIdWIEtMUxgYAESkIECVCDUDGoGNYNa94a4k7o5dCQgAwWowFstXuGjiG1iBbbEMIiBBUhABgpQgVCrUKtQq1BrUGtQa1BrUGtQa1BrUGtQa1BrqRYLz02MuDXwrrpvQTXp/qPo40Uh28QCJCADBXgfYgysRSHbRAdWYKjFcUX+DyzAUIujjfwfKMBQi0OP/B/owAq81WKMLUrWLIbQomRtogAVeMeNcbMoWbMYPY+SNbtrrjRK1iyGtKNkzWKELErWrIVwPPYHMlCAd8pfcWSR8wMdWIF32sfAWtSp+RWHE+keQ2hRp+ZXtG8kfAxBRJ2alzihO+MnOrACW+Kd8RMLMJ7QcQzGwJCIwzEDOjAk4iCtJfoFLEACMlCACjSgA6HmUKuhFk1SC5CADBSgAm+16JZHKdzECmyJ8TYQvdhYKW4iAW+16IM60tyR5o40d6S5I80daV6R5lEgN5GADBSgAg3owAqEWoFagVqBWoFagVqBWoFagVqBWoEaQY2gRlAjqBHUCGoENYIaQY2gxlBjqDHUGGoMNYYaQ42hxlCLV4QYXIjCu4lxl8QvxFvCQAYK8L4n7zocjdK7iQ6swJYYbwsDC5CAt1qMIEQF3sQ4NwqMuB1bYljFwAKMuBzIQAEqMAoJWqADK7Al9kKCjgVIQAZG60igAyuwJYY/DCzAOF4NjAhxsSLnOa5F5HzHyPmBEaEGEjDaIY4segEDFRjv6HEtekegYwW2ia33BToWIAGjO1ACBahAAzqwAqM05b5CUarX2yFq9SYKMOJSoAEdWIEtkeIsQoIKkIAMjLMINVKgAUPNAyuwJXKo1cACJGCoSWCotcBbLXrkUd7n0Q2P8r6JNTHyOPreUcg3kYECjLhxbj1jLbAl9oztWIAMjCq1jg6swKhSi5OPKcOBBUhABgpQgQb0xHiMRwc7qvUmEpCBcfJxseIxPtCADpy1gTpq+AKjYGBgARKQgQJUoAFnLan2Gr6BcRYdCchAAcZZRDtE8g50YAW2gRY1fBOj8rMjARkoQAUa0IEV2BKjTGBgnEUNFKACDRhn0QIrsCVG8g6Ms5BAAjJQgAo0oANrYqTpPahgUdM3kYECjP5zCTSgAyuwJfaOescCJGCoUaAAFWjAUOPACmyJvcveMdosDr1XwXdkoAAVaEAHVmBLjOy+uwQW1Xxu0ajxEB6owDgLDYyziJsgXt0HtsTI+YEFSEAGCjDU4oaJh7DHQUYeX3F7xuPWo9XjxXugAR0YEaLV4yHcMR7CAwuQgAwUoOYxRPneQAdWYJsYK7RNLEACMjDOggMdWIEtsX9LRoEFSEAGClCBBnRgTcwvpa3kl9JW8ktpi8o+v4vkLCr7JsZZxAnF43ZgBcZZ3Jc7qvwmFuB9Le7KK4tCv4kCVKABb7UarRN5PLAlRh4PLEACMlCAETfOOL4EozjNeMbWjgJUYByZBTowjizaIV6QO8YL8sA4smiHeEEeyEABKtCADgy1FtgSIzcHFiABGSh5xvHkbdHUkZsDW2K8IA+8496DJBalehMZKMD7nqT+ZwZ0YAW2xP7JdccCJODdOi1u5XjyDnRgBcZZ3Jc7ivMmFiAB7wy46zQsCvQmKtCADqzAlhh53PG+wR/p5cG6sC3sC9eFG/i+zZPLwrQwL7zoyqIri64suhr/fnchLMrQkuvCDWzXwmVhWpgXloV14UXXFl1bdG3R9UXXF11fdH3R9UXXF11fdH3R9UXXF9266NZFty66ddGti25ddOuiWxfduujWRbctum3RbYtuW3TbotsW3bbotkW3LboNulGxllwWpoV5YVlYF7aFfeG68KJbFt2y6JZFtyy6ZdEti25ZdMuie+dXu8e+Leq8Bt7ZNbEACchAASrQgA6EmkBNoaZQU6gp1BRqCjWFmkItasfvGVeLOq+BUT0+sAAJyEABKtCADoSaQc2h5lBzqDnUHGoONYeaQ82h5lCrUKtQq1CrUKtQq1CrUKtQq1CrUGtQa1BrUGtQa1BrUGtQa1BrUGupFuVgEwuQgAwUoAIN6MAKhFqBWoFagVqBWoFagVqBWoFagVqBGkGNoEZQI6gR1AhqBDWCGkGNoMZQY6gx1BhqDDWGGkONocZQY6gJ1ARqAjWBmkBNoCZQE6gJ1ARqCjWFmkJNoaZQU6gp1BRq8BKBlwi8ROAlAi8ReInASwReIvASgZcIvETgJQIvEXiJwEsEXiLwEoGXCLxE4CUCLxF4icBLBF4i8BKBlwi8ROAlAi8ReInASwReIvASgZcIvETgJQIvEXiJwEsEXiLwEoGXKLxE4SUKL1F4icJLFF6i8BKFlyi8ROElCi9ReInCSxReovAShZcovEThJQovUXiJwksUXqLwEoWXKLxE4SUKL1F4icJLFF6i8BKFlyi8ROElCi9ReInCSxReovAShZcovEThJQovUXiJwkuirKzdkzsWZWXtnm6xKCubWIEtMbxkYAESkIECVCDUFGoKNYWaQc2gZlAzqIWX3FMzFhVmEw3owApsieEl9+C4ReXZRALeavGOGMVnExVoQAdWYEsML7mnOiyqz5rEWYSXDGSgABVoQAdWYEsMLxkItQa1BrUGtQa1BrUGtQa1lmpRjTaxAAnIQAEq0IAOrECoFagVqBWoFagVqBWoFagVqBWoFagR1AhqBDWCGkGNoEZQI6gR1AhqDDWGGkONocZQY6gx1BhqDDWGmkBNoCZQE6gJ1ARqAjWBmkBNoKZQU6gp1BRqCjWFmkJNoaZQU6gZ1AxqBjWDmkHNoGZQM6gZ1AxqDjWHmkPNoeZQc6g51BxqDjWHWoUavMTgJQYvMXiJwUsMXmLwEoOXGLzE4CUGLzF4icFLDF5i8BKDlxi8xOAlBi9xeInDSxxe4vASh5c4vMThJQ4vcXiJw0scXuLwEoeXOLzE4SUOL3F4icNLHF7i8BKHlzi8xOElDi9xeInDSxxe4vASh5c4vMThJQ4vcXiJw0scXuLwEoeXOLzE4SUOL3F4icNLHF7i8BKHlzi8xOElDi9xeInDSxxe4vASh5c4vMThJQ4vcXiJw0scXuLwEoeXOLzE4SUOL3F4icNLHF7i8BKHlzi8xOElDi9xeInDSxxe4vASh5c4vMThJQ4vcXiJw0u8e4kGMlCACjSgA0OtBrbE8JK75sGiGm4iARkoQAUa0IEVeKvdJRgW1XATC5CADBSgAkNNAh1YgS0xvGRgARIw1DxQgAq81WJKOKrhJlbgrRbzy1ENN7EAb7W7qtuiGm6iAOO69d8NtRbowApsieElAwuQgAy81WJqMarhJhrQgRXYEsNLBhbgreZxFuElAwUYanEM4SUDHXirxaxdVMMNDC8ZWIAEZKAAFXirxbRerEc3sQJbYnjJwAIkIANDLQ49vGSgAR1YgS0xvGRgARKQgVBzqIWXxAReVM5NrMCWGF4ysAAJyMDwko4KNKADK7Al9veSjgVIQAZCrUGtQa1BrUGtpVq7LmABEpCBAlSgAR1YgVArUCtQK1ArUCtQK1ArUCtQK1ArUCOoEdQIagQ1ghpBjaBGUCOoEdQYagw1hhpDjaHGUGOoMdQYagw1gZpATaAmUBOoCdQEagI1gZpATaGmUFOoKdQUago1hZpCTaGmUDOoGdQMagY1g5pBzaBmUDOoGdQcag41h5pDzaHmUHOoOdQcag61CrUKtQq1CjV4SYOXNHhJg5c0eEmDlzR4SYOXNHhJg5c0eEmDlzR4SYOXNHhJSy/xK73Er/QSv9JL/Eov8Su9xKPor93fnngU/U10YLiyB7bE8JKB4cotkIAMvNXur1c8SgEnGvCeOL2uOJ7bTJIb+LaTB3NwWZgW5mAKloV1YQvWYF+4LjzfUfzKdxS/8h3Fo1gwXiA8igUnCjDeGizQgA6Md5QerCX2d5SOcY53nZ1HtWAyLxznWEIxii8m28JxjiUupdSFG1ijbUscmJaFaeEYBO14HzBHS/XB1Y4FSEAGClCBBnRgBULNoeZQc6g51BxqDjWHmkPNoeZQq1CrUKtQq1CrUKtQq1CrUKtQq1BrUGtQa1BrUGtQa1BrUGtQa1BrqRaVhRMLkIAMFKACDejACoRagVqBWoFagVqBWoFagVqBWoFagRpBjaBGUCOoEdQIagQ1ghpBjaDGUGOoMdQYagw1hhpDjaHGUGOoCdQEagI1gZpATaAmUBOoCdQEago1hZpCTaGmUNNuRR4cVnTX1HlUMibXhRs46r0ml4VpYV5YFtaFF11bdG3RtUXXu24JLgvTwrywLKwLd+utwb5wBdc5G+SlW0hHASrQgA7sZ8HBDdyuhftZSDAtzAv3s4ir1nRhW9gXrgu35Ch7TC4L08K88Jz5croUaMAuasF14QYu18JlYVqYF5aF+8m2YFvYF64LN3B/ExlcFqaFGczx7xznxbywLDzH2ZxyfNQpx0edcnzUKcdHnXJ81CnHR51yfNQpx0edcnzUSaAmUBOoCdQEago1hZpCTaGmUFOoKdQUago1hZpBzfINM+o+JzIw3zCj6HOiAeO63l8cei/5nNzA3QIGl4VpYV5YFtZ8U+0ln5N94a5LwQ1cr4XLwrQwLywL68KhGxbcSz4n14UbuJvF4LIwLcwLy8JdN9q2m8VgX7gu3JJ7yefksjAtzAtLvuH3ks/JtnBvZwquCzdw94v7U0jvJZ+TaWFeWBbWhW1hXxg9CB49l+DRc+kcuuFx3P1iMC8sC+vCtrAvXBcO3ciaWMIwuSxMC/PCsrAubAv7wl03zqv3Su6ljZx7r2SwLmwL+8J14QbuvZLBZeE5QOy9gHWgALuoB9vCvnBduIH7+8fgsjAtHCer0eD9/WOwLmwL+8J14Qbu5jO4LBy6GjdwN5/BsrAu3HXjAnXzGVwXbuBuPoPLwrQwLywLz4F47+WtAx3YRSW4gbvzDC4L08K8sCysC/eTjYvSnWdwXbglS3eewWVhWpgXloV7/PsGk+4Y92eBLt0xBsvCurAt7AvXhRu4O8bgmKuwQAIysIuWYF3YFvaF68IN3O1icFm4n6wE88KysC5sC/vCdeEGlmvhrhvn1Qc9BvPCsnDXjQvU7WWwL1wXbuBuL4PLwrQwLxyjO3H9VYEG7KI1uC7cwN1eBpeFaWFeWBaOk/W4KN1eBvvCdeEG7vYyuCxMC/PCPT4H+8J14QbuNjK4LNzjx8XtNjI4zuv+5s+lv8MM7rpxcfs7zOCuGxeiO0nn7iQe7dOdZHDXjevSnWRw6NbIrO4kg0O3xrl3JxkcuvcKRC7dSYK1O8n9iZ9rd5LBoXt/7+fanWRw19VgXbjrWrAv3HU9uIH7O8z9fZ5rf4cZ3HVbMC8cuvdnda7dkQaHbotz6Y7U4vi7I8XAr3ZHanGc3ZEGl4VpYV5YFtaFbWFfuC686PKiy4suL7q86PKiy4suL7q86PKiy4uuLLqy6MqiK4uuLLqy6MqiK4uuLLpjJDauyxiJ7VwW7rpxb3RTGiwL68K2sC9cF27g7kvRmdLuS4NpYV5YFtaFbWFfuC5865Yrzit8aXJZmBbmhWVhXdgW9oX7sEvc592vOne/Gtx1SzAtzAvLwrqwLewL14X7+UZOtWvhsjAtzAvLwrqwLewLd93whNaSo5j2wS04dOO+su5XMQtg3a8Gy8K6sC3sC9eFMbNg3a8Gl4UX3bLohl+VuC5RW5tsC/vCdeEGDr+aXBamhXnhrsvBurAt7AvXhRuY++97sC9cF25guRYuC/fjjGsnDNb++3EdtSxMC8fvxyBglLwm68K2sC9cF27g8IfJZWFaeNG1rmvBurAt7AvXhRu4+8PgsjAt3HXj3Ls/ULRh94fBtrAvXBdu4HotXBamhft9G8fQ32cG68KhG2N81v1hcF24gbs/DC4L08K8cJwvR5t3fxhsC/vCdeGW7N0fBpeFCTzGTK5gWpgXzmE/lLM6ylkd5ayOclZHOaujnNVRzuooZ3WUszrKWR3lrI5yVkc5q6Oc1VHO6ihndZSzOspZHeWsjnJWRzmro5zVUc7qKGd1lLN6L2eNfnovZx1IwFk66L2cdaAC+3WVYF+4LtzA3S8Gl4VpYV44VDsq0IBdVIPrwg3czWJwWZgW5oVl4X4T12Bb2BeuCzdwN4vBZWFamBfuui1YF7aFfeG6cAN3sxhcFqaFZ5mm94LXgQoM0RjF8+4Ug+vCDdydYnBZmBbmheNk+33YnWKwLewL14Vbcu1OMbgsTAtj9Lb2N4nBurAt7AvXhTFqXMu1cFk4RgNDNmaRBwrwbuO7kNVHKWxHB/YzleAG7u8Qg/uZWjAtzAv3FvZgXdgWjhaOob3a3yEGN3D0eSaXhWlhXlgW1oVDN3yj9neRwXXhBu7vIoPLwrQwLywLRyNHM8SM0kAHdtFo8G5QnbtBDS4L08K8sCysC/eT1WBfuC7cwN2jBpeFaWFeWBbu48vBjkHq6mVhWpgXloV1YVvYF64LZ1lSL4odWIAYpK797WSwLKwL28K+cF0Yg+O1YZC6trIwLcwLy8K6sC3sC9eF+7jtfXHbGLftXBamhTFI3S5ZWBe2hX3hujAGx1u5Fi4LZ/lXL5kdKEAMUrc+1DLYF64LY3C80bVwWZgWxiB1I1lYF7aFfeG6MAbHG18Ll4V7/BaMQeom18JlYVqYF5aFdWFb2Beuc4i718J2jDnogRikbmPQtjMvLAvrwrawL1wXxiB1s2vhsjAtzAvLwrqwLewLd904rz5u27nby+CyMAapm/PCsrAubAv7wnVhDI63ei1c5hB3r5QdyEAMUrduL4NtYV+4LozB8dauhcvCGKRujReWhXVhW9gXrgvn4Hi9rmvh7vkeLAvrwrawL1wX7s+aenO5Fu7PmhZMC4fufefXqw+CDA5di2PrgyCDQ/d+gam9ZHZy6N5vPrWXzE4O3ftmq71kdnLX1WBZuOtasC3cdeMc+wvM4K4b59hfYAZ33TjH/gIzOHQ9zrG/wAwO3X4t+gvM4ND1OMf+AjM4dD3Osb/ADA5dj3PsLzCDu26cS3+B8Th+6bpxzL2T5XGcvZM1uC7cwP0dZnBZmBbmhWVhXXjR1UVXF11ddG3RtUXXFl1bdG3RtUXXFl1bdG3RtUXXF11fdH3R9UXXF11fdKMYt8btFsW4AyswRGvcGL2TNbgsTAvzwrKwLmwLx8nWuGF6P2twA/d+1uCyMC3MC8vCunDXjZuw97MG14Vbcun9rMFlYVqYF5aF40srDzSgA7uoBjdwd6rBZWFamBeWhXXhfrI12BeuCzdwd6rBZWFamBeWhUP3nsqqpTvV4NC9p7Vq6U7VonFofshWe+3uwAIkIAMFqEADOrACoSZQ6+50T73U0t1pMC8sC+vCtrAvXBdu4O5Og7tu3APdnQbzwrKwLmzgvuLiPb1RewXuZF3YFvaF68ItOK5XX3FxcP/9uHZ9pcTBDdxXSrziePpKiYNpYV5YFtaFbWFfuC7cwG3R7Ssl3lMptdfYTuaFZWFd2Bb2hevCLbnX2NI9zVB7jS3dm6bUXmM7mReWhXVhW9gXrgs3cP/Sp2MBErCLSrAsrAvbwr5wXbiB6Vq4n6wH08K8sCysC9vCvnBduIH7Mqr3PEody6gOtoV94bpwA/dlVAeXhWlhXnjRlUVXFl1ZdGXRlUVXF11ddHXR1UVXF91IdqK42foyrYN94bpwA/dlWgeXhWlhXjgKduPymgIN2EXjBuuOMbiBu2MMLgvTwrywLNxPNrT6Gq2DfeG6cAN35xlcFqaFeeGuq8G6sC3sC9eFG7g7z+CyMC0cRdFxL8dXQgMV2EUt2BeuC7fksUDr4LIwLcwL95NtwbqwLewL14UbuC/QOrgsTAuH7j3zVMdCrHcldB0LsQ6O+PcMVu1VuYO7wwyO+PcMSO1VuZN5YVlYF7aFfeG6cAPztfCiy4suL7q86PKiy4suL7q86PKiK4uuLLqy6MqiK4vuWNhZg21hX7gu3MDdkQbHhy/3bdjLOCn6Yb2Mc7IvHCGjT9bLODv3Ms7JZWFamBeWhXVhW9gXrgsvumXR7Q+36Mf0Mk6KLkUv3Rz/3m+ru5CsSr+t7uKxKv22GiwL68K2sC9cF45ji+5Fr96cXBbuuhLcdTW461pw1/Vgw7n022rwco79lonxhl6ZOVkW1oVtYV+4LtzA/ZYZXBbuunFe/SEWYxjSH2KDdWFbuOvGufeH2OAG7g+xwWVhWpgXloV7/GjP/lyKcZFeYEkxFtILLCnGP6Q/iwbrwrZwA/dnS4yR9ELKyf3ejnusP0NiXKQXQFKMhfQCyMmycL+Ho31GDnb2hevCPRfu89WRg51L/o6OHOzMC8vCmu3TCyAn+8IV3O0/2qEXOvZz74WOkwV851SNx2HUHk40oAMrsCXe2TSxAAnIQKgx1BhqDDWGGkNNoBY7vseDNEoKK0UDiAIN6MCIe99kUR1Y4/EYxYETFWiJ981c4/EZBX0TFWjAW+3+2KlGMd/Elnjf9RPvs4jHbxTs1XjKRr3eRAM6sCbWCBZ3S2Vg/Fk0VA3haKh2AQvwvljxrImCuokCVKABI+7dklEbV+/Z+xqlcRMFqEAD+jzIqIqb2BLLBSxAAjJQgAq8497T+jWK3gbej56JBXjHvZd6qFHAVu9lmmrUr01siXHbDyxAAjLwPrJ7ur/GQpETDRhx7+sWVW71nsOsUeRW79nEGjVuo80E7StoX0H7Cto3bvuOGicUF0srsCXaBSxAAsYJRbDIgIEKNOCtptGoca9rNGrc6xpNcnv9RAYKUIEGdOB9FhrNd5v/wEiGgaEWjVoJyMBQi/atCjSgAyuwJUY6DSzAUIs2i3SK2YkoJ6sxIRHVZB2jmGxiAd5HFg/yWFdxogEdWIEtMRJnYAHeRxYvBVGJNlGACjRgSEhgS4xsiSd6VJTVeKBHRdlEB1ZgS4wcGliABIyD9MD7IOOZFRVlEw3owApsiZFZAwsw4karR7bEK0HUhdV48kdZWI2HcVSFTSQgAyNYNEk8RQYaMCTi3CILB7bEyMKBBUhABoZatE5k4UADhloNrMCWGLk5sAAJyMBQa4EKNOCtFm+9Uf01sSVGbg4sQAIy8FaL7kAUfk00YKjFFYrcjFf1qPqq8aYeRV81XtSj5msiARkYanEW8ahrcQzxqItxu6j2mliBbWKUetUYQI9KrxojM1HoVe8vF2rUeU0UoALj3CjQgRXYEiO7vWMBEpCBAlSgAR1YE+OxGCPhUcQ1kYECjLPwQAM6sAJbYqT/wAIkICf2vlM8iHoxFcWDpva+02Bb2BeuC8d7eTyZet0UxaOp101NloV1YVvYF64L9/jRhL2PNLgsTAvzwrKwLtx14+bqfafBdeEG7n2qwWVhWpgX7lpxx/Y+1WBfuC7cwH18b3BZmBbmhWXhRbcuur1vppEVfXxvcAP38b3BZWFaeLmmbbmmbbmmDde0l0jRvZto7aVQFM/zXgo12ReuC/dju+/PXgo1uSxMC/PCsrAubAv7wnXhRZcWXVp0adGlRbePofTz7WMoUV/RK50G97GSfo59rGQwLcwL9776FawL28K97xpt3sdKBjewLLqy6MqiK4tu94TBy7WT5drJcu1kuXbDE4J10dVFa+zFFsc29mLrXBdu4LEXGwWXhWlhXrh7GgfrwrawL1wXbuCxF1vnsjAtzAsvur7o+qLri64vur7o1kV37LkmwT2OBve/jftt7KcWPPZT61wWpoV5YVm4H3Nco7GfWmdfuC7c5vG0a+yn1rksTAvzwrKwLmwLOzjqpu/vyFqUHU28Z7nvacoWRUcTC5CA9wzFPbXYouBoogIN6MAKbIkxgz+wAAkItZigvz/3an31vXsqtfXV9+6JxtZX3xtYgARkoAAVaEAHViDUFGoKNYWaQk2hplBTqCnUFGoKNYNarKZT4mrGajoDGWiJscze/SlT68vsDWSgABVoQAdWYEuMUuaBIeGBDBSgAg3owApsibG23sACDIkaGMHiVo6l8wZW4B3snrpsfem8gQVIQAYKUIEGdGBNLJCIouJIsr4c3sCIwIEOrDPJChKyL4cXGdCXwxtIQAYKUIEGdGAFZkIWJGSvmOnHyzj0qJgZ6MAKbImRkAMLkIAMhJpATaAmUBOoCdQUagq1vplZnJDi5PteZbeXFEvDK1aABGSgABVoQEgY2tfQvo72dVxNx9V0XE3H1eypF8fbUy9umJqmEBU0EwnIQAEq0IAOrMC0oNKg1qDWoNag1qDWoNag1qDWoNZSLcplJhZgGl7UykwUoCeWNLwocZkoQAUa0IEVmIZHdAELMA2PSIAKNKADKzANj/gCFiABZXpfX2QuXK4vMjewJUq6UV9kbiABGShABRrQgRWY9tpXlhsYEeK69f3+Ogpw+QUDOrACW2Lf769jARIQag41h5pDzaHmUHOoVahVqFWoVahVqFWoVahVqFWoVag1qDWoNag1qDWoNag1qDWoNai1VOPrAhYgARkoQAUa0IEVCLUCtQK1ArUCtQK1ArUCtQK1ArUCNYIaQY2gRlAjqBHUCGoENYIaQY2hxlBjqDHUGGoMNYYaQ42hxlATqAnUBGoCNYGaQE2gJlATqAnUFGoKNYWaQk2hhvQf+xB3hJpCTaFmUDOoGdTgJQwvYXgJw0sYXsLwEoaXMLyE4SUML2F4CcNLGF7C8BKGlzC8hOElDC9heAnDSxhewvAShpcwvIThJQwvYXgJw0sYXsLwEoaXMLyE4SUML2F4CcNLGF4i8BKBlwi8ROAlAi8ReInASwReIvASgZcIvETgJQIvEXiJwEsEXiLwEoGXCLxk7EN8P9zHPsQdC5CADBSgAg3owAqEGkONocZQY6gx1BhqDDWGGkOtO8H9KtE384135b6Z78B8r+6b+Q4sQAIyUIAKNCDUDGoGNYeaQ82h5lBzqDnUeurdr819g97SMdqMAvMtvu/KO9CADqzA7JP1XXkHQqIRkIECVKABHZh9hr7pbrzx9013442/b7obr8J9092BBnRgBeZ7dd90d2ABEpCBUCtQK1ArUCtQK1AjqBHUCGoENYIaQY1yMKNvujuwJnIB5lt83zJ3YAXmW3zfMndgARKQgQJUYL7F931yB+ZbfN8nd2ABEpCBAlSgAUPifuPv2+DGu33fBncgA/Mtvm+DO9CADqzAfIvv2+AOLEACMhASFTdtxU2Lrqei66noeiq6noqup6Lrqeh6Krqeiq6nouup6Hoqup6Krqei66noeiq6noaup6Hr2XeuHchAASowb1pDh7TvXNuxFGDetIaup6Hraeh6Grqehq5n33d2IAMFqMC8aQ1dT0PX09D1NHQ9DV3PvtnsQAEq0IB50/a9ZOP27HvJDmRg3rSGrqeh62noehq6noauZ99LdmABEpCBkOhThC0uXJ8iHMwLy8K6sC3sC9eFG7hPKwxedPu0Qosbok8rDJaFdWFb2BeuC7fkvj7U5LIwLcwLQ7evG0V3+UHr60bRvQ5g6+tGTZaFdWFb+D5OviJOTAvy/RFZi2WikmlhXlgW1oVt4R6fguvCDczXwmVhWpgX7rocrAvbwr5wXbiB5Vq4LNy1JFgW1oVtYV+4LtzAei1cFqaFF11ddLXrxnVXW9gXrgs3sF0LL9fUlmtqyzW15ZpaelFfEYruIo7WV4SaXBamhfttGH/bZw4H68K2sC9cF27gPnM4uCxMCy+6ddGti25ddOuiWxfdYQ+3Sfqwh869qr9zr96PNOppHdwXc5pcFqZM2TrSurMsrAvbwr5wXbiBezXB4LLwolsW3bLolkW3LLrjK4wa3LXuW6Mv1zSZcY7jy4vOurAt3M+FguvCDdyrCe4yqdaXa5pMCy+6vOjyosuL7vjyonNdeLl2slw7Wa5dryYYvOjK0Pqf//C3x2//59+iuvZ2qaitDfAJdUILePwJ3X8SbxJXffwnx39G98kf/ykRMLpbj5zqEzT2+Hedv/Zo7cd/WvxndOYezdKnkm+IjtzDP3r8hwHEe8qljz/x+Sf1fgj0XyiPf6/49/t42v2fNcvvs/g+S++z8H6W3bdZdN9mgX+b5f1tFve3WdrfZuQ2I7cZuc3IbUaOGcJBJYmSIrrdNGv5YxpwUE1qk6Iy7q7ujynAqN2PGcBBnlQn0Szhj7m7QZ5Uk2b5fszbDSpJlBT12XTTrNyP2btBNalNisLUThHlvrpxNwXpLHaPL8yjYj++Lx/kSRH5boMoJw2KatJOJYmSIt7dVv0rhbs1+kcKN/VvFIJKEiXNuvvikqRJluRJNWnW95d6JZWkqC2/Wzzu0U6W5ElRxX63eJuV9jEVNkiTLMmTatKs6I9JsCjHjzmwQZQU8eSmiGc3RTy/abYfXbP9qFxJJYmSehX/bTDXnY8+q+991t77rLyPpg6QCTphVtxHMwfUCW1Ar4i/C6/KhKhwLyPle43hhDagV7bTSPmAWbHfZr1+tLbySPkAmxCRZaR8QBvQU159pnwnSuIkSdIkS/KkkKjTBu4as24DnaI0vUwb6ORJNWnW5Jde137fHFHt2kmSNMmSPKkmzVr8bhfG0y46URInSVJElmkcQWESd7V9TORHfXzM4w/SJEvypJo0i+9jBn9QSYqjCguJ+uG7/VSSNMmSPKkmzZL7bj+dIt7dujYLj7vp3DX23XTuCvpuOp1KEiVFlDQdT9PxNJ27Mr6bTqeaNGvsu+l0KkmUFBo+jaiTJoVGnUbUqSbNyvqYvx9UkigpNNo0rE6aFIXg1zSsTjVp1tN3w+pUkigpqtvLTZKkSaHB08SqThOrNk3srozvJtapJFFSaISdRTH4rRv5dr9BUrEkT6pJUQd+H0F8i3V3zanXnN/HQpTESZIU53GbNlmSJ9WkNu61mOQfVJIoiZMkSZMsaVbKxzx/FL/HNP8gSuKkOOa7rUSTLMmTatKsj4/1KQaVpF4cfz824sU02ukeHI9mCpAJOsEm+IQ6oQ2I9gkoE2ZknpF5RuYZmWdknpF5RuYZOVrqHmaPhgqgCTwhIt/v0DrBJviEOqENiPYJKBNoAk+YkXVG1hlZZ2SdkXVGthk5zOoeWA2HimX3y/iXcKV7VDEMqK9E/4DYIdMn1AltQHgPzYdxX99jAk+IY44PVO9/mc/pgDqhDeiv5mW+mpf5aj6f0zSf0wE6IQ51PqcD6oQ2YLya83xOd6IkTpLRNv053cmSPKkm9da872L6/+/i//8u/v/8XRxd/Lhn7z563LPRNbcJPqFOaAPing0oE2gCT5AJMzLPyHHP3vuWxD0b0AbEPRtQJtAEniATdECfHBv3WkwqZel0Fk5n2XQWTWfJtM1JHJtTODYncGxO39icvLEZ2WZkm5FtRvYZ2Wdkn5F9RvYZ2Wdkn5F9RvY5IdRrOrXfxR1mdWOdE0EVJdcTUH04Iad/MGOZUz8TcpJpRu4l0WX2fgZREidJkiZZkifVpDmx1DcOLzEIImPOp1dElzkcMmjO8vRy6E5zjqcXQ3cqSZTESZKkSZaUkTnnewozUIAKNKADKzAneopcwAKEmuRkS18ocKACDejACszpnb5E4MACJCDUFGoKNcuB27E2YIzWmQAVaEAH9lmBa3ST+sB+3357IAMFqEADOjBncvrqgR3rBSxAAjJQgDmF05cNHOjACszpm75k4MACJGBOofQlAgca0IEVmLM2fXXAgQVIQAYKUIE5XdOXBRxYgTlX07feHliAebH6moADBajAmdhjqb/oWVABEpCBOU8yVvnraEAHVmBOzRBfwAIkIAOhxlBjqDHUGGoMNcn5mLEKYGCfZaqBOdA/VpvrmMP8Y625jjlRMlaa68hAASrQgA6swJyYGSvMdYRag1qDWoNag1qfTI5zG3PJ5X4fKMCcnhjLxnUUoAL7odONDqzAfuh8v2lcwAKEWoFagVqBWjGgAyswL8tYPa5jAUJtzi7db1IxOxJjCFf8t/5++qXE1Ml9z3uMKtgEn1AntAH3nd6h3DBewjrwBJmgE2yCT4jI3l/CAuSaUCbQBJ4gE3RCRK79PDvUCRG59Y5DhzKBJvAEmaATbID5hDphRvYZ2Wdkn5FjBC62C5QJOiGuTRkdh4A6oQ2IjkNfzjbgfz4u17/823/7x//453/71//6H//+T/90X7n5D//9b//lf/nPv/1f//jv//Sv//G3//Kv/+Nf/uUf/vZ//+O//I/4pf/+f/3jv8bP//jHf3/8rw/9f/rX//3x8xHw//jnf/mnm/7nP+Cvr+d/+sgyGX/9yDLLAI+3qOMQ7PMAWEpZQsgfIeh5iFhOPSI8nj4Z4HFAfwTg5wHqNc+iTyv8/QDyPEC7h/4iQGuvBbB5BPcu8k8j7NpRa14KK/VpO/rzEBRrJvSGZEZLPl4j/whRd1dT50E0RQA/v6MMd5SxPz2Nsomh5vMo1CrOw/5szHvc4ektJXfG9guiSk9D0O6mmvfEYyoJ56H1PILO03gMrz+PsLmtKLbe7Ve0XIgh9GcI3RzEPdLdb+1Czw/CNgfBbYZ4vKgsN7fRa9fDn1+P3V3hMi+IusrTEG1zJlryTNTLsxB0vXtNadMUj3dez2uq5dk1pc2NFWuFDtd+GuCHtixoy/q0Id53vF2Ih8Xko6O1zaPDdjeW53E8rm7GeHRT/oyx8U275vPHyJYIenwmcl0zT+XxNHt+Jm33FNRMkUqL+Zb253Nwc13vXU3mzfX4u4IseYxj/BmlvN+mTO+26fZcHnKzUe815vX5uewcNPZ/GdlW23Ikf2YsbyyUPK8uOS3m9Ytz4WZ5LrJk/bdz2T3fTWcQMkN7PBzlzxi7B3yheWEefZo1xpfjaNtXvnmT8ePZ8DzG7jhinZAe49ELfRpDNveptDwOva72/Di2V8auTLvH1bWnV0Z416p5hzD5JsbuTrVW8i7j63mM3Z0ay+b3GI+hhtdiiEg+7ttzB5Gdo8psDjO8A973yh8R6u6NvObjpbTnITa3qcXyRcOD6vPD0N3tca9lmq5sLM+PZHdpPd8aHvj89tjeqMx1XtvHwLE9v0GUdw+IKFEaD4jq1xMzU/lL7VCufCt9jFvrc2tX+0sfMWJ5izy4Pbdlrbv3Y/Rf117T4+X9zxjt3TbdHoWUTH2R6+lR7F5BHmOweSbFy9NXEKNdBzB7C+xLb/zxOD+OIZx9L+E/7vQvMeT9lxjTt18Mty2ar+q3Nz9t0W0MYsTYXZX67hCLtXfHWPx6d5Bl3xI1s8RInraE7wabuOWTRWR9Vf/zhdB3j3umvMe5+vMYu+OQfCY8Um0TY/eo5pKPahV7GmPbpibpG/bHufziDrVs08ekhT2/Lm/fof72HVr/2jvU84HymHl4nu9117u/HAMEvHYE/3SuurlD3fJUfO3g/ybGvTz8bFBbuyxfY+j7LlztL3Xhxtlxam6v3eOxJeIYdKH6/Mq2d+/xdr17j7fyV97jj99t2dlhetoSjbfdrux18R/3uJ/HaJrPxavK8xi7+9PY0oaN69oifw7dtM0dWnMKpC7PZ/7yDrkfkLswILcM9Nrx/IFwtsbjsWZPh6Da9spmxnP5Y/DezmPElod/7+6wL63xgeH76/3x++v9AfzrAyP41/tD+NcnxvCv9wfxt3dHycEFps0zpVxvP+hLeftJvw9xNgC+bQ1NF+TdE7aU3aPe8/Z4oDyd9dsHqTlt53+ky7cg+n7W7iabDrN2G+Isa0t9P2t3k02HWbubbDqfedO3s/aH28PyHqvtxXuslhwDr7wcyLcgu5mWopxpZ8vj+usU9TbtWs6T82MI+Xna7SeeDmeY/f0pZn/7Zt++2R7e7LuRtMObfTfrdHyzH1+VFx9RLYdsHtN69vzuYHn/7thNOx3eHdsQZ3fHdtLp9O6o798d7QN3x/FVefXuSO943B31pVdkuUoOb16yucN2U06nRTLygbtU3r9L5f27VD5wl8r7d6l84i6V9+/S/d3xfn/SafbjxL097U+W3XSTUQ68mPDmkb+bb2oXpgKXG/3rE/+H9iC0B/mLbXpWgKS7+1QwEvWYZ30eo76ftdreztptiLOstfJ+1u7mik7r2/gDWXt8VTZZu787sjjjcXfYazEUo2Jqz58Lti2IuuaAll1FXoqhzdtJjP25HNXrFb/evtP97Zq/4vT+nb6bdTq8031jpUqUFkbLJPG3O30763RUfbhtjbMSyOL+9lHsivaazq6ktCVTvjfGcZD6WhC9aN4dem0vyzaI5bW91qqb3wXJgTEtl74YpORogZa2CVJ3b0H3TkLTUO8tfxCm1Fct5Gmla9lNQDkGP3zzarl/dTipty21fqDXsA3C6eyP97Hn3Zeym4QiN5Qz+fNHTPvACH97f4S/vT/C3z4wwt/eH+Fvnxjhbx8o09/fHWiPunnw72I8JpEwxbh5Xf8hxvV2DCn5lJFlOv9XMVBw8gj3NAZd/PYL2TbG6QvZvj3c8lxafTuGXvRim2bn9DHt6c/bY/fCbqindNll3e5AHK8h3p5aIe0mkk4v7nb++BMXFw8prrvj2M3JXw3lpWsR868aFZNRXJ/fZbSb9ZCchRZ6fm1pN4/0GI/M0gC5nr/a7Y+D83m7fhfytTn2z+ycJRReJ1++PLNp++nT2cAD0fX2M5t2Xz+dPbP3Ic4+wSJ++5lNu5mos2c2kb7/zD6/Ks+f2T/cHUcDD/sYZwMPtJuKOrQx+sRHfvz+Xcrv36XnZ/LcB3dTHmd9l639SH6pI7aU8H2zH7Z3SzZoNxF1WLKxP5WCGqlN72d/HGd1H/sDaVzRzX5eJEVS3m5ToXfbdB/iA82hBcNSRXbNoX/lna6SD1rVZpvD8N2ldZxKhqDri6PvJqLOPgbZHoViumOpcf92FLtPn6Rkv0Vofcc+D3HP1zDmbvR6LQjqPB9s5cUgeNsv67T+bxo1a7u1bi6t6l8aolyO99Krlqensg9yemX0E1dG378y+8y1rArStlYF/WZszEqejf35EfevgmT+P45p87K+m5DKgc+lOEl+4acmWWhuer3aHOycQbxszuT95769/dzfh/jAM8o0j8OsbJpjN5P0mFDlHNTWpk9z1zfPfbP8Su8xtb95Wu6mYB6Wnq9C1J7PzJPvK/BzHufi512P7QTKWUd9NyFV6oWv6+vjEj+dKvjp4lyMi7O86v4ia5zznd0fw32bi1PfHmCn3ddQp531+vbc6T7EWTeovj93SvXtuVPaTUgdd9aPr8qms76/O44G2LcxDgfYf4pxvR3jbIB9H+NwgH038bEMPGhr/lKM03Hcw+PYxti3Kb7PWpca+XYc+oH20L/6XI4mHI5jbCYcfrjHjiYcYnb13QmH/YGcTTjw7rOmw4u7jXF4s58ex+s3yNmkBe8+jjqdtNgfyNmkBV/13Xch3n0bdTppsT+Oo0mLH990ZXnTfbpMyG4BvdPX5W2Qw3GM7Xuu58JLxe35TfaBj6P4/Y+j+P2Po/gDH0fx+x9H8Sc+juIPfBz1Qy8oex+0fhLw9coSf8AK5f2s3c2LxXeo49ISv9Qcj/nhvC5l6bF/aw5/2wipfsAIt8dx1qQ/jG8tT5drqan7zSDZ4w8bgtBTI9wtyXc60rYN8pFR4dMWuT7RIvaJFrF3W+SHgsmS3/IUerX+s1yYU6LyPMj2Q088cB+jzP50WIh3E1OHtQYs9P7jUvjtx+U2xNnjcrue3uHjUuztx+X2C6nTx+XxVfHNVSlv1xrsY5zVGsSSGO/2YPT97voP53JUr8C7T6QO7/RtiMM7/fhMnr8I7eq1z2Zx9xaWq7H42rv9ZmHa3n/jt/fLpdjeLkTZhzi7sPZ+uRTb2+VSbB8olzq/KhsL294dh2/8uxX5Tq1jfxxH8y+866gfvmrvJqTO3pL3R3EWYruE5lnf5YcYZ30X1/cb9AOVp/vjOKs83a/YkSvR1VKfbyixX9nq7Mvb92tXub7/vQnXt7832Yc4M+P6/vcmXN/+3oTrB743Ob8qu+9N3n6d/EDlKrf3i/i3MU4Hgd6fsX3/m2xu7z/rtwvznX/+934FLbd330i321x4lp88pmzWNUHly1Fsl9XDJCev98YvQuA7gj9Wrf0zhOxWgDsc/dk1hrWcNK6XPm0Mud7f7+l6f8en6wM7oNi7l2S7d0mup7cuIPdtcdRdBMNa/fV5hN3riubw1b081xLDzmNIzuM9YujTGLLdZahRbqL14PasQfntstf9JixmuWLJY9J3ccCvWyjs9n46y/h9iLOML2+Pbm7X9XIsZ+yrB38Zhn/3Ht9GOLrHt3viHN7j+311Du/x3d5Px/f47hWScqj4j1Xpv22Ks4uhWDdcdRNju/kKZSflwfZ8/wXZuuhZprxvxLKbcPqAcXxpjva0Ofa7BOGF2HjdnYdfjOHvx1jKXX61W9Fl+bZw2fMdfmS76lv1TLtaeRNk12PK+p+6VHX+LkSuHFfVXwwheRTLKhKvhjB+rUFJsSHF2pf+ZRA8Fqzoi5c29nIfXri7LmX3Rpq9FV5XFP3VTlScDxjh3S12tpuVtPr86h7vzLWLcbrLmD/PW5F3O03bo3CslV8v3hzFpjlcM/Nd1y+n/3xEiW6XGqh4MqzTCf4lxu4VqC2LFa2f+32NQdsJ79xU68HL9m+lnrdqpZatuj60f+PrNfs9D7TnMbZPOpUsAXg4wfMnnex2gGoYIrjWgQbXLzF2I75okaK7HdN2K0fmdEArzxt1G2IpiVhnFL7F2E1tKGU1g9L6/eKX2303W/TI+HxV9nV7nHp+LuXKXejKupzV95PZVlWhE9XaxgB2k06nBrCbdTo1gN1nUKcGsPuI6dgA9teGsfMaN3rtZv0zSNsE2fVB8Jihunnz38bAWOWjE/BaDDZMLlyb7Q53+Z/TcLW+tlehYDT90UmsL8XQknX/Wqq8FkOyqkrXbyl+FcNLrmbnSzf3dzFqVkTVZX2/38XIzoNW2rRH3T6pMChf/sjd34aBnb0Rhi98ccvrx3+/DZMf3N9heBNm9/ZNKL5/sG0u03aPKNW6zM219nqYfOyoXdfLJ4Uvox8ntTua7XKwNVdgfnChl8MotqurXl++4Bg04kKbo9kvD1dQdPkYedSXw9gSppaXwyAZHmF2JyUfuVI/hDFfrpS/HOYzFxz7PD9YX3XyddlKfy0GalS01deeBnbl08BKee04rOTAh5Wd421jVGxFt2nTXX/yM7sSO0ajq2t5MUpFNtdarhejtOVYGm+SebunMPZJ9d2MyS5GRQFQvfzFGIoOsj1/G9x3blsub3w/6ze7G5dtferJtof7EEcTJ/sQRzMnP2w5vRTZt+vZKiG6+06nFUcX++n4/D4E5ao6jai+Mj7Pio4tr/UEv9vIG7ulFvZSN7fH2wUB+xBHkx5KbxcE/KI56PVGRc45v5i5947ViKLPe5S6W9bv8NJsQxxeGv9rL80fzbGbj/rh0qCz4b7ZuN7etjJ7ew54WzrMvOwdvRksUOZ3J8S3IR5uyNg92uTFIK7Z0/H1bv9dkByof3C1V+6ze8PSbFfl54///QYcpngBt1ZeikKxPMMYUlpeIuhqr8VY+hO/iqG56uJjoKy8FINRQsfrzjlfY9j7y/vtQshVcmKrrEPKdJ3HKDni+PA1eRpD5e06gX2IM1+Wt+sEto1BjBLzP16WvzTGdnm/lr1eacsL5vcgu++fsETY0n34Mh79w2EYDmNZ6uiX54JFF//Ym/uXQbB/hr7cqlm5r5ddz+/1/XfcudED72Lou4/LbYSjx6Vtt+o8K5naxjgsmVL7QFngdgEpze5YVXq+Cq7u5rQODWgb4syAdlf2zID2jWFLKYtvGsPfbYztRvSUX1Mw0/ON6GOX5afnclRLrP72ZtL7EIebSZf3Q2y76uiK0R9bzPiXU9lu19eymw3r8T8j7Ev/z9J1G8NiqYwew2ipuudLfhEFq/k9eHmy/DYKIYrQ8yi7Wofseqzr4PCXV9sfjgOfldkf35X96myi5GZGWSd9fhVFl5bV5buwr1F0Z0QfCkMXPhO51hHMbx2H7bonOadGf0yN/CoIpbMS+fMgbbudYX6KRA+vf57F9f3tDH+IgRzUws8f3tsgh28RPxzJ4WtE+0Dl9fbaCG4SbfX5tdnNEalkMar+sbwvfw2yy8CzL9y1vb8Hura390Dfhzj6qFLb+3ug2/X2Huh2fWAP9POrsknd/TP46At3230fdfg54w/HcfSFu+2W9zv7INuuXe3V8QrD+yM5+iR72yCHX7n/EOPoK3fbzQsdNup2db/Dr9z3x3HUpD+80GD00WSpm/z6DmHl7UH/fYijvp0V/0tDnHUPf2hRFOY+Wleftmh9v0u0e5tyzTvMrTzf0GPb10XdQGWSF/u6Z5dl9+HsYa999+WH5UoMdR0V+tYab0/D1LenYfaFXmdvhNsYhy+Etp23OB1X2i1urjkMS8bPL4ptV/Y7e5ez7UTO2buc8dvLUO1DHL3L2W5BvtN3ud1HDofvcrtv107f5c6vim+uCr3/LifvL3T2w3Gcvcvt1uM7fO0Q+ci73PZIjl48tg1y+C73Q4yzdzmp7zfqB5ad3h/HUZNuHy6edYJVX3s85QcjVp9XXX1gKNe38wS5CudjjHudbKjnMTwf1dz+WGjjPIZcGUOutRrma6Lo2+P8+8PIF3Qp28N4f+eNH2KcDWjtg5xOi+2P5PD9Zf+J1dn7y3bvHVEUohR/fpvt+qMoZiEzey2GZi0Lmcvze8T83bkg2y3rdzYXtA9xaCDbFl3Kaa/nLWq+XfLibPV92+0zRZ7Xlq8/5ui+HsnOAA43qzKX918/3l/bz7Zr+52/fvxwcY42q9p3KbOcXdZ3h69rMdluR6PDvaqsvr9SqtW3V0rdhzjre9T3V0q1+vbqaVY/sFLq+VXZPDH3d8fRXlXbGId7Vf0U43o7xtleVfsYZ3tVWXt/+55tjMPlCk+PYxtj36ZHe1XZbr7juD3srz6Xo72qjmNs9qr64R472qvKdxNRp3tV7Q/kbK8qv/jti7uNcXiznx7H6zfI2V5Vvp2JOtyran8gZ3tV+W6jqbNXIS/X+4MG++M4G4f56UX3ZK8q362VfPq2vA1yWBu8fc09Gwv28v68vpe35/X3IY7ex7y8P6/v9Pa8vtMH5vXPr8rufUzeHgt2kg9Yob6ftfL+6Ok+xtHoqdPbo6dOHxg93R/HWZPqu6On+wgno6f7716yT/rAZWmZ33w7Y/j+xhq/FqPmmhS0Dp/+7vsbvIhdtDmX3TzD6Uc82yCP65nzttWffoG7DdEy3R69An8tBGaP182l7PyqeD6oydeVpX5zZf+IIS/GIMTg5xfF5e0FfvchjuoK/P0vmrYhzt5a9u1pf/eTyN9dk2XMs73oHOtxvBoDry33agIvxhA6ivH2XJi+PRf2w0f3OdnRiF78bj9XG33g049Ut4sYnDXFPsRJW+yXlsCqqX+8Ev9qeYqCVTE3n8rvY+T7LK3Llf0uBvKkts0X3fvlRwQLh1R9viTLL6JsVsT6KYogij9fpsZ3y/wdLsDouzmowwUYf1iShbDi8fpx5y/bBP2Nx0V+eXmY9Vj45Sjoodcmm8XctqPijOUCdbNExHbp9Fy4lNap+a/Lnru//+T395/8bn9piMM1JnbtyfjOnf3atOd2naqDz5C3RyF4d1iHbr8dxW766DT7d+WAh9m/X1ibsOcN6dNz2cdYd0R63h5C2yn5sx0CtkHOei77EEc9lx9CnPRctjtQHL2C7COcvIFsd3o5OoZ9hJNj2K1+ltM9f2z+o34aAAtY1zU9fhEgS17qOuX9JYDvJos4Z7x5qTS5131/JcTSp/8aYldllt+RtWV/hl+0A8F3zV85AsIqNu2lU8AuAroO71o5DeB4C31MMy8X0+mlEMsGAl9D1N2HTtKw8fb6Bar+IkTavlLbhNjcUt5yxN3b+jb97ZuLXbFe7lEhy/cSjzed4/vyqp6j5esG4ufXpGDB3bouHi7Hd2aWcdFlLwXACNFaW/eLAIpBzPZKgNiSoF+HPzb6OD8CRyePXgnAJQsmyvMjqNu9o7JaUup6J7xyDHxtjqG+/VJWd5NIhy9l10la8dpn+MX9QNOtRV7Kidgn7NssxW8CvHsxzXKCwmyzTOguRAxDjgvh1ysh/MqGeMz320tH0bJf/GoIv/Kjssds/0tt4Zwu50yvHQVnbabzZnnf0xCbwZdtiIoQrb4UQnI43oX5pRA1ezxe7bUQkku8P7C9FMIKPlik166I5guua3vtinjOVnt9LVP/OJFXQ2APIfPX7gvPj+vci7x2FLm02COEvnYUis2QVN6+IuX53VllW6p/urT4Nk+KvXlv3HVLWBCYy0vHUUyxNqnpa9bz+ENsDWdaXwxi+IrC/PLXgjjhdFzsxSDLl+zeXmzYiqtjtZQXj2Rp2N2a+jFZ9jTM8QYTVbf7055uMPFjmLMNJn46qcMNJur+C6DTbQt+CvO+KTwuty43nr1642HZdKv6Yh413DHWTF4Mgq0cHv7/0qO8eMFi4V5ee098/CG2jfG1O/zLII4gbfP4sA/0pOwv7Uk9xhHyBf5mfa1FaFn5mF5tVsJq0P6YFnoxiC1H8uqthhVDH0z0YhBZguiLDcu8Bnnxpuel+Jzrq23iS5D24iWW5WYTevESy7UGkRfvE2y59ujjPL86dTe9VGRZ0FB2d8pPYbD8+ONgNs/l+pG9bn46mpwjevCm8/abk3ojjGMxc267Jq7/b7TNUlq6Lln/xkm9EUYKlmjf9dTrdiG+T7WN8HJSoh85KXnROK8L31Ff14vv/61dS5DXngOn20zu5tiyt/rHHNvx3FTL69L06Yab7fqrzyL3i6nr+uhfj2I3ZbuslsSvRaiYcK0vRrgwWPnCtaAr7ykq/tKEDqElqS61O78IgQXFbF2DS9vxZCOe5PrHg7xexyE0p4VU5cUQWb/3iFZeCUEFiyWs+7r9Yo7uESLnt8rSRfpVCJTY07IE6W9CoK6TaPnE8DchcHP/Wej/ixCe41mPfvlrzUm5zyiRvxaC82P+R6uU144CHyzw9VJzqmY34oH+2g2eE1WPG/x6KYTk1KXKOiR3HuKPDy/+KBM5D1GwfA6tmzB8CdF2ZUNpWotvyi8KLPApTF2X+T0/i+K6bM6zLgKkX85iWxQP+3Z69nHk7ihafiJV2h/Lyuv5idR8nK+fAX87Ed4uEXGyvEvbFWGdLe+yD3G2vMvWfCu2zl4WIvjeGNtFOh1Xxfz5Qp8/BOF14I+fBvFdsQQ+5NO1LPfb6ez6S9VQ9HFtltjn3V4Q2EG7rsUr34PsTgcF6Q8f4uens1tvzwpjt9LlW89ylV8EsaxVNlt3b/tVkIpXr7V68nsQ2Y37ndQN/nActlRx1s1x7CpSsEWoVF76jV96BU12n+AbLds5LC5gv2nWhofDde2uze47/itLKu7PBPGMKV93Yth1tlBv1crSyfgeZPcJPeuy33BbNl/71rT7Y8na5ceDdXcs/IEs3jYt5WcLfzz/vx/JdqXaammPj3kn3YSxT5xQ2dZI5ER2XV326w233WPPCwYY1lXW9MsDcDflpBfe767nIez6wI2/2xbq+MY3+siNvz2h09ttv+HW8e22+4j7+HbT7bZKWLuBNxd5+16AHo1fzxcRb7tZq8+cDMber6V39u1sfPvSJnhpK5u9d3YrlZyfTd0+v3I23OvudLafpWdfka+2CyIfuML+idt1ezolhyyZxDen45+4xPWvNvuG4sB1Evyb2e/WfxMsmyTX8ub3zUx2H0UVVK4WWcr825cOwm6E/eGkqEVeZp6pfg2yvWHzrY3XXUiZvzaJfODibE+HMDrBy3Pn++nYX30kUrD62lom/u1IdnUBV8G+mWvq2C9uNWTO4zXFnt9q7fqLe2+PeyPvNbo2fetGH/C1xn/16RDD19aVU7+djn7A19pHXmK3C5fBptevgEv5ksStfuSVbXssWAZJyuVPj6Vc1ydu2u3b42Gz3ANOf/2r7Hm7fMRpd0PJlENcj3Fp2x2Kvf0IewTx959hjyj1/YfYI8oHhrl+OKPDx9j9yvyXH8vhg6xcu9X3PvEkU8svO/SPns+3W6584J12O2OaGxY/JlTaK4PuYvmRqbg8H3R/nEt9d9T9EaO9O+z+Q4zT/XH3491Leanrs9VoSuTpu6Pm+yiH+3RtB80bYWJGXx40T3usZa1m/l2Q/Da9UqGNDew+Tz/9BPYRZWeyR9/A7kd3McZluuyC/LvRXSwCxc3Kyy8YZ5fnpyin12e3m9H59dktTvGB6+NWl09ynk+vPA5ku4BKXp+l6qvQ1xCbO1ZRfqDrF43fppn3r3/HN4p85EaRT9woP4xfHN4oQm/fKNux6nxo/LFbr3598Mj2234YNVPbXOPd2BIG7cikvDoYemjV+yDHV7h+5Aq3v/QKY3mqprq5wrvZLy35/amWtdLv6xXeDRBrwb1Gf4wyX78ZID68wvsgp1d4N/l1foV3c1+HV3g3tkvtwlKuusti3S7zK5nFV5PN5ZEPZPF+wPv0GusnrvFu9uv8Gu/2ofrANeaShZVczDfXeDfzJTXf7qVW3Vxj/0Qef8Kp/SNOvftm6/wa+/XuNf5hIIbxgSAvE1ffBmJ2G1IJYx2L5Qpb/UUMza8d1V6OkZ8n6fLV1y9jtKwvX2u7X45RX4xh2R72cntYtoe93B7WlrU9PhDj1fbA17D+cnt4toe/3B6e51Jfbo81xqvtgTX81qU1fhkjP4RdP/j5ZYwcJm8vt8ca49XjaOnLbetB+6FgLCF3rd+NfhsKbmXXhc0PYfmPjyR/F0XyZmW96qtRsPQ/27qize+ieI433vvtvDxEftwZ/sioVvvIqFZ7e1Trh2F2LNzxGPuQl4f8T9u2fKKTUq5PvMCWi//itpV8uXlMYZTnbRvbnjx/D84Zr8cEkT6bwrg/idu8Zy2D3H88wPxrkN1SoSffvv0Q4uTjt59CHHz9tp8VkoblHf/YBPlrk+7uVsFrltha9fh6EH4a5BdTZZuJyFK2n27j4wHhujmf3aq6MbYz3j3brlF2N2vBJO+D18rWd8L4pnW3c8VXPZgr3k8hSr5iqMpmAr3Q/gtYLLK0LpPB36LsbrmcIJL1WUrX1xjb8i0YG+1i7I6jpMOui79/jyGf8PrdN12HgxXbC6yejmLrgPD3C7xdqhWb9/LTvnDZz3T9vRD3+MlvpqqPn+afGI4q/Ilpg8IfmDbYfseQhdiNrk3p5P47hsMxoH2Q44a1jzSsv9+w2y8qlilrXVds/uUXFadNa59o2o9MdZUPTHXtP4c4vGf3Qc4+4HmczQfKX36KcuhMP0Q5vsr1I1f5/emu/Tcixwlkn5iDsI80rX6iqKDo+0UF21L3w+HpsjOVw+HpbYzD4el9jLPh6X2Ms+Hp4xj1xRiHw9P7GGfD0/sYZ8PTxzFebY/D4el9jLPh6X2Ms+Hp4xivtsfh8PQ+xtnw9D7G2fD0cYxXj+NsePqHr20OR6fLbpL6eHR6H+V0dHof5XR0eh/lcHT6h6+QDh++9ROFWqV+5O21vv/2ug1xODT9w0dVpw37kW5B/UiPq/pf27DH49K1fWBcuv2wHOfRuPRufuhwXHob4mxceh/iYFx6+9nd8bD07suu42Hp8yBPh6V/8SXiblR6+2XX6ah0a++PStN+/cHTUelfhdl8k1L+2kFpuXJ04BHt+YoLhXbVwceD0rSb5DoclKbdQP3hoPT+OM4Gpen6xMAAXe8PDOw/wc07TdbVyr9f4LKfwz8YlKZC7w5K//Al8OFzvH3ikwcqn6iCpfJ+FezxslTyfFmqx4Fsl9la9uFdPkAU+tKwu6+jT4tg2ycGx9snBseJPlFDQPR+EezuQXxcedo+8Q7c7CMN6x9p2PqX5g5jfX1eVzv/vkKd756gKC6+jDYJuJvi+kyUs111f4hxtK3uTzFO9tXdL2Wbu5CW5cp88aPHUdjOGnPtpetpiP0SyblAZlmW7v5+ELti7fwirS0JU7R+jbHbzKVdjmUy19c0Pl/2WnOHgHUr0l/s8bsEWPcq/MUmwfm6ug60/CbA0scrLwWwXPPwj92vzwMcbbW8DfDmTstnnwfv+h6CfVhlWXKV6XiD3kdGZoddWV4K4cuuJPLaUVTDhrLL0gu/CdHy85LS1nUjfxHCsBSv+WsnYg17gFyvnci1LGVWXzsKwiZjtH6N/4sQjE1vHv2O144iP8cqf2xg/ZujyI+0Cxd7ty1eDqENJ7JuFvybo3BcEXo/hL0UgnOZ6AfW10Jgoyp2finEajnyWltwg/Fd+n6I1y7quurMslXAr0LkwvQPtBdD4ETWte1/EyJfwIvU1y6q5Ajjoy9zvXhfYAtAeumiSm6B88cI5XkA3JpKz9uh0O7rwofvCexieVE8f78TbIThL51G7gRt8tK1UEX5o7wUIBeD18avBcjqhibvBVhLG37ViBhkfskrLQcf1zWoXzuC1y6j56oT636lv9hvouWI1PpZ9i8CFCyH9cceP785hhz1bPTaSWRXobm+2QqvBdAcTtPXNjDRhrXmXzqCYnjQrFs1/yaEO95t20vblxR8518avRaiMOYn5LUTKYaNp+przckNr0HttaNQbD76h83/JgQe/VrbayeCK8L02okwnnfrHvW/CSHo86wd2XL9uXtU4e2XHQWvdLR2vn4XA2/Z6wY7X2PU3eBIbuhnZS3xKef7h2iuUUe2DjZ9a5Cyi8KOPYuWtcb9W5DdfBHlkpO8Dr59D7JbT00rdifUWjelvrz70uu0i/6IIu/3j3+IcthFPj+WXf/0h3Y5HIP56So17D2q64jx37lKbTfkm6sS0lpK8v1o6PrEVTqNsm9fuj5yrXftQvngecyqPG+XXUpLjoQ/jIE3xkDbafG0bFm3rPZfdJ+x7tajcdY9JL8fya6zxLm4U1k3I74H6b9E2c15Xsuo+nUt9uLfrvL2vjVsNfeYqdNXGkZw8z8GCNbqzKudX+X8/OxxwfEE0fP7RHNsmRrTswiFd4sBlmUDwAcvA/UmvwrDKJEhXt6Av4fZFmaiYHXdo/Lbg2g3kfSbBxH7Jx5E29U9jy1uG+XYnE6PZW+U23Y5fhDtr9L5g0j4Ew8i+cjrgnzkQS8feenYtsvhg+jHvM6V+O+ZU3+e19tPphxrLy4T9/bLQ1ne29dar2+Hst0jqy27MbZ1O8ZvzxGlDzxHfjqais1Tr2vZi/t7mM0tE19rjt7uuivb+c68HEsrjun35VOBbw8T3S4NhheGu2Itj+Obf6tvu7zZIsvc+dd5fNZPFPSxvl3Q9zjr3VP6cEfYR5Tyfh/+EYXeHWb74XwOt+rt98K7A02PKPru0OU+xuno5Q/nczjq9UP+SMVgz7pF67f82S0VaPi6xcnW/Ra+ZpBvO1W5w/VjcnSd4igvecoywv/NU3ardPGFLYCvdZ+s+i3K7mkoit1Nl+mvvxPlE1/rsH+iGJXd3vem7VZZx960W+DydKz1h2M59pX6gQHs+9Pg931lW+5/7Cv1A6PpP+UQdqYp61bF3+7+uitsbbnbvF3L8+Pbm8rui6qCxV1LXXesc/rFoRgWOLAi1+ZQ6kde4baNW7Due2m0adxdnbvlTIEt9RLl20vPdtG90z1/eFcYfm5y7RPrAXCT901uu2/Wsck1+4TJbaMcv8btPrA6taftR1rH9rRtW3xBR7YWAXyNItcnXm5lt4jgYaucxvCX2+T0QSa7r5qOH2Sym+o6bhP7wJ2yP5/jB9nWJfHN5zqF+NUlpeyHtQ83WNsfi2fdYt05tuxmY+qV2x6sy6V/exZuv5DKDyXXbwj+znFsfPYxszxvFF0L378+CKXoXzu0vnYZyjL2pd8OZLf2e65XsFY2PeZDvsbYfa8ieKr/MV1N9WuUtp0p+Lul19+j7GamyPJZSia7Y/lh8T58Wrh+dP11QFC2u2aty+usnvJ1Skh2n1k9MjBLv9ZC1/LthGTXz01jMl/KRL4H2R2JZauosX4gyPpV3++CLOsRtleDoCzwga+eDjaLe+Du6uxuFMFHxrJ8+fB3bpTdTSvpsiLLHNf3m3a3lqBnpYUvu8s0/UWIlrd9WyZTv4fYvcwerr4g273vGqbrmjxf92AbhLCn9GOIlTdBtptmoQt2Pb9H9seBLW2vper++3G0v/Y4iuH7tSovNmqx8oEgOTnxRpC1x0Obe2Q/C4UXUP6jo/6bIPg4/87zTwTRV4MQSuhFXg6CJRy0feB0Xg+yfBZW6/tB1iWZfhdkLelfX4S/BtmtHniYw/vjMLxq7TJnt7DpqZfsHhQoULyW3Pv2pNjNgB1ugbsPcro0jexmwE6XpvlFkOcrpv/wJpDrh4k03bwJ7GbASjNM/v7x1QJ/jbIb3NL8LtTXTxe+3Si7KSPmdGnmtYfx9YbdzV7xhe2f19nj3wXBQ4eLt1eD5O3GVHZHshuSNULp2/Z02gfebrb7AJ45wf44Dt9u9htUvX8cp283PwQpHwhy+HazDXL6drP9gOv07WYb5PTt5jyIvhrk8O3mhyBnbzfHp/N6kMO3m9Mg27ebbZDTt5tqb+fw/jgO3252E16nXrI1aMVHCztP264geNqHbdcHXL6976774zh0+d081yeO49TlfwhSPhDk0OXb9QGX3y0ieOzyrX3A5c+D6KtBDl3+hyBnLn98Oq8HOXT50yBbl98GOXR5vd531/1xnLm8luuvdXnP2i9yq5vjoPeTbx/kMPl+EURfDXKWfD8FOUq+89N5PchZ8h0H2SXfPshp8u1GB85u+h+O4zD56P2BrG1HmnIK5/Hg21xe0vc70kr2/nvaNsjpe5rS2976w3GcvacpX3/tcRy+p/0UpHwgyNl72j7I4Xuabie1Th8V2yCnj4rzIPpqkMNHxQ9Bzh4Vx6fzepDDR8VpkO2jYhvk9FEhb/e1fjiOw0eF2Pteou/3xnW3KdaxQcvbk7A/HMehQWv5a4/j1KB/CFI+EOTQoLdBTg16/2HXoUHvv245NOjzIPpqkEOD/iHImUEfn87rQQ4N+jTI1qC3QU4N2t6ehP3hOA4N2vyvNejTjrR9YBRrH+Q0+ewDo1g/BDlMPvvAKNb56bwe5DD57AOjWPsgp8nn7/e07BOjWPX9UaxtxYDlcsGP0a5N7aDW7TBWQx3jsqVVk69Btp8f5oYNJEsFxLeNdXS3WRhhip0eb0sZhWv5TRQqeSy01DL+nSjHZ1R3Z7SLoniBVaddlO2kVK4MQ+uF/jtn1D7Suu0jrbsdgMU7uS+L374Tpb0cpeAZtjw5fhmlcrbuurLLb6NgtbPqL59RzVVm6I+lyH8XpVFe6ab6ah5VrHZQ7dpkwG7i4LQgyXbbXJ0WJNnuW67TgqR9kMOCpB+CnBUk2W6rrNNxVLs+ULO9DXLaTbfr7VfaH47jrJtuV/trj+Owm/5TkPKBIGfd9H2Qw266lQ/UbO+DHPYUfhFEXw1y1lP4KchRT+H8dF4PctZTOA6y6ynsgxz2FOz9qa4fjuOsp2Ck73uJvD+OartlDo8N+v2Jrh+O49Cg35/o2h/HqUH/EKR8IMihQZN/wKA/MdFln5josk9MdNknJrrsExNd9omJLvvERJd9YqLLPjHRZe9PdNknJrrs/YmuvUEfjqOa1A8k3zbIafKdB9FXgxwm3w9BzpLv+HReD3KYfKdBtsm3DXKafPp+T2t/HIfJpx/oaW1Xhz8rSLLdAobHHend11vHr1j2/nvr/jgOX7Hen+baH8fpK9YPQcoHghy+Ym2DnL5ibdctPHV5vz7g8udB9NUghy7/Q5Azlz8+ndeDHLr8aZCty/v1AZf39911fxyHLl/L+15SPtAH3o1mH490bofET12+vu+u++M4dPnqf+1xnLr8D0HKB4Icuvw2yKnLtw98XLAPcury50H01SCHLt8+8HHB+em8HuTQ5U+DbF2+feDjAr/ed9f2gY8LYlG5v9LlDzvSfn1gFGsf5DD5fhFEXw1ylnw/BTlKvvPTeT3IWfIdB9kl3z7IafKVt0exfjiOw+Qr75dr7+f6a1YM1LqpmfHdyoResbDusk/DizUHbd0X+Xe1Oy13afyj/uHvRNk+yLGZjCzjAl/Lq3y71pzjbvU/1oj/RZCa68zXKpvj2Nyrp6vl/CLIi6vlKGM7Ull3Evha++a7OQ8uuZn4YxBoG2VbnpXrhv+xIO7fibLfcC5fG8uy8OT3KLt5rdrm3dbKut0u/yJGy8XU733IdkF2Kw8croDpuy1xTlfA3B/J4QqY50E2K2D+EORsBcx9kMMVMPdBDlfA3N4nj+TJytFLdnebbBfLOFyxymXjB6cFYrGb9FM7OCwQ892+VKcFYvsghwViPwQ5KxDz3eTW6bh2LEH67oiHy9ulAz8cx9mIh+v11x7H4YjHT0HKB4KcjXjsgxyOeLh+otOln+h06Sc6XfqJTpd+otOln+h06Sc6XfqJTpd+otNl73e69BOdLrP3vcTeH9f23YIop+Pa2yDHLv/+uoQ/HMehy7+/LuH+OE5d3j7woe0PQQ5d3j7woa1/Yl1C/8S6hP6JdQn9E+sS+ifWJfRPrEvon1iX0D+xLqF/Yl1Cf39dQv/EuoRe61/r8qfj2u0DpQP7IKfJ1z5QOvBDkMPkax8oHTg/ndeDHCZf+0DpwD7IafK1t0sHfjiOs+Sr709u7TvShwVidTe5ddqRrpe8/562DXL6nlavt731h+M4e0+r769KuD+Ow/e0n4KUDwQ5e0/bBzl8T6uF339U7IMcPip+EURfDXL2qPgpyNGj4vx0Xg9y9qg4DrJ7VOyDHD4qKr3d1/rhOA4fFSTvewm/3xuvn1hSsNLbhVn1E0sKVmp/7XGcGvQnlhSsn1hSsH5iScHKH/gUdh/k1KD5A5/C/hDk0KD5A5/Cnp/O60EODZo/8CnsPsipQcvbhVk/HMehQYv+tQZ92JGu8oFRrH2Q0+STD4xi/RDkMPnkA6NY56fzepDD5JMPjGLtg5wmn77f05IPjGJVfX8Ua1sxwHXJm/Y/X6tP+TMKbaJs623Y8uVGrnXr2l9V7Yhgmai2iVJ3n2xZ7sVryzbJ3PhrjJ3BXmiVa7nGv4tCuMpkpb4axfGaVIvuomzu2harsEWUpuuyV7+Lwrn1c5P9sWzXfLv0gh+YvXxO2TLvnBNlaWIj+UiUxWx/ea3XZaKcN1F8E6W1HGIr18W7JPDdpGxh7MpbuNCH4ryaCKyaFUVrsdbvosiV9v14PvKrUQpPwxO6yibKbt3Ce8YFtahtKXf8O3HKzq6M4VfrZuq/jPMwuzyex//Rh+K0z8Sh18/r/E7ex6F0nAf7p46nvnz/YNvOe4R5dzfv1iEsRLnp9YPVX44j2PD9EfJ6OY464mh7I47xZ+Jk7eyD+eXrVVnTmStvH3y/iLN9UOzjYDLmEeeS14+HP3M8ssQRtVfdmbLnI9tHeru2R4PFLO8nXHk5TvTDR5yq/Jk4Rm/EQSvXnYu13dzIaVV6231uc1qV/sMZteW+abK5j/cfH9SCV23afTawj5LvKfS4TZ9H2X+UIWhdpVejGDoP5u4vRnkM88wbz8U3iyO33Z5Jxx+ItLKdFDj8QKSV7eTg4QcirejuRfvs4462/VbsNI2KfyCNtkdy+HHHeZDNxx0/BDn7uGMf5PDjjn2Qw487tvfJ8ccdjbb1Cocfd7TdCoinH3e03azL6ccdbfvB2OHHHfumPR0F+0UU2jXt9gu4sw9N9s50OpS2j3I6lNb4/aG0xp8YBNtHOR0Ea2wfGATbRzkdBGtcPzII9sM5HQ6C7aOcDoKdR9kNgu2v9ekgWNtNs50PgrXduoi/GDr4VZxXE+F4EGwb5XgQbB/ldBCs7XYD+8UgWNPrI4Ng+zjng2C/itM+E4deP6/zO3kf53gQ7FfHU1++f44HwdpuSu4Xg2A/xDkeBPshzvEg2E9xTgfBfopzOgi2v17ng2C/ibN/ULSPDIL9dDz8meM5HgTbu/PxINh2ru4Xg2D7OOeDYL+IY/RGnNNBMOcP9N53E3bHvff9GR0Pgu0HWE4HwX6I8olBMI/VDnpn1au+GKVabrNUjenFKI+x0BmlXX69GoUK5yvy68fCedc9uiDlxSiP92JsV3aVshuSq/tSQRQardt7XfVXUS7UPC1vS29E2R3LvmUe7yPLuwm/ev8+/jZ78+VxaLpr4U1uV2x9VtU342HHQdYt7n4ZxBDEXw0iR0GErt1AsGU30dciKvp6KO2wTH1pV2q/iIGPkWytB/seY9N1fjyCZpCHd6/VbfSlTXbLfT3eOnJIzY12bbJf+z7P6K7ORBb515u2bRdhspJDWWXtkH0Js9tmjLTknMG6gtmfEejafbVmmYO2rvd16S9iaMvnmZX1Of89yvbjt3x5YVo2cDP5GmQ3BEBZHMq8dLu9fQ2yXXGhejqT1uVDvPsN+Euc3ea5hs6gLRNMTN+u0K6mknKdurJe5l9GYXR0ZHGE14+Fl2fi34myaxfHUnWPObNdlO1Vavm68GDyzVUq2xXXCZm4jox8O5rtd0HHV+k0yr5999/UnV7rbbuQ5Wagf4xk0EsO9ZhFeO5QW9/WfHVnXYJ884XSduafO9jyYnP2uwPJKU023RjU9q3nMe+XF+fxlG7PjP+HMI6eyIOfPz/OT2mdOvh+StsxacupquVxyKd3idGV7xlUljee62Ha/+vjP//xv/3zv//Xf/m3//aP//HP//av//3+y8cB9Qz5hwcyUIAKNKADK7AllgtYgFArUCtQK1ArUCtQK1ArUCOoEdQIagQ1ghpBjaBGUCOoEdQYagw1hhpDjaHGUGOoMdQYagw1gZpATaAmUBOoCdQEagI1gZpATaGmUFOoKdQUago1hZpCTaGmUDOoGdQMagY1g5pBzaBmUDOoGdQcag41h5pDzaHmUHOoOdQcag61CrUKtQq1CrUKtQq1CrUKtQq1CrUGtQa1BrUGtQa1BrUGtQa1BrWWao8xdWABEpCBAlSgAR1YgVCDlzC8hOElDC9heAnDSxhewvAShpcwvIThJQwvYXgJw0sYXsLwEoaXMLyE4SUML2F4CcNLGF7C8BKGlzC8hOElDC9heAnDSxhewvAShpcwvIThJQwvYXgJw0sYXsLwEoaXMLyE4SUML2F4CcNLGF7C8BKGlzC8hOElDC9heAnDSxhewvAShpcwvIThJQwvYXgJw0sYXsLwEoaXMLyE4SUML2F4CcNLGF7C8BKGlzC8hOElDC9heAnDSxhewvAShpcwvIThJQwvYXgJw0sYXsLwEoaXMLxE4CUCLxF4icBLBF4i8BKBlwi8ROAlAi8ReInASwReIvASgZcIvETgJQIvEXiJwEsEXiLwEoGXCLxE4CUCLxF4icBLBF4i8BKBlwi8ROAlAi8ReInASwReIvASgZcIvETgJQIvEXiJwEsEXiLwEoGXCLxE4CXSveTe8le6l3QMtbuvKd1LOobaXRoi3Us6htq9BI90L7nXWJbuJR0rsCV2L+lYgKF2TxZI95KOAlSgAR1YgS2xe0nHAoSaQ82h5lBzqDnUHGoOtQq1CrUKtQq1CrUKtQq1CrUKtQq1BrUGtQa1BrUGtQa1BrUGtQa1lmp6XcACJCADBahAAzqwAqFWoFagVqBWoFagVqBWoFagVqBWoEZQI6gR1AhqBDWCGkGNoEZQI6gx1BhqDDWGGkONocZQY6gx1BhqAjWBmkBNoCZQE6gJ1ARqAjWBmkJNoaZQU6gp1BRqCjWFmkJNoWZQM6jBSxReovAShZcovEThJQovUXiJwksUXqLwEoWXKLxE4SUKL1F4icJLFF6i8BKFlyi8ROElCi9ReInCSxReovAShZcovEThJQovUXiJwksUXqLwEoWXKLxE4SUGLzF4icFLDF5i8BKDlxi8xOAlBi8xeInBSwxeYvASg5cYvMTgJQYvMXiJwUsMXmLwEoOXGLzE4CUGLzF4icFLDF5i8BKDlxi8xOAlBi8xeInBSwxeYvASg5cYvMTgJQYvMXiJwUsMXmLwEoOXGLzE4CUGLzF4icFLDF5i8BKDlxi8xOAlBi8xeInBSwxeYvASg5cYvMTgJQYvMXiJwUsMXmLwEoOXGLzE4CUGLzF4icFLDF5i8BKDlxi8xOAlBi8xeInBSwxeYvASg5cYvMTgJQYvMXiJwUsMXmLwEoOXGLzE4CUGLzF4icFLDF7i8BKHlzi8xOElDi9xeInDSxxe4vASH17ymHPy4SWBoXZXSHr3EuUbGRhq95dX3r3E4s8M6MAKDLV7Ntm7l3QMtfsrB+9e0jHU7i0pvXvJPWvv3Us63mpy12l6eMnA+rdRaOHhJR3DS+SetPHwErk7Ch5eMvBWk/vjFA8vGahAAzqwAltieMnAAiQg1ARqAjWBmkBNoCZQU6gp1BRqCjWFmkJNoaZQU6gp1AxqBjWDmkHNoGZQM6hZV7uvsVVgS/Sudl9CL0ACMlCAiggGhJpX/G5LrFCrUKtQq1CrUKtQq1CrUKs4t4pza1BrUGtQa1BrUGsKNKADcW4t1ep1AQuQgAxMtXop0IAOrMBsyVouYAESEGpFgAo0oAOhVqBGUCOoEdSIgTg3wrkRzo2gRhWIlmS0JKMlGWoMNYYaQ42hxmhJxrkxzk1wbgI1wXUTtKSgJQUtKVATqAnUBGoKNUVLKs5NcW6Kc/t/SrujHUl65DzD97LHc1Akg4ygb0UQBGm9NhZYaIW1ZMAQ9t7dxawaPoABn+jkxzfV1fVmRGa/P5MZ0zMvbd7zNm8n5+3kvJ1cl7YubV3aurR1aet2ct3a1q1t3dquSyrvecvbybydzNvJ65LKS8tLy0u7LqnrkrouqeuSui6purS65+26pK5L6rqk6tLq0q5L6rqkrkvquqSuS+q6pK5Lal/avuftumRfl+zrkv36TduvcWPcOG9cN+aNdePv2vZ1yW6X1vqN48a4cd54ae3Srkv2dcm+LtnXJfu6ZF+X7OuS3S+trxvzxrrxdnJc2ri065J9XbKvS/Z1yb4u2dcl+7pkj0uLe96uS/Z1yb4u2XFpcWnXJfu6ZF+X7OuSfV2yr0v2dcmelzbvebsu2dcl+7pkz0ubl3Zdsq9L9nXJvi7Z1yX7umRfl+y7Ltl3XbKvS/Z1yb4u2Xddsu+6ZF+X7OuSfV2yr0v2dcm+LtnXJbsure55uy7Z1yX7umTXpdWlXZfs65J9XbKvS/Z1yb4u2dcle1/avuftumRfl+zrkvZ6/cb95Ebu5EEO8iQvcpKLDLe9yI3cyYMMt8FtcBvcBvf65f3X7cnU26m3w+1BnuRFTjLcDnfAHXAH3EGfB/UO6h3UO+COItPnoM9BnwNuwA24ATfgBn0O6g3qndQ74U7O76TPkz5P+jzhTrgT7oS74C76vKh3Ue+i3gV3cX4XfV70edHnhJtwE27CTbhJn5N6k3qTehNucX6LPhd9LvpccAtuwS24Bbfo86beTb2bejfczfnd9HnT502fN9x9uQ1fNXzV8FXDVw1fNXzV8FV7XW57Ffn2ueGrhq9ag9vg4quGrxq+aviq4auGrxq+ah1u7+RBDvIkw+1w8VXDVw1fNXzV8FXDVw1ftQF3LDJ9xlcNX7WAG3DxVcNXDV81fNXwVcNXDV+1gDs5v/iq4auGr9qEO+Hiq4avGr5q+Krhq4avGr5qC+7i/OKrhq8avmoLLr5qSb1JvfiqJdyEm3DxVcNXDV+1pN7HV+/H/D/59w7WT+7kQQ7yJC9ykou8b94vMtwNd8PdcDfcDXfD3XD35fbXi9zInTzIQZ7kRU5ykeE2uA1ug9vgNrj33q31uxHU+t0Jah1fdXzV8VVnfdVZX3V81fFVx1cdX3V81fFVx1cdX3V81fFVH3AHXHzV8VXHV33AHXDxVcdXHV91fNXxVcdXHV/1gBtFvj+/HV91fNUn3AkXX3V81fFVx1cdX3V81fFVX3BXJ9NnfNXxVV9wF1x81Rdc1led9VXHV531VWd91fFVT85v0uekz6yvesEtuAW34LK+6qyvOuurzvqqs77qBXdzfjd93vSZ9VXfcDfcDXfDZX3VWV8N1leD9dVgfTXuXnUbryBP8iInufgcuA1ug8v6arC+GqyvBuurwfpq4KvRinz7PPqL3MhwO9wOt8PFVwNfDXw18NXAV2PAHZ1Mn/HVwFeD+8Ex4OKrga8Gvhr4auCrga8GvhoBNzi/+Grgq4GvBveDY8LFVwNfDXw18NXAVwNfDXw1JtzF+cVXA18NfDW4HxwLLr4a+Grgq4GvBr4a+Grgq8H6arC+Gvhq4KuBrwbrq8H6auCrga8Gvhr4auCrga8GvhoFtzi/+Grgq4GvBveDY8PFVwNfDXw18NXAVwNfBb6Kuxve4j5aa4GvAl8FvgruB4P9q8BXga8CXwW+CnwV+CrwVbC+CtZXga8CXwW+CtZXwfoq8FXgq8BXga8CXwW+CnwVHe597NYCXwW+CnwV3A8G+1eBrwJfBb4KfBX4KvBV4KsIuMH5xVeBrwJfBfeDwf5V4KvAV4GvAl8Fvgp8FfgqJtzJ+cVXga8CXwX3g8H+VeCrwFeBrwJfBb4KfBX4KrgfjOT84qvAV4GvgvvB4H4w8FXgq8BXga8CXwW+CnwVBbc4v/gq8FXgq2D/Kti/CnwV+CrwVeCrwFeBrwJfBfvt8z68axNfTXw18dVk/2qyfzXx1cRXE19NfDXx1cRXE19N9tvnfZTXJr6a+Griq8n94OR+cOKria8mvpr4auKria8mvprst8/7YK9NfDXx1cRXk/vByf7VxFcTX018NfHVxFcTX018Ndlvn8H5xVcTX018NbkfnOxfTXw18dXEVxNfTXw18dXEV5P99jk5v/hq4quJryb3g5P9q4mvJr6a+Griq4mvJr6a+GqyfzXZv5r4auKria8m94OT/faJrya+mvhq4quJrya+mvhqst8+i/OLrya+mvhqcj842W+f+Griq4mvJr6a+Griq4mvJvvtc3N+8dXCVwtfLe4HF/vtC18tfLXw1cJXC18tfLXw1WK/ffF8cOGrha8WvlrcDy58tVhfLdZXC18t7gcX++2L/auFrxa+Wvhqsb56hq2f/c/V737dGi9yI3fyIAd5khc5yUWGG3ADbsANuAE34AbcgBtwA+6EO+FOuBPuhDvhTrgT7oQ74S64C+6Cy/3gYv9qsX+18NXCVwtfLdZXi/XVwlcLXy18tfDVwlcLXy18tfDVwlcLXy2eDy6eDy58tfDVwleL+8HF/tXCVwtfLXy18NXCVwtfLXy1eD64eD648NXCVwtfJfeDyf5V4qvEV4mvEl8lvkp8lfgqeT6YPB9MfJX4KvFVcj+Y7F8lvkqeDybrq2R9lfgqWV8l66vEV8l+e7LfnswzJOur5H4w2b9K9q+S/fZkfZWsr5L1VbK+StZXyX578nwweT6YzDMk66vkfjDZv0r2r5L99mR9layvkvVVsr5K1lfJfnvyfDB5PpjMMyTrq+R+MNm/Svavkv32ZH2VrK+S9VWyvkrWV4mvkueDzH03Br8bk9+N0e/G7Hdj+Lsx/d0Y/26JrxJfJb5iBLwl++3JPEPiq8RXia8YBG/J/lXiq8RXia8SXzEO3pgHbwyEt2S/PZlnSHyV+CrxFWPhLdm/KnxV+KrwVeErhsMb0+GN8fBW7LcX8wyFrwpfFb5iSLwV+1eFrwpfFb4qfMWoeGNWvDEs3or1VbG+KnxV+KrwFSPjrVhfFb4qfFX4qvAVg+ONyfHG6Hgr9tuL54OFrwpfFb5igLwV+1eFrwpfFb4qfMUYeWOOvDFI3or99uL5YOGrwleFrxgnb8X+VeGrwleFrwpfMVTemCpvjJW3Yn1VrK8KXxW+KnzFcHkr1leFrwpfFb4qfMWIeWPGvDFk3or99uL5YOGrwleFrxg1b8X+VeGrwleFrwpfMXDemDhvjJy3Yr+9eD5Y+KrwVeErBs9bsX9V+Krw1cZXG18xft6YP28MoLfNfvvm+eDGVxtfbXzFGHrb7F9tfLXx1cZXG18xjN6YRm+Mo7fN/eDm+eDGVxtfbXzFUHrb3A9ufLXx1cZXG18xmt6YTW8Mp7fNfvvm+eDGVxtfbXzFiHrb7F9tfLXx1cZXG18xqN6YVG+MqrfNfvvm+eDGVxtfbXzFwHrb7F9tfLXx1cZXG18xtt6YW28MrrfNfvvm+eDGVxtfbXzF+Hrb3A9ufLXx1cZXG18xxN6YYm+MsbfNfvvm+eDGVxtfbXzFMHvb7F9tfLXx1cZXG18x0t6YaW8MtbfNfvvm+eDGVxtfbXzFaHvb7F9tfLXx1cZX+/qqM9/emW/vzLf3191v76/7fLC/rq/66/qqv66vOvPt/fWC2+A2uA3u9VVnvr0z396Zb++vBvfuX/XX9VV/XV/11/VVZ769vzrcDrfD7XCvrzrz7Z359s58e38NuPf5YH8N+jzo86DPA+6AO+AOuAE36HNQb1BvUG/ADc5v0Oegz0GfJ9wJd8KdcCfcSZ8n9U7qndQ74S7O76LPiz4v+rzgLupd1Luod8FdcBNuwk3qTepNuEm9j6/e+5/9M9/+/oWw/TPf/v5Xo/pnvn2c9z++ivP+x1dx3v/46v07s/tnvv2TD/f9z7/0z3z7Jx/uPJ//+OqTD3c9n3+467z++OqTG/lw16n98dUnH+77L9T3z3z7Jx9unmN+fPXJh5vPZ+7f+TPf/smH+/7dvf0z3/7Jh/v+u/n9M9/+yZO8yIf7/lv7/TPf/sn75sdX739AtX/m29+/G7d/5ts/+XDf/8Rd/8y3f/Lh7nNsj68+Oclv7nz/joD+zLd/8vHVz5PKkxu5k9/cn6eWJwd5nnyO7fjqm9/c808S9We+/Zv3zcdX8/2Lffsz3/7Nh3uu7We+ffZzDMdX3zzJhzvO8RxfffPhjucz983HV998uOeab8dX33y453p+5tu/eZIPN85xHl998+HO09vjq08+vvp5GnhyIx/uPJ95fPXNQT7ceT7/+OqbD/f8XDzz7d+8bz6+mutcA8dX33y4eY7t+OqbDzdPb4+vvnmRD7dOn4+vvvlw63CPr+Y+n3l8NZ9r+/jq+/ogB3mSFznJxWfu+3q97uvVeB1uwa3g/XALbsGtIu/7vZt6N9wNdw/eT7178jrcnbwOd996n/n2b759fubbv68PXg9en7y+eD3JRb71PvPtn9dbI3feM3g9eH3y+uJ1uA1uo94Ot8PtcDvcTr0dbofb4fbidbgD7oA76POgzwPuoM+DPg+4A+6AG3ADbsAN6g24Qb0BN+519cy3f1+HO+/P0TPf/n0d7oQ7Ob8T7qTPk3on3Ml1tah3cT0vuIs+L+pdcBf1LrgL7oKLr3pSb3Jd4auOrzq+6viq46uecBNuwcVXHV91fNXxVcdXHV/14vziq46vOr7q+Kpv6t1wN9wNF191fNXxVd+XO/DVeDVy5z2D14M8yYuc5CLf63m0ez0PfDXw1cBXo8HFV6PBxVcDXw18NTpcfDV6Jw/eAxdfDXw18NXAVwNfDXw18NXAV2NQ77jndwy4+GqM5D3UOzi/+GpE43W4+GoEXHw18NUI6g3qxVdjwp1w8dXAV2PSZ3w1Jlx8NSbcCXdxfhd9xldjwV3Ui6/G4vziq7HgLrgJF18NfDXw1cBXIyfvoV58NfDVYH018NUo+oyvBr4aBbfg4qvB+mrgq1Fw8dXYcFlfDdZXg/XVYH018NXAVwNfDdZXga+C9VWwvgrWV4GvAl/Fa/Ge5PXidbj4KvBVNLj4KlhfBb4KfBUteU/x+v35DdZX0akXXwXrq8BXga+iw+1wO1x8FfgqBlx8FfgqWF8FvopBn1lfBb4KfBX4KlhfBb4KfBWsryImn0O9rK+C9VUEXHwV+CrwVUyuK3wV+CrwVeCrYH0VrK+C9VWwvgp8FayvgvVVLOplfRWLellfBb4KfBX4KrgfjISLrwJfBb4KfBX4KlhfBb4K1leBr6Lg4qvAV4GvgvVV4KtgfRX4KvBVfHzVT3644+SHO0+e5EVOcpH37zw/vnpyI3fyIAd5khc5yUWG2+A2uA1ug9vgNrgNboPb4Da4H1+tkxu5kwf54ebJkwy3w+1wO9xBvYN6B/UO6h3UO6h3wB1wB9wBN+AG3IAbcANuwA24ATfgBtwJd9LnSZ8nff746sn0+eOrJ8OdcCfcBXdR76LeRb2Lehf1LupdcBfcBTfhJtyEm3ATbsJNuAk34Sbcglv0uehz0eeiz0Wfiz4X3IJbcDfcTb2bejf14quJrya+mvhq4quJrxa+Wvhq4auFrxa+Wvhq4auFrxa+WvhqteuN1Rq5kwf5emO1SYaLrxa+Wvhqdert1Nupt1Nvp95Ovfhq4auFrxa+Wvhq4auFrxa+Wvhq4auFrxa+Wh9fnV59fHVy0Oegzx9fnR5+fPVkuPhq4auFrxa+Wvhq4as1qXdS76TeCXfCnXDx1cJXC18tfLXw1cJXC18tfLU+vjr9+fjqyUmmzx9fnb59fPVkuPhq4auFrxa+Wvhq4auFrxa+WvhqFdyCW3ALbsEtuPhq4auFrxa+WpvravPzu/n53UHm53cvMlx8tfBV4qvEV4mvEl8lvkp8lfgq8VXiq8RXyfoqWV8l66tkfZWsr5L1VbZ7XWVLcpHvz2/2e13lx1dPhouvEl8lvkp8lfgq8VXiq8RXia8SXyW+SnyV+CrxVeKrZH2VrK8SXyW+yujkQb7/X8iYZLj4KvFV4qvEV4mvEl8lvkp8lfgq8VXiq8RXia8SXyW+SnyVi3pXkCeZ6+rjq9OHj6+eDJf1VeKrxFeJrxJfJb5KfJX4KvFV4qvEV4mvEl8lvkp8lUW9Rb3Fz1Hxc1TXz7n5OWJ9layvkvVVsr5K1lfJ+irxVeKrxFeFrwpfFb4qfFX4qvBVvW699Upyka83qt16qzUyXHxV+KrwVbG+KtZXxfqqWF8V66tifVX4qvBV4avCV9Wpt1Nvp95OvYN6B/Xiq8JXha8KXxW+KnxV+KrwVXE/WNwPFveDxf1gsb6quNdzBfUG9Qb1xr2ea1Ivvip8Vfiq8FXhq8JXha8KXxW+KnxV+KrwVeGrwleFrwpfFb4qfFX4qvBV4avCV4WvCl8Vvip8Vfiq8FXhq6r7/6PifrC4HyzuB6vu/4+K+8FifVWsr4r1VbG+KtZXha8KXxW+KnxV+Ko2fd5cV5vrat+fo/2619V+NfLlbny18dXGV5v11WZ9tVlfbdZXm/XV5n5wcz+4uR/cLci3z7stMlx8tfHVxlcbX218tfHVxle73+t546uNrza+2v3+/G58tVlfbXy18dXGVxtfbXy18dXmfnBzP7hZX23WV5v7wc394MZXm/vBzfpqs77arK8266s94bJ/tdm/2uxf7Xl/jjb7VxtfbXy18dXGVxtf7QV3wcVXG1/tBXdxXbF/tdm/2vhq46udcBNuwk24CTfh4quNrza+2vhq46uNrza+2vhq46uNrza+2qyvdnFdbbjcD+7NdbW5rvDV3vwc4auNrza+2vv3z9F4XV+N1+s3d7xenTzIQZ587yK/uT87YCcXed98fPXN7eRxciePkw/r+Gq9/zWo8cy3f/MiH257nVzkw23nM4+vvrmRO/lw2zw5yIf7nvMcz3z7Nyf5cPs55uOrTz6+Wu+Zz/HMt3/z4b5nPscz3/7NhzvOZx5fffMiH+54Pr/IhxvnmI+vvrmRDzfO+Tq++ubDjXNsx1fffLjz9Pn46puLfLjr9Pz46psPd51jPr765sNd55iPr775cNfhHl99c5IPN0+vjq8++fjqZ1fn5Ebu5EE+3DrX4fHVNy/y4dY55uOrVec4j68+OR/u6UM28uHuc2zHV98c5MPd59o7vvrmNzefn5Hjq2/eNx9f/ezSnNzI/eRzbMdX3/zm5nM9H1998yIfbjvXw/HVNx9uO/0/vvrmRj7cfuo6vvrmIB9uP6zjq28+3Of6P77K5zo/vnryM9/+zY3cyYMc5Ele5CQXGW6D2+A2uA1ug9vgNrgNboPb4Ha4HW6H2+F2uB1uh9vhdrgd7oA74A644+Guk4M8yQ83T05ykffN8SK3+znRyXAjeP8kww24ATfgTrgT7oQ74U7qndQ74U64E+6Eu+CuRu7kQabeBXctcpKLvG9OuAk34SbchJv0Oak3qTepN+E+vvpk+lz0uehzwS24BbfgFtyiz5t6N/Vu6t1wN+d30+dNnzd93nD35fbXi9zInTzIQZ7kRb7c/iry7XNvL3Ijw21wG9wGt8FtSS4y9Xbq7XB7Jw9ykCcZbofb4Xa4A+6gz4N6B/UO6sVXfSwyfR70edBnfNUDbsANuPiq46uOrzq+6viqB9zJ+cVXHV91fNUn3AkXX3V81fFVx1cdX3V81fFVX3AX5xdfdXzV8VVfcBdcfNXxVcdXHV91fNXxVcdXPeEm5xdfdXzV8VUvuAUXX3V81fFVx1cdX3V81fFV33A35xdfdXzV8VXfcDdcfNXx1cBXA18NfDXw1cBX43W547XISS7y7fNocBtcfDXw1cBXA18NfDXw1cBXo8HtL3Ijd/Igw+1w8dXAVwNfDXw18NXAVwNfDdZXg/XVwFcDXw18NVhfDdZXA18NfDXw1cBXA18NfDXw1Qi4wfnFVwNfDXw1JtwJF18NfDXw1cBXA18NfDXw1VhwF+cXXw18NfDVWHAXXHw18NXAVwNfDXw18NXAVyPhJucXXw18NfDVKLgFF18NfDXw1cBXA18NfDXw1Si4m/OLrwa+GvhqbLgbLr4a+Grgq4GvAl8Fvgp8Fa/LjVeQJ3mRk1x8Dlx8Ffgq8FXgq8BXga8CX0WD24p8+xz4KvBVdLgdLr4KfBX4KvBV4KvAV4GvYsAdnUyf8VXgq+B+MLgfDHwV+CrwVeCrwFeBrwJfRcANzi++CnwV+Cq4H4wJF18Fvgp8Ffgq8FXgq8BXMeEuzi++CnwV+Cq4H4wFF18Fvgp8Ffgq8FXgq8BXkXCT84uvAl8FvgruByPh4qvAV4GvAl8Fvgp8FfgqCm5xfvFV4KvAV8H9YGy4+CrwVeCrwFeBrwJfTXw1X5c7X508yEGe5MXnJLnIcPHVxFcTX018NfHVbHDbIie5yLfPk/vB2eHiq4mvJr6a+Griq4mvJr6aHe54kekzvpr4anI/OPHVZH01WV9NfDW5H5wBl/2ria8mvpr4arK+mh9f7ZMPN+LkIu+bH1+dvf1nvv2bD/fs4T/z7d98uLOdPMmHO5/PTHKRD3eeuh5fffLhrsN9fPXJgxzkw12n3sdXn5zkwz17/s98e559/me+/ZsP9/17UcYz3/7Nh5vn2B5fffIkH+7796KMZ779mw+3zjE8vnry46tPPtw6x/b46pMP9+ztP/Pt3/zm1vv3loxnvv2bk1wn95P3zcdX9Tp9O76q1zmG46tvHuQ4+RzPnuTDbc9nJrnIh9ve5/qZb//mw+3j5E4e5MM9+/nPfPs3H+77d/iMZ779mw/3/ft8xjPf/snHVzXOZx5ffXMnH+44n3989c2He34unvn2b07y4cY6ed98fFVxju346psP9/17S8Yz3/7NQT7cuU9e5MM9z8Ke+fZvPtz1vjae+fZvbuROHuQgT/IiJ7nIcANuwA24ATfgBtyAG3ADbsCdcCfcCXfCnXAn3Al3wp1wJ9wFd8FdcBfcBXfBXXAX3AV3wU24CTfhJtyEm3ATbsJNuAm34BbcgltwC27BLbgFt+AW3A13w91wH1+dZ77PfPs3T/IiJ7nI+3d+5tu/uZE7+XDP/zue+fZvPtz37xEaz3z7NyfvKfK+73l89cntvufx1Sc/3HEy3MdXnwz38dUnw3189eQO9/HVJ8Pt1Pv46jmGDvfx1SfDfXz1yXAfX30y3MdXnwx3UO/jq+cYBtxBnwfcQZ8DbtDngPv46pPhBvU+vnqOIeAGfQ64kz5PuJM+T7iPrz4Z7qTex1fPMUy4kz4vuIs+L7iLPi+4i+t5wV3U+/jqOYYFN+lzwk36nHCTPifc5HpOuEm9j6+eYyi4RZ8LbtHnglv0ueAW13PBLep9fPUcw+OrT364efIgB3mSFznJRX6477XBM9/+zY3cyYMc5Ele5CQXGe7jqzPT8sy3f3MnH27Nkw/3zLQ88+3fvMhJLvLhnjXwM99eZ77lmW//5k4e5CBP8iIn+XDPHNoz3/7Jj6/2qf34ar/O8RxfffMgB3mSFznJRd43H19988NdJ3fyIAd5khc5yUXeN88XGe6EO+FOuBPuhDvhTrgT7oK74C64C+6Cu+AuuAvugrvgJtyEm3ATbsJNuAk34SbchFtwC27BLbgFt+AW3IJbcI+v9plpfObbdzs/X8dX39zJgxzkSV7kJBd5/87PfPs3N3InD3KQJ3mRk1xkuA1ug9vgNrgNboPb4Da4DW6D2+F2uB1uh9vhHl/9fMLJi5zkwz1zcc98+ycfX31zI3fyuJ/z+OqT4T6++rw/yXAH3IAbcANuwA24ATeoN6g34AbcCXfCnXAfX31ykCeZeifcx1efvG9+fPXJjQx3wV1wF9wFd9HnRb2LepN6E+7jq0+mz0mfkz4n3ISbcBNuwS36XNRb1FvUW3CL81v0uehz0ecNd8PdcDfcDXfT5029m3o39e7f3Hjm27+5kTt5kH9z45lv/+ZFTnKR983tRW7kTobbgjzJi5xkuA1uh9vhdrh9kKm3U2+n3g63F5k+D/o86POAO+AOuAPugDvo86DeQb1BvQE3OL9Bn4M+B30OuAE34AbcCXfS50m9k3on9U64k/M76fOkz5M+L7gL7oK74C64iz4v6l3Uu6h3wU3Ob9LnpM9JnxNuwk24CTfhJn0u6i3qLeotuMX5Lfpc9Lnoc8EtuBvuhrvhbvq8qXdT76beDXdzfvFVw1cNX7XX5bbXIAd5khc5yUW+9TZ81Rrc1smDHORJhtvg4quGrxq+aviq4auGrxq+ah3uXV9Fw1cNXzV81QbcARdfNXzV8FXDVw1fNXzV8FUbcIPzi68avmr4qgXcgIuvGr5q+Krhq4avGr5q+KpNuJPzi68avmr4qk24Ey6+aviq4auGrxq+aviq4au24C7OL75q+Krhq5ZwEy6+aviq4auGrxq+aviq4atWcIvzi68avmr4qhXcgouvGr5q+Krhq4avGr5q+KptuJvzi68avmr4qr8ut78auZMHOciTvMhJLjLc9iI3cicPMtwGF191fNXxVcdXHV91fNXxVe9we5AneZGTDLfDxVcdX3V81fFVx1cdX3V81QfcUWT6jK86vuoBN+Diq46vOr7q+Krjq46vOr7qE+7k/OKrjq86vuoT7oSLrzq+6viq46uOrzq+6viqL7iL84uvOr7q+Kon3ISLrzq+6viq46uOrzq+6viqJ9zi/OKrjq86vuoFt+Diq46vOr7q+Krjq46vOr7qG+7m/OKrjq86vuob7r7cga8Gvhr4auCrga8Gvhr4arwud7yKfPs88NXAV4P7wdHg4quBrwa+Gvhq4KuBrwa+Gh1u7+RBDvIkw8VXg/XVYH018NXgfnAMuAMuvhr4auCrwfpqfHw1Tn64+50/vnry4Y7z+Y+vPnmQgzzJi5zkIu+bH199MtwJd8KdcCfcCXfCnXAn3AV3wV1wF9wFd8FdcBfcBXfBTbgJN+Em3ISbcB9fved24plv/+Yi75sfX31yI3fyIAd5kg83zjE8vvrkh3uun8dXT3589bzn8dUnd94zyMF7Jvnh9pPhPr765Mt95tu/+XKf+fZvHrwnyJP3LHL+PoZnvv37+r65wX189clwH199MtzHV58MtyW57jE0uP1Fhts7GW4PMtzHV58Mt1Pv46vnGAbcQZ8H3EGfB9xBnwfcx1efDHdQ7+Or5xgCbtDngBv0OeAGfQ64UWS4k3ofXz3HMOFO+jzhTvo84U76POFOrucFd1Hv46vnGBbcRZ8X3EWfF9xFnxfc5HpOuEm9j6+eY3h89clPn9fJi5zkIu+bH199ciM/3Dp5kIM8yYuc5CLvmz++enIjw318NcfJQZ7kw33P/cYz377fs47xzLd/8/6dn/n2b27kw33PPcYz3/7zhOXkIE/yIie5yPvmx1effLjvWa945tu/+eHWyYeb53geX+U8eZGTXOR98+OrT27kTh7kIMPtcDvcDrfDHXAH3AF3wB1wB9wBd8AdcAfcgBtwA27ADbgBN+AG3IAbcCfcCXfCnXAn3Al3wp1wJ9wJd8FdcBfcx1fvuZp45tt3nevq8dUnL3KSi7xvfnz1yY3cyYMMN+Em3ISbcBNuwS24BbfgFtyCW3ALbsEtuI+v6vxsPr765E4e5CBP8iInucj7d37m27+5kTt5kIM8yYuc5CLDbXAb3Aa3wW1wG9wGt8FtcBvcDrfD7XA73A63w+1wO9wOt8MdcAfcAXfAHXAH3AF3wB1wB9yAG3ADbsANuAE34AbcgBtwJ9wJd8KdcCfcCXfCnXAn3Al3wV1wF9wFd8FdcBfcBXfBXXATbsJNuAk34SbchJtwE27CLbgFt+AW3IJbcAtuwS24BRdfLXy18NXCVwtfLXy18NXCVwtfLXyV+CrxVeKrxFeJrxJfJb5KfJX4KvFV4qvEV4mvEl8lvkp8lfgq8VXiq8RXia8SXyW+SnyV+CrxVeKrxFeJrxJfJb5KfJX4KvFV4qvEV4mvEl8lvkp8lfgq8VXiq8RXia8SXyW+SnyV+CrxVeKrxFeJrxJfJb5KfJX4KvFV4qvEV4mvEl8lvkp8lfgq8VXiq8RXia8SXyW+SnyV+CrxVeKrxFeJrxJfJb5KfJX4KvFV4qvEV4mvEl8lvkp8lfgq8VXiq8RXia8SXyW+SnyV+CrxVeKrxFeFrwpfFb4qfFX4qvBV4avCV4WvCl8Vvip8Vfiq8FXhq8JXha8KXxW+KnxV+KrwVeGrwleFrwpfFb4qfFX4qvBV4avCV4WvCl8Vvip8Vfiq8FXhq8JXha8KXxW+KnxV+KrwVeGrwleFrwpfFb4qfFX4qvBV4avCV4WvCl8Vvip8Vfiq8FXhq8JXha8KXxW+KnxV+KrwVeGrwleFrwpfFb4qfFX4qvBV4avCV4WvCl8Vvip8Vfiq8FXhq8JXha8KXxW+KnxV+KrwVeGrwleFrwpfFb4qfLXx1cZXG19tfLXx1cZXG19tfLXx1cZXn/n29+9zjs98+/vvrcSZb++v998NjzPf/jvHyfvkSV7v3NbJSS7yfufz3G2/ffWT+8mNfLjn+dqZb/+dD7fPv//6w//+57/9+Z//5S9/+l9/+G//+fPH//Ef//rHf//zX//188d//z//9v3Kv/ztz3/5y5//5z/929/++sc//ff/+Nuf/ukvf/3j+2t/eH3+8w8/3tm/fsTy+sdff/g5in/Y718pvH/uBn7+PM7X5/z5+prvr7+/4efmdfz6+U+9Xzjf8fp54ec/8x//fj7iP8/3jf4r+vd7Zvs11/vL/f3l89LPw8R+Xhq/X/rpUW/vl+L7Ib1+jfp+SMSv2O8vz//3O9b93PjVz7vyvpS/Rn+/VPcb968e75f2tw99/HzjnJ+qf7Yq8ze4vzE/nE+9vc+fP+ap9ncbe44fbny+fb5+rdfvb/9pYH/+eL59vSsf59vb99vbT7vaHJ9vb+3nT/1399rPBdD67363nz3h9rSz9f/qB4zfBfzsjveVv5udv2a/h1y/er7ON8TtYf604bw2//8nvd2z87MN/VxJ74+t/FU/p+rvf//Hv/9f",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "notify_created_nullifier_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "random",
        "decompose_hint",
        "lte_hint",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "commit_public_user",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "src_asset",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 90
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "src_receiver",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3559210201980528457": {
            "error_kind": "string",
            "string": "Function commit_public_user can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "10870837545714573535": {
            "error_kind": "string",
            "string": "HTLCAlreadyExists"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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EwAqGBMUHAoKEwIcChEKAgQqEy8RBCoKORMAKhETCi0IAREAAAECARwKEhMAJwISACAnAh4EPy0IAD8tCgtALQoSQQAIAB4AJQAAI9MtAgAALQpAGAQqOxgSACoTEhgnAhIAQCcCHgQ/LQgAPy0KC0AtChJBAAgAHgAlAAAj0y0CAAAtCkATBCo8ExIAKhgSExwKPhIAJwIYAEgnAh8EOy0IADstCgs8LQoYPQAIAB8AJQAAI9MtAgAALQo8HgQqEh4YACoTGBInAhMAaCcCHgQ7LQgAOy0KCzwtChM9AAgAHgAlAAAj0y0CAAAtCjwYBCoQGBMAKhITEBwKOhIAJwITAHAnAh4EHy0IAB8tCgsgLQoTIQAIAB4AJQAAI9MtAgAALQogGAQqEhgLACoQCxItCAELJwIQBBgACAEQAScDCwQBACILAhAtChATLQ4SEwAiEwITLgyARwATACITAhMuDIBHABMAIhMCEy4MgEcAEwAiEwITLgyARwATACITAhMuDIBHABMAIhMCEy4MgEcAEwAiEwITLgyARwATACITAhMuDIBHABMAIhMCEy4MgEcAEwAiEwITLgyARwATACITAhMuDIBHABMAIhMCEy4MgEcAEwAiEwITLgyARwATACITAhMuDIBHABMAIhMCEy4MgEcAEwAiEwITLgyARwATACITAhMuDIBHABMAIhMCEy4MgEcAEwAiEwITLgyARwATACITAhMuDIBHABMAIhMCEy4MgEcAEwAiEwITLgyARwATLQ4LERwKGgsAHAoXEAAcChkSABwKGxMAHAocFwAcCh0YABwKFRkAHAoUFQAcCgoUAC0IAQonAhoEDAAIARoBJwMKBAEAIgoCGi0KGhstDgwbACIbAhstDgsbACIbAhstDhYbACIbAhstDhAbACIbAhstDhIbACIbAhstDhMbACIbAhstDhcbACIbAhstDhgbACIbAhstDhkbACIbAhstDhUbACIbAhstDhQbHAoJCwAcCgcJAC0IAQcnAgwEDAAIAQwBJwMHBAEAIgcCDC0KDBAtDgYQACIQAhAtDgsQACIQAhAtDggQACIQAhAuDIBHABAAIhACEC4MgEcAEAAiEAIQLgyARwAQACIQAhAuDIBHABAAIhACEC4MgEcAEAAiEAIQLgyARwAQACIQAhAtDgkQACIQAhAuDIBKABAuCIBGAA0jAAARmw0iAA2AUQAMJAIADAAAHKwjAAARsC0LEQotCwoMACIMAgwtDgwKLQgBDCcCDQQEAAgBDQEnAwwEAQAiDAINLQoNEC4MgEcAEAAiEAIQLgyARwAQACIQAhAuDIBHABArAgANAAAAAAAAAAAXAAAAAAAAAAAtCAEQJwIRBAUACAERAScDEAQBACIQAhEtChESLgyARwASACISAhIuDIBHABIAIhICEi4MgEcAEgAiEgISLQ4NEi0IAQ0AAAECAS0ODA0tCAEMAAABAgEtDhAMLQgBEAAAAQIBLgyARgAQLQgBEQAAAQIBLgyARQARLQsKEgAiEgISLQ4SCi4IgEYAByMAABKfDSIAB4BSABIkAgASAAAcYiMAABK0JwITBBQtCAAULQoNFS0KDBYtChAXLQoRGAAIABMAJQAAJNMtAgAALQoVEi0IAQwnAg0EGQAIAQ0BJwMMBAEAIgwCDScCEAQYACoQDRAtCg0RDCoREBMWChMTJAIAEwAAEyYuDIBHABEAIhECESMAABMFLQgBDQAAAQIBLQ4MDS4IgEYAByMAABM+DSIAB4BSAAwkAgAMAAAcFSMAABNTLQsNCicCDAQYLgIACoADKACABAQAGSUAACVHLgiABQAQACoQDBEtDhIRLQ4QDS4IgEYAByMAABOMDCoHDAokAgAKAAAb5iMAABOeLQgBCgAAAQIBKQIADAB6PyscLQgBDScCDgQNAAgBDgEnAw0EAQAiDQIOLQoOEC0ODBAAIhACEC0OBRAAIhACEC0OCxAAIhACEC0OCBAAIhACEC0OCRAAIhACEC0OBhAAIhACEC4MgEcAEAAiEAIQLgyARwAQACIQAhAuDIBHABAAIhACEC4MgEcAEAAiEAIQLgyARwAQACIQAhAuDIBHABAtDg0KLQsBBQAiBQIFLQ4FAScCBQIALQgBBicCCAQfAAgBCAEnAwYEAQAiBgIIJwIJBB4AKgkICS0KCAsMKgsJDBYKDAwkAgAMAAAUmi0OBQsAIgsCCyMAABR7LQgBCAAAAQIBLQ4GCC0LAQYAIgYCBi0OBgEuCIBGAAcjAAAUvw0iAAeAUwAGJAIABgAAG5kjAAAU1C0LCAYnAggEEC0IABAtCgYRAAgACAAlAAAl1S0CAAAtChEHLQsKBi4CAAaAAygAgAQEAA0lAAAlRy4IgAUACAEiAAiATQAJLQ4HCS0OCAotCwIGACIGAgYtDgYCLQgBBicCBwQfAAgBBwEnAwYEAQAiBgIHJwIIBB4AKggHCC0KBwkMKgkICxYKCwskAgALAAAVdS0OBQkAIgkCCSMAABVWLQgBBwAAAQIBLQ4GBy0LAgYAIgYCBi0OBgIuCIBGAAEjAAAVmg0iAAGAUwAGJAIABgAAG0wjAAAVry0LBwInAgcEEC0IABAtCgIRAAgABwAlAAAl1S0CAAAtChEGLQsKAi4CAAKAAygAgAQEAA0lAAAlRy4IgAUABwEiAAeATgAILQ4GCC0OBwotCwMCACICAgItDgIDLQgBAicCBgQfAAgBBgEnAwIEAQAiAgIGJwIHBB4AKgcGBy0KBggMKggHCRYKCQkkAgAJAAAWUC0OBQgAIggCCCMAABYxLQgBBgAAAQIBLQ4CBi0LAwIAIgICAi0OAgMuCIBGAAEjAAAWdQ0iAAGAUwACJAIAAgAAGv8jAAAWii0LBgInAgYEEC0IABAtCgIRAAgABgAlAAAl1S0CAAAtChEDLQsKAi4CAAKAAygAgAQEAA0lAAAlRy4IgAUABgEiAAaATwAHLQ4DBy0OBgotCAECJwIDBB8ACAEDAScDAgQBACICAgMnAgYEHgAqBgMGLQoDBwwqBwYIFgoICCQCAAgAABceLQ4FBwAiBwIHIwAAFv8tCAEDAAABAgEtDgIDLQgBAicCBgQfAAgBBgEnAwIEAQAiAgIGJwIHBB4AKgcGBy0KBggMKggHCRYKCQkkAgAJAAAXcC0OBQgAIggCCCMAABdRLQgBBgAAAQIBLQ4CBi0IAQInAgcEHwAIAQcBJwMCBAEAIgICBycCCAQeACoIBwgtCgcJDCoJCAsWCgsLJAIACwAAF8ItDgUJACIJAgkjAAAXoy0IAQUAAAECAS0OAgUnAgIEWicCBwQ8LgiARgABIwAAF+QNIgABgFMACCQCAAgAABoJIwAAF/ktCwMCJwIEBBAtCAAQLQoCEQAIAAQAJQAAJdUtAgAALQoRAy0LCgIuAgACgAMoAIAEBAANJQAAJUcuCIAFAAQBIgAEgFAABy0OAwctCwYCJwIGBBAtCAAQLQoCEQAIAAYAJQAAJdUtAgAALQoRAy4CAASAAygAgAQEAA0lAAAlRy4IgAUAAgEiAAKAUQAGLQ4DBi0LBQMnAgUEEC0IABAtCgMRAAgABQAlAAAl1S0CAAAtChEELgIAAoADKACABAQADSUAACVHLgiABQADACoDDwUtDgQFLQ4DCi0IAQInAgQEDQAIAQQBJwMCBAEAIgICBCcCBQQMACoFBAUtCgQGDCoGBQcWCgcHJAIABwAAGRouDIBHAAYAIgYCBiMAABj5LQgBBAAAAQIBLQ4CBC4IgEYAASMAABkyDCoBDwIkAgACAAAZvCMAABlELQsEAScCBAQMBiIEAgInAgYEAwAqBAYFLQgBAwAIAQUBJwMDBAEAIgMCBS0OBAUAIgUCBS0OBAUnAgYEAwAqAwYFACIBAgYuAgAGgAMuAgAFgAQuAgAEgAUlAAAGUwAiAwIFLQsFBCcCBgQCACoFBgE3CwABAAQmACIDAgUAKgUBBi0LBgItCwQFLgIABYADKACABAQADSUAACVHLgiABQAGACIGAgcAKgcBCC0OAggtDgYEASIAAYBJAAItCgIBIwAAGTIAIgQCCQAqCQELLQsLCC0LAwkuAgAJgAMoAIAEBAAfJQAAJUcuCIAFAAsAIgsCDAAqDAENLQ4IDS0OCwMBIgABgFMACAwqCAIJJAIACQAAGl8lAAAmlAAiBAILACoLCAwtCwwJLQsGCC4CAAiAAygAgAQEAB8lAAAlRy4IgAUACwAiCwIMACoMAQ0tDgkNLQ4LBgAqAQcIDCoIAgkkAgAJAAAasiUAACaUACIEAgsAKgsIDC0LDAktCwUILgIACIADKACABAQAHyUAACVHLgiABQALACILAgwAKgwBDS0OCQ0tDgsFASIAAYBJAAgtCggBIwAAF+QAIgMCBwAqBwEILQsIAi0LBgcuAgAHgAMoAIAEBAAfJQAAJUcuCIAFAAgAIggCCQAqCQELLQ4CCy0OCAYBIgABgEkAAi0KAgEjAAAWdQAiAgIIACoIAQktCwkGLQsHCC4CAAiAAygAgAQEAB8lAAAlRy4IgAUACQAiCQILACoLAQwtDgYMLQ4JBwEiAAGASQAGLQoGASMAABWaACIBAgkAKgkHCy0LCwYtCwgJLgIACYADKACABAQAHyUAACVHLgiABQALACILAgwAKgwHDS0OBg0tDgsIASIAB4BJAAYtCgYHIwAAFL8cCgcKAAAqDgoNACIQAhEAKhEHEi0LEgowCgAKAA0BIgAHgEkACi0KCgcjAAATjAAiCgIQACoQBxEtCxEMLQsNEC4CABCAAygAgAQEABklAAAlRy4IgAUAEQAiEQITACoTBxQtDgwULQ4RDQEiAAeASQAMLQoMByMAABM+ACIKAhMAKhMHFC0LFBInAhMEFC0IABQtCg0VLQoMFi0KEBctChEYLQoSGQAIABMAJQAAJqYtAgAAASIAB4BJABItChIHIwAAEp8BIgANgEkADAAiCgISACoSDRMtCxMQLQsREg0iAAyAUgATJAIAEwAAHNslAAAmlC4CABKAAygAgAQEABglAAAlRy4IgAUAEwAiEwIUACoUDBUtDhAVASIADIBRABAOKgwQEiQCABIAAB0bJQAAI68AIgcCFAAqFA0VLQsVEg0iABCAUgAUJAIAFAAAHT4lAAAmlC4CABOAAygAgAQEABglAAAlRy4IgAUAFAAiFAIVACoVEBYtDhIWLQ4UES0KDA0jAAARmygAgAQEeAANAAAAgASAAyQAgAMAAB2ZKgEAAQX3ofOvpa3UyjwEAgEmKgEAAQW+Hj//PqT2+jwEAgEmKgEAAQUxZNrSOf7nSTwEAgEmJQAAHXEcCgIFACsCAAYAAAAAAAAAAAEAAAAAAAAAAAQqBQYHLQgBBScCBgQEAAgBBgEnAwUEAQAiBQIGLQoGCC4MgEcACAAiCAIILgyARwAIACIIAgguDIBHAAgtCAEGJwIIBAUACAEIAScDBgQBACIGAggtCggJLgyARwAJACIJAgkuDIBHAAkAIgkCCS4MgEcACQAiCQIJLQ4HCS0IAQcAAAECAS0OBQctCAEFAAABAgEtDgYFLQgBBgAAAQIBLgyARgAGLQgBCAAAAQIBLgyARQAILQsBCQAiCQIJLQ4JAS4IgEYABCMAAB6rDSIABIBLAAkkAgAJAAAfKyMAAB7AJAIAAwAAHs0jAAAe/ycCAQQJLQgACS0KBwotCgULLQoGDC0KCA0uCIBKAA4ACAABACUAACamLQIAACMAAB7/JwICBAktCAAJLQoHCi0KBQstCgYMLQoIDQAIAAIAJQAAJNMtAgAALQoKASYMKgQCCSQCAAkAAB89IwAAH3sAIgECCgAqCgQLLQsLCScCCgQLLQgACy0KBwwtCgUNLQoGDi0KCA8tCgkQAAgACgAlAAAmpi0CAAAjAAAfewEiAASASQAJLQoJBCMAAB6rKgEAAQUC3G4ngHYSnTwEAgEmJQAAHXEtCAEGJwIHBBgACAEHAScDBgQBACIGAgcnAggEFwAqCAcILQoHCQwqCQgKFgoKCiQCAAoAAB/qLgyARwAJACIJAgkjAAAfyS0IAQcAAAECAS0OBgcuCIBGAAUjAAAgAg0iAAWAUgABJAIAAQAAIBwjAAAgFy0LBwEmHAoFAQAAKgQBAi8KAAIAAS0LBwIuAgACgAMoAIAEBAAYJQAAJUcuCIAFAAMAIgMCBgAqBgUILQ4BCC0OAwcBIgAFgEkAAS0KAQUjAAAgAiUAAB1xLQgBBgAAAQIBLQ4EBi4IgEYABSMAACCIDSIABYBSAAMkAgADAAAgoiMAACCdLQsGASYtCwEDLQsCBA0iAASAUgAHJAIABwAAIL8lAAAmlAAiAwIIACoIBAktCwkHASIABIBJAAgOKgQICSQCAAkAACDnJQAAI68tDgMBLQ4IAi0LBgMuAgADgAMoAIAEBAAYJQAAJUcuCIAFAAQAIgQCCAAqCAUJLQ4HCS0OBAYBIgAFgEkAAy0KAwUjAAAgiCUAAB1xASIAAoBRAAQOKgIEBSQCAAUAACFNJQAAI68NKIBSAAQABQsiAAWARQAEJAIABAAAIWolAAAnyi0IAQQnAgUEDAAIAQUBJwMEBAEAIgQCBScCBgQLACoGBQYtCgUHDCoHBggWCggIJAIACAAAIbEuDIBHAAcAIgcCByMAACGQLQgBBQAAAQIBLQ4EBS4IgEYAAyMAACHJDSIAA4BRAAQkAgAEAAAh4yMAACHeLQsFASYAKgMCBA4qAwQGJAIABgAAIfolAAAjrw0iAASAUgAGJAIABgAAIg8lAAAmlAAiAQIHACoHBAgtCwgGLQsFBC4CAASAAygAgAQEAAwlAAAlRy4IgAUABwAiBwIIACoIAwktDgYJLQ4HBQEiAAOASQAELQoEAyMAACHJJQAAHXEBIgABgEkAAy0LAwIBIgABgEsABC0LBAMcCgMFBhwKBQQAHAoEAwYBIgABgEQABS0LBQQBIgABgEwABi0LBgUcCgUHBhwKBwYAHAoGBQYnAgYEBQAqAQYILQsIBxwKBwgGHAoIBgAcCgYHBicCBgQGACoBBgktCwkIHAoICQYcCgkGABwKBggGASIAAYBNAAktCwkGHAoGCgYcCgoJABwKCQYGASIAAYBOAAotCwoJHAoJCwYcCgsKABwKCgkGASIAAYBPAAstCwsKHAoKDAYcCgwLABwKCwoGASIAAYBQAAwtCwwLHAoLDQUcCg0MABwKDAsFASIAAYBRAA0tCw0MHAoMDQIcCg0BABwKAQwCLQoCAS0KAwItCgQDLQoFBC0KBwUtCgYHLQoIBi0KCQgtCgoJLQoLCi0KDAsmKgEAAQWW3Pkm00vg3zwEAgEmKgEAAQVFp8pxGUHkFTwEAgEmKgEAAQUHKoPuEPeQ8DwEAgEmJQAAHXEtCAEEAAABAgEuDIBKAAQnAgYEAicCBwEBLQgBBScCCAQhAAgBCAEnAwUEAQAiBQIIJwIJBCBDA6oAAgAGAAkABwAIJwIKBCAuAgAIgAMuAgAKgAQlAAAn3CcCAgQhJwIGBCAuCIBJAAMjAAAkRgwqAwIHJAIABwAAJF0jAAAkWC0LBAEmLQsEBwQqBwcIAioGAwcOKgMGCSQCAAkAACR9JQAAKFwMKgcGCSQCAAkAACSPJQAAJpQAIgUCCgAqCgcLLQsLCRwKCQcABCoIAQkEKgcJCgMogEoABwAJBCoJCAcAKgoHCC0OCAQBIgADgEkABy0KBwMjAAAkRiUAAB1xLQsEBQsiAAWARQAGJAIABgAAJPUnAgcEADwGBwEnAgUEBi0IAAYtCgEHLQoCCC0KAwktCgQKAAgABQAlAAAobi0CAAAtCwEFLQsCBi0LAwctDgUBLQ4GAi0OBwMuDIBIAAQBIgAGgEkAAi0LAgEmLgGAA4AGCwCABgACgAckAIAHAAAlYiMAACVtLgCAA4AFIwAAJdQuAAABgAUBAAABgAQAAQEAgAOABIAJLgCAA4AKLgCABYALCwCACoAJgAwkAIAMAAAlwC4BgAqACC4EgAiACwEAgAoAAoAKAQCACwACgAsjAAAljygBgAUEAAEDAIAGAAKABiMAACXUJiUAAB1xLQgBAwAAAQIBLgyASgADLQgBBAAAAQIBLgyARwAEJwIFBB0uCIBGAAIjAAAmCA0iAAKAUwAGJAIABgAAJiIjAAAmHS0LBAEmLQsEBgIqBQIHDioCBQgkAgAIAAAmPSUAAChcDSIAB4BTAAgkAgAIAAAmUiUAACaUACIBAgkAKgkHCi0LCggcCggHAC0LAwgEKgcICQAqBgkHLQ4HBAUiAAiAQwAGLQ4GAwEiAAKASQAGLQoGAiMAACYIKgEAAQXFa8RaDhAAAjwEAgEmJQAAHXEtCwQGCyIABoBFAAckAgAHAAAmyCcCCAQAPAYIAS0LAwYLIgAGgEQAByQCAAcAACdbIwAAJuEtCwMGLQsBBy0LAggtCwQJDSIABoBEAAokAgAKAAAnBiUAACaULgIAB4ADKACABAQABCUAACVHLgiABQAKACIKAgsAKgsGDC0OBQwBIgAGgEkABQ4qBgUHJAIABwAAJ0YlAAAjry0OCgEtDggCLQ4FAy0OCQQjAAAnyScCBgQHLQgABy0KAQgtCgIJLQoDCi0KBAsACAAGACUAAChuLQIAAC0LAQYtCwIHLQsECC4CAAaAAygAgAQEAAQlAAAlRy4IgAUACQEiAAmASQAKLQ4FCi0OCQEtDgcCLgyASQADLQ4IBCMAACfJJioBAAEF9C7lhLv0IdE8BAIBJigAgAYEAAIHAIAEgAaABS4AgASACCgAgAkEAAANAIAJgAWAChcAgAqACiQAgAoAAChbAwCACAACgAgBAIADgAmACy4BgAuABgEAgAOACIALLgGAC4AHAQCAA4AJgAsuBIAHgAsBAIADgAiACy4EgAaACwEAgAkAAoAJIwAAJ/gmKgEAAQUohpKwR9z9QzwEAgEmJQAAHXEuCIBGAAUjAAAofg0iAAWARAAGJAIABgAAKOkjAAAoky0LAgUtCwUGACIGAgYtDgYFLQgBBicCBwQFAAgBBwEnAwYEAQAiBQIHJwIIBAQAIgYCCT8PAAcACS0LAQUtCwMHLQsECC0OBQEtDgYCLQ4HAy0OCAQmLQsDBgwqBQYHJAIABwAAKP8jAAApay0LAgYAIgYCCAAqCAUJLQsJBy0LAQgAIggCCgAqCgULLQsLCQAqBwkKLQsDBy0LBAkuAgAGgAMoAIAEBAAFJQAAJUcuCIAFAAsAIgsCDAAqDAUNLQ4KDS0OCAEtDgsCLQ4HAy0OCQQjAAApawEiAAWASQAGLQoGBSMAACh+",
      "debug_symbols": "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",
      "brillig_names": [
        "commit_public_user"
      ]
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABAMnAgEEACcCAgQAHwoAAQACgEYlAAAAPyUAAABVKAIAAQSARicCAgQAOw4AAgABKACAQwQAAygAgEQEAAAoAIBFBAABJiUAAAReHgIAAgAtCAEDJwIEBAMACAEEAScDAwQBACIDAgQ2DgACAAQAASIAA4BFAAUtCwUEJwIFBAIAKgMFBy0LBwYcCgQDAAQqAwYHJwIDAQEkAgAEAAAAuCcCBgQAPAYGAS0IAQQnAgYEAwAIAQYBJwMEBAEAIgQCBjYOAAIABgIBIgAEgEUABi0LBgIAKgQFCC0LCAYcCgIEAAQqBAYFJAIAAgAAAQcnAgQEADwGBAEtCAECJwIEBAIACAEEAScDAgQBACICAgQfMIBFgEQABAEiAAKARQAGLQsGBBwKBAYEHAoGAgAtCAEEAAABAgEnAwQEAQAiBAIGHzCARIBFAAYnAgYAACcCCAANLQgBCScCCgQEAAgBCgEnAwkEAQAiCQIKLQoKCy0OCAsAIgsCCy0OAgsAIgsCCy0OBgstCAECJwIIBAQACAEIAScDAgQBACICAggtCggKLQ4GCgAiCgIKLQ4GCgAiCgIKLQ4GCisCAAgAAAAAAAAAAAMAAAAAAAAAAC0IAQonAgsEBQAIAQsBJwMKBAEAIgoCCy0KCwwtDgYMACIMAgwtDgYMACIMAgwtDgYMACIMAgwtDggMLQgBCAAAAQIBLQ4CCC0IAQIAAAECAS0OCgItCAEKAAABAgEuDIBEAAotCAELAAABAgEnAgwBAC0ODAstCwkNACINAg0tDg0JLgiARAABIwAAAmkNIgABgEMABCQCAAQAAAMkIwAAAn4tCwsBCioBDAQkAgAEAAACmCcCCQQAPAYJAScCAQQMLQgADC0KCA0tCgIOLQoKDy0KCxAACAABACUAAASHLQIAAC0LCAEtCwIELQsKCS0OAQgtDgQCLQ4JCi0OAwsBIgAEgEUAAi0LAgEKKgUBAiQCAAIAAAL5JQAABZoKKgcGAR4CAAIBCioHAgQSKgEEAiQCAAIAAAMaJQAABaweAgABADQCAAEmACIJAg0AKg0BDi0LDgQtCwsNCioNDA4kAgAOAAADTCcCDwQAPAYPAS0LCg0LIgANgEMADiQCAA4AAAPfIwAAA2UtCwoNLQsIDi0LAg8tCwsQDSIADYBDABEkAgARAAADiiUAAAW+LgIADoADKACABAQABCUAAAXQLgiABQARACIRAhIAKhINEy0OBBMBIgANgEUABA4qDQQOJAIADgAAA8olAAAGXi0OEQgtDg8CLQ4ECi0OEAsjAAAETScCDQQOLQgADi0KCA8tCgIQLQoKES0KCxIACAANACUAAASHLQIAAC0LCA0tCwIOLQsLDy4CAA2AAygAgAQEAAQlAAAF0C4IgAUAEAEiABCARQARLQ4EES0OEAgtDg4CLgyARQAKLQ4PCyMAAARNASIAAYBFAAQtCgQBIwAAAmkoAIAEBHgADQAAAIAEgAMkAIADAAAEhioBAAEF96Hzr6Wt1Mo8BAIBJiUAAAReLgiARAAFIwAABJcNIgAFgEMABiQCAAYAAAUHIwAABKwtCwIFLQsFBgAiBgIGLQ4GBScCBgQELQgBBycCCAQFAAgBCAEnAwcEAQAiBQIIJwIJBAQAIgcCCj8PAAgACi0LAQUtCwMGLQsECC0OBQEtDgcCLQ4GAy0OCAQmLQsDBgwqBQYHJAIABwAABR0jAAAFiS0LAgYAIgYCCAAqCAUJLQsJBy0LAQgAIggCCgAqCgULLQsLCQAqBwkKLQsDBy0LBAkuAgAGgAMoAIAEBAAFJQAABdAuCIAFAAsAIgsCDAAqDAUNLQ4KDS0OCAEtDgsCLQ4HAy0OCQQjAAAFiQEiAAWARQAGLQoGBSMAAASXKgEAAQX0gAGmWdMnQjwEAgEmKgEAAQUfAFASQCQi7jwEAgEmKgEAAQXFa8RaDhAAAjwEAgEmLgGAA4AGCwCABgACgAckAIAHAAAF6yMAAAX2LgCAA4AFIwAABl0uAAABgAUBAAABgAQAAQEAgAOABIAJLgCAA4AKLgCABYALCwCACoAJgAwkAIAMAAAGSS4BgAqACC4EgAiACwEAgAoAAoAKAQCACwACgAsjAAAGGCgBgAUEAAEDAIAGAAKABiMAAAZdJioBAAEFRafKcRlB5BU8BAIBJg==",
      "debug_symbols": "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",
      "brillig_names": [
        "constructor"
      ]
    },
    {
      "name": "get_htlc_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "view",
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "key",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "Train::HTLC_Public",
            "fields": [
              {
                "name": "src_receiver",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "amount",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "token",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "hashlock_high",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "hashlock_low",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "secret_high",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "secret_low",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "ownership_hash_high",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "ownership_hash_low",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "timelock",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "claimed",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 8
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/+29CZRcx3Ul+LM2oBIoVAIEQBAAF5AAF4BLblVZ5U2QZVuWRMmSSK22lqxcKJIQQRIAdxAfC0EQAElwAUmQ4iLJkixb3mS727Ll9nLa454+4+7p8Zxxt2d6utunt9OnN3e3Z47HPZ5BkPkyb958f8nKF4UkWXEOUD9/vLjvxYsXL17Ejx8/E7yVVp3/l2ldj7X+ym9Mcm93629+sFQwxMqvUuQcaf0dpbqNt/5OtP6uaP1d2fo72fqbBf10AWNaBXkjLWZjLSYTLfCVLdAsggHezmu7GY9AvsPb3fqdHywVJomvJf5cvlqfDLqTsfylSdCzL/0Ipgf8vBjaV8Ogy2YC4jvV+o32JmWcLV0cdK5PQhmXvgbYGcr7usJX8n421OVw6RuQN0Z534S8ccr7FuRNUN7PQd4Kyvs25K2kvJ+HvEnK+wXIy1LedyBP+qC09+qgk2fYH4qCP+UB/3xauEiRfwrq5tL7wqCdOnyb5UqpXqnO1hbm6gulWrk6VylXK9WZ+dlCoV7N1+fn8wvFWr5aac7NzM00moWFRqNQm68283Mz1ZJg/xjodMyuXnnB/3E/+G0/+BN+8IuC//5Q032psVDJl2aqs3MLhWZ1tplfKFfmStVmpVKv1ufLjcpMvl6ozRZqxUJzbq46M1OtzcwXCs3G/Exzblawf1LFbszN1eYXKs18s9qcL1bzxXxxoVZvzuRnz/NoNmozzWapPJ+fKc3Vq7V6pVaYr5Xmis1aY76Zn2+36wdU7Hpxptqs1esL5XxzvlSpVubO2858ZeE8wFyhNFuo1ubP21Sz0KjWKrWFaiN/nlejUK1XCvVKaUawPwg6t+sLHfwPecHv2MzNXvALbZv/sB/9LAj+R8JAadu5QvW8D6jXy4W5eq1eyjdKzfO9f65ars8W5px5luYW6qWZSuO80yjMVSvFmcbMbLV63k6rtUJbNz+lYjeKlXK5NF+olAuV2XpptlHPz9Wac/VSoVooLBTq9WbzvO9ZOG/4zdnK/Ox522zUGpXG3MLs+Q7QtsmPqtiDJcH+mIJdmCsVi5XSfCU/P1fPF8r1WnGuWHTGf14xtWJjvlyYb5aL5VKtft6JlueqBdfpavPNuW7sjw8udyFK7ltCH7bS8V+3+sEvC/4n/OC3beaTgJ8J7H3Bp/zgt+X/tB/8dvt+xo/+m4L/WS/yl9pj4E97kb/Uts+faeEHVtiFTt/9nDV2Pt8eAz8fjb1otybYX1Cwi9VSLX8+gqjOnB8aGnMz533++dCxsTDXaM4Wqwu1cr5YLxQKjfL5/4qNenl+4fywsjDbOD+MLJxn19bJF0Mf7VmoCX7VGH+2mp9vzM5WBH/BGH9hYbZSPa9Pwa8Z45dqs41mqdL2B3Vj/OpMudmcKVUFv2GMP1PIN2aKlbZtNo3x5xfyM7PnI2rBv80Y/3x8X6rPV9ux2Zes9bPQyNfqhXmZE97ewhceLgnvO4x5t9J8hvgFQff6SkD8sySrdRyfIX4oD+qH10fuDHtlzSl56GM4b1S5J3w0rAVDrJohVt0Qq2GI1TTEus0QS/q1375Wbo+jd3rBL80J/h4v+PmG4H/ZBz7EXncBfmAnfxt/L+BnPODf7Uf/bfx7/OinPW+6t4XvA3ufPXY7PtrvR+/t+O6AH/z2fOk+P/jt+Pd+P/htv/OAH/x5wX/QD347/n3ID347fnzYD347/n3ED377ueFBL/iFtn0+6ge/rf9DgG/n94ttvxz6wW/r/7AX/FJb/iN+8Nu+/6gX/HIb/5gf/Lb/f8wPftv/H/eD347bHveCP9Oe35/wgj/bbt8n/OC344eTfvDb68Wn/OC310NP+8Fv2/+TfvDb9v+UH/z2+PK0H/x2/HPGD347/nnGD357fHzWD347PnnOD357fHzeD37bf571g9/2ny94wa+0x/cX/eC3/edLfvDb/vOcH/y2/3zZD37bf77iB7/tP7/iB7/t3171g9/2b6/5wW/7t9f94Lf9zxst/MAMe6Ho9sK5PXZnN7+F5/aSrWlh39bY/6N79tbu/MiBLy807sXVeneNOxfx/mjQm1YHnV1q51Fvvf3LjX37q1++O6os3x+LwFzXwXzf3rv231ut7X9vvX5vY9++KIRMEJ8caraD+snGvftu33sXo40vDu19X6reftcH6ow2kRJN9hOuAHrDODsv+05XknzIG/cQG86h62meEyH/LMlqvCZRyBA/kYf1g8+JMkGntbFsTsnjNswqfLIKn5ySx3H5IFgvGmI9aYh11hDLso7PGWKdMcR63hDrKUOsQ4ZYlrq37EMvDSnWCUMsS5uw1L2lfZ0yxLLs25Y2cdIQy9JHv2KINazjo8x3JoPe+MD6ua7DXO0HvyS6WBWjC+QvsRLGVpmIv4LFecIrS1jGdSvE1Q3l53bG9wJRB1FYq/rEmlTyfLRpNqbezD+KXouXhX4qBh/pp4NeG54iXazxo4tiXLvhu13CfzXUud5YOHDbzXtvCyiNkh5Eb1uJTvZ6jAS9+l4dgRXQ7610bxTwMDm86dZ1s7G/9qVbq7fd1qifl34fUfYUldfM+D5Pi5DGswkXF+tKPLnhQho36ZKY/Gqg3bO3Wn9f9e59B/Y0RkiVOANmdSIcV5ubKgMi4T1ee8E3Cl2SN660dR/Ecfme34hsiLmtUWSQvGngvZLycpCXpby1gCUrcRmFz6hSd6mv4/fK5g4u07Gs2JbTlIeeMAe82SZWKXykbiMK/WrCihrJRlPw06IAXrGJW3VK04WlHi7lFB7cjkvvigqlt7sr8htBFtoj7GpFntWKfqQtp5Q8wRIfMB7oo/VqqCPSs/8Yp3srWg2WI0yX5C3FuOgG74l+3QpwJtNdN+2kCL/tUC6ktVPhnw28DuGFOLvQIma/40s5n6ZdUV4ej7jt0K+jnSL9FNSRx69pkGOc7m0gO0WbZjtdo9QH76GdTrdwJyPqs7v1Oz9QqlS4jwsP5O0n4i/U0vYD4Z8NfNpdpx9o7aT5Ey3WkbI5JY+fRkwrfKYVPjklj1dIBsE6a4h10hDrtCHWS0OKdcYQ63lDrKcMsQ4ZYj1riGVp98Oor7hxsF8slyxt9Zwh1tOGWJa2alnHE4ZYw9q3XzPEOmyIJTuOtHUPjpWw71nP3ZCf1APvIf8syWorTydW0vSqxbSin5wf/bTlySny5BT98HoTt537J/uecM6A9DmoI9LjtZTHe19oNViOMF3iOcNapT54D+cMn8l01w3bhu3UZzsgP5Eb7yH/bOCz3+Rj7ULr/5NBbzsb6iefpl1RXmnLdUqeYF3U+o12ivRroY5Ij9dSHu99mewUbZrtdJ1SH7yHdnob2Sm2Ddupl3YoNFPbqfDPBj77TcdONbvIKXqcDHrb2VA/+TTtivJKW16k5AnW+tZvtFOkXwd1RHq8lvJ472GyU7Rpfkv8IqU+eA/t9EALdzKiPrtbv/MDpZmy1pZ2+JXClFJP7meoazu7LqXuZ8I/G/TahY9+tp7kibID0d0GRdacksc2skHhs0Hhk1PyeF4zCNZpQ6xDhlgnDbGeNcQ6YYh1xhDrOUMsS5s4ZYj1uCHWS0ZYmn8eRK4XjeRy6ZwhlmXffs0Qy9IXWvbH5w2xLNvxdUMsS5uw1L1V3w6M62hpE2cNsYbVT1jK9W6ImZbHtAune8v++KQhlmUdvzKkclnGE5Z15OcDOLfMtP5OBr19z3Ce3cgQP6kH3kP+WZLVVp7OPFvT63pFr6K7jYqsOSWP59kbFT4bFT45JY/HjEGwThtiHTLEsqzjGUOs5w2xzhliWer+NUOs5XbsD+t1QyxLmzhliHXWEMvSf71kiGWpe0tbtdT9sPovS1u1tK/nDLEs29HSviz7kKV9vWiIdcIQy7KOwxrLWdbRMp4Y1nYc1ljuK4ZYwxrnWMaYy/HEO6MPWfoJS7ms7Mtd87rqIHK9bCSXS5a6t4wBZKzl/W6C75LfNbRi6j22vIbmZQ9WwhqatrduMui1Q0P9FNK0M8orbXmxkidYm1q/cU8Y0m+EOiI9Xkt5vLe3pZQcYb6ZF3bLcLFSH7wn+nV7wm5v/ZiMqM/u1u/8YGmO10OFB/JGPRnaXaqvSSH/bODT7jr9QGsnzb+I7jYpsuaCXtthe9ik8Nmk8FnGGi6sTxphxfkwyXdpUiln7W+Rn9QD7yH/bODVLxTi9Kr5S9HPJX70096jfIkizyWKfqQtNyt5grWl9RvHI6S/BOqI9Hgt5fHeczQebQZa7gOblfrgPRyPnhzprhu2Ddupn3ZI/86H8M8GPvtNx041u9D6/2TQ286G+smnaVeUV9pyi5InWHLaFNop0m+GOiI9Xkt5vPdVslO0abbTLUp98B7a6SutH9NBdP9M058RV/PbrEMsx/3BS3sXGvm0/UH4ZwOf/bPTHzan1KvoZ4sX/dSbaewH5ZW23KrkCdalrd/YH5B+C9QR6fFayuO971J/wL7D/WGrUh+8h/3hO+S3sW3YTr20Qz7fTGunwj8b+PSTHTvV7EIb/yaD3nY2lKeRpl1RXmnLS5U8wbqs9RvtFOm3Qh2RHq+lPN77PbJTtGl+V+9SpT54D+30t2i+y/XZ3fqdHyg1Clpb2uFX26ezXuoFvzg/qbSXHf7CnOBf7gd/VvCv8II/127fbV7wZ9r6udIPfl3wr/JjP235t3vBL5UEf4cX/EZb/qu94Jfb+Nd4wV9o999rveDPt+3/Oj/6abfvTi/4zRnB3+VHP235r/cjf9v/3wj4lmsRgp/3gt85KfqmoJNGlToJf4lFbgD6TMRfweI84ZUlLF9xn1Y3lJ/nfTeBPKiDKKyb+sSaVPJ8tOmNMfVG/lMxsnI9XOIzcBarE5dOGWIdN8R60QhLi20HkeuIoVxbjeTS4t9BsC4zxFphhOXSsdBOrsuN5HLXVwwp1jZDrCsNsa4yxNpuiLXDEOtqIyyX+MuOg8h1jaFcLxjKda2RXO76OkMsq7HDXe80xNpliHW9EZZLvHY6LFjyDNnveld53u96V6nqd72rXPe73jVT8rveVa74Xe8ql/2uR5VrMheQMVJ4oO3imGc3bymnftdU+GdJVlt5OvPH7SQP64f3B+1QZM0peewDdih8dih8ckoe7xUeBOsVQ6wThljPGmKdMcQ6ZYh1yBDrOUOs04ZYLw0plqWtPmWIZaV7LS4YFlu17I/nDLGGtT++bIhl2YeGVfdPG2JZ+gnLsdbSR1vq3lJfw2pflrGJZTta6v7d4CdeM8Jy1zxHHkSuY6GdXJcZyWWJ5dLR0E6uyw3lOhbaYT1uiGUll7veFthhrTDCcsnKJlw6boTlrq8IbLBcOhYOp1xWtjrMvnCtoVyW/uuKIZVrGPXlkqWtXhnYYLl0LLTDsvJfLr1uiGUZfz1piGW5pmAZk1vOFSzXHiW+l3XsbZCXaf31+wwgv+hnANv8yBP7DGCboldtP6yhPPU07YzySltereQJljyTHwcspN8BdUR6vJbyeO9/aTVcjjBd4ncHrlbqg/dEv+7dgf9ptLtu2DZsp37aIf03ZoV/NvDabwpxdrFd0aNmF1I2p+RxTJ+2vbS25711g2CdNcQ6aYh12hDrpSHFOmOI9bwh1lOGWIcMsV4wxLLsQ5bt+Ioh1glDrHOGWJZ929K+LPuQpV99N+j+OUMsSx8tvnA66I2HJoNuPv3OHbC80Pl9H2ym6Pd9sJlZv++DlZsSd10Les2Q7nCfpl2MOJf6PA3hnyVZbeXpxKw7SR7WD8esuxRZc0oe76/apfDZpfDJKXnsWwfBesUQ64Qh1rOGWGcMsU4ZYh0yxHrBEOtFQyxL3Q+rrZ4zxDptiGVpX5Y+56wh1rtB988ZYlnW8aUhxbLs208ZYlnp3l3z3slhsdVhjQEssZbH7eVx++0ydiyP28vj9vK4/c7U/bDa6suGWJb6svQ5lrp/2hDLsg9ZjtvD6qOHNZ6wrKNl7GvZjpa6fzf4ideMsNw176EYBGuHIZbVOrm7vtoIyyXeHzqIXGsN5ToW2mE9boh13AjLXfPzr2Xdx9eR97cPgnWZIdblRlguWerrOiO5LG3VJcs+NKx2P6x1fKf7Qku5XFoeO97+Y4dLjxlhuWvLPQ/HQju5rjSSy11fYYhlNda6ZDk+WunLpWOhHZal/3rdEMtyzvekIZblMx3LdQDL9QnL/Tn8DhLuDcu0/mpnhjs+u1u/8wOlYup3O4R/lmS1laezT07T605Fr6K76xVZc0reFXCNecjneoVPTsljex8E6yVDrJOGWGcNsV4xxDptiPXikMp1yhDrkCHWa4ZYhw2xXjfEstTX84ZYlv3xnCGWpd1b+kLLdnzSEMvS51jaxHOGWJa6PzGkcr1giGVpE5axieW4bdmOw+q/LO3Lsj8Oq4+2xLK0r6cMsUT3/F6P4Lukfb/JcK5XzhA/qQfeQ/5ZktVWns5cT9OrNocW3d2oyJpT8vgZtPaNoBsVPjklj33zIFhnDbFOGmKdNsR6aUixeFwcBOt5Q6ynDLEOGWK9YIh1whDLsj+eM8SytC9LfT1riGVpX5Z9yNKvWtqEpV8d1r5t2R8t+9ArhliW/fHdYF/PGWJZxgB8TgTG23xORL8xP5YXuimlXKb11+83VedTn4Mg/LOKTnzE/Dem1Gs/3+t015bfn+SxaRCsVwyxThhiPWuIdcYQy/JbqYcMsay+w+eS1XdXXbLU/bDa6jlDrNOGWJb2ZelzzhpivRt0/5whlmUdXxpSLMu+/ZQhlpXu3bXVd6NdsrTVYY0BLLGGddy21L1lDGDpoy3jiWG11eVx+8KNacsxeX9YyzH5hbOv5bjwwtnXMMaFLlnqa1ht9WVDLEt9WfocS90/bYhl2Ycsx45h9dHDOqZZ1tEy9rVsR0vdvxv8xGtGWO6a9zgNItdRQ7l2GMnlrtcaYlk+H7LU15WGcj0e2mEdN8Jy1/yu9DDYhEvHQjssK91b9m3r/mjVh9z11UZYLln2x3eDffE5LoNgXWaIdbkRlkuW+rrOSC5LX+iSpY8eVrsf1jq+08daS7lcWo5N3v5jh0uPGWFZxhMuHQvt5LKKyd31FYZYVmOtS5bjo5W+XDoW2mFZ+q/XDbEs1xSeNMSyfG5luc5kuf51yhCLz3HBva2Z1t/JoLe/OD67W7/zg6XU57gI/yzJaixPIU6v2j5t0U/ejzwLGcJHefKKfqQtC0qeYBVbv/Fb0kifhzoiPV5Lebz33ybe+psjTJf4W9IFpT54T/TrIP/jRHfdsG3YTv20Q6Ge1k6Ffzbw2m8KcXah9X/NLqRsTsnjNZy07aW1Pe9NGATrrCHWSUOs04ZYLw0p1hlDrOcNsZ4yxDpkiPWCIZZlH7Jsx1cMsU4YYp0zxLLs25b2ZSmXZTtaymXpJyxtwrIdnzPEsvT3/L4hxlb8vmFcfKrxwfJCN6WUk9hqMuiNUeziqbmZDPGTeuA95J9VdOIjviuk1KvorqjImlPyeO2qqPApKnxySh730UGwXjHEOmGI9awh1hlDrFOGWIcMsV4wxHrREMtS98Nqq+cMsU4bYlnal6Vclu1oKZelX7W0Cct2fM4Qy1L3Lw0plqWfeMoQy0r37prfXRwWWx3WeMISazkGWI4BfPrV5RhgOQZYjgGWY4AkLEt9DautvmyIZamvYfUTTxtiWfahYR07hjX2HVb7soyjLdvRUvfvBj/xmhGWu+Z9EINg7TDEslq/d9dXG2G5xO+yDCLXWkO5joV2WI8bYlnJZd2OVnK5dNwIy9omrNrRXV9qJJe7vswQ63IjLJcs9XWdkVzu+hojLJeG1VaPhXZY7/T+aF3HYbQvl5bHoWW757zHjLDcteUekWOhnVxXGsnlrq8wxLIat12yHGut9OXSsdAOy9IXvm6IZTkXfdIQy/K5leX6hOW6ieV+Jn6/aQXkZVp/ZV8h+nPHZ3frd36wlPrbZcI/S7Iay9PeV7g26NXrCkWvorstiqw5ynOJ3/PZovDZovBZKiytvd2/3a3f+YHSzMyUwpttDfc32LVtYS6trQn/bNDbtj5sbSvJE9VuortLFVlzSh634aUKn0sVPjklj5+zDoL1jCGWpVxnjbDc9erABsu6jocMsZ4zxHrJEOspQyxLfZ0zxHrVEOsFQ6zThliWuj9jiHXKEMuyjq8ZYh02xJK5B8cWLu1u/c3nm+VKqV6pztYW5uoLpVq5OlcpVyvVmfnZQqFezdfn5/MLxVq+WmnOzczNNJqFhUajUJuvNvNzM9Wy39hhpjIZ9Pp4w9ikIPiX+cEvCv7lfvBLgn+lH/x2++7wgz8j+Ff7wZ8V/Gv84M/5ff+rMC/4RT/4VcEv+cGvC37ZD35D8Gf84DcFf9YLfjEv+BU/+G3/NucHv+3f5v3gt/3bD/jBb/u3H/SD3/ZvP+QHv+3fftgPfnv8/RE/+G3/+R4/+G3/udsPftt/vtcP/oLg/6gf/Jrgv88Pftv//5gf/Lb//3E/+G3//xNe8Ett//9+P/ht//+TfvDb/v8DfvDb/v+DfvDb/vNDfvDb/vNmP/ht//ZhP/ht//YRP/ht//NTfvDb/uejfvDb/udjfvDb/ufjXvDLbf9wix/8tn+41Q9+2z98wg9+Oz78pB/8dnz4KT/4bf/2aT/4bf/2GT/47fjws37w2/7zp/3gt/3nz/jBb8eHn/OD3/bPn/eD3/bPX/CD3/bPX/SD3/bPVS/4M+34cMEPftv/1/zgt/1/3Q9+2/83/OC3/X/TD37b/9/mB7/t/78UdFIHu9RYqORLM9XZuYVCszrbzC+UK3OlarNSqVfr8+VGZSZfL9RmC7VioTk3V52ZqdZm5guFZmN+pjnX9v23q9iDpM66/B0+9FJotvvVnYCfMZN/ro2/xwt+vm2XX1Z135ibq80vVJr5ZrU5X6yeX2csLtTqzZn87Pn2bTZqM81mqTx/vvvM1au1eqVWmK+V5orNWmO+mZ9vY9/lRff1ts/cq8heLNdnF6r5SrNSrc41zw9wxfr5P7PnLbI5U6zOl2rV8zWoLzSq5x9VzRdr9WK91Jg7X5FGaX620eiMJ3erehkkldpj7T0qdr04U23W6vWFcr45X6pUK3Pn5ZyvLJxX7FyhNFuo1ubPP2drFhrVWqW2UG3kz7dBo1CtVwr1Smceeq8Xe+k8p9hn3qZzb/7vjkL+45VvYcm5fOPAayXVq3V0cvusZ5fuDjs045CP9BtbDzHd73/UAp2iMoLh0iSVt/WvhfkM8QsCfW+T8M8quvGxt2mC5GH98N6mFYqsOcpziZ91r1D4aPv1NKzXDbEOGWK9YIh12hDreUOsU4ZYZwyxLOv4lCHWsNrXCUOsFw2xzhliWdqXpb6eNcSytC/LPnTWEMvSJiz9aj/78TGOMRy3i2njCOG/VPvxVwbp9Or23a5qXe/ZW62/r3r3vgN7GiOkSgzDWJ0Ix9VGtWDeKN0bI7r3h92/PxT2lgsUbJcvTZ6l+7tbv/MDpdmGmNtdigyStxd4T1De3ZC3gvJwivJG2KHjNKrUXerr2uaVzR1cpmNZsS33Uh4eq3038GabWKnwkbqNKPSThLVSKSftlsTPcxcv+LWnfClDOonSi/CPc3dp3ZHwWip3pNUtzs2j3fEUVMOa7BNrUsnz0aZxbhj5T8XIqtWD/XHaaaPQZ2PkQvpphbeUFR1OQZ710BqlQ+yLwn810NYbCwduu3nvbQGlUdKD6G0T0cl4MxL02uBkBFZAvzfRvVHAwxS3DJKmP4ucLuUULFmeWQ6T2mk5TFoOk95tYZI2/PDqKq+6urS79Tc/UKoXJhWZOthzhWq5Olevlwtz9Vq9lG+UmrV8da56/rFCYc493CrNLdRLM5VGvVItzFUrxZnGzGy1ev4pV7VWKDp5P9BSljZk4aot2gB+sXBS0e040f9S7q2/jt+HWwWca2jdDhYO7Lnz4439997euK9xfvTZF1BK6s8fCbt//1TYW05Ly669nXy5djYh365dml7S29m1j1PeO8W1aw/KkA+7dqRfjGuP4jel3OPu72mmk7r784zT12w9Q/w0HbvUZ/fncztRnQjH1V5s97eI7PxMzPrv/tzFsfuvpLxBur/Ut9/uj23J3R9dKHd/bSKPfKRuIwp9lrCiFjxGF8FPohZ0FxzRCO1DLSDPbiK/DnC5DsvRSzstRy/L0cu7LXrR3Btvs/G5Roa8J4Perra79TefbxQr5XJpvlApFyqz9dJso56fqzXn6qVCtVBYKNTrzWa5WlkoNyrN2cr87ExprlFrVBpzC7PFQrOsubJMYPbKW8VNSs8OMAl2CbdyTUI+0j/WunD8zsEkWI5iuK+65/Z6dX/jx++650DjQKP+kb37G/vee1f9x+9r3LW/7ynxT4bdvz8Q9pbTkuFSRpFvCPYqkNtwEKiJta9W6iV5GNzhMg4nzdOI3M4Sf6MPT4M9dIry0KrXUB5a4TTloZfPUd6EIs9iezvqaEVEvSz4oI44uF1pyEd7IsH6tuAT9+TH0xPRBanHqqA3cd/AttX6Brf1Gsjj9pmGPNZpDmTYF3boOCWN7H+Sor+9m/Uro1MQLOvXQr+L0eHqLR1cpuN6YFutJlrcLJ6h8nwYp9RzTCnv0l1hN5bQ/8lkR+4dW7pl08YPjvBs2z79oZnCPxv0jk8+JpTaRjvUjzah3Ld/773V2xofb1TrKDrCXQz3MR+T0GBol1F+Z+j3COEcDHtxOIn68JpNNQgGHxaxHHffEUM+iMUP8ll/Lnl+byK1efN7E2Ne5Il/b2JM0avn7l+J627ak1ctfOZdBDgRi5twjwS9rh9DwXG69x9aFxxSusTuWZuwa8vpTvZ/M9ldN19hvLSvtjggfcXR/5fJ7rpIOdQnlhU/M070d8LE9y9poq3ZvuTx5iu8xv49qtyL8zts05762IymX0ncxiijNr2ShcCMgqWFJVInZ2vX9hGWoM65PcYUWdk2RJ4oP6K1h9BJe3h6V2xW61dcf35ehXnYbx8OO3SctPaQOvXbHqhzlk3z3YghNqO9nzhB5SYUWUX/jB3FmxfKAqiDtG2OsHe3fucHSoWC6AvPfJUkefgsBe2ck9Z+Irdrvy8sMsxfR3mo84soD9t6PeXhGLaB8nAM20h5OG27mPJwSW4T5eGU6xLKwynXZsrDKdcWysMpl5ylO0k4xjayoH0TICC58Fxf7HucNBsRufu1kRFFF9r0/lLKw3P3L6M8tPXLKe8iyLuC8tZD3jbK2wB5V1LeRsi7ivJwrrOd8jZB3g7KuwTyroZrbJvx1rXYitCILxpR8rSxajwhn20SE9qU9tAnQ7QZokVsngONRPBBHM0/o+1ivMbfmEAawdgK8o0H0b6fxyGkRz68RIVLguNBb7/juBfxWbe8BM3tjrpdS7QrIvho7Teu1BF1EvW+f5RO1hE9xhbaPoSJPuWZ7FOei4h+0liebJ/yrCf6rLE8q/qUZwPRrzKWZ3Wf8mwk+tXG8kwRfSZBnosj5I+SJ63vGgt0H83+PENyj9B9oV0TU68xhc8mose53Fig6ypNvTJB7zyJ65UhWpEzo2BPK+WYHvlcQvTamiLLEgR63McbPVCuEcrDWIcfW2obJbS4lteA0Lb5ZT/thacppX5Rjzaxr2uxMq+loI6jHmNif3VYcfPraUUeXhfB/WvanidelxH6u1vKcb9f3dKNqW0D1ebzQq+9GKe9GTAd9OqCx4aklx5xLQTLTwTxe/54Q8b9UP83WvWPW5/gtWXE1toQ7fTNuoS9mFJ+DPIs151d3b5Oj3dQl+PAN43u+2136dO5oLet+UVNbauB5p+0tUexCc2XSFlc05T2ukiRVXhiDDJK9MhT6DcAn1GFRsqOE/1JsMPvkR2iTLwOsAFkEXuVOfRGkn1363d+sJR636fwz5KsxvK0n2NsJHlYP33u++RwGNWJcFxtVAvmLcW+z010f3frd36g1P++T17Kwn2fvFw1yL5PqW+/+z6xLXnfJ4axvO8TbWKjwkfqNqLQX0xYG5Vy0m5J/EaVchcRRibodTlyf73Ce5zovw4u6ftbovWwPojWg/xeocjJ+pZ8l/za80wlrQsT/tmg1zZ8uLBNJA/rp08XxjNEgf8kwQkN0mL6JIiE9Dxj4Ga/TSnHSVTJq4GS55KYwyVUZnfrd36gVEg9ogn/bODTPDvmcAnJw/rhp5ieVs3b8mxW5Nms6IdX2bnt3D9Z7YtamdwMdUR6vJbyeO97Lbdl+RVjF839Wrabn/Stvw9Ptn+7dT0d9PY/XkXQ3PlGhXdOKS90Gp9VA/JZpfDRNsfKpjKeZWt5uFLAT5bWQDnepTMNeR+lPFxR5tn52hjMdQqma7vPr+7guX/XAp3mivnJ6naQB8vi73GidenesDtPaP8M7Oofkl3hMMTtfXGC3HHtzU8E0U64TbE/c5uin2D9a/1Re/LGbbotBvMqBdPp7ROru+lQ7zy2XAv3DUON2bRji/DPBr325GNs0ewb9cNjy04/+pnJED7Ks1PRj7TlLiVPsK5v/caxBel3Qh2RHq+lPN77tzS27AJaHlt2KfXBezi2/Hm2u27sP7S/gsv3uH+jbqKevLqEu77+Q7a7LlIO9YnjURPykf4VOPPjP8f4MG6/7VTHJN+7SaljWj9+C2Ftj5FrZwLWJwgLy+8krF0JWLcSFpbfRVjXJ2DtJywsfz1h3ZCAdYCwsPwNhHVjAtZ9hIXlbySsmxKw7icsLH8TYeUTsB4gLCyfJ6zbE7AeJCwsfzth3ZGA9RBhYfk7COvOBKyHCQvL8xci9iRgPUJYWJ6/BnFXAtYewsLydxHW3gSszxAWlt9LWHcnYN1MWFj+bsK6JwbLXcsunmmlvJTVlsfEz2tfTrgQ82HhnyVZbeXpxCz3Br16Rf3wk8Z9iqw5JY/nZvsUPvsUPhrWdkOsaw2xdhpi7TLEut4Q6wZDrBsNsW4yxMobYt1uiHWHIdadhlh7DLHuMsTaa4jF409c/OyuZadoXPws5dAH8XonzxuRHjGi4nN8THFtgsyXk8yLjdPd9ZWEtdg43V3vIKzFxunu+mrCGiROlx0fg8bp7voakmuxcbq7LhDWYuN0d10krEHi9EfDbqxB4vQvEtZi43R3XQq6sRYbp7vrMmEtNk531zOEtdg43V3PEtZi43R3XSGsuDj93gSsOcLC8vzVsn0JWPOEheX3Edb+BKwfICwsv5+wDiRg/SBhYfkDhHVfAtYPERaWv4+w7k/A+mHCwvL3E9YDCVg/QlhY/gHCejAB6z2EheUfJKyHErB2ExaWf4iwHk7Aei9hYfmHCeuRBKwfJSws/whhHUzAeh9hYfmDhPVoAtaPERaWf5SwDiVg/ThhYflDhBUmYP0EYWH5kLAOJ2C9n7Cw/GHCOpKA9ZOEheWPENbRBKwPEBaWP0pYx2KwXPrpsBsLyx8jrMcSsD5IWFj+McI6HsTX8YNBNxaWP05YjydgfYiwsPzjhHUiBsulO8NuLCx/grCeSJDrZpILyz9BWCcTsD5MWFj+JGGdisFy6cNhNxaWP0VYpxPk+gjJheVPE9aTCVg/RVhY/knCeioB66OEheWfIqynE7A+RlhY/mnCOhOD5dIdYTcWlj9DWM8kyPVxkgvLP0NYzyZg3UJYWP5ZwnouAetWwsLyzxHW8wlYnyAsLP88YZ1NwPokYWH5s4T1QgLWpwgLy79AWC8mYH2asLD8i4T1UgLWZwgLy79EWOcSsD5LWFj+HGG9nID104SF5V8mrFcSsH6GsLD8K4T1lQSszxEWlv8KYb2agPV5wsLyrxLWawlYXyAsLP8aYb2egPVFwsLyrxPWGwlYVcLC8m8Q1lcTsBYIC8t/lbC+loBVIyws/zXC+noCVp2wsLyUnVKwMq2/8szoZ+G+3TOaciFD/KQeeA/5Z0lWW3k6z4x+NujVK+qHnxl9Q5E1p+TxmuM3FD7fUPhoWDsNsXYZYl1viHWDIdaNhlg3GWLlDbFuN8S6wxDrTkOsPYZYdxli7TXEutsQ615DrH2GWPsNsQ4YYt1niHW/IdYDhlgPGmI9ZIj1sCHWI4ZYBw2xHjXEOmSIFRpiHTbEOmKIddQQ65gh1mOGWMcNsR43xDphiPWEIdZJQ6xThlinDbGeNMR6yhDraUOsM4ZYzxhiPWuI9Zwh1vOGWGcNsV4wxHrREOslQ6xzhlgvG2K9Yoj1FUOsVw2xXjPEet0Q6w1DrK8aYn2NsJL2yTVa13H75KRc1PtYo0Cj7Y1DjKh9eKMgc9J+vCbJrPHU3m+8J+zOw/cbeU8+vvPM7z7iO8z8vhW+3/h1ytsGefyu21WQJ/XR3m+cjKkPnrrD7/Xi+7n8Djeelsanu05DHp/umoM8PtEUTy3dRnl4KuJVUFd5P3ec6lpt3fd86o36Fca496MzEX+DoHdd3CXut3iCEp8wttGQD2K9P+zmc7EhH8T6XNjNZ5MhH9xrzHrbrPARu+FTUXe3fucHS6nfpRH+2aDXx/h4LqKdfbBZ0WvKo0b4eAdUJ8JxtVEtmDdK93yclrSN7u9u/c4PlPo/LYld7t2Qxy53kNOSpL79npaEbcmnJeGQxqcloU1sUfjwER9Iv5WwtKNBOLyI4jeqlOOjZDJ0fxzur1d4jxP9Y61hyOn2d+kgRY0XdjWxXe47UYfIsQxC/wTI8L0tOuZYRL0uicD8yuqOLKdX65iBgqnVayvVi2XYQjII/Rmo1xt0EtVWpXwQcc/9xpOosCz/1myGDyTellAfbiehfyGmnTYrMuBxN6xTloFptkbI8LIiA7r62t67H2y5+oBS0reoWOV8KtRmBScqiRpc9cQURwkXzTeIuMdNL2UdpLjAemNPY38jotI8fo1FMBsJ9MTTCinnkt/jm9KHIMI/G+h+a7eNPLHHSaF+eGuGNgbklDw+qHtDSj6rg86hvO77bVG2kDY2ySjycPmAsDLKPZeW7Wfx9pMyhGWzQXUiHFc7qsmSzERmW5IWE8LykLW79Ts/UOo/hOVDPTGE5fB2kBBW6ttvCIttySEsug4OYdEmNit80O0z/RbCigs/k/hpIS4fGsruJiqE5VBP6H8PQoLvb+muJ4/hX4Lri1rXF26WXUi9+/AdOsvOEZzQIC2mHIiE9HEHerokh6D046L8HBy2NLNsd93vF+Klvq4b/UEfn4DC7pzGRWkzcF6o3gZ591LeVZC3j/Lw5fr9lIeL9LJZi13JP6FFWU+RgLooK7ymg1694kI32/eoco8XF7H8hhg+uQH55BQ+nnVZ8Ntf86U0URvy534h+dpfweI8jkh9H0Gv1S2unaNCgiiszX1ieZ4ZtNv0kph6a/5Vk1WrB68IyUOsRqsjOt/8n2IegnH44eer9aXUh3wK/yzJ6sse4z7N4RLPsKcUWdn3ufRY2KHjvFHl3kgM1llDrJcNsZ43xDpliHXIEMuyjpbtaFnHk4ZYlnV8zhDrBUOsZw2xThtinTPEOmOIZWkTlv3Rsg9Z2oSlvp4yxHrJEMtS908aYlnq/kVDLEt9WfrCE4ZYlvoaVl9oqS9Ln/NuiJksbcJy3LbSvbvmT+QOi91b6v5pQyxLu7eso6WfsIwBLPX1miHW64SVdl4v9NMKvbYuJWuZuOlXysoaCq5NWj9ljtITbjQW/s4XyOdD642FA7fdvPe2gNIo6UH0NkN08uh1JOj1OWsisAL6PUP3RgEPk1uzOttqrKlWftwjMz/rsaXUT/WF/1I9MtNeStDWPUV32oddckredXCNechH+0BLTsnjcXsQrOcMsV4wxHrWEOu0IdY5Q6wzhliWNvG8IdYhQyxLm7DU11OGWJb6etIQy1JfLxtiWdrqKUOsd0M7vmiIZakvy3HohCGWpb6GdRyy1Jelv7e0L0ufY9kfLW3CMmay0r275jWYYbF7S90/bYhlafeWdbT0E8Maf71miCVrMNqL5bx1PO5jphofLL8zBZY2Hxb6GxT6uLUe7cMwsvaABy36WOvR2uMG4Cn8F7PWI3orEB2v9aBvuz4CK6DfBboXtdbD+5b+cWthSfTraT+aui+S9yviXqirqH7a+iLeY/vF8tkYPlMD8plS+Ewp5aTenvVczxA/qQfeQ/5ZRSc+1tA2pNSr5/2BtUzQ669GFZ78+kicb5X+iq83ID2/VYz9G/3NON379y3jygW9fpc/7pzWv7u13n891V23xe5nRVxt3EjTHxbLB7HkQ9HSv7Ed2Y/0u4cVy2+OwJJ2d0k+Yuvy+cOb0h5jCqZL8kH7caL/q1Z7ufHmutbmetEp7nPFD2b/9VS8rFgWZR0n+oO5DubftDA1PUu7a3bAb0ZmFb4aJvvmfttuSpEhDgvbaw3R4yE3Gj2/Wd1+56IFhG+KZ4JenWv2szlCBrQf/LBilP2sBhnS2s+aNfGysv2sCbp5C/0XwH7Wtoi0Z3px9rOG8tB+REfa2J4LuuvQ79iO5eNiiIspD2XfRHkXK/XKUB7Kd3GMfGsUGWT85I9a7m79zg+U+n/HKUd5d0PeWsrDd5zWUR4eNM3jCh4czeM2HgTNhz4dgLxtlIcHNa+hPDx4mV/JxTRKv7FdXF+8Hvoi0wXEE+2G38XCfoj6RV3hKRtan+d5wU2tSrt+OzXdzS8ursWDtAztrpQmTkD+SxXXriV5onyK6G6dImuO8lw6GnboOG9UuTcSg3XIEOsFQ6wThlgvGmKdM8Q6Y4hlqa9nDbEs7et5Q6yzhliWNnHaCMtdrwxssFx6yUgulyxt4qQhlqVNPGeIZelXLfu2la26NKx+1dImLP2XZR+ytAlLfT1liGWpr1OGWJa2ainX8rh94fRlGa9a+mjLGOBlQyxL/zWsNmHpJ4Z1HLKcw1jW8VVDrGW/+s7wX5bt+IQhlqW+htXnDGtc+KQhlmV/tBxrLdtxWOPV0BDLUi5Lv/q0IZalnxhWH20pl6Xuh9VPWMbk74Z5reW4/YohlqVclvNay3a07I+Wc5gXhhTL0ia4D8lzTzzbVfauuCQfihon+tWt59CTxCMTmD5rLsfti/P8pZZyhvgFgf6cW/hPKfLw3k7MGxtA1vlGZaZUbNQL1drcQmOhvZdyG8nK93g/+HaFPm4vqKfzeouy72I07ODjB9JcGoO8bZQ3Dnl4xu6a7d3ye9qLU0yjf+SfU+h5H2natlwXdNsa9kdtzwjuk+C+5Kcfl1LvGRH+WZLVVp7OnhHNl65VdDwVo2Ntn9wVcM3+a1S5F7V31yWO9wfBeskQ66Qh1llDrFcMsU4bYr04pHKdMsQ6ZIj1miHWYUOs1w2xLPX1vCGWZX88Z4hlafeWvtCyHZ80xLJsR0v/ZamvFwyxThhiWerLsg9ZxhOW+nrWEGvZr144v2qle3fN5wkMi91b6v5pQyxLu7eso6WfeMoQa1jj1SOGWBKv8lqhu8b3T/yup+WLS/UNGW1NC+tk+Q0Z4bVU35DR6hZnB7jehTqIwtreJ5bfdbVOm26LqTfyn4qRVavHOkOdbCGstGtL/bbtdNDbnlLWcx9rr3NuidET8l/M2RyityLR3RJ29MD63haBFdDvIt0bBTxMomNcf9xEWJpPXgP35CyR6aDX1jYQ1qYErFsIa0OMXFsSsD5BWFiebXhbAtathKW1SZx9I9Z+wtLsW7B2JmAdICzNNgVrVwLWfYSF5XcR1vUJWPcTlna+jGDdkID1AGFpZ/UI1o0JWA8SlnbOjmDdlID1EGFh+ZsIK5+A9TBhYfk8lctDHp4poL0ri+/Xf3u6WybtfAZ8d5U/kSr0/3G6g/md6W65sbycxT1Nv931RpIZdSE+Snw8nntt7eORXxDosY/wz5KsxvK0Yx/tnHLUj4yPKT+XykdaoDoRjquNasG8UbrHr2ZPUrnFfNHZ0yvdfR8lMEV5d0Mev6I/yBedpb79ftEZ25Jf0c9B3t3Am21iWuEjdRtR6HOENa2Uk3ZL4jeqlJsijAzdj/qiMx8HIvT/Q4uh0+3v0nEoGi8ttOG+I0eyMA3LIPR/H2T43hYdcyyiXlMRmP8c3PAfT+uYgYKp1StH9WIZpkkGof9HUK836GvZuaD7N/qFe8Nu2dYqvIKIe2zbayPy4vgmlXXXF8E152l2u57ocWtCGnsV+j+LsZU1igxYX25XloFpchEy/J+KDDjc1Pbe/WBruAko8dezeXjgpuQmWKPgRCVRg6veP5/WceR3nPmhC9Pc7lSEjFh2NdDVG3sa+xsRCuLxNhvBbCTQ01SgC+XSZOA1REkdMgn/bKD72d028hS4X4g8rB/e3pJTZM0peWgY/fBZHXSW9Pft33tvlC2kjaW0/s/lAyqbUe65hJ9eWarj6zQ+awbksyYlHx9Huml8cgPyySl8GEubqrl0R9jJR/r/F/z4q1t0zJEITFk+Efo7lPpoR4UJ/Z0K/R1KHUWXt0PenUEyb9Qlj3t7+pT1LoV+D9DcQbKifHf1KestSyzrZkXWKYU3jyFYrwsxhgj/rFJHH2NInF5d6nPajabO6kQ4rjaqBfN4qFhLdD8Zdv9ezLT7brq/u/U7P1CqFLQpsiTttL07KA9P29tDefsBq99pt9S332k3tuW9lIfLB/uAN9vEXQofqduIQr+XsO5Sykm7JfGLcxuCoZVzv7+slJkKel0fu5O9hL+79Ts/UCrMpHUnwj8bUd/dJvJ03MneoFffqB8OSe9WZM0peThVxjzkc7fCR8Paaoh1uyHWOkOsDYZYmwyxthhibTPE2m6ItdMQa5ch1vWGWDcYYt1oiHWTIVbeEOtOQ6zNhljThljXEpY2FdTGgsUuG/Aa2l0R/Ncr5QMqm6F76yOwBMfdwzCZp2IyLkwEetzBp5gL/cdzb/3FpeVRomF50nxJ1tO4n3paI/yX6kuySdNRjkPuVGTNKXk83t+eko+Fjbsk852MIg+XDwgro9zDPM3GcWlEbJyfuGNZfOKu7c6QuETbbZElebSdG0h/CdFfDzJo9Pj1EKRvKH1O23UxFcEP5cN7cUtq10dgRZ36f2mE7HeC7LzUpe0w0ZZthV7bRYLjvMij6YbH8BuU+mB7ys6PcaK/R6lP3NvDslQ8BnmG/qTu5Pg6yMF6HQ+76x2nQ5dY59puG9Sl6CxH9Kh/3hWMPCUP+xbHp9rOLdw5zP1e+5oJfski7qslw9Tvj6bs91dF8EP54vo9lu+n37sku61Y9if67PdXKfINU79/OmW/F5ta7veD93ttvE/b73G85y8gsT9BLJfP6wkiF9oMxgy3QT7Svx7TBzQfEvd4QevTOPfmryehLq+nPJRd5kQXbgybmdVsuetraGF6XbjEutP8DfoIae9c0OtbdlIeziF57UMbp3BnNdsr2hmOU/+h1Sm0HZrjQTfG8naD/rcbpHxUxMM+P+Uf9FERb6V5f9j9ezGPinJ0f3frd36g1P8OTf4wEy7D8O7NQXZoSn37fVSEbck7NHHJ6W7gzTaxRuGDu4SYfpqw4nZXJvEbVcrxB44ydB+Hr0mFN3/46Y9g+Pr+lmg98M5izS19SZGT20Lyg8D3JvNCIa0Le5tvMmcXJvA5ghMapMWEm4uRnncVcte7Oewtx4ldmJ93GG1dWNQmc3c9AdecNBcm9XXd7A9oZhEoWDzyp3Vh2ia7eygPn2LyE3R8+reP8nBT7n7Kw5XqA61r3gz+L1pCiQ14+lab+u1pbufliOodE1F9JOz+vZiIaiPd3936nR8oDW9EJfW1jKjQpVtGVBsIy3dEpZVzv1cqZfghhOS75PnT76mPOxT+S/WJTO2V5bhPZG5UZM0pefgZZMxDPhsVPhoWP3CeTinzYh+gcQi1JoL/iFI+oLLcx3khJKvUBfs2PyQWWSaC+P4xzvStOEJ7SKyVD4J0/WXYhl/f/UXzT3H9RXvnL6fk8YPCqZR8LGzcJRmXM4o8XD4grIxyD/M0G8cZ6ocieE8E+uyYbVzo1ys2LroeV8o7/A/Q+x0PAR1/vvNh+D1K9Fo9HqF6MM1DVA+h3wL1+B7VA2USeaaovOS7JP30IMm+u/U7P1hK3U+Ff5Zk9dVPD5I8rJ8+w2Q0C1YnwnG1o7pGUnd8X9j9ezFh8iG6v7v1Oz9QmsuLuYWKDJJ3GHg/RHlHIO8RyjsKWP2GyVLffsNkbMvDlPco5B0B3mwTBxU+UrcRhf5RwjqolJN2S+I3qpR7iDAyQa/LkfsPK7zHib4MLokXHpHXw0G0HuT3WkVO1rfku+TXnmfm0row4Z8Nem3Dhws7RPKwfvp0YWhiCP8pghMapMX0KRAJ6Tlq5mbfqpTjJKocJ5k/3LIZN5L+SOt6Oug1e17NQBniRgHt0bfQaXxWDchnlcJHusA4lJMPb0jehFJX7fWeu6ncAcj7KOXdF/TWS/Luj8F8IAbzQSXPyf6b6zq8otwYmjgfmIVtEGXPUVh8YBaWP0RYYQIWH5iF5UPCOpyAdSthYfnDhHUkAWs/YWH5I4R1NAGLD8zC8kcJ61gCFh+YheWPEdZjCVh8YBaWf4ywjidg8YFZWP44YT2egMUHZmH5xwnrRAIWH5iF5U8Q1hMJWHxgFpZ/grBOJmA9QlhY/iRhnUrA2kNYWP4UYZ1OwPoMYWH504T1ZALWzYSF5Z8krKdisNy1bMGdVso/RVhPJ2BdRlhYXspOKViZ1l8Jo87AfcPnt6lXOIV/lmS1lacTRp0JevWK+uEVm2cUWXNKHo5FmId8nlH4aFgHDbEOGWKFhliHDbGOGGIdNcQ6Zoj1mCHWcUOsxw2xThhiPWGIddIQ65Qh1mlDrCcNsXgsi4vr3fXlreu4uF7KoT+LWhrRYnnEiJo34NLIoQSZrySZFzt/cNc7CGux8wd3fTVhYXn2uUnzh4NhNxaW72f+4K6vIbkWO39w1wXCWuz8wV0XCWuQ+cOjYTfWIPOHLxLWYucP7roUdGMtdv7grsuEtdj5g7ueIazFzh/c9SxhLXb+4K4rhLXY+YO7nmtdW8wf5gkrbv5wJgHrBwgLy58hrGcSsH6QsLD8M4T1bALWDxEWln+WsJ5LwPphwsLyzxHW8wlYP0JYWP55wjqbgPUewsLyZwnrhQSs3YSF5V8grBcTsN5LWFj+RcJ6KQHrRwkLy79EWOcSsN5HWFj+HGG9nID1Y4SF5V8mrFcSsH6csLD8K4T1lQSsnyAsLP8Vwno1Aev9hIXlXyWs1xKwfpKwsPxrhPV6AtYHCAvLv05Yb8RgufTTYTcWln+DsL6agPVBwsLyXyWsrwXxdfxg0I2F5b9GWF9PwPoQYWH5rxPWz8ZguXRn2I2F5X+WsL6RINfNJBeW/wZhfTMB68OEheW/SVjfisFy6cNhNxaW/xZh/VyCXB8hubD8zxHWtxOwfoqwsPy3CevnE7A+SlhY/ucJ6xcSsD5GWFj+FwjrOzFYLslJmtNK+e8Q1i8myPVxkgvL/yJh/VIC1i2EheV/ibB+OQHrVsLC8r9MWL+SgPUJwsLyv0JYv5qA9UnCwvK/SljfTcD6FGFh+e8S1q8lYH2asLD8rxHWrydgfYawsPyvE9ZvJGB9lrCw/G8Q1t9KwPppwsLyf4uw/nYC1s8QFpb/24T1mwlYnyMsLP+bhPW9BKzPExaW/x5h/VYC1hcIC8v/FmH9dgLWFwkLy/82YX0/AatKWFj++4T1OwlYC4SF5X+HsP5OAlaNsLD83yGs303AqhMWlv9dwvq9BKwGYWF5KTulYGVaf+X50+/DfbvnPeXU7w8K/yzJaitP5/nT7we9ev09uMfPn/5AkTWn5PGa4x8ofP5A4aNhhYZYhw2xjhhiHTXEOmaI9Zgh1nFDrMcNsU4YYj1hiHXSEOuUIdZpQ6wnDbGeMsQ6Y4j1jCHWs4ZYzxliPW+IddYQ6wVDrBcNsV4yxDpniPWyIdYrhlhfMcR61RDrNUOs1w2x3jDE+qoh1tcMsb5uiPWzhljfMMT6piHWtwyxfs4Q69uGWD9viPULhljfMcT6RUOsXzLE+mVDrF8xxPpVQ6zvGmL9miHWrxti/YYh1t8yxPrbhli/aYj1PUOs3zLE+m1DrO8bYv2OIdbfMcTiNcdQwcI1x2brOm6fnJQ7DHn8quAolUF6xIjahzcKMh9OkPk2klnjKVhHErC2EhaWl7Lae2P3hN15+N7Y01RuP+Txu2gHIO8g5eF7Y79HefdD3iHKewDyQsp7EPKkrvje2DjV9bdb9z2/5a4eUsX6QP1nIv4GQe+atEvcZ/C0gjHic9CQD2J9Luzm86ghn0dj6nPIkA9iySv0Wj/k0zZC4sP3mA+WFzqNz8SAfCYUPowlr3K7JO9oYr8eJ/r/uWXM7lXuS7Z3Yx4OeuWbgHv8PmYIMklZ6YtHIM/yuYrgH/ODXxJdHFV0gXUS/nzkgeRrfwWL84RXNuj18z6eSWl1Q/nZDvHZCeogCuton1iTSp6PNj0SU2/kPxUjq1aPkHQSKny0Q/qE/liMXEgft/9ddIjPkwx1WIzTobaH3h1LIKfV1BsLB267ee9tAaVR0kPY+r2F6MTvjAS9Nng0Aiug31vo3ijgYVoqP67xWTMgnzUKH+24ln78k8YnVGTWTiGS8cjV/y/o3X+xbzyKBN/T4c/XCP3RzR3M/9bC1N4jCoNufvhb+OGZCXx6k/CLOr1pf4R8fwXj6/foEwP7lTpfGiOzYOJpeiiznA/BMvwNxcWexmI1LhZe0yRvJujEtdP0210fpLyoI3EwLwg6esR7bK9x50bI76g4KoR8pJ9onbCbNo7CfsFxlHYEkTbnYz1ofLRxQ9NDHJ/pAflMK3wGjZM0PprMPOd1Cf3QRRd1yqC9Yp/EsnIewDjR3wN+aGMLU/NDKCP/1nw6+yHhF+WHwkCXbwvYJ/uhkOqM9dRkFkz0Q4LhEvshob+iJYPn+E71Q8JLG2dzga6PIEg3zuYUPfgeZ3PE54ghH8SSvqLFmux/+o39sTzH2lH99caLdJ5af0XbHSf6eeivBeqvaO9h0J0XQh6PbUcUvtxngqB3/uhSnC87EoGVdowS+vmYMSpuLuRS3Fw/Sr6xQO9Te8NOnaOwAuWe0OP4yOtfR4n2SAxt1NzVXd/euva7vjA3I/aO7ylLkrzjisySh+8Rfyzs0HEapd9YJ2cPW7d3cJmO5UE9HY/A1HzCvWE3rdR5RME9RrjYz1lfcqYY9/FPt+zd9fEPX6TjsZ24JGuffufQc7Pcvpi4fVk/nLT2Fbld+36oj/bFNnyc8tAv83l06M8Fw9Ev0Lg/bH1pMf3lQwP2F02f/JxGGx9Rn+OE8RjYe53sXWh4THBJ+o/0WdHfmFLeJY7vhP5LML68uF3nH9ffgkD3C6gHPkfyeKDLotVZaI+QPWIfs7PHckHa8QTJjLyf8MQ7Q/yCQF9rFv5Tijwid1bJGxtA1plCpVKcLddnmguzczMzjQzhi6x8j9dJtfMl1iv0outTXnRdqosPwE8zngS9ujQGeU9Q3jjkiYyuD63Z3i3/SU/yp9E/8s8p9PvCDl0/bZlT+PC8YhCsI4vEWhd09wFtLMTYhsdCjF/wzNOvRvjlNL5OfBv7fawn+8HXyNfh+GdoQ2UtHmVfd8IT77S+TvhPBdFtm1XyBvF19Zlyodycn1moN0uNeqWZCXrHhFHlHvs6zW4vUug9+4q85uvYn41B3gnKQ18nMmq+zs+4WMqn0T/yzyn07OvStmVO4cO+bhCsI4vEEl+HcRDHqejrOE49ptQHfR3Py36WfJKnrz+o64DsU1Fel3AOfQz0xPplHLyHcTOWCYNufQj9dyBu//ZFunxSh48q8mn7urBev3RRNN0xhc49q5X189sa+2/5UvXeRv2WRu3exv7RQBePqxhQ9Xk6FRCdS2N070H6zcs3E4QjQ/BYkJzQJBBLazrE5qH3uzDleZlcGH8VZHfrb37ApE0deaj184ivmHpaIfyzQa/J+djCoi1fon54ePTz6KGYXxv0Lm+79OWwVzcsB28h1D7gk0b/WF9tqZ3tpv0Is/UXXWDrsudx5z8Al/V7tCQfkmzMM+5xZxhEY2UU+jspDx+PZWLweRnkf4B+/AZ94xVDHanHZOvvGORZ9jMnx9dBDvZ/GEZF2T/Si875EQ/qJO7xuKv3P6DHJNojee2RJw7DbNfa43C23XUKH999ZB3VJ4Q83jIQBr31CWP4aPaY9NjrzyL6WNRjr1nIR/qd8Njrn1J7auHDBewDxX77QAh53AfctRzrmVPoPxt252l9QNMT28KEIoM2Dmm2MBHBx6Xbw8Xz4fJClyaO8BOap/+8u/BfqjjikZR6Ff2EfvSTT+NbNH+oTVEES3tUro0D2uM4nP7xdO6vWn4kbvtA3DilPQZ3Ov+vNG3xHQ/F9YfF8kEs+VSNbHOTOcVoa836zZhlfXR5+TzNBJTRth5wfULAwDFlYn2nDJZD+wgBl5cYhf4vLulgTpJcaWME9qP9xghx2wNDBQvHEf7sT5pto6sCfZvqva1raWNZKlkPbbyudZ005l9M7YO+UGsf4Z20HCC4LOMWkPESkjFqG++lEXTuel/QS8e+KAj0+IXbEJcpNHreHiD021p8k+J6sQe/MU1Bjeux/TmmSRqPxHbjtlRxO1egna+j/qr5xcX2yah4MsqXe35tbz5tzDEMH6fVYo6ovuOSxHca/TEFX2s3t3bBfhu3Ngpf/OjwMbrHY05cjOIS+pIfWK9jYP20OEeO2EeMNL68X3sOlToNQ79JY9can7gYyMdrpdhunl/bK4vuHwM5tZiXt6sdhzqMEoZGz+uIjH+c6KX8WKBvkZX+wOPYQfDZH6axNK6OLt0a6nUUmZnmKMksj4UmImS+lWQW+o/D2MtbzrW5CG7b4m32Qv8JwHx1iy5nEKTzo9rjMXwEJvJoW59PUDl8DMdtrmHzo3ANh49c5HqOwL0NCrb2KNj92936nR8wCZ48KsXtvicVecaJvkZ2fJp0Gqcz9++UwhePStxAfE8R3zdtiLZBi2wY32O7c5tw3Mly7qF8ob8d+vNtNO7heI3j496IGBrnA0/EyHpCkRX7zKGwO1/ov4wx9HZdVpQHZb1w64d6rN21jhF260fzH0i/WP+hPao/Rnla3J4Jen1YmjEG20Gj522RQv+wMleKW6d0fw/GrENEvVqXNE5p81d8DnF4vY4b9cqWfFqWn2H9OaxbHEs5Jz/eJ+9bIni/DLyfSLFmYhn/aW11cdBdr7TrdDmlPL+icMRA5lyMzNr4HAbd9dHWG47G8MHyR6k+R5X6eI5nU89dhX9W0YmPuas2t9RevRV67XN8YQz9cYVeazecu6JvDYgvzl2P071BXkt7o0+/gGvBSH8X+IWvx8xlpR9oPmNToMsSBPFtlFPK854EX/PCTVSfMIiuTxj01idMWZ+Q6oPlBq1PqMicZDffJbvBNXbNbqJeP/4psJvfiLGbuNfqQ8rD+qRZU8d7cWsNcXwOD8jncEo+72Sb+kMjm/phsKm/FxPntYq/Y/V81JCPttbD4xbrF/OED9+Li5OitomiDO7en67Xeaa1G6HfAXbzZynsRmuDI5R3VOG7VHtzlsofxmFpsbfQa7FtXAyW9nmA9jql2Lbf10nS7w8R/lmS1VaeTryrrRE8puhuddBZ+6g29hWKcz/WqN374N37uTEEMBd0K/k4AQp9QL+5nBNqjGhChYdLeMYHGhKfh8EBNeOnkSmJNilf64SPRdQzCNJ1QiwfRmBFnbFwHPKR/r/AIkqaMxbQeNKcsaAt6CDdqFKHbEQ5XDTGPKzzh2LqLPR/FVPnowl1voXqrG2O1hZij0TUWe6vDPRNEoKh6fiSoFv2MOiVHe+xPWF5ofMdrFxCfKIG9/ENnTKoh6gNpHdBPtKvg8F9ZQsz7twU3/VHnvgb63UX0HBgJfUaUzBd4hc/hH5tq+6eF37Ud5iiAjqsn7t30YZk3cS1udCPQZtvTNHmcf0HdfuOD2QKjXwaG0f+b/tA5p9lupWcNpDhcnGBDNNGdepBAxlNpijafgMZnAFwINPvjhEsL3R+d1MVe3Yo41Md7Ew8IzsMddAG6KidoJkI/MNEL+XHInTHOyyEfmfLsb351LAVxGhttTlCviBI11ZYfql292wmPr4OjecVjRDKL0WwHmWD8jZMUpA03+eAGUI+0v/6pg7mD9GAGUL5NDui07wl1+8Kf6jw6bf/sI7GFEyXog6l/TQFUBzQ7279zg+UZvIX7qndTOrBnwM6bVdFVskbG0DWmUqzkJ+drZSaxepcY2aWx0iRle+leaJ3lULvd8WorB7C8xjo1aUxyDtGeeOQh08G+WAKP4FZuZ5G/8g/p9DfC3Xopy01rA8tEksOk9Am6xfKl0Ut4jwC+Uj/eYgF0hzmHMK9NIc582SI68g+0aXdrb9JltRMSMJP2meFIssR0ovQNkAv39zeXZeonT9jEfXFugUKRpTumMeIUnZv0C3b0RSyaQtPiHEwQk6HsVQ7UDQ+2wbks03h4/PJF/JMisfup3gs6YnUI2EnH+m/BvHYQxSPaW8RCb8QfmuxEPtIKS8775iG/Y3QH4J+xTulH6E6Yz3j7AzjMZQ5akHr2BAsaHGdx4LO7l70jz8W6nVOOhBZ6LWYBe2Ifbg2/jJW1KJ5CPlYt3ta29cc31Nk5/LGVlT9fzzsxhT6727sYD7VJ+ZPRGB+e0MH8xnqO0LjrrcEOj+XRpV77B+wvNCJLfp661vwD/jBb39oaL+iC6yT8B/043HIKxv0tpGPhUStbnHtjB8A4TelNKz9fWJNKnk+2nQipt7IfypGVq0eHANpfLYoOhH6+2LkQnrpw2j7UlZ0iB9uNNRhMa698UOSwn8xH48SvV1MdPzxKNT9gQisgH5fTPdGA/3jUU6Gv24RTyv1u4lwtbbDe2z/WF7oND6TA/KZVPjEYd2kYPHYjvSTCr3UAz8QujRr2x37vF+RVVujW4x9it62Ep3ELSNBbx98IAIroN9b6V6UfY4qPA5Tubh+6dK0gsF+/f4YnlJXl7Q3YIWOD7b9hxSv+vFVcxX+UK3wQN6PeOKddsyPeo6Acmtvsw+yflisNsu1WilfmC/MNKul+bj+rT0PEXptvSev0IuuD/vRdTnuVAht/ZBPyBqHPJFRWz/047Pmymn0j/y1Uwp5/bDfZ1txc+O0WLJ+iH5f+vZS+Zo4rDCIrqPIPBHozzbZlwn9/wbzf3nzbjSI1kOg3BsJev3Ux8O3/mpj6YpAl13jLfgu5ZTyQnfhfGV+pl9fmVV04mN+9EhKvfKzWSyrPWvlj3b0u24+7Fho2/whecnX/gofvsd8sK+vID6+nsOn6SeL5YNYEkP6ft4va4mex+ai9iapJF6r1uwG1+84VsL1PG4fbR8Lf+jAXd8N15xG6TfHB9/e3sFlOknaZjse9w4TT74XN+4dprrhegGux49u1HniejyugYSQj/QvwzrlxMbuOmL5qL1DuLaNskbtNVjV4nEhP4A7qdTPsI8UtA+qStJOTeI+gv2H+wj2H+4j2H/4xHNMWj8QXbh+8Od99INxpR5xH8jVNpdLPbTxYJzy0IcfpjyMH45QHvpKOX0tQ/xc0vorP4OIq7PveHhSqeuFtF0+reqoore0Nih1cja4eUcHl+lYHtR51Jqt6Al9IcuIMkQ9N5SyPG+4fmNHdn5u+ACUEcyHATPqlDL0rRhTsG8V+gL5Vk9rcqpvTXNi/lKsFSK/INDnHcNwqqA233Zrl6ta13v2Vuvvq96978CexgipEru+5uqZHmkDJW+U7u0nug+E3b+lO3AXZmyXP2zhKA+ZacJRl94IO3ScksLKVzZ3cJmOZcW25C0gIeQdA95sEwcVPlK3EYU+JKyoA3xHU/DTlrl4qNLKud/3RJRhl60NnTxEa/UTrMMJWPweHJY/TFhHErA+QVhYPupViSisWwlL2yYlWMcSsPYTFpbnLSCPJWAdIKy4LRrHE7DuIywsf5ywHk/Aup+wsHzUgWxRWHwwddxheE8kYD1IWNq3zgTrZALWQ4SlfSNSsE4lYD1MWFj+VEQ5d42PxdN8yMDPtz8LpQzxE3nxHvJfqg8ZaHrXDsMU3Z1WZM0pefi4HPOQz2mFj4Z1nyHWA4ZYoSHWYUOsI4ZYRw2xjhliPWaIddwQ63FDrBOGWE8YYp00xLrfEGvcEOuAIdaDhKVtedR87urWP5f27d97b6M15wooxc2R3O+DEfzXKeUDKpuhe+sisATH3Yt7vIuHgmrxuOCNE/3TsITBjz4nlPIuxW2T9LylM/V0X/gv1TbMAyQP64fH+/sUWXNKHi8TTaTkY2HjLsk6QEaRh8sHhJVR7gWBvi1PW17MUJ7w43txS6j8Ks3h1u/Xwe6jXjHSHqu4xK85CP3XAJMPR9fqoPkmoT8aU2eUR5tjSlm/j1vmStryryRtrYUfeWivzWuP/nj9BmMBXoLEsR11wklbvxE9pX0syPYiuGwv4qvZb2JZfLynbQ3eRTw1f4P3uE9geaHT+EwOyGdS4ROHtUvBEnptS0zcVlVtq6bnbS/traraNlxt6+xitqqK3q4iOt6qqm0RZayAfl9F90YDfauqZisTEXIK3yRb0V7BYCx8fCJrdC4/hHyk/1N6HHIf1W1363d+oDRfitsS4/dx3XzqNY+o7S4ot7YNa6BtqXOlQmEuX2g08uV8tZ6P68vaNiyh17ZtXa/Q+328NJ/XtqXy1tMxyHuA8sYhT2TUtqX68U/zqfSP/LXtTLwttd+tiph3yyKxZFsq+nh+5cK3b+JXNv8PJYZcalkkhvoXMfGsNjZpH0mIeyVJe62F69Xvay0TKfncOCCfGxU+U0q5TMRf4cP3mI8mc9KWrv9IW7pwi7IWS8ra/zjRfx5eZ/2LmC1dvOabtFWC+6uUx60SceOy0P9fMVsl7qM6Yz01O5M6jyn1com3Sgj9X1Ns4GnrsbpVgsfipY8b0q+d8Csrnl5DLMSNAdoWqZRbJdjEUZ0Ix9VGtWBe0hLJ+8Pu34vZKuHprZQZbVuDJG2qze4Rp9o8fcfHp/1ulcBQqJ+tEtiWxykPQ6jHgTfbxAMKH36LA+kfISwtjJZ2S+KnPUrlKYpWzv3+UkQZlBF5aEsQ0zH1E6yDCVgcLmhvNwlWmIDFWyXiTiY6koDFWyWwfJptF4jFWyXitl08loDFWyWwfJqtEog16FYJxBp0qwRiDbpVArEG3SqhhUtxWyW4HIYcLqXZ3oCP7gy3N6Q+h1/4L9X2Bk3vcdsbTimy5pQ8XgbStlGcUvhoWMcMsQ4bYt1niPWIIdZBQ6zQEOuIIdZRQ6zHDLGOG2I9boh1whDrCUOscUOsC72N4IEI/jmlfEBlM3QvF4ElOO6etoVW6LVtBNqbObyN4JbW8sPyNoLBxtV36jYCmSNnFHm4fEBYGeVeEHRvIxA67W0rbe4i9PyWDmPwo36hXwB7fzXixECUIe5Rf9JWen7bTNuGrz0Cxbn8m9hhL6bfb0Dna9o3oFE/42F6XbjEutPmhBjH8JuEcW8gxs2Jk+wq7hG/lMXlXm2+u5149vvmPpaPO718ckA+kwqfOKztCpbQa3PUuEf82hxVxgqMVazHiihb0+a5i3nEL3rbQnT8iB/t93gEVkC/t9C9pEf82Kb3RcgpfJNsBcvH2eTEgHwmFD78iOylls/2vOZa0l5P47jmuCfeaeMaXjtFeUTurJI3yNaA5lwxXys1G/mZ0sJCLd8+cV1b88J7aXzGtQq9X78wp24NeBz06tIY5B2nPBz7REZta8DjnuRPo3/kn1PoeWtA2rbUsD60SCzZGoC+8UL5mqOt369CfMhbA3zL4nnbZ9/PlPi0AOy/2OactOdGuEWzn9MCUOe81tLvaQEiQ9rTAoT+O2AT/Agcywhm3GkBgomPwAXDJX4ELvS/SmMgrof5fgQuvJbqu8F+67g0z1bdNW8dwHW0ccrD5xB8ArK2Nq69fniY8p6EPN5u/RTk8Zwek9aXpV1cf7h+aweX6QLiGUIexzHo80S/2jaYnXCNeSIr32N7w/LjEeVQHpc8n+pc8HvsQufk7aTn2Ww/i91ihbyyhGWtu7i6xW0ti9oLEIWVZpskYnneEtRu0/tj6q35IE1WrR68Tq/1s52KToT+cIxcSK+tjUlZz2Nd7GnV2BeF/2LWB0Rvu4iOT1NfzGnVu+he1PqA0GvbLw8qMqXZfnh/AhbvNdFecYjrb4jFe000XcXZHWLxXhPN7gTraAIW7zXRbEawHkvAGnSvCWINutcEsQbda4JYg+41QaxB95og1qDHciBWP8dyaPNJl7T1dtx6/H/TsxMpi89CcB38COQj/Q9v6mD+P7ANmV/xRD/waNCdh7HjIZIfn4mJT/L7ek/654PCP0uyGstTiPO92qsDKbfK8mkiqE6E42qjWjCPHwPyo90JKreYrbJ+QqFKTesukrRlBJ5ePQp5/EGhQ4DV71ZZPCCxn62y2tK7dnjio8CbbeI+hY/UbUShv5+wtMfT0m5J/EaVcvxRoQzdR9f1sMJ7nOg3tFyX0+3v0pKMxgu7Gi8LaW9GIA3LIPSXgAxRb0aMRdRrfwTmTeCSt27SMQMFU6vX/VQvluE+kkHor4B6vQHPoJBGfqNfkCVlnjJF2SNPL7WwjvPkt8Y3qay7fgiuOU+z24eJXrYcRemUbUXor4uxlQOKDHFbfVgGprk/QoYbFBlwuKntvfvBiF0iY3CtDQ/clNwEBxScqCRqcNWT7sA48jvO/NCF7Vd47I+QEcs69YjLrjf2NPZHbaPh8XY8gtlIoCf+2JmUc2lYt1R5+lBc7JYq7aN22tjIW6qiXtvoh89it1RFxVJa/+fyAZXNKPeCFuYfr+ymi5sWuHRH2MlH+t3gJ3iLlNCMRGDKVF3otVOiQrjHy0ZPKvS4xC38ZfqBS+NPBsm80WGwX32qT1mfVuhxWf00yYryPd2nrLcssawTiqxTCm/2UVivC+GjhH9WqaMPHxWnV5f6nNahqbM6EY6rHeUW2BXxOPiTYffvxUzrnqH7u1u/8wOl+fZh0c8qMkjec8D7NOU9D3lPUd5ZwOp3Wif17Xdah235HOWdgbzngTfbxNMKH6nbiEJ/hrCeVspJuyXxi3MbgqGVc7+/rJThJ5iS79Jk0KsXO9sqpP7mlfDPRtR3t4k8HXdyJujVt3aooujuGUXWnJLHy0XPKHyeUfhoWMcMsU4ZYo0bYt1niHW/IdYDhliHDbGOGmI9Zoh13BDrcUOsE4ZYTxhinTTEOmiI9aQh1oQh1gFDLH6bTXvTRxsLrN5mezqC/3qlfEBlM3RvfQSW4Lh7GCbzVEzGhYlAjztwaov0Z5Wly1GiYXnSvCXuadxPPa0R/kv1lnjSdJTjkCcVWXNKHo/3aQ/bt3qbTeY7GUUeLh8QVka5h3majWsHP2unnuDbm/x0V/s4SNwyhoyfuOyDGHvCTj7SfzNm2UfbcRDCvTQ7/XEsFnm0HQq8+w/LSZyh7eAXOs9vxjW0N+OwvuNhty60XRFIz7rTdj5gvCBtnyN61GOO9IU82d9he7h792/opjsC8mQi/oqsfI/HO8SS791qhxEPygex7iI+hyEPd1V8nx63iU6wHx0G3rOQj/T/GB7h/W7rOm6HEB9G/QfQDz+2I7q86FI76Ya/34h2wHGZVk/UH/sLof97IOettKMf+6XI5blfNrV+iX6P+6Xmo5Ce+2VcP0ad5YLePnuYsA4rWKjzpDcXuE0Fj98a+BMlHtK+zXmMZD/Yp+zaeKT5mcNQj/mWn0nzISptDNTaKqeUPxaBNaLIj/2a231U4a3Ri03go3/Nf48T/T/H8Xe7jhlEyHA4QuaJCPrHSQah/5eKvcT5CbT/44Qp9P8GMPmA0yTMuyIw/11MrKL1U9x92e94y/EI6vEJykPZedw8Afy5TX8m7OaPOGjnzDeIkVd7cz5OXh6P2nmXvPXX2dJftvQ+SXjGvrwU15Y3KPVJ25aHY+rPWFJuLOi117g+hPr675t0zPE+Mf8/JSbQYh35VvIEyBHnQw/DPfbb6FMwPvw+xTQ4DoUkv2CsuKQj/6swRr8pS9gpL1heY4VCI6/FCqiLceCbRnfsU7Td3tjOHMMj/d6wOy+EcoeJz2GFz2LG4os2dOMejcF115eSHHExpLu+A/KRfqNiF3E6jNO5NkfFOEDk0fz4ccrTbHrY7BX1w/YapwuX+p2vs71q45NmrxzHxdmVS3H2KmXdvfGY2LEFoa4t8HOKJJvhteLHQQaNnmMgod8Fdv5GingFY4fFrg/0M8Zhv0Wd3Bx210foCyn9ubSL37lfoaD1D9Qr9484HbrEOtfeIEFdis5yRI/61/rHCcpD+0wzB0rbd3D8/tP13bhHUuJyH0abwRiTfb3QvzfG11uPr7w2ouk1zncMmy0Pi6/nNY4Q8oSnZn+4fvGHZH/amBB3cphmK0cV+bV1MV531tbFLtg4H9H2cWtYcf3ApX5jJG577XQhbY2I11iSfMrNVI8kn8JrrUL/hT59SpxdWfoUlD1sXV+4tdHhtqs4n9KvXcWNgeiDvtvyQdqJJnyCoGZHIdxb7Nwvzo5GFbnQT04quC7tbv3ND5jinslMBr3ta7j2k3pvnvDPKno0lKcQ166onxHSz3E/8pTXBr19xaUvh726YTm4P4Ugu+j4VsDhE6DwTWd8dvZoxFoT+nPtLXxeDzgGa2eHCVM7YStt35ey7t4b63VZETdUyrIdTETQY92R/kTMHFDzn5ptCX1SDMenqKV9vn4kgo+2l0Abl4X+6ZTzw6V5Zl8sXOhn9rxGEvfMHtuA9xxqtqqd4KG99oxzwEcj+pb2TMwl9Akoo8jh0h6g4XUTLb7TTpng+O71PuO7jXCv33GZ+0y/c3GtHeJ8htY2PXtyYnxG0j4f1qnQfztGp5ofitOpxT6ftDrlV6CET1qdCv2vpPDDaXUq9L8Wo1NNR3E6TdpnwDpFffO+4iSd8ut62vpmnE6F/rdidIonbabRqdD/zgXUKdb5BJVDn8ExJ/u7bES5DTGYj0VgxsWfjBHVlppP47b8o5i21Or1WMp6HTeq1/E+6yX0f+ypXgcj6nWwz3o9llCvqNOx/0SplzaGRc1rtTUXl3jtX+j/dJie5Q7B2gavi2lxeNyeqzh7Wcz85jitbaB9sg3gyVBx63S8r+xfp7QBPNnYpTHI820DaMtsA9qac9wzt7RrzjmFXubJmg3wfMvKBg6v76bT1nH4r/Dke3F7a6VurCecR4RAz/OI48BX64tML/1uLNDjTeHFPvKv0F63v3WtvfeBaxp/fYnOO6qv8JqG0K/Z3MH8mxam9pq96HWxvjsEWaJ89+hm0MOy727rTPPd3KfjfPeEwieEe9xvQ4WP+zuxPll+bS1Z6LWYT4vBOOZbB3bxRkSsre0RcNeVCMyLwe43bO6uv7bfydFdvtmG92bFzgUz6ZTKftd2eO+Qtt+C681tJfWOe+eFdYKxKtJzrIp5/cwttL29rMOJCHqOwYX+asXO0ux90ORLOy5iXM0+XXueFGcLcXED8tWeK7F/197XuHDPCItFzRdjfdkXx8VELlntidT8NPpi7h+hwietrUhZd+/PLnrrWlu7eiRF3bQ9GJr83FekPj8CfYX3zWvrqXFxu9C/N8YvanWIe16e9pmvFs8cjymHNjSp8Nrd+pvPNwdKwk/81gpFlqjx8gOgx29u12XN9Mg7WNLGzgzpyc8Xh4r5DPELgt65Ao9N2niz20SezjNZbR1Q63d+vyhVaOIzWbRffCYbddq12IsW/+J85BaKjTQfgP50BvKR/jMQl30yAjMI+vedUtbdu/Gibtw4X+HSoM8V0LfEPd8MKU97X4djHNQv0vM+R6Gvgm+Iey9ySZ59FpoXfG8s73/FvbE8dmv2F/XVKdRhVByKfQTp98TEoSGU5/25R/qU/ZgiO/dz7jvcz633514K+Uh/ICY2uJB76bDc4db18v7cdPtzD0Ne2v25F5HvPqzIo51rwfaK9odyXAb5SP94jP0ljUv9rteKPP3uEQ5b1xdwzax4odfMpO3T7BEOIU94auefSHu4Nv2L1ifofOqxMpdvx7TShmKvnMYgH+lfbtlrFuohf8cGkLNZqRaapWqzOlOt18u1Kn+RzyVpM3ekqLOHs5s7MmaA9qsQ671Ga3BjgMdnZIxDnpzT8ea+2RaGxNPYB3cvsr7dqdCQuq4IuuuE8w1e91wJcojNjsA9/rIRll9JfITvL4LuvrW5g4XYLJtLb4TdeUL7C6S7FYBnODdSv+AovKR9MQ/Xn3958+Lo0JbkHWS2JcRDW9J4jZG86KMEj22faQPAFJ2jDRnqvJwhfkGgz4/lXlapl4/58SjJw/oZIT2PKbLmgt42Fp+QUfJGlXsjS4w1FfTWn22B67q79Ts/WEq9f134ZwOvtlmI0+uoolet30rZXBA9PmSUvFHl3sjbDAt9k+arWG/cpzEP9S1rO3HjMfs4bfwaIznF1+P9CQWbx7t/QuPTSqrH7tbv/IBJG5+El1a/0Zj6aXOBT0TU77/BeP5PNyfzmw56x+kM5aGORihvEvK4jSRmHE9ZB6H/lymf34vMns/cKmtzEZH1TfnD7nqvgrxRhZ7nIqsV+lVAw3Ph1ZDH/Vfr/3HrKKLDCYUe8djO/lPM2hLafJZkx7qvpLxRhS+Pf2hzTs5VLd6TgW7ju1u/84OlyhTVH9NU0NtP2JdiP2FfmiWZMQ/tAHXAied0qAsn16d2dHCZTpLmJ9gXrFDqofkJjG3flC/sletC9Fvh6RL3W+yjowq99J1c0NtubK/YByYpD/vACsobjeGH7S+6xj4QNY5qMY7IKG0xptTFJR5HhX4d9bsLMc+bVOpnyHtW2zsnaSqIHjc1f8B9fpJkxjy0q377vOii3z6vxYGaP+A+z+3uktYHuH9gH+DxDccB7h/aHDxDmEEQP/ZNB73y4VqT9VpXvlivzTaK55fjKrOF4ny9n7WuTNBbb22O+xDpQvQ9odAj3jjR39Dq19oeOYwFpI0Ohr2YLHNa3yJ0BZDhabBh1oPoz7MfqGWIXxDoc13hn1X04WOuq8V62hqC59hogccSlEeLJTXfyf4H1ytHFfoJqCP7WlwnHad776FYFeM5nkuvUOqD90S/TpZ5ijOwbTIRfwWX78XN0XnNUJtrO3l+jPou9ndtXUT8B/fFD2zpYL6f3rvRbH9VEO+zsL48D8K1V42efZbQfzjGZ00o9Ua5DoY65kcBk5/TaXahtR/bMtKvUOoVt24/HfT6FOxPb2KHvZieY+yaFmOjfsbD9LpwiXU3qdDzmo1LOaLX4grsRxy3Ja0b8r4GzS6x32ljuLZOnVF4SFtra2xx8iLWLYSlycvrg0yn9RmkRwwNX2jjxiuU+RMks8YzbqxBrFsJC8tPULmocUhbt4rq/xo+1z/Jb+wPu2XWeGp9YCJCZqyX1u80fJZ5ZYLMB8JumTWePJfW+Gn10vq+hs8yTybIfF/YLbPGk9ftNH5avbQ1BA2fZc4myHw/yazx1NYOJyNkxnpp65UaPsu8KkHmB8JumTWeUm51DD+tXtqaqYbPMq9OkPnBsFtmjaeUm4rgNxZRrymFt4YvGJmYcijzQySzxlOTGekyCnYUby4XkKx8fzHPjkQHmBcV++Bv9GvaHjDeI6D5E239ZpLytP6hrd+sojytvX2sOdRmZhdq5ZlqvlFwP4tJaw7W/M+zrtSqlUJhvlxolAszSfynW9cTYScf41mXVrR+S/9ietyvgvTfgjnMt+l50rjCz9H9ZgxdJuLvmxjKvbGw+95k2Es/GvbSC+9s2Cuj5K2CvHHis7r1G/WFWCLHONH/BszzXFoJZaR8TuG/kvh3ya3cQz/AWKPKPZxv/1JLxvYzRuBtvdbyJk/Cx3ss22/Cerx1vyrOzc3OFxfy5Uq91qyXS0vdr2sLswvlxkJttlCeLZXz9aXmX6zXG4VyoTI/1yiX6/Mzg+wb/N/BL/whzWERr91vA3382r3IurBq0/gT5J8NesdaH+uM2rq6pm/P+88WMoSP8mjrStqYG/XsPSrOHIU6cuyDseQ43fsTWmfEWJnXGbU4Gu+hb/ljstN+97dqz7Q4b0VMXppn3C7xvp+sgulk2La1G09r27g9rmz7iLUqAStujWQVYa1OwOK1i6i4PiqmRixeu9DiecFak4DFawpYfg1hTSdg8Vwfy08TVi4Bi+fgWD5HWGsTsHhujOXXEta6BCyes2L5dYR1UQIWzyWx/EWEtT4Bi+d4WJ6/Q7whAethwsLyGwhrYwLWI4SF5TcS1sUJWHsIC8tL2SkFi8fnTXD/QozPwj9LsvoanzcFvXpF/fB4eIkia07JY791icLnEoWPhjVliLXGEGvaECtniLXWEGudIdZFhljrDbE2GGKx30oarz8TvvU3zfob2i7SjQb6Gp02vkfFAxibJ8UFN5PMGs/FvveirbvxOh+uu/EaGcaY7Pdx3W015eFcU+qDMWaad3BwjTFurTBLedq7O5qOeI0Rx4+4dUupt4859UJ9tpafLxXq1WolX5md62dOzXMsLCfjMdv57kXK2Z1qhYwipzYeC/8syWorT2c8jtvPjboU/Uz50U8+zn9pzwFEnjVe5MmXxFZyCm+RVcY9nI8j/RToEOnxWsrjvfeSD9DmGznKc4nn6tocCe+NXCAsbb6FepM2dT5llnSB9pqJ+Cu4fI9lxPaMevZhwQexZK1B60/u3+7W7/xAqVSUeqxR6iG80a7s+s5MJa2vE/7ZwGtfLsTZMOqH5x45RdZc0GvDR8MOXZJ9Ix8N69yQYp02xHrOEOsFQyxLfZ0xxHreEOspQ6xDhliWdTxriGUp10lDLMv+aNmOpwyxLPvQS4ZYlu1oaauvGGJZ2teLhlivGmJZ2v2w+hzLOr5miHXYEOt1QyxLfVnGJpb2NaxxoaXdD2ssd8IQ61lDrHdDLDesdm8ZmyyPaf1hDWssN6y+0DKWs/SFlu1oqa9hjb+OGGINa/z1pCGWZd+27EOW+rIchyz70LDq3tJ/Wa7LDevakKV9Wca+wxpjDuPY4a75mZXF2DEdgY3Xcc+GNT4ZRWbtmTLuNZkMeutr+VxZ8Nd5wpd6a/tQsU7Cn58xS772V7A4T3hlCcu4boW4usU9i8bn7qiDKKy1fWJNKnk+2jQXU2/kPxUjq1aPKUOdjBti8dluWv/Xnt8KvbZ/WrOTuP3T0ra4l9CwbYtxbavtwXZ7FmRfVr2xcOC2m/feFlAaJT2I3j5JdPIewEjQ2zfWRmAF9PuTdG8U8DAtlX+fUsoJnec9Q8W0/lL4ZxWd+PCXa1LqVdtvtIZ0jv1nX9i5Rlo+f9MlfjdHG2/8jr2zpbTtI/yXajyL8+sucfuk8esuHQs7dIP4Ype+Yoj1giHWaUOsk4ZY5wyxLOt4yhDrkCGWpU2cMMSytIlnDLHeDTbxvCHWWUOsYe3blrq31NeThliWdXzWEMuyHS3t/ilDLEu7f9oQy9ImXjPEsrSJ5fjrneGjLcfaxw2x3g2+8HVDLEuf84Qh1suGWJZ9yFJflmPasMaFwzqmDevcylL3ln3IUl+WPnp57HhnjB2WcytLX/iiIdbymsKF60OWures46uGWMM6H7LU/RlDrGFdL7SMc5b9xIWLJ5b9xIXT/bD6iTTxF57/z2cvansbBGtdAhafvYjl05yzh1ifICxtj4eUWx/BB88b0c7Wc2kq6K1bpvV3UsG33q+E/KROeA/5Z5U6+njOrp1biPrh5+wbFFlzSh7aFuYhnw0KHw1rLcmAdr5E7VdcbPut9SNPbPtp/qPf9os6y0rygyHWuafvpMXqfGJAnbt0b/jWX+1cT973p8mwXpEhp5QXOo3PugH5rEvJZ+2AfNam5ONDb/xb29slbSl9BNt5d+tvfrBUFvvaSHIhX09nl6bum8I/S7L66pvaGbWoH+6bmxRZc0reBtKrh/YsXcCzcVO35zvlbFxpv2lFr3x+qCbDJkWGnFJ+Uwyfiwfkc7HCZ1Ipt7v1Nz9QKpVZx8Ib+W6G+xfCPoV/Nuhtcx/2uZnkYf2wfW5RZM0pef7bM9+cUurA7bnFj/5St6fwzwZe7avdnltIHtYPt+dWRdackreI9izWmoXSTKMyk5+tlmfqs6VivVjJ18szzUJhrlCcL8+VSs1aea4+Vyw1i5VibUqpA7fnVj/6K6dtT+GfDbzaV7s9t5I8rB9uz0sVWXOU55LEdxklb1S5NxKBxWPCIFguyTdEPI4DM2z7IjvyxfpdCL8h/LOBV7svxLUZ6oft7DJF1pySt4nKYXsujc5LC4vVuadYNVbnWrzUj85deizs0HHeqHJvJAbrhCHWGUOsZw2xThtinTLEOmSIdc4Q66whlmUdTxpiWdbxOUOsFwyxXjbEsrQvy/5oaV+WvtBSrucNsSzt/t1gE08bYlna10uGWJZ1tNT9k4ZYlnb/oiHWsp94Z/gJyzq+aohlGU8Mq+5fM8Ra7kP9YT1uiLXchy6c7i3n7pZzZD5rDNeQ+DlYv+uSWF7oND4XD8jn4pR81g3IZ11KPmsH5LM2JZ+JAflMpOSzrLduPmn19k7rP++0+lwyIJ9LUvLZPCCfzSn5bBmQz5aUfLYOyGerwmdSKbe79bdQKhXy+Xql0Kw3SzOV+eJCYbY0O9ssNyuzc+V6c6ZcrVcahXK1VJxvVPLNwlzj/FPTUq0y25yv12ab2jfs5Ztzri//9WXd9ZFviOKeYvxm5wjkI/2Dl3cw/6aFyd8sDeB6kvAygeVzkmLq710L/yzJaitP57nNCMnD+uHnNqOKrDnKc+mxsEPHeaPKvTiss4ZYLxtiPW+IdcoQ65Ah1iuGWCcMsZ41xDpjiDWs7Whpq5b90VKuk4ZYpw2xXjLEsrSJJw2xLG3iRUMsS31Z+i9Luc4ZYlm2o6Vcwzp2WLajpe4t+7ZlHV8zxDpsiPW6Ida7Ydy27Ns+xlqZK+N8Tr6nPk3l3PUqyhuDPMTAPJRvLEY+LD8WUY7rIfNRX+/PCf5KP/jtbwKsUHSFdRL+Mr8cB/pMxF/B4jzhlSUsa93F1Q3lZztYAfLwuqeGtaJPrEklz0ebTsTUG/lPxciq1WOMdKL1s4yiE7m/MkYupJ9WeEtZ0eEk5BnqsBinQ+yLwn8x31MQve0iOjlzYCTotcEVEVgB/d5F90YBD9M0YWh+lPtzVPvmIsq7NBXDZ0opJ/VbBTJeAfkriccVQa+MV8TIiOWFTuOTGZBPRuHDWNqaqUt3hJ18pD/SWjN1dXh1SzfmNkU+ra3k/pUK/TagEXk03VyZopxLUwovkUn68VVw39oXIj+RF+8h/yzJ6mtMuorkYf1w39iuyJpT8tgvbFf4bFf4aFjSntNBb/vy91c0u9sWw2dK4ePXFopl1iUmyduh1FHyroY8tA9Oo/Qb6+T67LM7OrhMx/KgzkW2YdPTNsq7GujlnBrJuwby5L2rxejwm33oENtK5BafKt+aOdmqhBtrv3F5N42cWfAL8KzqW5d389im1Gsq6O3r/P2a7Uqewz/eApS+h7bHYx/qe1S5Fzf2XR2BNQZYk4AlZxiNE/3fa+lDbPMawLWzzdmK6O1akInHkus88U47lgj/KUUekTur5I0NIGuzNpcv5Wdn643Z8sJMuZkhfJGV73E8sFOh174hJLreFXjRdbH9ncWwg78T9OrSGORdR3njkCcyOrtfs71b/p2e5E+jf+SfU/LwDJx+2jKn5N0S2mChP7DAWrFIrHVBd39Cn6P5TN6P1a/PxPJXx/BZOyCftQofvz61OKf5VEmaD+Nvfu6MqD8nbUyXOrm++V/7GNNR5yLbdNCrJ16/uYbk4Xtx+9aETtoDbc+wPeZZ54FS/51KHSUPfTLqiZPWHlIn1x4rru7gMh3LgzoX2YZNT9dQHq6R3Bp2510Pef3GqajDUh86xLZiHfqJaYpV1lOgyLVL0QXryV33OyeSOjk9hYu0tV2Uh7Ymsk0H0T5ssWPYOqUeGp+1A/JZq/DxG7sUF7R2l6S1O48HN0TUn5NmE1KnfscD1Dm3u+YrM0Gv3Y8q9+LGA+6jfmLhzhk16JO4/jcodZS8GyEP9cRJaw+MnfsZD1DnItuw6Wkn5d0I9Dwe3AR5/Y4HqMN+xgNsK5QbZR8L9NjmU+Fbf8eJfvMVb/11NrLpim5+uKYjvB3dZ4lupyK337ZNv44r/LOBTx/ZWcfdRfJE+Q/Nb0rZnJLH3z+/XuFzvcJHw4obn/j9hH7Hp40Kn2Hr5xspD/0h2genpL787CLHp2H1h7xuhf6Q13Gt/GE/67jamMJ2m9YfCv0PXvHWX8/+K7+O6oW8tHnMsPtVP/OReL+q+aF+/SrODwb1q2KPWpzJ72P1G2derPAZNn9xMeVZxZnPDugT3k5x5jD4VW1sShsTpo1HPx2+9Zfj0S9c0cH83BXRcu0A3q8T3XI8+vaKR6Utp4NeG+N4dIfCZ0cMn40Kn+V4tFce1Pmw+s0dlPd2ikdF9rT+UOjDK976Owzx6A6l/n6fRaX3q8I/G/Tasw+/qj030vyQ9gxGyuaUPI5HNf+9S+GjYXE8im3E8Wi/z8EuVurj+flOX88mUEZtbEP74JT0DKcfv6o9mxg2PfFzMPTH7FdvgLxBnoN9c5FjU9QcOSkmvEbh4bcd8o20vov3AHnypW3fdS3JE9XX3R52Oefotsb+jx5Y2HN77UONB/e99676R6v37r+9uue99fq9jX37sDbIYUqpLVsL08h1TrmPGDsTasFf6sNW3klYuxKw+Et9WH4XYV2fgMVf6sPyWBZ/jwe9csruwJEUONxzNbluJbnQW3I0c2MC1n7CwvI3EtZNCVgHCAvLY1n8PR70ysn6isNx/woJct0XdsuVh/IFwiomYN1PWFi+SFilBKwHCAvLY1n8PR70ysn6isNx/8oJcj0YdstVgvJlwppJwHqIsLD8DGHNJmA9TFhYHsvi7/GgV07WVxyO+1dJkOuRsFuuWShfiSgX5cvQN2h9twL5mq1i22Odp5R7PLrOwX3D0ayednQV/tmgt118jK5zQa/+UD88M5hXZM0peTwzmFf4zCt8NKydhljXGGJdb4h1gyHWLkOsvCFWwRCrYohVMsQqG2KJH9NiLz7Jrt+ZN5bnmR62uZ3PKbXffsCxRJLkzSl11HwP+kVO2mxO6uRmcx+8poPLdCwP6lxkEz2hPV9IPfEsE+1LxmXJ+wHI63dGLPV1Ory/Dx2iPc1R3i6lrF/9pl+lE/7ZoNcWfIzFWgyv9WHRXVGRNafksQ+Pi5mQj4YlcZ02j+BTL/MKn3wMn82KzJ77WpF1iUnySkodJQ/9PdoHp6T+1M8qHepcZBs2PeUpD+dbvEqH8eYgPqmfVTpsqxLgsw6RDt901+bPmlwZBSdPtJI3opTlU1kxj09/1fwH3uP+tkWRd0opx34Z/cGF8MvCPxt4HScKcf5S06vWD4qkc62PZCgP+ZQUPhoWxwBx46qf+C79F0GF/1KNq9o4pH0RdCnsO6qdCzHylP3I037LU1u/0uIO9zbERNBrQ9paG8s9A/hyL03Mw+vi/a5bIhavi/e7bolYvC6u6YDXKT+07a2/Toc/uK2bRtZ03wM0P9y61sYs0YOj+wDR8fqwS5NBb/tciL4v/LMkq6++r7Uj6gdte0UQb2PYxlHPG25U6so2f0OCTGzzGi/NJoROswntqaSj+3AM3fUKHWOI/eLzLz6lQmg/2sJwsdrfvUbnKxgued5FktpmeRec790a2lpO3G6NC7l72AJrWHdk8A6updhp8Ed9rKtoz1HcU3DZSXL+Kfj559+frO65vV7df/veuz7euOdAY9/+MYLdESGO/OYNqsIKcYIYcV0aobxrKB8fR2kpzcYINKkLMS0R/ku1MSLp0T27iRsUWXNKHm5SiRqublD4aFhiK9rLW/xRkX5f3tqqyDxsm0C3Uh6GB2gfnCw3yy6/vNWhWexmWWwrDsG2Af09YXfeVVDuaiqHh9UJPh6eJXR4YOk2wrgM8q6ivMshbzvgn20RTisy8uFckufSqHIv7nCuqyKwog7nknYeJ/pvtSo9GfTqzc5mO4dzxYWiV3vinXaMYRtCeUTurJLn43CutIcDCb22aTfucC4/YaB+OBduKnVpDPKuprxxyMPQjQ/n8nSIXDGN/pF/Tsnjw7n6PehJOyRxUCz0BxZYKxaJJYdz4TRPfI7mM/kwln59Jpa/KobP2gH5rFX4+PWpxRnNp0rSfBgfxnJNRP05aWO91Knfw1i0MXs66NUTH8bS72G1E4qs0h5+lhiKs6zzQKm/dgCZ5KFPRj1x0tpD6tTvYSxanOR3PC5WtPlmEKOL7ZSH8xY+jAXn0/3Gr1Lffg9jQXu6lvKuVsoO64tSfto7/kUpbYzQbIDHW8xD/WMe8rlW4aNhXdS61l5AZZ/U7wuoE4rMw3aAI/skXIrs98BAPMBxsS+g8trDsOiJly/R7/CcWjskbzE67GdOrR2COUyHLqIuWE/u+kq45pS0zBsu0nfzYQzaErD2ChHHqP36n3VKPTQ+awfkszYln6sG5HNVDB/MY3/ab8w9ocis8dk+IB/tAwvD1Je0GGnYDjDF9uB+tl0p6/mFzNQxEr+Q6WcuF/9CpjbP0cYkKasdps19epCDuTlG8t2n306HKqN9cErqT88uch49rIcq85q5tsXH2if1EyNhW/Ejd1xPl3sY2/OhcUJ/XStwcTZyzZXd/LYBD3xmcDvRXaXIPaz+8Co/8sT6Q81/9OsPx+F6UH/I65doV3xoUb/rWBsVPsPWz/nQIvSH/a5jLdYfan357RSjDYM/1MYUttu0/lDoP9jybZ79l3poEa/FLceZ/uNMfgV4EL8aN6fjQ4v6jTMvVvgMm7/gQ4uW48x3TpyZNiZM63/50Dihvwvi0T0RcSbK4eh+6UpdfqF1adlv2vpNy3hU2lL7OCfHo9sUPtti+GxU+Lyd4tGl8puo82H1m9so7+00PxfZ0/pDoX96iOLRbUr9/e5RSO9Xeb/bNj/yFLS2i/ND2rNhKas9z+V4dJBnw3HzfI5H+53nX6zw8bxfpe99GByPamNOWp+A+1UWO88X2YZNT3H7VdivDrJfBXX4zUWOTeyTLGJCT74r9SGa7Lt8x4Sa79L6+uIP0cTdBlxbthamkeukQzSvSagFvziJrZzGyyIWvyyM5flFuusSsPhlYSzPn02R3+NBr5x8aF8cDvdcTS4+RBO9ZZpDRxGLD9Hs99BRxOJDNJfq0NEbE+TiQzRvgPJpDgpFLD5EUzvgU7DyCVh8iCaW58NG5De/eO4S6ysOx/0rJMjFh2j2+/I+YvEhmv2+vI9YfIjmhTx0FOXiQzS1wxS4XJQvQ9+g9V08nEGzVWx7rPOUco9HV0+HVqY+RFP4Z4PedvExumoHaGgHaonuZhVZc0oe7xrVDoedVfhoWNcYYm03xLrOEGunIda1hlg3GGLdaIhVNsTKG2IVDLHEj2mxFx+i2e/MG8vzTA/b3M7nlMriQ3AskSR5M0odNd+DfpGTNpuTOrnZXD+HaKLORTbRE9rzhdQTzzLRvvgQTTyYs98ZsdS330M00Z5mKO9apaxf/aZfpRP+2aDXFnyMxVoMr/Vh0d1Niqw5JY99eFzMhHw0LInrtHkEH6J5g8Lnhhg+mxWZ/dpCscm6xCR52kGhkof+Hu2DU1J/6meVDnXOh40Oi55uoDycb/EqHcabg/ikflbpsK3ygM86RDo8RFObP2tyZRScG4hW8kaUsnyIJubxIZqa/8B73N+2KPJOKeXYL3s6+Cy1Xxb+2cDrOFGI85eaXrV+cBPpXOsjGcpDPnGHDiMWxwBx46qf+C79oWTCf6nGVW0cijtE06d9R7XzjTHyeDoktn0ag7Z+pcUdeIgm2pC21sZyFwFf7qWJeXhdvN91S8TidfF+1y0Ri9fFNR3wOuVnr3rrr9PhB6/qppE13Y8Azc2ta23MEj04uk8THa8PuzSsB+h6Ovks9gBd7XA/PEQzysawjaOeN2gHnbLN70yQiW1e46XZBH4mmm1iG9BdC3Q/E0N3nULHGNohmtsoT2i/0MJwsRoforkt6MZ3yfMuktQ2y7vgtvmRJ3YXHOpnsbvgeE12kF1wljuRh3VHxjbKW4qdBv0coqk9R1nEIZrbIsSR33xwpbAa5BDN7ZSf9hDNuI0RaFIXYloi/JdqY0TSo3t2EzsVWXNK3lVwHTVcaV+217DiXlDnQzSvUvhcFcNnqyLzsG0C5UM0l18yeOe9ZIB+kA/RxEMu+QDEpEMuxwn/51v3pe22QXnDxw91thvhgby3e+Kd1tfyJkDtEAnNDw9ymGSxsVCbrVabpVozX6s2G5mg1+fG+WGh1za0bVLo/R4UVqqK3eNhkrwVbgzytlPeOOTh4V58mKSfcK5UTaN/5J9T6O8NO3T9tGVO4cOHNqbFkkMb0U9L39Z8DPdFP34gfdwj/LMkq6+4Z1vQq9cxRa9xm261w3T4JaF+4xHEEr+/1C8JoQyG43lZi78lSd4OpY6Sxwf6yjUnbcyWOg3ykhAfCDcseuJ+rh1Oq01b+417UIf9xD3YVnwo2zalrF/9pvdJHAN48pGFOF+h9eG4eEUbU66E60HHJ2nL6aC3bfkFmzGFz1gMn4sVPsPW1/gFG/RJaB+cLH2S1p+GTU9jlDdsPknz6yz7uEJ7BeUJ7b+BRy6rWkrS+sjqoDvvCshbBdfIF7cMCL1Ld4S6nP8elshv3aFjjkRgYtu4hHE99kmXxiDPztZqBSf317d05GDfOB5210nzZ1qMJfRxLwOhjnJBr12zL9V83Da4J49hNH3iepNLY5DnW58oI+vzyoQ6sT41/aOeREfaeHIZYV2mYKGO4/QpMl4IfaKMafSpjYNxcQDqU3SkzRkuJyxNn1fAvQ+RrFJ+QqFHvHGiX9lqVKebN7Z0y7cayrMtrFKw0YfG9bOsUo8pysOyDvevL+vcd2lF2I375l+4Nw64b9YP6SlvEvLGwm4+2dbvMeCDWCLHONFvgrHkzTpAGSmfU/hPEP8uuZV7aIOMNarcE3qn07UtGV1bZglH9L+79TvfZ2oslOcrC/O1mXw9P1+YL/FL+yiL4+/s72xrf2XcukdGwRmNwc4pWLLuI7EXHoxpOD8oCv4Kks8IvyB6Gg969SS8V3qpW7OZph2Qf5ZkNdZ1ey62kuRh/fD66qQf/TTclhKxPeyjE4puWI4VJGPWk4zaWCwyaWvAIoejWX9tt4wjnmT020eb7ecdOEe5O3zrr+NZoPFM2gZje7T7EchH+tntHcwyzTPY57q0CvJXKPnyW9prRKHlNekVpENNr0gvNjkRUdcJqqvQ/xDEFN/bomOi/lCukQjM9wDmq4SJ8URcnxf6VQo99jGRZzro7ZurqBzKPhl0J7yntU+GaHkMxucTK4h2RQQf1ocmw0oFh8dJxmSebA8ucSw3qvDBPoVj/qTC33B8mNHGSkmSxwdsYx7W/fNhh46TttYhdXL13bq9g8t0LI/W1yxjI7k/DveZ7yjRThAtPzdBGccNZMwpfCYId0WM/BnCGVPKTQV6f9T+ppU3o8irjTWD8kGsL4TdfLCdcUxr0JiGfnxUKfto2MlH+jtgTPtSyjGNfQnW4Yth5x77bI5juU/yfJjHLqbBcRzp9ypjF/sHxHL37kkRI2hxH8cIz4A+95M+tRhgOujVDdvwJPHC+FjGF9bBIyDHg9ujeYlep2Lq6O49ul2nQxmQjjG0sVMwtH4t5aYVubjvse+YiOGhjWcaj3HKG7R9tHEbYw0thtHycTxHPnxvRKFPij+yEdga7oSCo/n5lZSXUfLYh2F90YdxbKLNydA3av0uqu3iYm9N9jRx1USM7Jr+0A9Zr+Xk5/KFfK0y02wW6rPVhXLSWo41/+LM/Fx1fiFfKDaLxdLc7FLzny3PFubmqnO12VpzvlxbWGr+tfnZ5nyptFAozdcb84Ulr3+jXFpoFprn1/NKzXxprrDU/Geq+WKjXFhYmCk0qvPzzX7WEjX/jGMF9iG8j/1Pnm3yeP3LtNfNz1qbfuBpmjFOq5/mXz4RUb+/D3HAr21P5hfnM7WxcITy0C9yG4lNaTGVVgeh/y1l3UBb98I1N5fGwu767W7dzw+WytozKJyvj4fd9Y5bq3CJ4+TVCj0+q+GYBp/x8FxuXMHSxiW2s4lAj3sFj+3sD2OeQaHNZ0l2rDvHCqMK37g1Difnv6D+7Om5QEVbU5A0FejxDeZhP+G9RbxWjHloB/3uwxNdOLn+PMUahuYn2Bdo636an8A9KW/KF/bKdSH6LcbY3G+1NUmkl76TC3rbje1Vix21PsAx52gMP22+hH0g6pkc+gRcU/hXKdYUsCz7a6H/7zDm/Fsac9A/sb1ofoZlCQLdj6VZa9LmrtIu2nM+y7XLDPGTeuA95J8NvPqvAvt71GvcszZP8VFZ5NHmvFo7u2dza4LeNtPm17jOysfOamufmm/j+EjzbVpfZz+gzVnj1ibi+jo+X0oTO2r9mPt5l03seOuPy794R3f9kV/UOl8QxLdhXJujfnktRnteE7dOE+fPV8bIlfSMieXSnjEFCu+kOsTZnRZfX8AxdUYbU7HuPKbGxbYucRtMKfRavJsjetR53NqT1i9XUV7afolx6MW091Mbv9DP8vqQ1j9xjMZxPUOyIA9cP5OjhzPEY0KhR7xxor98R0eGN7bomOJrXHok7MVkmfE+6oXn7UJ3FchwzbVvXad518rT3pXU7z2295gp+vAxvmvzP23/o+f5Ui2uH2hxH8+vuO2wD0ftQ+DnnDg2oN/ndftCy7ZyhOmSnHOQUfK0Z1q4V2/Xju66+Xq2yvv/o/bFzJKPwv6u7Q0Q/8F98QchTpinOEGz/VVBvM/S9uKw/UTtZ2GfJfTvifFZ2jwH5Xok1DF/FDB5P4tmF1r7sS27pNkyPy/UntNp7zxgf3oTO+zF9Bwj1LUYAfXDMUKcLlzqN34U+8gRPepR60e8Bhpnqy7F7Z3BfdDS78zX+AuFQnO2vDA3Wyvmm/XaUq/xl5uV6myzkp8p1suNYr26mP3CUWsTn42Ip/pdm7gHfNXnyFctr0101wPvIf/ltYnltQnMuxBrEwegH59eXpvowtDkWl6b6K07xx3vlrWJ057WJj7rKa5plouNxsxceWHh/FWhXugnrsgE3brAOmaUOoota7FbHNZIDFYmBms8AYuPvI2K7bkcxw6e1j1SH8HJ6x5+3jWJX/dA/fAzVy2+ywXJ41e/sZ/2LNUCi+f8iB3VN7TxFnUUEB/eL+7Sx8O3/vp9zym/oPnvgOq8WpE5o9CPKnXE96J+A+YkTMc8UXerKQ/HyinKw1hgDeXhODpNedr8IE0fdCnOfsYj6mXBR5tTa+sAg/LRYm3WtwUfLY7XYiDu33H7eTU+GYWPtsaN8+S/u0PnGbW2xfNkof9nEF//0Y5uGtHR/wg0/2vrelKR3dAPzGv7NgLSDfognl/j/hm2efQfbKcYu7FtrQEZ8H0vTprfETqH+Scp/I6ma09j6VDpOq0+RReu3GraKxgoWNp4KXXCdeq4foR8uR/9OfSR/0x9U5vzaX5H7ifN+XiNWJvzDes4rbU928wayGObmYY87p94tD3qhFNSXJC2f/7nCB8sPNgH8/wqat72d+F5g8/5zXgCVpo5SRxW2rnS8vymJ72t5jdjhlgZqg/qPmnun2TPbINxc2wst0Q2mHp9nm0w40eeQlq9LtYGLe1m2LEs3wXPRciJfKL2Amy9uruMlIvaC8DzBqHfdnUH8/LWddr3ibmezJPfVdD0r/lAoY97Rw95ac9f4t4VjXoXCXWHdZPnPPxM47qWvpLec7mQ6+dL+dxedKY9t2f/EXcmwKiCiTa/vCa2vCa2vCam/03LZ5jXxD52tc4zak2M/bPQ74Gx7daru2lER58EmmrrenlNrEPHyWpNjHW9vCbWoRm2NbG90EcOUt9cXhN7Z66JHYzwwcKDfXDaNbGPKTGc0OG7CGiPLsk+bp6/vOeaDvYx8vGC9wTY7/Gru+XEen8q7M7T9iW5ez/U4qn5Lvdvd+t3fqBUqcbFMX73GJZraeIK5L9UZ42m3WOoxai83wbjqeNhh47zRpV7IzFYZw2xzhlinTbEOmSI9bQh1glDrJcMsSz1ZVlHK7k0PzgstvqiIZZl37a0iecNsZb917L/8llHS92fNMSytPuXDbEs+/aw9kdLHz2sY61lO54yxHo3jEPvhjpaymXpV4d13A4NsSzlstTXVwyxzhhiWcYmwzqmLffHC1fHYR233w3zNEubeMIQa1jt/gVDrGFd63jFEMunjxZafLYhZxq5dE/rmp9RzNMzAU/r8vW4vQB+v69VTn1mEj/n187Azyp5g7xzulBolhr5hYVycaE+Mzs7myF8kZXv8Zpl2u8aia5X+dH1graPLAt6dWkM8iYpbxzyREan+zXbu+X38wy1vJBG/8g/p9Dz2U1p23Jd0G1r2B+15357w+68CUUGfO4Xt09Ne/6J71y//5qOrFiO7Uzb78h79Ucj7uN1hu4jX+T36bC7HD9zZFm4vqOKnJouRhRdaPsXRgkD+ynuRXVt/A7bP95I62eHdf+457Pp6myPKE/cfsALcTbdT7dsXNvfF7UPOVBkEN5BS5ZPUN+50PvRv3hNdxkpF7Ufnc+mE/oG7Oeota6X96N3143PtxP6L7f05WxvCPajN5wc7+T96F8EfS/vR++t4/J+dL1eFnyW96NH+wDr/ehnr9F5Ru1HZ/8s9L8CY9tL13TTiI5eBppv0JoCym7oB5b3owe9ul7ej96hGbb96L8GfeT3qW8u70d/Z+5H//0IHyw82Aen3Y8uvt36DLxKsTZTLc3M52uNmUp1ttLPGXjLMWSHZjmG1OtlwWc5hoz2JdYx5L/qM4aMOucruLaD+W8jYsh/B+PjXy7HkG+mpYgh/3I5hnwzvR1iyFHoR2uv7dAjnyBYjiHfSTEkt7NVDPmvoN+/eS/s0Bm2YVHqMx52ZBbdjIUduSdAbpdWQp7QiayTfmTNi6zZFr70T+SJdRkher4ep3tXQ1tiHaUeeA/xhX4V5An9KNwTGcV+JyBvVdgf1krCWjEAlsiVU+hXLFIuDWuCsCYVLLyHz6Y2tdrGxzdLqpXGfHm2VKyVmvPVufxc0rzq/wfvokIWvmcGAA==",
      "debug_symbols": "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DWwD28A2sA1sA9vANrANbAPbxDaxTWwT28Q2sU1sE9vENsPmkygXFrCCDeyggAoaOEBsBVvBVrAVbAVbwVawFWwFW8FWsVVsFVvFVrFVbBVbxVaxkSVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZomSJkiVKlihZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGlhhZYmSJkSVGltjZ6OLYwA76TTgnDbKgETQvGuedTKcSVINaUA+SIA2yoBEUjhKOEo4SjrOtzbGDAvomnI4GHpvQb8n77MkLva0vLGAFG9hBARU0EFvF1rA1bN7WPkPAZ08u7KCAChroNt863tYneltf6MO4TjWoBfUgCdIgr3gcLv5iyu6zFnxaZPdJCT4tcqGACvqS+l7wJr1wBnqTXlhAv9Hl1IIOl99S8EmRCxU8XD5m5JMiF85Ab9HzSPIWvfBYs1PhLXphB33NnDTIgkbQXOTdeZJX9M3mP97ndvUf7zYcBzgD/cf7wmNJffKET3Fc2MAOCnjYfPH9t/uk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",
      "brillig_names": [
        "get_htlc_public"
      ]
    },
    {
      "name": "is_contract_initialized",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "boolean"
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "is_contract_initialized"
      ]
    },
    {
      "name": "lock_private_solver",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock_high",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "hashlock_low",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "ownership_hash_high",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "ownership_hash_low",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "randomness",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "src_asset",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 90
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::include_by_timestamp::IncludeByTimestamp",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                          "fields": [
                            {
                              "name": "recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "content",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6418028854678020178": {
            "error_kind": "string",
            "string": "FundsNotSent"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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ZZ5b5rllnlvmuWWeW+a5ZZ5b5rllnlvmuWWeW+a5ZZ5b5rllnlvmuWWeW+a5ZZ5b5rllnlvmuWWeW+a5ZZ5b5rllnlvmuWWeW+a5ZZ5b5rllnlvmuWWeW+a5ZZ5b5rllnnvmuWeee+a5Z5575rlnnnvmuWeee+a5Z5575rlnnnvmuWeee+a5Z5575rlnnnvmuWeee+a5Z5575rlnnkfxV/UgTbIkT6pJbVLkeaeSREmclBqcGpwanBqR5zWoTYo871SSKImTJEmTLMmTUkNSQ1NDU0NTQ1NDU0NTQ1NDU0NTQ1PDUsNSw1LDUsNSw1LDUsNSw1LDUsNTw1PDU8NTw1PDU8NTw1PDU8NTo6ZGTY2aGjU1amrU1KipUVOjpkZNjZYaLTVaarTUaKnRUqOlRkuNlhp3njf6h/uT3yupJD00mgRxkiRpkiV5Uk1qk+48H1SSUqOkRkmNkholNUpqlNQoqUGpQalBqUGpQalBqUGpQalBqUGpwanBqcGpwanBqcGpwanBqcGpwakhqSGpIakhqSGpIakhqSGpIakhqaGpoamhqaGpoamhqaGpoamhqaGpYalhqWGpYalhqWGpYalhqWGpYanhqeGp4anhqeGp4anhqeGp4anhqVFTo6ZGTY2aGjU1amrU1KipUVOjpkZLjZYaLTVaarTUaKnRUqOlRkuNNjWiWG1QSaIkTpIkTbIkT6pJqZF53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53jLPW+Z5yzxvmect87xlnrfM85Z53mae0zXznK6Z53TNPKdr5jldM8/pmnlO18xzumae0zXznK4rNUpqlNQoqVFSo6RGSY2SGiU1SmqU1KDUoNSg1KDUoNSg1KDUoNSg1KDU4NTg1ODU4NTg1ODU4NTg1ODU4NSQ1JDUkNSQ1JDUkNSQ1JDUkNSQ1NDU0NTQ1NDU0NTQ1NDU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avSq0atGrxq9aok3ub70qtGrRq9a4k289KrRq0avGr1q9KrRq0avGuerxvmq0atGrxq9apyvGuerRq8avWr0qtGrRq8avWr0qg28g+tLrxq9avSqDbwDL71q9KrRq0avGr1q9KrRqzbxTq4vvWr0qtGrNvEuvPSq0atGrxq9avSq0atGr9rCu+717fSq06tOr/rnevsn4QZ3eMATvuvt9KrTq17wlgon3OAO4y146VWnV51edXrV6VWnV51e9cAbA54w+0yvesVb8dKrTq86ver0qtOrTq86veqJN7m+9KrTq06veuJNvPSq06tOrzq96vSq06tOr3rD27i+9KrTq06vOp8HO58HO73q9KrTq06vOr3q9KrTq97xdq4vver0qtOrzufBPvDSq06vOr3q9KrTq06vOr3qE+/k+tKrTq86vep8HuwTL73q9KrTq06vOr3q9KrTq77wLq4vver0atCrwefB8Qm4wgk3uMMDnvBd7yh4S4EDrnDCeAteejXo1aBXg14NejXo1aBXI/BGgzs84AnjrXjp1aBXg14NejXo1aBXg16NirdyfenVoFeDXg0+D47ES68GvRr0atCrQa8GvRr0ajS8jetLrwa9GvRq8Hlw0KvB+Wpwvhr0avB5cHS83L8a9GrQq0GvBuer8fTqe+/0jH6fe25n9vvlgCuccIM7POAJ3/uEZwj8ZbwT78Q78U68E+/EO/FOvAvvwrvwLrwL78K78C68C++63jMY/nKBA67wvb6T+1eT+1eTXk16NenV5Hw1OV9NejXp1aRXk15NejXp1aRXk15NejXp1Qy8gZdeTXo16dXk8+Dk/tWkV5NeTXo16dWkV5NeTXo1K9464Anfn99JryafByf3rya9mvRq0qtJrya9mvRq0qvZ8LYCs8/0atKryefByf2rSa9mw8v5anK+mvRqcr6anK8mvZrcb5/cb5+dfeZ8Nfk8OLl/Nbl/NbnfPjlfTc5Xk/PV5Hw1OV9N7rfPwfWd7PNknzlfTT4PTu5fTe5fTe63T85Xk/PV5Hw1OV9NzleT++1zcX0X+7zYZ85Xk8+Dk/tXk/tXi/vti/PV4ny1OF8tzleL89WiV+sz4AnffV6crxa9Wty/Wty/WtxvX/Rq0atFrxa9WvRqcb99RYEDrnDCeLl/tejVoleLXi16tejVoleLXi3ut6/aYPaZXi16tfg8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+/cMxDPf/vD2zv2aT68e3t55nnPC6/Lp1dr7cHr18NfbPtu7e/Vywg3um2PzgCe8Nn9f85lv/zkdbS7w8c7NFd7e73+oOc58+8sd3t7v35kQZ7795e39/mfZ48y3v1zg7Y392navXt7e2K9t9+rl7f3+lyHizLe/POHt/f5N53Hm21/e3v3ePvPtLfdr2L16OeHtzf16dq9e3t48zznhdXn3qu33/Jlvf3l79/v5zLe/nPD29v06d69e3t6+93b36uXt7Xvtu1cvb2/fz7l79XKFt3fs59+9enl798/FmW9/ecLbO/d7YPfq5e2d+7XtXr28vWvv7e7Vyw3e3rX3effq5e1d27t71T/7OXev+nlv7169jwdc4YQb3OHBc04eX/fx8bmPD7wD76h8Pd6Bd+AdA558L+udeCfeGffrJ+udyeN4Z+dxvJP1TryLfV54F96Fd+FdeBfrXXgX613Xe+bbXy6/v+bMt7+PVx5PHm883nl8wBPGW/AWvAVvqTDegrfgLYPH8Ra8gTcKfPf5zLe/jyePNx7HG3gDb+CteCveynor3sp6K95631dnvv19HG+9P0dnvv15PPEm3uT6Jt5kn5P1Jt6cfA3rbff9fObb38fZ58Z6G97GehvehrfhpVezs97O+4peTXo16dWkV5NezY634+146dWkV5NeTXo16dWkV3NwfenVpFeTXk16NSfrnXgn3omXXk16NenVnHjp1Vx4F96Fl17NhZdeTXo16dVcvJ/XfT8verXo1aJX61PhhBvc4QFPGC+9WqXAwdfgpVeLXi16tejVoleLXi16tejVCtYb9/quwEuvVnS+hvXG5HG89f78Lnq16NWqeOnVolerst7KeunVqngTL71a9Gol+0yvVuKlVyvxJt7k+jb2mV6threxXnq1GteXXq2Gt+FteOnVoleLXi16tXryNayXXi16tThfLXq1BvtMrxa9WgPvwEuvFuerRa/WwEuv1sTL+Wpxvlqcrxbnq0WvFr1a9Gpxvlr0anG+WpyvFuerRa8WvVqL60uv1uL60qt1e1U/t1f18ylwwJWvTx5vcOdrBo9PHl/38fK5jxe8Be/tVf0UvAVvwVvw3l7VT8EbeANv4A28gTca39t5HG+w3sBb2eeKt+KteGve56mst7LeirfirXiT9SbeDB7Hm6w38SbrTbyJN/E2vA1vw9vwNtbb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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "notify_created_nullifier_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "random",
        "decompose_hint",
        "lte_hint",
        "field_less_than",
        "build_msg_block",
        "attach_len_to_msg_block",
        "get_random_bytes",
        "get_random_bytes",
        "get_app_tag_as_sender",
        "increment_app_tagging_secret_index_as_sender_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "lock_public_solver",
      "is_unconstrained": true,
      "custom_attributes": [
        "internal",
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "hashlock",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "ownership_hash",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "timelock",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 64
            },
            "visibility": "private"
          },
          {
            "name": "src_asset",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_chain",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_asset",
            "type": {
              "kind": "string",
              "length": 30
            },
            "visibility": "private"
          },
          {
            "name": "dst_address",
            "type": {
              "kind": "string",
              "length": 90
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "10870837545714573535": {
            "error_kind": "string",
            "string": "HTLCAlreadyExists"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "15001264570739363109": {
            "error_kind": "string",
            "string": "Function lock_public_solver can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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AgACgAMuAgANgAQuAgAMgAUlAAAIiy0KCwIoAgADBIB4JwIMBCAtCAELJwINBCEACAENAScDCwQBACILAg0uAgADgAMuAgANgAQuAgAMgAUlAAAIiy0KCwMuCICYAAQuCICZAAUuCICaAAYoAgAHBICbJwIMBB4tCAELJwINBB8ACAENAScDCwQBACILAg0uAgAHgAMuAgANgAQuAgAMgAUlAAAIiy0KCwcoAgAIBIC5JwIMBB4tCAELJwINBB8ACAENAScDCwQBACILAg0uAgAIgAMuAgANgAQuAgAMgAUlAAAIiy0KCwgoAgAJBIDXJwIMBB4tCAELJwINBB8ACAENAScDCwQBACILAg0uAgAJgAMuAgANgAQuAgAMgAUlAAAIiy0KCwkoAgAKBID1JwIMBFotCAELJwINBFsACAENAScDCwQBACILAg0uAgAKgAMuAgANgAQuAgAMgAUlAAAIiy0KCwolAAAI0SUAAAleKAIAAQSBTycCAgQAOw4AAgABAQCAA4AFgAcuAIADgAguAIAEgAkLAIAIgAeACiQAgAoAAAjQLgGACIAGLgSABoAJAQCACAACgAgBAIAJAAKACSMAAAifJigAgEMAAQAoAIBEBAADKACARQEAACgAgEYEAAAoAIBHBgAAKACASAAAACgAgEkBAAEoAIBKBAABKACASwAAASgAgEwEAAIoAIBNBAAEKACATgQABigAgE8EAAcoAIBQBAAIKACAUQQACSgAgFIEAAooAIBTBAALKACAVAQAFygAgFUEAB4oAIBWBAAgJiUAACHQHgIADAAeAgANADMqAAwADQAOJAIADgAACYIlAAAh+R4CAAwBHgIADQAKKgwNDiQCAA4AAAmeJQAAIgsnAgwAAi0IAQ0nAg4EAwAIAQ4BJwMNBAEAIg0CDi0KDg8tDgwPACIPAg8tDgEPJwIPBBAtCAAQLQoNES4IgEwAEi4IgEUAEwAIAA8AJQAAIh0tAgAALQoRDgsiAA6ASAAPCyIAD4BFABAkAgAQAAAKFCUAACPrHgIADwYnAhEEEi0IABIuCIBFABMuCIBIABQtCgwVLQoOFgAIABEAJQAAI/0tAgAALQoTEC0IAQ4AAAECAS0OEA4tCAEQAAABAgEuDIBGABAtCAERJwISBBgACAESAScDEQQBACIRAhInAhMEFwAqExITLQoSFAwq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",
      "debug_symbols": "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",
      "brillig_names": [
        "lock_public_solver"
      ]
    },
    {
      "name": "process_message",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "message_ciphertext",
            "type": {
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec",
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 17,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "message_context",
            "type": {
              "kind": "struct",
              "path": "aztec::messages::processing::message_context::MessageContext",
              "fields": [
                {
                  "name": "tx_hash",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "unique_note_hashes_in_tx",
                  "type": {
                    "kind": "struct",
                    "path": "std::collections::bounded_vec::BoundedVec",
                    "fields": [
                      {
                        "name": "storage",
                        "type": {
                          "kind": "array",
                          "length": 64,
                          "type": {
                            "kind": "field"
                          }
                        }
                      },
                      {
                        "name": "len",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "first_nullifier_in_tx",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "recipient",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "vb3friW5cWf9Ln3ti00yIkjqVQYDQ/ZoBgIEyZDlD/hg+N1nM5jkijrlw8qz9+m5US91V8XKf/ztTJLJ/M/f/tef/uU//s8///mv//tv//7bH/7Hf/72L3//81/+8uf/889/+du//vEff/7bX5//9j9/e4z/SbX+9ofyT89/tt/+oOOf/bc/1Oc/2/M/9/HP9NsfUhqQnzD+Wa5/yvVPff5zVGi2oC5oC/oF/bEgLcgLygJZsCr3Vbmvyn1V7lfl/HgsSAvygrJAFugCW1AXtAWrclqV06qcVuW0KqdVOa3KaVVOq3JaldOqnFflvCrnVTmvynlVzqtyXpXzqpxX5bwql1W5rMplVS6rclmVy6pcVuWyKpdVuazKsirLqiyrsqzKsirLqiyjch1QF7QF/QJ9LEgL8oKyQBboglVZV2UdlduAfoE9FqQFeUFZ8Kyc04Bn5awDbEFd0Bb0C+pjwbNy7gPygrJAFjwrl8cAW1AXjMrjQI3m5zDa34Rn5TIUowFOKAtkgS6wBXVBW9AvGG1wwqrcV+W+KvdVua/KfVXuq3JflftVuTweC9KCvKAskAW6wBbUBW3BqPw8p2W0wQlpQV5QFsgCXWAL6oK2YFXOq3JelfOqnFflvCrnVTmvynlVzqtyXpXLqlxW5bIql1W5rMplVS6rclmVy6pcVmVZlWVVllVZVmVZlWVVllVZVmVZlWVV1lVZV2VdlXVV1lVZV2VdlXVV1lVZV2VblW1VtlXZVmVblW1VtlXZVuXRBuUxoF8w2uCEtCAvKAtkgS6wBXXBqlxX5bYqt6uyjMM7WqWMwytpwPjr/m/agn7BOJgT0oK8oCyQBbrAFqzKuirrqmyrsq3Ktirbqmyrsq3Ktirbqmyrsq3KdVWuq3JdleuqXFfluirXVbmuynVVrqtyW5XbqtxW5bYqt1W5rcptVW6rcluV26rcV+W+KvdVua/KfVXuq3Jflfuq3FflflXWEWhiA9KCvKAskAW64FlZHwPqgragXzACTdOAtOBZWWVAWSALdIEtqAvagn7BCLQJacGqnFflvCrnVXkEmuqAuqAt6BeMQJuQFozKdUBZIAuelW3s6Qi0CXVBW9AvGIE24VnZxvaMQJtQFsiCUXnYR6BNqBeMhqZtwPjr41yMZmX+b55/uI7jPJrVhLagXzCa1YS04FmnjsqjWU2QBbpgVB6u0awmjMp9QL9gNKsJaUFeUBY8K7dx1Y1mNcEW1AXPym0chNGsHEazamMzRrOakBeUBaPyUIxmNcEW1AVtQb9gNKs+pKNZTcgLyoJn5T42YzSrCbZgVB5XwmhWE/oEG21nwvjrOuD5h3sbMG7e8oDnH+7PzbDRUiakBXlBWSALdIEtqAvaglU5r8p5Vc6rcl4b5nfdj8cg21Q3tU19kd96P2RQ2pQ3lU2ySTe5YxwHvwOf1Db1RX4T/hgb6nfhk/Km4UhjW/xGfJJuGg4/xH4vPm7PzW/G09hfvxt38tvxSWlT3lQ2DUcelf2efJJtqpvapr7Ib8wnpU15U9m0HbYdth22HdXrjX2raVPeVDbJJl3kz7Hjt938QXaSVx5npu8t7XtL+9rS6s+c4zmg+kPnpLJJNukm21Q3tU19kT98TtqOtB1pO9J2pO1I25G2wx85sw3yv1sH+d/tg3STbaqb2qa+yK/2SWlT3lQ2bUfZjrIdZTvKdpTtkO2Q7ZDtkO2Q7ZDtkO2Q7ZDtkO3Q7dDt0O3Q7dDt0O3Q7dDt0O3Q7bDtsO2w7bDtsO2w7bDtsO2w7bDtqNtRt6NuR92Ouh11O+p21O2o21G3o21H2462HW072na07Wjb0bajbUfbjr4dfTv6dvTt6NvRt6NvR9+Ovh19OdrjsSltypvKJtmkm2xT3dQ2bUfajrQdaTvSdqTtSNuRtiNtR9qOtB15O/J25O3I27HbedvtvO123nY7b7udt93O227nbbfzttt52+287Xbedjtvu5233c7bbudtt/O223nb7bztdt52O2+7nbfdzttu522387bbedvtvO123nY7b7udt93O227nbbfzttt52+287Xbedjtvu5233c7bbudtt/O223nb7bztdt52O2+7nbfdzttu522387bbedvtvO123nY7b7udt93O227nbbfzttt52+287Xbedjtvu5233c7bbudtt/O223nb7bztdt52O2+7nbfdzttu522387bbedvtvO123nY777ud993O+27nfbfzvtt53+2873bedzvvu5333c77bud9t/O+23nf7bzvdt53O++7nffdzvtu5323877bed/tvO923nc777ud993O+27nfbfzvtt53+2873bedzvvu5333c77bud9t/O+23nf7bzvdt53O++7nffdzvtu5323877bed/tvO92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",
      "brillig_names": [
        "process_message"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "516370165797458160": {
            "error_kind": "string",
            "string": "InvalidTimelock"
          },
          "772057049813214347": {
            "error_kind": "string",
            "string": "HTLCNotExists"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2570651705007895968": {
            "error_kind": "string",
            "string": "HashlockNotMatch"
          },
          "2722406262643068352": {
            "error_kind": "string",
            "string": "HashlockAlreadySet"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3559210201980528457": {
            "error_kind": "string",
            "string": "Function commit_public_user can only be called internally"
          },
          "3564161243949231814": {
            "error_kind": "string",
            "string": "Function refund_public can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6012086182631426650": {
            "error_kind": "string",
            "string": "NotAnOwner"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "9323748002447105156": {
            "error_kind": "string",
            "string": "NotPassedTimelock"
          },
          "10870837545714573535": {
            "error_kind": "string",
            "string": "HTLCAlreadyExists"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "15001264570739363109": {
            "error_kind": "string",
            "string": "Function lock_public_solver can only be called internally"
          },
          "16870384257694633552": {
            "error_kind": "string",
            "string": "Function add_lock_public_user can only be called internally"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17814817983036354427": {
            "error_kind": "string",
            "string": "Function redeem_public can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "redeem_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret_high",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "secret_low",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "ownership_key_high",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "ownership_key_low",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::include_by_timestamp::IncludeByTimestamp",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                          "fields": [
                            {
                              "name": "recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "content",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "load",
        "store_in_execution_cache_oracle_wrapper",
        "directive_integer_quotient",
        "directive_invert",
        "directive_to_radix"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "redeem_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          },
          {
            "name": "ownership_key",
            "type": {
              "kind": "array",
              "length": 32,
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 8
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "772057049813214347": {
            "error_kind": "string",
            "string": "HTLCNotExists"
          },
          "2570651705007895968": {
            "error_kind": "string",
            "string": "HashlockNotMatch"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6012086182631426650": {
            "error_kind": "string",
            "string": "NotAnOwner"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17814817983036354427": {
            "error_kind": "string",
            "string": "Function redeem_public can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "redeem_public"
      ]
    },
    {
      "name": "refund_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::include_by_timestamp::IncludeByTimestamp",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                          "fields": [
                            {
                              "name": "recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "content",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log_hash::LogHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "length",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "length": 20,
            "item_types": []
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "18313900523101689315": {
            "error_kind": "string",
            "string": "Note contract address mismatch."
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/+xdB3wbRdZfW5YTO3GiNJIQShpJSIDTSrIl3x1HOHrvvcoqgSMkkAKEksgJEAhpBEilXu+9997rd7333nvl7puBfdLz89vVynrj7IDn93v2amfmP/95M/Om7Oxsi/O0W9HuOA/En75uURLz/rcqmUnuwX98HWfCdTL3xjL3xjH3Esy9Scy9KUoWk3vTlFTIvenMvUMYvEOZezOZe7OYe7OZNOYw9+Yy9w5j7s3z0sCuxfu/2PufTvZkMqVsquSm3Xwy1duX605muvt6cm7O7c51F1O5dLqUy+SyvX292WSvm0mX3HJ3b7qcfNqNidWwkk25VMEkz7FiPJNJkzy7hs4zRW9obhOVtCGuurz+613Pd2rXY9H9Lu8a4o1Tv8crSSiZEKvdB9dKdJBszrnzBPU5Ua7cXdy2NO5Mw3rA3JvVwyRDepjk6aGN6AC7FmG9tDhm2rIjy7OXwxY3GJPlDHCfSZ5TBHj2pnTi6R6TPA8YOs80vcEZ4MnI0E7xMcYHEAM8Vf2epmS6kgM9A9zm1Dp7P7e4SX17LgUDORNp0DKVNhbzneHp+JPNOXdqzKxRE++dJgn2TjMM9U4zUO/U6gweuZgoSFO9ky0VTprnJEt4xhzDDVi6pztIuNHRnu6gIUw1Dla/D1FyqG64qKcbi/JvshAPFqxsmO+smEHCs9AYYLFQ5dBKjzn2KT2OeM729DLH+z/X+3+Y938eXZDSHqNJZluFFSvYPbhzLVnUmD90nhl6o56lmY2u52ALRCzNAvX7cCULlSxiFjViRAfJ5pxkJXcXCA69jhC2eLRsjkBlcDi6XoiuF5GyOVL9PkrJc5Qk90MvcJiAfkvlp1wJ83VjBglrcCljBeRdwUqbEqy0pnSoOUoZP9BhyhIjnZbjmeEMQRo1eC1wfWTMf+Ejo353K+lRko0NxBspe7myz8nxTHNln0NlPA9dZwLKvlf9fq6S5yl5/jA8dZghaJ+ONrSecXTM/BO9F8hxT3F14QVDmBYeozkpOVbJC/fDgOAYQ9PC42IGCVfBBSsHKD7mmFe6LQtpx8Ts4DlJUJ8HIZ7He5XhBO//id7/k7z/J3v/T/H+n+r9P837f7r3/wzv/5ne/7O8/2d7/8/x/p/r/T/P+3++9/8C7/+F3v+LvP8Xe/8v8f5f6v2/zPt/uff/Cu//ld7/q+jygM5ghdw7ibl3MnPvFObeqcy905h7pzP3zogN3rdyprd8ge+dzcQ9l7l3HnPvfObeBcy9C5l7FzH3LmY4X8JwvpQJd1msNnKEe5cz4a5gwl3JhLsKNVpwo7z/cD/ZnHMvbdQwuP5elzWG5QZ5Xj50gzUI94qhYjEMr2zekFZRrxIczV0ds2MUnx8yTzdL73Ajt6vRCO14dH0Cus6TkVuf+l1QUlRSiplfZjtRcOTdJ1iHyobqkLT+ThLUX0FQf0ss0d/JgvorCurvGuEZDLUNZWQDlqDra9B1idiGa9XvFym5TsnSYbANpwiWzbWCZXO9JXX7VEH9vUhQf8ss0d9pgvq7TlB/yw3bhuuRDViGrpej66XENtygft+oZIWSlcNgG04XLJsbBMtmlSV1+wxB/d0oqL/VlujvTEH9rRDU302GbcMqZANWo+ub0PVKYhtuVr9vUbJGya3DYBvOEiybmwXL5jZL6vbZgvq7RVB/t1uiv3ME9bdGUH93GLYNtyEbcDu6vgNd30psw1r1e51ee1TSPwy24VzBslkrWDbrLanb5wnqb52g/jZYor/zBfVXEdTfnYZtw3pkAzag6zvRdT+xDXep33cr2ajknmGwDRcIls1dgmVzryV1+0JB/d0tqL9NlujvIkH9bRTU332GbcO9yAZsQtf3oet7iG3YrH5vUbJVybZhsA0XC5bNZsGy2W5J3b5EUH9bBPV3v+G6vR3V4fvR9VZ0vY3U7R3q9wNKHlTyEFO3pZ9D7hTTgZvFPKV3/B0jWO67BPPMlfvOGL97dlfMfwflbvV7j5K9SvbFarvm4s7wvKcvueHIJM/dgm22HfF82DN6j3j/H/X+P+b9fzz2dF4WeOGfUL9frOQlSl6q5GVKXq7kFUpeqeRVSl6t5DVKXqvkdUper+QNSt6o5E1K3qzkLUrequRtSt6u5B1K3qnkXUrereQ9St6r5H1K3q/kA0o+qORDSj6s5CNKPqrkY0o+ruQTSj4ZcwZuoNHkZzrDuw3zEWHjCu5TMYOEPxWTx/20oOUyle9Px2oKFsJNDmdle9RQZftMzCDhzxiobJ+NeGXT+f6s5ZXtMUOV7XMxg4Q/Z6CyfT7ilU3n+/MGKpsJrp/2Gob0+P4LMTsb2eOGGtkXYwYJf9FAI/tSxBuZzveXLGlk2hh8wUAj+z/DCwmPoInjo+j68Zj/O/NfVr+/ouSrSr42DItkgr2i+2XBOv91w2XzdVQGX0HXX0XXXyNl8w31+5tKvqXk2zH/V2Wbzbtul/9noL5/R7Csdd67nOF5S+3hmKx9ok4GO5Uzh/30a56gW1jM+K7Sy/eUfF/JD5T8UMmPlPxYyU+U/FTJz5T8XMkvlPxSya+U/FrJb5T8VsnvlPxeyR+U/FHJn5T8WclflPxVyd+U/F3JP5T8U8m/lPxbyX+UPKnbh5L/6UqgKkSLklYlMSVt+PC8Fo8sfWvoe8y97zP3fsDc+yFz70fMvR8z937C3Pspc+9nzL2fM/d+wdz7JXPvV8y9XzP3fsPc+y1z73fMvd8z9/7A3Psjc+9PzL0/M/f+wtz7K3Pvb8y9vzP3/sHc+ydz71/MvX8z9/7D3HuSufdf5t7/mHtPVW5yr4W518rcizH32tpqRhLc4d7/xd7/ZHNugNFstuP4rgCWd15D+XtyWMXvy2H1/kAOy/2hGFbJ/ZEYVsH9sRhWzv2JGFbS/akUVinp/kwKq5B0fy6FlUu6v5DCUm37l0JYJYX1KyGsgsL6tRBWTmH9RghL28LfymCVNNbvZLAKGuv3Mlg5jfUHGayn+o4/imCVnsL6kwhW4SmsP4tg5Z7C+osI1tN97V8lsEpPY/1NAqvwNNbfJbByT2P9QwLLG5v8UwCr6GH9SwCrz8P6twCW95q3+5/msVLe+Mt9snksF7D+2zRWrgxY/2seqw+w9Bi7SSwYr7otTWNlq1itTWN1V7FiTWO5Vay2NjOLInQHUBTmDoAVl8uzqzGkF6r0AuF3YvILd+3CZS29y0vvqsHlnGzOubqc29vk9TjKAj1K1nFdJib0OFpQj5obXZzX5QSL8KPbwp1f16EuOpWMUTK2zdw5lnr32PcMtPF3x80+hGuWn85zh4G69J64mX6sTbjcO9rk8twl2MYF641rS1m8WHBMMa7NTBuOUrvgbGwXsqvjQtrY8eoioWSCkokGbazenft9Azb2vRG3sTrP4w3Y2PdZ0q7HC7bFSYI2VrDeuLaUxUsEbezkNjNtOErtgrOxk5BdnRzSxk5RFwcomapkmkEbq99++IEBG/v+iNtYnecpBmzsByxp11ME2+J0QRsrWG9cW8ripYI29sA2M204Su2Cs7HTkV09MKSNnaEuDlJysJJDDNpY/XbZDw3Y2A9G3MbqPM8wYGM/ZEm7niHYFg8VtLGC9ca1pSxeJmhjZ7aZacNRahecjT0U2dWZIW3sLHUxW8kcJXMN2lj99u6PDNjYD0fcxuo8zzJgYz9iSbueJdgWDxO0sYL1xrWlLF4uaGPntZlpw1FqF5yNPQzZ1Xkhbex8dbFAyeFKFhq0sfp0hB8bsLEfjbiN1Xmeb8DGfsySdj1fsC0uErSxgvXGtaUsXiFoY49oM9OGo9QuOBu7CNnVI0La2CPVxVFKnqMkadDG6tNnfmLAxn484jZW5/lIAzb2E5a06yMF26IraGMF641rS1m8UtDGptrMtOEotQvOxrrIrqZC2ti0usgo6VbSY9DG6tO9fmrAxn4y4jZW5zltwMZ+ypJ2nRZsi1lBGytYb1xbyuJVgjY212amDUepXXA2Novsai6kje1VF89V8jwlzzdoY/XpiT8zYGM/HXEbq/Pca8DGfsaSdt0r2BaPFrSxgvXGtaUsXi1oY1/QZqYNR6ldcDb2aGRXXxDSxh6jdaXkWCUvNGhj9em0PzdgYz8bcRur83yMARv7OUva9TGCbfE4QRsrWG9cW8riNYI29vg2M204Su2Cs7HHIbt6fEgbe4K6OFHJSUpONmhj9enfvzBgYz8fcRur83yCARv7BUva9QmCbfEUQRsrWG9cW8ritYI29tQ2M204Su2Cs7GnILt6akgbe5q6OF3JGUrONGhj9dcVfmnAxn4x4jZW5/k0Azb2S5a069ME2+JZgjZWsN64tpTF6wRt7NltZtpwlNoFZ2PPQnb17JA29hx1ca6S85Scb9DG6q/X/MqAjf2/iNtYnedzDNjYL1vSrs8RbIsXCNpYwXrj2lIWrxe0sRe2mWnDUWoXnI29ANnVC0Pa2IvUxcVKLlFyqUEbq78O9msDNvYrEbexOs8XGbCxX7WkXV8k2BYvE7SxgvXGtaUs3iBoYy9vM9OGo9QuOBt7GbKrl4e0sVeoiyuVXKXkaoM2Vn998TcGbOzXIm5jdZ6vMGBjv25Ju75CsC3mBW2sYL1xbSmLNwra2L42M204Su2Cs7F5ZFf7QtrYgrooKikpKRu0sfrrtr81YGO/EXEbq/NcMGBjv2lJuy4ItsUlgjZWsN64tpTFmwRt7DVtZtpwlNoFZ2OXILt6TUgbe626eJGS65QsNWhj9dfDf2fAxn4r4jZW5/laAzb225a062sF2+L1gjZWsN64tpTFmwVt7LI2M204Su2Cs7HXI7u6LKSNXa4ublByo5IVBm3sW2K17+Bh3GZ1+p2I21id5+UGbOx3LWnXywXb4kpBGytYb1xbyuItgjZ2VZuZNhyldsHZ2JXIrq4KaWNXq4ublNys5BaDNvatsdp3RTFu098ZiLiN1XlebcDGft+Sdr1asC2uEbSxgvXGtaUs3ipoY29tM9OGo9QuOBu7BtnVW0Pa2NvUxe1K7lCy1qCNfVus9p1mjNv0GdgRt7E6z7cZsLE/tKRd3ybYFtcJ2ljBeuPaUhZvE7SxlTYzbThK7YKzseuQXa2EtLH96mK9kg1K7jRoY98eq333HuM2fT5rxG2sznO/ARv7Y0vadb9gW7xL0MYK1hvXlrJ4u6CNvbvNTBuOUrvgbOxdyK7eHdLGblQX9yi5V8kmgzb2HSrdPxuwsT+JuI3Ved5owMb+1JJ2vVGwLd4naGMF641rS1m8Q9DGbm4z04aj1C44G3sfsqubQ9rYLepiq5JtSrYbtLHvVOn+xYCN/VnEbazO8xYDNvbnlrTrLYJt8X5BGytYb1xbyuKdgjZ2R5uZNhyldsHZ2PuRXd0R0sY+oC4eVPKQkp0Gbey7VLp/NWBjfxFxG6vz/IABG/tLS9r1A4JtcZegjRWsN64tZfEuQRu7u81MG45Su+Bs7C5kV3eHtLF71MVeJfuUPGzQxr5bpfs3Azb2VxG3sTrPewzY2F9b0q73CLbFRwRtrGC9cW0pi3cL2thH28y04Si1C87GPoLs6qMhbexj6uJxJU8oebFBG/sele7fDdjY30Tcxuo8P2bAxv7Wknb9mGBbfImgjRWsN64tZfEeQRv70jYzbThK7YKzsS9BdvWlIW3sy9TFy5W8QskrDdrY96p0/2HAxv4u4jZW5/llBmzs7y1p1y8TbIuvErSxgvXGtaUs3itoY1/dZqYNR6ldcDb2VciuvjqkjX2Nunitktcpeb1BG/s+le4/DdjYP0Tcxuo8v8aAjf2jLWfvC7bFNwjaWMF649pSFu8TtLFvbDPThqPULjgb+wZkV98Y0sa+SV28WclblLzVoI19v0r3XwZs7J8ibmN1nt9kwMb+2ZZzSATb4tsEbaxgvXFtKYv3C9rYt7eZacNRahecjX0bsqtvD2lj36Eu3qnkXUrebdDGfkCl+28DNvYvEbexOs/vMGBj/2rLnkzBtvgeQRsrWG9cW8riA4I29r1tZtpwlNoFZ2Pfg+zqe0Pa2Pepi/cr+YCSDxq0sR9U6f7HgI39W8RtrM7z+wzY2L/bMj8VbIsfErSxgvXGtaUsPihoYz/cZqYNR6ldcDb2Q8iufjikjf2Iuvioko8p+bhBG/shle6TBmzsPyJuY3WeP2LAxv7Tknb9EcG2+AlBGytYb1xbyuJDgjb2k21m2nCU2gVnYz+B7OonQ9rYT6mLTyv5jJLPGrSxH9bpGrCx/4q4jdV5/pQBG/tvS9r1pwTb4ucEbaxgvXFtKYsPC9rYz7eZacNRahecjf0csqufD2ljv6AuvqjkS0r+z6CN/YhK938GbOx/Im5jdZ6/YMDGPmlJu/6CYFv8sqCNFaw3ri1l8RFBG/uVNjNtOErtgrOxX0Z29SshbexX1cXXlHxdyTcM2tiPxp5OVHycGHEbq/P8VQP5/p8l7fqrgm3xm4I2VrDeuLaUxUcFbey32sy04Si1C87GfhPZ1W+FtLHfVhffUfJdJd8zaGM/psewBmyN0x5tG6vz/G0D+W5pt6Ndf1uwLX5f0MYK1hvXlrL4mKCN/UGbmTYcpXbB2djvI7v6g5A29ofq4kdKfqzkJwZt7MdVuq0GbE1rxG2szvMPDeQ7Zkm7/qFgW/ypoI0VrDeuLWXxcUEb+7M2M204Su2Cs7E/RXb1ZyFt7M/VxS+U/FLJrwza2E+odGMGbE1bxG2szvPPDeQ7bkm7/rlgW/y1oI0VrDeuLWXxCUEb+5s2M204Su2Cs7G/Rnb1NyFt7G/Vxe+U/F7JHwza2E+qdNsM2Jr2iNtYneffGsj3KEva9W8F2+IfBW2sYL1xbSmLTwra2D+1mWnDUWoXnI39I7KrfwppY/+sLv6i5K9K/oZsLLhW4XIe78jp889tZup2TDjPuwXr9iOCWH8X1J+uN2OdWl+CnXR/Lckb8/1Hm0HC/2iTx/2n5KKooXz/E1kUIdynKpuypVXjZLKy4cabbNKZ5PlIzEyj+Beqt/K7/AVHTZpbzOMIpHVFGeUMj1WSLABcsf/tNaD/6DyZKIB/GbBM/xLumk3lu9VgvpveImVYh8nmnKsr5pMmtjEJd+9gFDRuxcOV1sV/DOnif4Z08b8AXUjU2/8a0EXH/l1OKdTh5+p8/89Avjvbo20HdMf3pAFbKljerqQOdX882uFHn06DOqhXpzCmdLlJ29mqiweMGJPNOfdJQwYRk26Qs1svHc0Z4wNus4ZhTETW9hoZyDS93yYeTQMzpt1MvdT5rTgDXaPlU0/nkuXTisrHTadV2yhm3XKxnO7O9qb63J50T085U8725DLFcncmX8yW3Ew+neotZZNlN1cqZbvThWxPubdY6Cljo+0W0+lMsbev4HanevJ9yVwxnU+WM9l0KpkvprPFYjrX05NPp4s9uXKuN5dK5cvpXLI7m+1N9qTSvSlT5dPqlc9wzjR3G5ppxuJe/bLFgJviFzNgrONxMxUwHjc3q9G6aDOgi3ZDumiPm53VxA3oosuCWU27gXyPi/isZrehWY1gebvjRmY11LnSdhbcKBtnNaMMz2pGGTAM45+Fs5rR8WgamPGGRs2jLZvVdAjOasYJzmpMlU8HmtX4dQpRXo4yydNUB9NpYwfTabiD6TTQwSQMdTBxYZ6SBmyM4GvFkstmkp1VwpAxHBOis2pWp2Pjcp3CgGWzCHVWpspn7DNoCa7LMyLj4sxmj2RzzvXb9CC5i6fpc7wEdwSZKHjQYcwSHTY9G4tHuzx0gxlvYpBgaIkyYXC5dpwhXUwwpIsJBpdrtR4SBnQxKeLLtTrfEwzke7IFy7U679LLtYLl7U4eWa6lzk0Ymk1PNDmbHm/IIE40OJvWnCcaMAxTLFmuHS84A54Uj6aBmWJohjVpGJZrJctnsuBy7WTBGbCp8pm8H2bApl53mOLNgA+wxYCb4jfFgLGeaqjjmmpwVqN1cYABXUwzpItphmc1U03UCwtmNdNM1AELttabmNUIlrc7bWRWQ5071dCsZrqNs5rphmc10w0YhunPwlnNgfFoGpjphkbNB1o2q5khOKuZJjirMVU+M/bDJpRE3Ey7t6WDOcjGDuYgwx3MQQY6mAMt2YQiacAOllyCa49mZ3WgIWN48DBsQjlEcBPK5PZodlamyucQpnyk9wgIbjpxHxM8R+pQQbs+nOdIHWqoE50ZN0h4Zlwed5agYTaV71nxmoKFcIf1HKnHLDlHSnJnG24Us+MGz5GaJTh1xVYdSD8TthbO8RrQ3LiBc6R0Acw2YJlmG35QI5XvVoP5bpbjYRF/2KUr5mEGpljzDE035xl82DXXkC7mG9LFfIMPu7Qe5hnQxcERf9il8z3fQL4PsWAL32EGbKlgebuHjDzsos6dZ2gatcDkWuRhhgziAoNrkZrzAgOG4VBLHnYdJjgoOjweTQNzqKH1qcOH4WGXZPksFHzYdYjg+qGp8lm4H7bwPWZoprnIm2keYYsBN8VvkQFjfaShjutIg7MarYsjDOjiKEO6OMrwrOZIA7qYZcGs5igD+Z4d8VnNY4ZmNYLl7c4emdVQ5x5paFbzHBtnNc8xPKt5jgHDMOdZOKtJxqNpYOYYGjUnLZvVuIKzmtmCsxpT5ePuhy188+Jm2r0tHUzKxg4mZbiDSRnoYOZasoVP0oClJbcDtkezs5pryBimh2ELX0ZwC98h7dHsrEyVT+YZtATX7RmRHm6zR7I55/ptepDcxdP0soDgSNhEwYMOpfeImtJhs1jZiJeHbjBZA4OEnKEBU87gcm2PIV30GtJFr8HlWq2HnIkNORFfrtX57jWQ7wUWLNdmDSzXCpa3u2BkuZY6V9rOgnuuydl01pBBfK7B2bTm/FwDhuFwS5Zrs4KDoufFo2lgDjc0w3reMCzXSpbP8wWXaxcIzoBNlc/z98MM2NTrDkd7M+AX2GLATfE72oCxPsZQx3WMwVmN1sULDOhisSFdLDY8qznGgC4WWTCrWWwg30dYsLXexKxGsLzdI0ZmNdS5xxia1Rxr46zmWMOzmmNN7NZ8Fs5qXhiPpoE50tCo+YWWzWqOE5zVHCE4qzFVPsfth00oubiZdm9LB3O8jR3M8YY7mONNbIG3ZBOKpAE7QRBLctlMsrM6ypAxPGEYNqGcKLgJZUF7NDsrU+VzosEVkM+rRL4Uk7dBJxleBZOwPScxey2SzTnJfsg9SdCmnRzx8tBnCp5soC88RXiPifT+Jr0KI8nxEQ/Pka3XRlagHvW4Spf5qYJ1fTjPnjvV0MD7tLhBwqfF5XFPFzR8pvJ9+rO8kZ1haDYrbWAl69KZEe9MdqiyluSoy/jMYarnzeb9stjTbVL6cYZk/TnL0o7pckPnP54dN0j4bAMd0zkR75h0vs+xpGPSDfYsAx3TuRHff6HL51wDhuoswbp5XsRni1dYYOzPt9TYX2nI2F8QN0j4AgPG/sKIG3ud7wstMfa6wZ5vwNhfFHFjr8vnIgOG6nzBunlxxHV4fMye2fYJFnE90SKuJ1nE9WSLuJ5iEddTLeJ6mkVcT7eI6xkWcT3TIq5nWcT1bIu4nmMR13Mt4nqeRVzPt4jrBRZxvdAirhdZxPVii7heYhHXS20aDyie5xlYr7kk4msNunwuMZDv0yOeb72edLGBfF9qQXlf+iws76sM2SL9oGKcw79PIb0GOkWwvK4a+kOPQdv8mayLYWO9XuaV3+Vxr4LAfuHLvAqN712OKiS4Rl9IqkfWVIE0iJWkb2NeJrhYfnlctqKYeNBymQGDdkXEnwhP8eq99H5uyTotWQ+vFNzmhe0ExpXennaVVzeleGusKw2UeRO2J7CcmtafoXfcMK6JbXmXGXgAeplgGV1twW4XEzq8QlCHeWEdyua1L3OFsO3Rmy90nqXekyuVtcsUJcoEsCTze5WgHeuLy5Wrg5x0fyXZXxeEt45Ljxt1mRQMjBuLhvoswOUmnNK2Q9eDy+R2xbm6v9E7daXOea62d0O2Yz/WAZeWhcM4GeyBk+uSN7ku08l1iZlclwMGUMnm3FNbuq820DB7I308lWp0hiayNw7T6TvPhsbcLNaKaB5UMWgBqSSY57LgQECwDbuC7cJtolwHGfwwHbxE+5CeUHIdfLIp97RNFMMSrIfNDPLKA1ym4DBOpi4N7OCXeEbiGtrBL2E6+GuY1XNpI7NE0MhcEzczUJDsfPdn58FVOumBm55NlQwMYK6Nm+k0pWfPkvX5RRGfPesyeZGBFbprBXV4XcQfSeu8XmegvSyNSw0UyuXhfA9vqfDKCbjr4wYJXx+Xx10m2AhM5XtZvKZgIVwjXAseV+lGtjzij1Ag39IGuiBYN2+I+COUy4QfocDK1rNlGfRG4cce0rNgE4/IroibWY6XKpMVkW5zT8+sBW2rq23MjQbs/0pBPdq6h/BSC/cQrvLGLavpKsgqZhVktWV7CC8V3EO4StDorI7LVhTxk3kUvxUGjMTiiH8RRQ/mVhrI97ER+eBDHSfa9m4S7LQE6417bMTroLYzNxmogzcb2odxs8G9g9p+rzKwv/PSmGx5SeX3FkEsXEa3WNZvr3mW2A5w0ivvknXy1oivvOu6cqsBe3mbIXt5W8C+Nb/6kGzOuZJ25TbhsSt1UthYr7d7k5w76CTndmaSc8cwGEtTBdLsJOd2QV53CFaURhqLZCecbM65NjaWtV5jWUcby1qmsawL0ViiWiDNNpa1go1lXcRXBHQPe7uBXrZiyV4GybLuj/iISpdJv4FHZRVBHa6P+F4Gndf1BtrLBkv3MmwwtJfhzrhBwnca2MtwV8T3Muh83xWvKVgI11indJeBRnZ3xPcyQL6lDfStgnVzY8Sfq+pB5UbhgeXdBuriPcKGc6JTG6Dr32PUSP6/3vVsn+sDvGuId6/itEnJfUo2x5++3+bUJgZ+brFMPlItzuCZoLRtmR2Trb+2cDTB814Tg3xd4Tqc2i58x5E3Enod9ZyYrIE9EbUQcaU4ctiZZDJX6s4VrasYBngebUlDi8lhDVgS2uI1sq10SUh7zHQGOulGuEVwVLJNsMfHetjm6UEbpU5neKZUWw1MqVoQz+1Q2EFDBh0Irsei+11kyHC/CrdDyQNKHozX7puqNFsFK839w2SlmuX5kADP3rz+cHYpY6JM9KcxJJ8mnh2r7VKT1ONOw0PuyaidPITaz050PZ+0n13Kb7eSPUr2Mu1HeofEdsFy2iXYFvcZLpt9qAx2o+s96HpvfGDZPKx+P6LkUSWPoenQGGdYpkPpoGlXs2lgewA6EuTu7jRgW6U5bo8Pj/1PNufchw3xrDrpDmGboGF43NDI7nE0smt1BhrekemmPZVYmuc2S3hKTgkdzkk/aZXM/AJDmZfOc4tgng+3JM+tgnleaEmeBRuju2iY8pxszrlHCOpvnCXrcEc6dvA8yhKez7GEZ1KwrmsMafujB5g3C+8Nv8fAJglXuLylbdqRyg6lBI8L01i9MXmeKcG6c2TMjv4mLZjnGZb0NxnHDp7dlvDssYRn1hKeOUt49lrC87mW8HyeJTyfbwnPoy3h+QJLeB5jCc/FlvA81hKeL7SE53GW8DzeEp4nWMLzREt4nmQJz5Mt4XmKJTxPtYTnaZbwPN0SnmdYwvNMS3ieZQnPsy3heY4hnlF+3nvuMOU52ZxzzxPU30RL1mXPd+zgeYElPC+0hOdFlvC82BKel1jC81JLeF5mCc/LLeF5hSU8r7SE51WW8LzaEp55S3j2WcKzYAnPoiU8S5bwLFvCc4klPK+xhOe1lvB8kSU8r7OE51JLeF5vCc9llvBcbgnPGyzheaMlPFdYwnOlJTxXWcJztSU8b7KE582W8LzFEp5rLOF5qyU8b7OE5+2W8LzDEp5rLeG5zhKeFUt49lvCc70lPDdYwvNOS3jeZQnPuy3hudESnvdYwvNeS3husoTnfZbw3GwJzy2W8NxqCc9tlvDcbgnP+y3hucMSng9YwvNBS3g+ZAnPnZbw3GUJz92W8NxjCc+9lvDcZwnPhy3h+YglPB+1hOdjlvB83BKeT1jC88WW8HyJJTxfagnPl1nC8+WW8HyFJTxfaQnPV1nC89WW8HyNJTxfawnP11nC8/WW8HyDJTzfaAnPN1nC882W8HyLJTzfagnPt1nC8+2W8HyHJTzfaQnPd1nC892W8HyPJTzfawnP91nC8/2W8PyAJTw/aAnPD1nC88OW8PyIJTw/agnPj1nC8+OW8PyEJTw/aQnPT1nC89OW8PyMJTw/awnPz1nC8/OW8PyCJTy/aAnPL1nC8/8s4fllS3h+xRKeX7WE59cs4fl1S3h+wxKe37SE57cs4fltS3h+xxKe37WE5/cs4fl9S3j+wBKeP7SE548s4fljS3j+xBKeP7WE588s4flzS3j+whKev7SE568s4flrS3j+xhKev7WE5+8s4fl7S3j+wRKef7SE558s4flnS3j+xRKef7WE598s4fl3S3j+wxKe/7SE578s4flvS3j+xxKeT1rC87+W8PyfJTw1oA08Wyzh2WoJz5glPNss4Rm3hGe7JTxHWcJztCU8Oyzh2WkJzzGW8BxrCc8uS3iOs4TneEt4JizhOcEQz1bCM0rfpZ8onGfpvJ4Yc5xb43J45yi8VXH5ujPJkjo+uaV5XebL5aybz2ZM1vGYYJ6nDFO7Tjbn3ANa5PR3b9yOPE8VzPNWS/I8TTDPR8fsyPN0wTxvidthaw+0pE+YYQnPgyzhebAlPA+xhOehlvCcaQnPWZbwnG0JzzmW8JxrCc/DLOE5zxKe8y3hucASnodbwnOhJTwXWcLzCEt4HmkJz6Ms4fkcS3gmLeHpWsIzZQnPtCU8M5bw7LaEZ48lPLOW8MxZwrP3Wfic8rnPwjw/z5I8Sz6re74lz+qOFnyeMdWSZzgvEMzzpNizrz0fY0l7FtzL4C5+FtqwYy2xYS8UbM8PW/Ls/TjBPG+z5Dn08ZaMa0+whOeJlvA8yRKeJ1vC8xRLeJ5qCc/TLOF5uiU8z7CE55mW8DzLEp5nW8LzHEt4nmsJz/Ms4Xm+JTwvsITnhZbwvMgSnhdbwvMSS3heagnPyyzhebklPK+whOeVlvC8yhKeV1vCM28Jzz5LeBYs4Vm0hGfJEp5lS3gusYTnNZbwvNYSni+yhOd1lvBcagnP6y3hucwSnsst4XmDJTxvtITnCkt4rrSE5ypLeK62hOdNlvC82RKet1jCc40lPG+1hOdtlvC83RKed1jCc60lPNdZwrNiCc9+S3iut4TnBkt43mkJz7ss4Xm3JTw3WsLzHkt43msJz02W8LzPEp6bLeG5xRKeWy3huc0Sntst4Xm/JTx3WMLzAUt4PmgJz4cs4bnTEp67LOG52xKeeyzhudcSnvss4fmwJTwfsYTno5bwfMwSno9bwvMJS3i+2BKeL7GE50st4fkyS3i+3BKer7CE5yst4fkqS3i+2hKer7GE52st4fk6S3i+3hKeb7CE5xst4fkmS3i+2RKeb7GE51st4fk2S3i+3RKe77CE5zst4fkuS3i+2xKe77GE53st4fk+S3i+3xKeH7CE5wct4fkhS3h+2BKeH7GE50ct4fkxS3h+3BKen7CE5yct4fkpS3h+2hKen7GE52ct4fk5S3h+3hKeX7CE5xct4fklS3j+nyU8v2wJz69YwvOrlvD8miU8v24Jz29YwvOblvD8liU8v20Jz+9YwvO7lvD8niU8v28Jzx9YwvOHlvD8kSU8f2wJz59YwvOnlvD8mSU8f24Jz19YwvOXlvD8lSU8f20Jz99YwvO3lvD8nSU8f28Jzz9YwvOPlvD8kyU8/2wJz79YwvOvlvD8myU8/24Jz39YwvOflvD8lyU8/20Jz/9YwvNJS3j+1xKe/7OEp9NqB88WS3i2WsIzZgnPNkt4xi3h2W4Jz1GW8BxtCc8OS3h2WsJzjCU8x1rCs8sSnuMs4TneEp4JS3hOsITnREt4TrKE52RLeE6xhOcBlvCcagnPaZbwnG4JzwMt4TnDEp4HWcLzYEt4HmIJz0Mt4TnTEp6zLOE52xKecyzhOdcSnodZwnOeJTznW8JzgSU8D7eE50JLeC6yhOcRlvA80hKeR1nC8zmW8ExawtO1hGfKEp5pS3hmLOHZbQnPHkt4Zi3hmbOEZ68lPJ9rCc/nWcLz+ZbwPNoSni+whOcxlvBcbAnPYy3h+UJLeB5nCc/jLeF5giU8T7SE50mW8DzZEp6nWMLzVEt4nmYJz9Mt4XmGJTzPtITnWZbwPNsSnudYwvNcS3ieZwnP8y3heYElPC+0hOdFlvC82BKel1jC81JLeF5mCc/LLeF5hSU8r7SE51WW8LzaEp55S3j2WcKzYAnPoiU8S5bwLFvCc4klPK+xhOe1lvB8kSU8r7OE51JLeF5vCc9llvBcbgnPGyzheaMlPFdYwnOlJTxXWcJztSU8b7KE582W8LzFEp5rLOF5qyU8b7OE5+2W8LzDEp5rLeG5zhKeFUt49lvCc70lPDdYwvNOS3jeZQnPuy3hudESnvdYwvNeS3husoTnfZbw3GwJzy2W8NxqCc9tlvDcbgnP+y3hucMSng9YwvNBS3g+ZAnPnZbw3GUJz92W8NxjCc+9lvDcZwnPhy3h+YglPB+1hOdjlvB83BKeT1jC88WW8HyJJTxfagnPl1nC8+WW8HyFJTxfaQnPV1nC89WW8HyNJTxfawnP11nC8/WW8HyDJTzfaAnPN1nC882W8HyLJTzfagnPt1nC8+2W8HyHJTzfaQnPd1nC892W8HyPJTzfawnP91nC8/2W8PyAJTw/aAnPD1nC88OW8PyIJTw/agnPj1nC8+OW8PyEJTw/aQnPT1nC89OW8PyMJTw/awnPz1nC8/OW8PyCJTy/aAnPL1nC8/8s4fllS3h+xRKeX7WE59cs4fl1S3h+wxKe37SE57cs4fltS3h+xxKe37WE5/cs4fl9S3j+wBKeP7SE548s4fljS3j+xBKeP7WE588M8WwlPNPJnkymlE2V3LSbT6Z6+3LdyUx3X0/Ozbndue5iKpdOl3KZXLa3rzeb7HUz6ZJb7u5Nlz3seYJ5/vkw5TnZnHN/0Sqnv8fjdpRzm6D+fmlJ3Y4L5vlXluS5XTDPv7Ykz6ME8/wbS/I8WjDPv7Ukzx2Cef6dJXnuFMzz7y3J8xjBPP/BkjyPFczzHy3Jc5dgnv9kSZ7HCeb5z5bkebxgnv9iSZ4Tgnn+qyV5niCY579ZkueJgnn+uyV5niSY539YkufJgnn+pyV5niKY539ZkucDBPP8b0vyPFUwz/+xJM/TBPP8pCV5ni6Y5/9akucDBfP8P0vyPEMwz07MjjwfJJjnFkvyfLBgnlstyfMhgnmOWZLnQwXz3GZJnmcK5jluSZ5nCea53ZI8zxbM8yhL8jxHMM+jLcnzXME8d1iS58ME89wpmGcF9dR+lx97GV6g5HAlC5UsUnKEkiOVHKXkOTo9Ja6SlNaJkoySbiU9SrJKckp6lTxXyfOUPF/J0UpeoOQYTwfHKnmhkuOUHK/kBCUnKjlJyclKTlFyqpLTlJyu5AwlZyo5S8nZSs5Rcq6S85Scr+QCJRcquUjJxUouUXKpksuUXK7kCiVXKrlKydVK8kr6lBSUFJWUlJSVLFFyjZJrlbxIyXVKliq5XskyJcuV3KDkRiUrlKxUskrJaiU3KblZyS1K1ii5VcltSm5XcoeStUrWKako6VeyXskGJXcquUvJ3Uo2KrlHyb1KNim5T8lmJVuUbFWyTcl2Jfcr2aHkASUPKnlIyU4lu5TsVrJHyV4l+5Q8rOQRJY8qeUzJ40qeUPJiJS9R8lIlL1PyciWvUPJKJa9S8molr1HyWiWvU/J6JW9Q8kYlb1LyZiVvUfJWJW9T8nYl71DyTiXvUvJuJe9R8l4l71PyfiUfUPJBJR9S8mElH1HyUSUfU/JxJZ9Q8kkln1LyaSWfUfJZJZ9T8nklX1DyRSVfUvJ/Sr6s5CtKvqrka0q+ruQbSr6p5FtKvq3kO0q+q+R7Sr6v5AdKfqjkR0p+rOQnSn6q5GdKfq7kF0p+qeRXSn6t5DdKfqvkd0p+r+QPSv6o5E9K/qzkL0r+quRvSv6u5B9K/qnkX0r+reQ/Sp5U8l8l/1OiG1uLklYlMSVtSuJK2pWMUjJaSYeSTiVjlIxV0qVknJLxShJKJiiZqGSSkslKpig5QMlUJdOUTFdyoJIZSg5ScrCSQ5QcqmSmkllKZiuZo2SuksOUzFMyX8kCJYcrWahkkZIjlByp5Cglz1GSVOIqSSlJK8ko6VbSoySrJKekV8lzlTxPyfOVHK3kBUqOUbJYybFKXqjkOCXHKzlByYlKTlJyspJTlJyq5DQlpys5Q8mZSs5ScraSc5Scq+Q8JecruUDJhUouUnKxkkuUXKrkMiWXK7lCyZVKrlJytZK8kj4lBSVFJSUlZSVLlFyj5FolL1JynZKlSq5XskzJciU3KLlRyQolK5WsUrJayU1KblZyi5I1Sm5VcpuS25XcoWStknVKKkr6laxXskHJnUruUnK3ko1K7lFyr5JNSu5TslnJFiVblWxTsl3J/Up2KHlAyYNKHlKyU8kuJbuV7FGyV8k+JQ8reUTJo0oeU/K4kieUvFjJS5S8VMnLlLxcySuUvFLJq5S8WslrlLxWyeuUvF7JG5S8UcmblLxZyVuUvFXJ25S8Xck7lLxTybuUvFvJe5S8V8n7lLxfyQeUfFDJh5R8WMlHlHxUyceUfFzJJ5R8UsmnlHxayWeUfFbJ55R8XskXlHxRyZeU/J+SLyv5ipKvKvmakq8r+YaSbyr5lpJvK/mOku8q+Z6S7yv5gZIfKvmRkh8r+YmSnyr5mZKfK/mFkl8q+ZWSXyv5jZLfKvmdkt8r+YOSPyr5k5I/K/mLkr8q+ZuSvyv5h5J/KvmXkn8r+Y+SJ5X8V8n/lOiBRYuSViUxJW1K4kralYxSMlpJh5JOJWOUjFXSpWSckvFKEkomKJmoZJKSyUqmKDlAyVQl05RMV3KgkhlKDlJysJJDlByqZKaSWUpmK5mjZK6Sw5TMUzJfyQIlhytZqGSRkiOUHKnkKCXPUZJU4ipJKUkrySjpVtKjJKskp6RXyXOVPE/J85UcreQFSo7Ra2ZKjlXyQiXHKTleyQlKTlRykpKTlZyi5FQlpyk5XckZSs5UcpaSs5Wco+RcJecpOV/JBUouVHKRkouVXKLkUiWXKblcyRVKrlRylZKrleSV9CkpKCkqKSkpK1miRH9bXn+3XX8TXX9vXH/LW38nW3+DWn/fWX87WX+XWH/zV39PV3+rVn8HVn9jVX+/VH8bVH93U3/TUn8vUn+LUX/nUH9DUH+fr6JEf1dOf7NNfw9Nf2tMf8dLfyNLf39Kf9tJfzdJf5NIf+9Hf0tHf6dGfwNGf19Ff7tEfxdEf3NDf89CfytCf4dBf+NAfz9An82vz73XZ8rr89r1Wej6nHF9hrc+H/txJfpcZ31msj6PWJ/1q8/R1WfU6vNf9dmq+txSfSaoPm9Tn2Wpz4nUZzDq8w312YH6XD595p0+T06f1abPQdNnjOnzu/TZWPrcKX2mkz4vSZ9FpM/50Wfo6PNpPqhEn6uizyzR54Hoszb0ORb6jAh9/oI+20CfG6Dfydfvu+t3yfV72vodaP1+sX53V78Xq9851e9z6ncl9XuI+h0//f6cfjdNv/el36nS7yvpd4H0ezb6HRb9fsgPlOj3GvQ7A3rMq/e6633keo+23rOs9wPrPa16j6fe86j3AOo9cXqPmN4zpfcQ6T01eo+J3nOh9yDoZ/L6GbV+ZqufYepnevoZl37mo5+B6GcCeo1crxnrNVS9pqjX2PSak16D0WsSeo6u56x6DqfnNHqM3/r0cMHR+3W1W+DUnGdKNNxT/np/q97vqfc/6v2Aen+c3i+m90/p/UR6f43eb6L3X+j9CPr5vH5erZ/f6ueZ+vmeft6ln//o5yH6+YBeL9frx3o9Va8v6vU2vf40U8ksJbOV6Pmrns/p+Y3ePz7fGezOR9fTvf9TfnLs9Bs//YoTcLgZAX5zAvxAL49MvKkyf5ku8Zpb5P3/8ZRz9q0ds+C/2K83APPoAEzdl2t32/FHpx/4xqvXYb97PL/HXnXI22b8pPVS7LcpwG9HgN+DAX67Avz2BPg9EeD3kgC/Vwb4vTrA7/UBfm8M8HtngN+7A/zeF+D3gQC/TwT4fSrA7/MBfl8M8PtWgN93Avx+EuD3swC/Xwb4/TrA788Bfn8N8PtXgN9/AvxgAYbzaw3w6wzwGxvgNz7Ab0KA3/QAvxkBfjMD/GYH+M3z/N79sdv+/cQ3P3gd9jvS83tP7mOnfuMV4w/Afs/1/D537r6vXDjx5gT2e16A3/MD/I4O8HtBgN8xAX6LA/yODfB7YYDfcQF+xwf4nRDgd2KA30kBficH+J0S4HdqgN9pAX6nB/idEeB3ZoDfWQF+Zwf4nRvgd36A3wUBfpd7flwffqXnd9yT3znpjTvuxsOnp8b9fvHuDPC7OwBzU0C8Fwf4vc7Hb7z3f8y8p/93eL9hMKLNpx7/LfZ+J5tzbgfClcbPJfOZDmegE+af7kCYBvBTgN9mBv+pd5eeqiuVgfgOSbfL+92CdAlxwA8PWF/i+Y32/OG637vuIHgmyh1zktbbJIZ/K8qbdsdVTKSdKgD+8R6+MwC7nMmmi9l8T6EvV+xLFzL5XDaTz+a7e3tct5hPFnt7k32pQjKfLefUQ6RS2e0rldxCb76czHXn04B9AuIu+O5mEvBPNINftScnmcFPAf7JFU736VJfNpnuzvfk+txyvqec7Mtkc+l8OZst5ou96lled7LoFnrcQsot53L57u58obvXdcul3u5yrgewT2GxS7lcobcvW06W8+XelHoemEz1FYrlbvWQMJsrlwrd5XI605vsTueK+UIxW3B7C+lcqlwo9ZaTvdVyPZXFLqa68+VCsdiXSZZ709l8NqfqTm+2TwHk3HSPmy/0qjpVdkv5QrbQly8lVVolN1/MusVsuhuwT0M6l6vvNfzTjeDX6swZRvBTfYB/ZoXTfWNc6Q3APssId7eKf7aZsq3q5hxWNzk3r+xXsZhxc8VCMZ0spcvKcuXymWKPm9NNK53rK6a7syVl8NxcPpvqLnX35POqjeULbrVcz2WxS6lsJpPudbMZN9tTTPeUislcoZwrqmftrtvnFovlsrKbfarRlnuyvT2qXZUKpWwp19ejGm+1PZ3HYjfnAPt8pPMWR76+X2AGv2ojL6yYqDPJqu4vqgzWvZtLp1LZtN4PkSsm3UyxkMqlUtqwqYpTSJV6M25vOZPKpAtF1UFmcnlXG9RCbzn3NDhgX2yGe1U3l5jBr453L60YKduq7i8zw78M+JcbwXezgH+FEf2kq334lUb4p6vle5WH70hhu7W6f7U0djJZ7cPz/thDbrqA3cdgp/LpQlKNgPLdqnso5bqV3VdD31JfrlTuSeX7Cplkqui6bimj/qRKxUxvn+pa+npKqivpU8lVdVKomChPtzqWLwrj9+STvaWenmp9Lwnj9/X1ZPNKn4BfFsZPF3pK5XS2ai+XCOPnuzPlcnc6D/jXCON3u8lSdypbrZvXCuP39iW7e9SMAPBfJIyv5ifpYm++Oj67Tlo/faVkoej2wtrAUg8f0tAO0r5eOG3P9baQ9Bxn4NqHQ9LvJFyl5yEtJD3MB+sH1hlAd8sqg7kmGL8i4k39Ysw9SIfDKglilQWxlghiXSOIda0g1osEsaBdm21rmWo/uswIfjoH+MuN4CdLgH+DCXw09roR4Tty/Kv4KxB+iwH8lWb0X8VfZUY/1Tnxag/fBPZN8tjV8dHNZvReHd/dYga/Ol9aYwa/Ov691Qx+1e7cZga/F/BvN4NfHf/eYQa/On5cawa/Ov5dZwa/CPgVI/huVT/9CF/OLqeqdnO9GfyqfjYYwU9X+d9pBr9qm+8ygp+p4t9tBr9qnzeawa/a53vM4FfHVfcawe+uzr83GcHvqZbvfWbwq/37ZjP41fXcLWbwq+uVW83gV+v/NjP41fq/3Qx+dXxyvxn86vhkhxn86vjkATP41f7xQTP41fHDQ2bwq/3jTjP4Vfu5ywx+1X7uNoKfrfbve8zgV+3nXjP4Vfu5zwx+1X4+bAa/aj8fMYNftZ+PmsGv2rfHzOBX7dvjZvCr9u0JM/hF/S6O3nc3xnsJhtuvKDjeSsJeQNg3CGngtOPovuBcqhhmPR+n30m4mljPx+kBH6ofvJ6v/doZrgnGj5ZhO5NOO5NOgvGj47NmsPYIYm0TxNoliCWZx4cEsXYIYu0UxNouiNUviCWpe8k2tDeiWJsEsSTrhKTuJevXFkEsybYtWSc2C2JJ2uhHBLGi2j/CuLfD4ccHi73fySYd4I82g58GXYwK0AVOH8ZKeGzV4vMfsKgfpNVJsITz5gblDfOn5TwK8cE68MMa1SBWB+NnokzbA/JN0/cLz42XIXxHAD4OP94ZXIc7iC46zegiFVRu+B04SH8s4lks9a1ecvryJQ5xfuP/g0g4eCbf6gzW92gfLIf8PojciyE87DRveIewXFpVuOb8/JIlpaJiv5KEHBT1+Ap/n06LcBjDVTg1VFNiyAy7YcykdlDldXGM8a6XLs8Xj8vfsHL10lIrUSWeAVN1YjiabVpULYiSExDu+MrA3/BmT8zxd6BKwBuN/DgVACa0er9aT4urjUkX7rUy4UcRrFFMPOAeC4iPMXA8WpWCmkOY6gr50I5bVaBvfAat5Jhpdm56qM3O9EpOUFlhvZodLbmpoDYwmtEPlGUH4wdY0PPEHb5nGo3ySHvKTsQjTu790fufIJjawdtTQT05vgf61fX11yRvuGxoPTVTDhk3bD2F9Dsdo92VG1QvuNFhhzO4nCV3fYYpV8wXyrKT8QMs6M5wPcXhO1AecXh8DfHxvf95/xPO4DpN62knkx98D9fTf3rXHT75Wez9TjblslnaxiENnLaZ0a1bCNsOIP1Ox2S9q7UDrpw4ewK6G8NwTTB+dLQ8hklnDJNOgvGjqwHNYO0SxNosiLVVEGtvRLF2CGLtFMTaLojVL4j1oCCWZL2Por6C+sFGsbSTrKv7BLHuF8SSrKuSedwkiBXVtv24INYGQSzYZUHHmYCvXYczuO1Jz91wepAPfA+n30m4yvKpjZU4vXJjWtDPWDP6qfIZy/AZy+gHyrKL8QOscd5vPGfA4ceiPOLw+Bri43uneAWWIJja0TlDF5MffA/PGY5rGZg3XDa0nposB5we8Mb3cPqdjsl2kwysF1z773AGl7OgfpJhyhXzhbIcx/gBFqyc43qKw3ehPOLw+Bri43sXkXqK6zStp+OY/OB7uJ6eQ+opLhtaT42Ug1sOXU8h/U7HZLup1VOuXoxl9NjhDC5nQf0kw5Qr5gtlOZ7xAyx4kxjXUxx+HMojDo+vIT6+VyL1FNdp+ubqeCY/+B6up1d5uB0++Vns/U425bozXFnK4WfdLiaftJ1hXcvV63TodgbpdzqD64WJdpYgfPzqAehuAsM1wfjROjKBSWcCk06C8aPzmmawtgpi9QtibRbEelAQa5Mg1g5BrIcEsSTrxBZBrHsFsfYKYXH2uRlee4R4abdPEEuybT8uiCVpCyXb405BLMlyfEIQS7JOSOpeqm07wnmUrBO7BLGiaickeT0bxkwjfdr+071ke9wmiCWZx0cjyktyPCGZR/p8AM8tW7z/Hc7gtic4z4YlkGp6kA98D6ffSbjK8qnNszm9Jhi9gu4mMlwTjB+dZ09k0pnIpJNg/Gif0QzWVkGsfkEsyTzuEMTaKYi1TxBLUvePC2KNlGNjWE8IYknWiS2CWLsEsSTt115BLEndS9ZVSd1H1X5J1lXJ+vWQIJZkOUrWL8k2JFm/9ghibRLEksxjVMdyknmUHE9EtRyjOpZ7VBArquMcyTHmyHjimdGGJO2EJC+p+qWv6bpqM7weFuKlnaTuJccA0NfS/W6Ar53ZNbRU6D22dA3NyB6sOmto3N66DmdwPRTUjxumnDFfKMtJjB9gTfZ+4z1hOPxElEccHl9DfHzvEk8pCYKpHd0TNonJD74H+tV7ws7zfnT45Gex9zvZnMvR9VBIA6eN9SRY70J94Qan3+mYrHe1dsCVE2dfQHeTGa4JZ3DdofVhMpPOZCadEaxoYZ0vhBVkw8Bfuw4mnrS9xelBPvA9nH6nY9QuuEF65ewl6GeKGf1U9yhPYfhMYfQDZXkA4wdYU73fuD/C4aegPOLw+Bri43t3kP7oABSWtoEDmPzge7g/url1YN5w2dB6aqYcwr/zAel3OibbTa2ecvWCa/8dzuByFtRPMky5Yr5QllMZP8Ca5v3G9RSHPwDlEYfH1xAf37uP1FNcp2k9ncrkB9/D9fQu78d4x799hmnPGJez21SHOB5tD0bK2y0lw7YHSL/TMdk+a+3hgJB6Bf1MNaKfYjlM/cF8oSynMX6A5R1UPaA94PBTUR5xeHwN8fG9h0l7wG2HtodpTH7wPdwedhK7jcuG1lMj5ZBMlsPWU0i/0zFpJ2v1lKsXXP/X4QwuZ0E+pTDlivlCWU5n/ADrQO83rqc4/DSURxweX0N8fO/VpJ7iOk3f1ZvO5Affw/X0pWS+S/Oz2PudbMqVXK4s5fDz1ZNIpxvBT/V2MOUlh9+XA/wZZvB7AP8gI/i5avkebAS/u6qfQ8zgFwH/UDP1p8p/phH8dBrwZxnBL1X5zzaCn6nizzGC31dtv3ON4PdW6/9hZvRTLd95RvDL3YA/34x+qvwXmOFftf8LEb7kWgTgH2EEv3Yq8iKn5mJMniB9GIscjsK3+PwHLOoHaXUSLFPjPi5vmD+d9y1CfLAO/LAWNYjVwfiZKNOFAfnG6XcFcKX50I6egTNUnWi3RRDrHkGsPUJY3Ni2GV53VuR4TRPixY1/m8E6UBArJoSl3d0VOV4zhHjp64MiinWwINYhgliHCmLNFMSaJYg1WwhLO/o1u2Z4zRHktVuQ11whXvr6MEEsqb5DX88TxJoviLVACEs7unYaFSx4hmx2vSvTa3a9K503u96VKZpd7+pOm13vymTNrndlMmbXozIFmAtAHwlp4Lo7E92PyaUd+l1TSL+TcJXlU5s/ziR8qH7o/qBZDNcE40dtwCwmnVlMOgnGj+4VbgbrEUGsTYJYDwpi7RDE2iKI1S+I9ZAg1lZBrL0RxZKsq9sFsaR0r6/puCAqdVWyPe4TxIpqe3xYEEuyDUVV9/cLYknaCcm+VtJGS+peUl9RrV+SYxPJcpTU/bPBTjwuhKWv6Ry5GV53C/I6UIiXJJZ2d1XkeM0Q5CWle+3uFcSSrBN0rb4ZrJgQlnZSdUK7e4Sw9DVd34lKOUrykqqr+jqqtrBLkJdUXZUuR0leUdSXdpJ1la6tRqGuaidlv7R7QhBLcvy1TRBLck1BckwuOVeQXHuE8T2sYx+M/Fq8/2afASSH/AzgYDN8Ap8BHMzoldsPK8inGKacMV8oy9mMH2DN8X7jdwdw+Fkojzg8vob4+N57vYJLEEzt6LsDs5n84HugX/3uwNtjA/M2E4Wj9dRMOYT/xiyk3+kYbTduUL2YyeiRqxcQN8H40TF92PLiyp7urWsGa5cg1mZBrK2CWHsjirVDEGunINZ2Qax+QazdgliSbUiyHB8RxNokiLVPEEuybUvWL8k2JGlXnw26f0gQS9JGgy2E9+NnOTXsuDMwnVlMOrMC0sHxIZzZ98G6U2bfB+vuMfs+WKYM4665SK8tRHd4n6bcGDEX+jwNSL+TcJXlUxuzziN8qH7omHU+wzXB+NH9VfOZdOYz6SQYP2pbm8F6RBBrkyDWg4JYOwSxtghi9Qti7RbE2iOIJan7qNbVfYJYWwWxJOuXpM3ZJYj1bND9Q4JYknncG1Esyba9XRBLSvf6mu6djEpdjeoYQBJrpN8e6bdt6TtG+u2Rfnuk335m6j6qdfVhQSxJfUnaHEnd3y+IJdmGJPvtqNroqI4nJPMoOfaVLEdJ3T8b7MTjQlgtzuA9FM1gzRLEklon19ezhbC0u6six6tLkNfdFTmsewWx7hHC0tdzHDmsZ7ru9TXd394M1oGCWDOEsLST1NdhQrwk66p2km0oqvU+qnl8pttCSV7ajfQd9vcd2m0UwtLXknsepPSlrw8R4qWvDxLEkuprtZPsH6X0pV0U+w7tnhDEkpzzbRPEknymI7kOILk+Ibk/h76DhPeGtXj/uTPDdTqLvd/Jplwq9LsdkH4n4SrLp7ZPjtPrPEavoLsFDNcE40ft6QImnQVMOgnGj9b3ZrD2CmJtFsTaJYj1iCDWVkGsPRHltUUQq18Q63FBrA2CWE8IYknqa6cglmR73CeIJVnvJW2hZDluE8SStDmSdeIhQSxJ3W+KKK/dgliSdUJybCLZb0uWY1Ttl2T9kmyPUbXRkliS9Wu7IBbonr7XA/jacd9vEpzrZVpIepAPfA+n30m4yvKpzfU4vXJzaNDdQoZrgvGjz6C5bwQtZNJJMH7UNjeDtUsQa7Mg1lZBrL0RxdohiLVTEGu7IFa/INZuQaxNgliS7XGfIJZk/ZLU14OCWJL1S7INSdpVyTohaVej2rYl26NkG3pEEEuyPT4b6tdDgliSYwB6TgQeb9NzIhod8+P4EK6Lidfi/Tf7TdXe0OcgQPqdjE5MjPkXhtRrI9/r1NeS35+kfVMzWI8IYm0SxHpQEGuHIJbkt1L7BbGkvsOnndR3V7WT1H1U6+o+QaytgliS9UvS5uwSxHo26P4hQSzJPO6NKJZk294uiCWle30t9d1o7STralTHAJJYUe23JXUvOQaQtNGS44mo1tWRfnv/9WkjY/LGsEbG5Puvfo2MC/df/YriuFA7SX1Fta4+LIglqS9JmyOp+/sFsSTbkGTfEVUbHdU+TTKPkmNfyXKU1P2zwU48LoTV4gze49QMr7sqcrxmCfHS112CWJLPhyT1dYggr3uFeGl3jxCWvp7jyGFJ1Qnt7q7IYUnpXrJtS7dHqTakr2cLYWkn2R6fDfWLnuPSDNaBglgzhLC0k9TXYUK8JG2hdpI2Oqr1Pqp5fKb3tZK8tBsZm9jfd2i3UQhLcjyhnZS+9LXUmFxfHySIJdXXaifZP0rOYaLYd2j3hCCW5JrCNkEsyedWkutMkutfkvsL6TkueG9ri/e/wxncXnQ6i73fyeZc6HNcIP1OwlWYjxukV26fNujnCDN8+loIPuZzBKMfKMsjGT/AOsr7jb8ljcMfgfKIw+NriI/vfa/96f8Jgqkd/Zb0kUx+8D3Qr4b8RvvAvOGyofXUTDm4xbD1FNLvdIy2GzeoXnDtn6sXEDfB+NE1nLDlxZU93ZvQDNYuQazNglhbBbH2RhRrhyDWTkGs7YJY/YJYuwWxJNuQZDk+Ioi1SRBrnyCWZNuWrF+SvCTLUZKXpJ2QrBOS5fiQIJakvafvG+KxFX3fMGh8yqWD40O4LiYejK06HH6Mstj7nWzK5bpbSHqQD3wPp9/J6MTE+O7IkHoF3R3FcE0wfnTt6igmnaOYdBKMH22jzWA9Ioi1SRDrQUGsHYJYWwSx+gWxdgti7RHEktR9VOvqPkGsrYJYkvVLkpdkOUrykrSrknVCshwfEsSS1P3eiGJJ2ontglhSutfX9N3FqNTVqI4nJLFGxgAjYwCTdnVkDDAyBhgZA4yMAephSeorqnX1YUEsSX1F1U7cL4gl2Yai2ndEdewb1folOY6WLEdJ3T8b7MTjQlgtzuB9EM1gzRLEklq/19ezhbC0u6six6tLkNfdFTmsewWxpHhJl6Okvu4RwpKuE1LlqK+nC/HS1wcKYs0QwtJOUl+HCfHS13OEsLSLal0daY/7L49RrF/ajfRDI/We+m0UwtLXkntEJOvXIUK89PVBglhS/bZ2kn2tlL60i2J71O4JQSzJueg2QSzJ51aS6xOS6yaS+5no+00x5Nfi/Yd9hdie63CLvd/J5lzob5dB+p2EqzCf6r7CLmewXmOMXkF3UxmuCeKnHX3PZyqTzlQmneHC4spby2Lvd7Ip193dxaRN6xre3yBXtm4ubF2D9DudwWVroq5NI3z8yg10N53hmmD8aBlOZ9KZzqSTYPzoc9ZmsB4QxJLktUsIS1+PdmSwpPPYL4j1kCDWXkGs7YJYkvraJ4j1mCDWbkGsrYJYkrrfIYi1RRBLMo+PC2JtEMSCuQcdW2i32PufTJYz2XQxm+8p9OWKfelCJp/LZvLZfHdvj+sW88lib2+yL1VI5rPlXHeuu1R2+0olt9CbLydz3fmM2bFDd7bDGWzjBccmLuAfaAY/BfgzzOCnAf8QM/jV8p1lBr8b8Gebwe8B/Dlm8HNm3/9yewH/KDP4ecB/jhn8IuAnzeCXAN81g18G/JQR/FQS8NNm8Kv2LWMGv2rfus3gV+1bjxn8qn3LmsGv2recGfyqfes1g1/tf59rBr9qP59nBr9qP59vBr9qP482g1+1ny8wg1+1n8eYwa/az8VG8NNV+3msGfyq/XyhGfyq/TzODH7Vfh5vBr9qf04wg1+1Pyeawa/ah5PM4Fftw8lm8AuAf4oZ/Kr9OdUMftX+nGYGv2p/TjeCn6nahzPM4Fftw5lm8Kv24Swz+NXx1dlm8Kvjq3PM4Fft27lm8Kv27Twz+NXx1flm8Kv28wIz+FX7eaEZ/D7Av8gMftU+X2wGv2qfLzGDX7XPl5rBr9rny4zgd1fHh5ebwa/a/yvM4Fft/5Vm8Kv2/yoz+FX7f7UZ/Kr9z5vBr9r/PqfmZLBra88FE9zdcrXuF1nu6VJfNpnuzvfk+txyvqec7Mtkc+l8OZst5ou9mVK2O1l0Cz1uIeWWc7l8d3e+0N3ruuVSb3c5V+23Soh7i5huclXuZSP4yWq9XGJE98WqXbuG0X0qU+zpyyez5Ww+nyurTihVVP96lObL3al8b7qQVyVR7Cvl1eOY3lShmCqmSznVVkvp3p5SqWbzr2XLtRmXrvaHL2KxS7lcobcvW06W8+XeVF6tX6b6CsVyd7JHMS6XCt3lcjrTq6jmivlCMVtwewvpXKpcKPWWk71VnV/HYhdT3flyoVjsyyTLvelsPptTOujN9imAnJvucfOFXvWcquyW8oVsoS9fSqq0Sm6+mHWL2do8dKmR+lJb579evL7knvqrjxJ+m7d5Ac61W4bSaif5Wu79hrOStVtZqYVZhvxx+LeOf/q/xnuXl16YfWht4vl+Sq+9LSQ9x+H3BkH6w7UPrY3wofqhe4PiDNcE8dOOPiuOM+nEmXQ4rCcEsfoFsXYLYm0VxNopiLVFEGuHIJZkHrcLYkW1fm0SxNojiLVPEEuyfknq60FBLMn6JdmGdgliSdYJSbtK97NjPzqOwOMYwX47FXYcAel3OoP7bRPjiHYnnF7HKhnjXS9dni8el79h5eqlpVaiSjwMo+rEcDTbWC3Yjw75aLiTKwN/n14ZHM9hsGMIrwP5cSoATBj24jx1+MTDunCYe61M+HaC1c7EA+6xgPiOY7w6V5cGOs3gp4PKBucJ0u9yBuu8xec/YFE/SKvT4XW+WEh3QXnD/KlJ60B86HSLw+poEKuD8TNRpu0B+cbpdwVw5fIRJzrhugxuigThOwN44fDjmbQhLuhwDPKT7kb8dIjbIqSvzTa8clAs9a1ecvryJQ5xMaIH0Ns0Eg7sYKsTbAcxlkN+TyP3YggPu6Apf5j2DDy1SzBYsBQxMiSoupEhwTN7SMCZWlqVOpzBeV3s/U8249xcuoPhVMPOuflMPlcsZtxcsVBMJ0vpciGZz+XVUrSb0wv/6VxfMd2dLRWzeTeXz6a6S909+bx6ApAvuCmNOctTPGeeqVkCUxl3BneXWEdxEv5ytDp5mBdBN4OE59+3eul155ZWrbi2dFNJWdqVDnH16u45lYG/z60Mjse5oOFPVM2Y6eFVUN3XrkEzRquQaTMGRQ9Oyoy1MZhhzBgtLi5d7VqZ8EFmjC6UxwLia9fF3KNV3dAINnRVpzMJU7OwoHLG+mmyqmN1Yjia7f3ZY3OD93YGM2jwHlQ9HeZevYFwUC8U80mvIyA96I24phEnYV/oARluEsmJCJfmYaRXqrqRXumZ3SvFmHiUW7NrVJAP7RKOf/47nMH6WOz9TyZLqWwmk+51sxk321NM95SKyVyhnCum3bzr9rnFYrmcyWf7MqVsuSfb29OdzpUKpWwp19eTcssZrtm2OHKv82jcCwIG8nQySQfy2uFtBh3IH4e/zPPQ6V2CBvLwmupN+aXXFvOrSicsu3F1aXWpeObyVaWVxy4rnnBTadmqhof1p1QG/j61Mjge57QBAC1MQPhUC9gIx0h47aBFQfhJ3v12p8YBh4G4cRL+ak9TekVpgvfGM1cTgU8XiQ/+2kFNmky4L/Z+J5tzoTsASL+TcDXVAUwmfKh+GuwAcLWg6sRwNNv7swOYgvw4FdAOAOdpik88WuXpvVYm/GSCNZmJRzsALj7GwPFoVaLND68+TGTSps3vRtT8Jk/3T3eiM1gPtAnGmPSguU4hYbWD5noAwVjs/U425bqzYZsrpN9JuJpqrgcQPlQ/DTZXXMUw/IUEDsLgsNhdiCg5PuG4Ys8z8aij45UDiJ92UB3MHIHlhrbekH6nY7J61qoDd5Qa1k8r0Y+hI8sCjwibxugHyvJgxg+wDvV+Y7OEw09DecTh8TXEx/c2emYrQTC1o0fVHczkB98D/eqRS3/HwPSgbe1GY7t7yVgStz9cV/zM+WQm7QQTH8Jx6YxqMp1RTDr02ah2N1YG+nUG+OHnkwcQzLEoHn1Oho/oOY/4jUOYowjm+ADMBIOpy+6IMTU8LfNROM4U02HDPMQHx8W/4ySsdqsrA/0g7CtRvXqE1CvcDdHynlKHd1B5QzjQFa4ntExxe6Zliu0E1T/XHsHvUCZf4DczAHMug6n1NmfMwHBY77RvmY/uCw41esL2LZB+pzO4PpnoW7j6jfVD+5YFZvTT3ULwMZ8FjH6gLA9n/ABrofcb9y04/AKURxweX0N8fO/tpG85HIWlfcvhTH7wPdy3vLFjYN6o/eD+Ay69R9s31g2ULzfWgjal+bynY2BeIB7WJ+6Prkb+OPwp6AHm+wNsGC2/eSSP9WzvAUwew9rxiwnWvABeC+pgXUiwcPwFBOvwOliXECwc/3CCtbAO1s0EC8dfSLAW1cG6hWDh+IsI1hF1sNYQLBz/CILVVwfrVoKF4/cRrEIdrNsIFo5fIFilOli3Eywcv0SwynWw7iBYOD59NXBJHay1BAvHX0KwrqmDtY5g4fjXEKxr62AtJ1g4/rUE67o6WJcRLBz/OoK1tA7WWQQLx6ev2V0fgKWv4fjG8Ux8iNvFYIGdhz4ZvxK3P+bDkH4n4SrLpzZmWeYM1ivWD30NbTnDNcH40bnZciad5Uw6HNY8Qaz5glgLBLEOF8RaKIi1SBDrCEGsPkGsgiBWSRCrLIi1RBDrGkGsawWxrhPEov1P0PhZX8PxvuOdwfZvHomHbRBd76TzRhweY/iNz/Fjivl1OM8gnIc6TtfXhxCsoY7T9fUsgjXUcbq+nk2wmhmnX14ZiDXUcbq+nkN4DXWcrq+PJFhDHafr66MIVjPj9EplIFYz4/QCwRrqOF1fP8cZiDXUcbq+ThKsoY7T9bVLsIY6TtfXKYI11HG6vk4TrKBx+rI6WBmCheMvI1jL62B1EywcfznBuqEOVg/BwvFvIFg31sHKEiwc/0aCtaIOVo5g4fgrCNbKOli9BAvHX0mwVtXBei7BwvFXEazVdbCeR7Bw/NUE66Y6WM8nWDj+TQTr5gAs7c6oDMTC8W8mWLfUwTqOYOH4txCsNU5wHo8mecTx1xCsW+tgvYBg4fi3Eqzb6mAdQ7Bw/NsI1u11sBYTLBz/doJ1Rx2sYwkWjn8HwVpbB+uFBAvHX0uw1tXBOo5g4fjrCFYlAEu7KysDsXD8CsHqr4N1GsHC8fsJ1nonOI/HOwOxcPz1BGtDHawTCBaOv4Fg3RmApd2yykAsHP9OgnVXHV4nEl44/l0E6+46WCcRLBz/boK1MQBLu7MrA7Fw/I0E6546vE4mvHD8ewjWvXWwTiFYOP69BGtTHaxTCRaOv4lg3VcH6zSChePfR7A2B2Bpd31lIBaOv5lgbanD63TCC8ffQrC21sE6g2Dh+FsJ1rY6WGcSLBx/G8HaXgfrLIKF428nWPfXwTqbYOH49xOsHXWwziFYOP4OgvVAHaxzCRaO/wDBerAO1nkEC8d/kGA9VAfrfIKF4z9EsHbWwbqAYOH4OwnWrjpYFxIsHH8XwdpdB+sigoXj7yZYe+pgXUywcPw9BGtvHaxLCBaOv5dg7auDdSnBwvH3EayH62BdRrBw/IcJ1iN1sC4nWDj+IwTr0TpYVxAsHP9RgvVYHawrCRaOD3G7GKwW7z88M3oc3Zd7RpNxW0h6kA98D6ffSbjK8qk9M3rcGaxXrB/6zOgJhmuC8aNrjk8w6TzBpMNhLRDEOlwQa6Eg1iJBrCMEsfoEsQqCWCVBrLIg1hJBrGsEsa4VxLpOEGupINYyQazlglg3CGLdKIi1QhBrpSDWKkGs1YJYNwli3SyIdYsg1hpBrFsFsW4TxLpdEOsOQay1gljrBLEqglj9gljrBbE2CGLdKYh1lyDW3YJYGwWx7hHEulcQa5Mg1n2CWJsFsbYIYm0VxNomiLVdEOt+QawdglgPCGI9KIj1kCDWTkGsXYJYuwWx9ghi7RXE2ieI9bAg1iOCWHTNsd4+OfgMVtA+OYjn9z5WDIXh9sZhDL99eDHEud5+vKsJZy5N7v3GVZWBfvj9RronH7/zTN99xO8w0/et8PuNdM12JvKj77rNRX6QH+79xo6A/ODzeul7vfj9XPoO91jkN434dSG/g4kffj/3UOI3HvnNJH4J5DcX5RXez42TvD7Hu2/4hBf26LGg96NbfP47zuB1ce1ou8XnELWQdCYLpoOx4Gi8oKM5hpoObqN0zf0AwXTouxw4nWlMOlBvcLsVrDeh36WB9DudwTbGxHMR7uyDaYxeQx41Qo93wOrEcDTbWC3YL0bu0XASJwPhYyQ4FdDXTHGeDvWJh3XhMPdamfAHEyy/YzNiPulxRYnj0arUQu77nQw0Ffnj8Kd59UGfDDR1ei28X1pYH/RwMODudzgY5QDhz0IcJkznMdt88jXNB7NvTI3LuWN4TIfB5PJ1KMkX5XAw4QDhL0T5OpCcunQoE9/xuQf6d5i49DdXZyaS8DPr5IeWE4S/PKCcpjIccJukOp1JONAwh/pwuJrhgM1aYfkNazyz5hBHT09sIb+pyukJSFMZHD8HatDZg6oYI7jURNF0MA7lpLMMI7ZiaWlpVckn09RWt/gk1urwjg6hHWdwd2uoewvd3UL6nQ5fFxfL8Ak8Ognrhw6JuKOQEowfrhi0AgalM9apDe1Xrlq+wq8uhO2HWxg+NL5TBwt+j9SfodefkMM1Wm2wOjEczbZfkdWrJhKHbgcNczAmDNeChli4uCYx6cK9Vib8NII1jYkH3IOGYxgDx+O6RdrFcl0wPugRh1+Luj84yJHGgd9FdE0Pahz+2ZMbelfZM3T2lCBwEAaHxS6BKDk+4bgqD4dbhGmOZg+E6umD6nYdwwH88KYaumCFD6GgC1Z4Aw3+Gg11MSbvkF/djA6eXsOl4ShX3LSXEj/cbOgiIx6hLyN+M5HfcuKHFwtvIH74pekbiR9efIWNM/RM2F1ksc1Qr8cutkFa453BesULmLR+x5h7dNEIx58UkM64JtMZx6RjWJeu2fZa+9Be0AgFp0/bBfhz/wGL+tHRl+ljtIO6bO1oOXOrQUFY0xrEMjwKTtMhB5dvzr5yXLl80NUPeDgxx5uS6Cnw6wIebtDhh5kPg6ZDH94I6XcSrqbqI/f9Ge4DnNwDHohLbZ92Gyu1cNQvxtxrDcDaJYj1sCDWTkGsLYJY/YJYknmULEfJPG4WxJLM40OCWLsFsR4UxNoqiLVPEGuHIJZknZBsj5JtSLJOSOpruyDWXkEsSd1vE8SS1P0eQSxJfUnawk2CWJL6iqotlNSXpM15NoyZJOuEZL8tpXt9PdqRwdJOst5L6v5+QSzJei+ZR0k7ITkGkNTX44JYTxCssPN6CN/FhOfWpWAtE2/mhLiwhoLXJqWfqPrpCW8ghfQ1R7AHxVLf6iWnL8dnJFbjYz2A3rpJOHgk2OoMtjljfbAc8rub3IshPOzwxyTDPDIzsx6bDv0EG9Ifrkdm3GZzbt2T+8AHxE0wfoeha+yH0+E+vJFg/Gi/3QzWQ4JYuwWxHhTE2iqItU8Qa4cglmSd2CmI1S+IJVknJPW1XRBLUl/bBLEk9fWwIJZkXd0iiPVsKMc9gliS+pLshzYJYknqK6r9kKS+JO29ZP2StDmS7VGyTkiOmaR0r6/pGkxU6r2k7u8XxJKs95J5lLQTUR1/PS6IBWsw3AvDdJt00EcquXRw/AUhsLj5MIRfxIQPWuvhPvjR4f3GB+iZWOvhymMRShPSH8paD+jNJeHoWg+2bQt9sBzy2yX3/NZ66L6lnd5iEujX0H40dl8k3a+I90LNJfnj1hfxPVp/cfzOgHTGNJnOGCYd7sPSkG/Dei62kPQgH/geTr+T0YmJNbRJIfUK+jG0pldocQbbqxiTJvCFsgyyrdBe8esNODz9IDxu39jexMm9V3ttM+EMtrv0o71h7bte633p2IF5G+p+VozL9Rth2sNQ08FY8AFg7vUZakca3cOK40/zwYJy1w4+Tqr96QcVoTzaGEzt4EPlcRL+HV556f7mTrR/X4fB+1zxh5DfNTaYK46LudI3pheNr2G+18Pk9AzlztUD+hZgJ5Muh0ltc6NlN4bhEISFy2ssCY8PL+HC0zezIfzHUdkdSN4iph+n1g7Xn2k+HHD9wR/M86s/nx5C/fns2GCutP6MdQamXT1ABtWfL5D6g3UcVH/GEj9cf0BHXN9O33lotG/H8YPGEFOIH+Z+APGbwuSrhfhhflMC+I1lOED/ST9WuNj7nWzKNf6O0zjih99xGk/88DtOCeKHD/2l/coNyI/22/hQXnqYDz5kdybxW4n8xhI/fAguff0Uuxj5jctFt8WNDbyLhesNfReLO/CJ1nl8ogTX5um84LfofYbPdA1ML2hciw9IEqx36TDjBJz+cI1rxxM+fjaFOyQK4iaIn3Z3VWrhqF+MudcagNUviLVbEGuTINYeQax9glg7BLEk9fWgIJZk/dopiLVLEEuyTmwVwtLX7Y4MlnZ7hXhpJ1knNgtiSdaJhwSxJO2qZNuWqqvaRdWuStYJSfsl2YYk64SkvrYLYknqa4sglmRdleQ10m/vP31JjlclbbTkGOBhQSxJ+xXVOiFpJ6LaD0nOYSTz+Jgg1ohdfWbYL8lyvE8QS1JfUbU5UR0XbhPEkmyPkn2tZDlGdby6XhBLkpekXb1fEEvSTkTVRkvyktR9VO3Eg4JYz4Z5rWS//YggliQvyXmtZDlKtkfJOYzkuq8klmSdoG0Innvio+Vh74p2q7zrOAn/ae85dAdJo8URfdacCdoXB2nPNJR2C0nPcfjn3JA+d64q3duJ/dqa4NpbynanU6Wimy/k+kp91b2UMwlXeo/uB5/HhA/aC2rovN4U7LuIVWr4+MNX2rUhv5nEL4788Bm7184ayN/QXpxUGP3j9BNMeLqPNAhLOyibic7AuobbI7dnBO+ToG3JTDtOh94zAul3Eq6yfGp7RjhbOp7RcVeAjhOM30HomtqvGHPPb++udnS83wzWXkGszYJYuwSxHhHE2iqItSeivLYIYvULYj0uiLVBEOsJQSxJfe0UxJJsj/sEsSTrvaQtlCzHbYJYkuUoab8k9bVbEGuTIJakviTbkOR4QlJfDwpijdjV/WdXpXSvr+l5AlGp95K6v18QS7LeS+ZR0k5sF8SK6nj1TkEsGK/StUJ9jd8/MbuelkyZXUOqfW+EW9PCeZL8hgykNVzfkOHyFlQP8HrXTHTthzWvQSyz62q1Mp3p+Ocbp98VwJXLR0JQJwcTrLBrS42W7XhncHlCXMNtrLrOeXCAnnD6QzmbA/SWIuEurtT0QPU90wfLIb9T5F4M4WEHOsbrj/Sj8JxNHovu0U9J4ro2iWAdUAfrYoI1KYDXwXWwLiRYOD6twzPrYF1CsLgyCarfGOtmgoXj+72/74d1C8Hi6iZgHV4Haw3BwvEPJ1gL62DdSrC482UAa1EdrNsIFndWD2AdUQfrdoLFnbMDWH11sO4gWDh+H8Eq1MFaS7Bw/AKJV0B++EwB7l1Z/H79knEDOXHnM+B3V/2+aP/ScTXMF40byBvH73AG+nUgv8mEM9YF2Ciw8fjca2kbj9NzHH7sA+l3Eq7CfKpjH+6ccqwf6B9Dfi6VHmmB1YnhaLaxWrBfjNyjr2Z3kHhD+XrxOOQXpsvhjkan8bAuHOZeKxO+i2B1MfGAeywgPsbgjlWn+cdHW8D9iUzacRL+di/zeigylRz9waWF9QE6pfUEjh+hYSgHCF9BHCZM5zHbfPI11gdzJzI5G8bxmA6DyeVrHMkX5VB91E7Cb0T5OpB8GRrXV9oGVlcGchvPpOX43MPYOC71C0q3Xlx9PQFdUz+u3k4k4fFj+DD1FcJvD6grYxgOOL+0XCkHGmacD4cHGQ7YtBaW37DGM60OcXg3EWcKaVHSIhjD4Pg5UIPO3s5xPA78Dqp+2ISNZdIY68MRxx2LroulpaVVJR8F0b6l0yexVod39JOcEE+7Dsdodxx6eADpdzp8vV0sw8eldhz4UP3QrRzjGK4Jxg9XjEbSGYvCrly1fIVfXQg7buD6KxrfIXFbmHva4c+MDNdRbVw6Y5tMZ2zIdEwcX8alM67JdMYx6VAsblqi3fWVmj8O/xZkx1fN4jFbfTBhqQDCl5n8cMdiQfglTPgyk0fQZQn5LXHqp411Sfu9axrkei0T/hoUpky4Yn7XNsj14mHmOo3h2sWkTfsQnK/90YdA+p1MHk30IUF61a7BKSau6lSdGI5mG6sF+9GuYjwJd0pl4O+hTDHxaXKcCugUE+fpOp94tEnQe61M+GsJ1rVMPOAeC4iPMXA8WpW4ePr3i5g4YZrOdQR/sfc72ZRzu8M2HUh/uJpOvXpDh19LGa4Jxg9PC7EfTmcpkw6HdaggVkkQKyGINUkQ6wBBrIMFsWYKYs0TxFogiHW4INZCQaxFglhHCGL1CWIVBLGWCGJNE8TqEsSaT7C4aY/fMGqsd93IFJmuF13rk/5kJr5D4raQe5N9sABH38NjGTrtAPLtTvCUJ07CQ6bwMmqMhKF8wnwhlI6VFnu/k8250EN4SH+4vhBab+pFxyFLGK4Jxo/296WQ6UjUce1gbN/C8KHxHYLVwtzDflwdx8sAUMfpk1QcFz9J5Z66w7iEe4reSfhwT+Rx+Kkk/ELEgQuPvwqBw09i2hz3NH2MT3qYH74XtHy00AfL7zT36T7cpyPudFmH2znALVFC+COY8LifBz6cbmgfvojJDy5PeKIfJ+EPZfIT9FYoLIu2IT9Be1LUPG5GPKhe45WB+Q7SoXZU59wuCqxL0FmChMf653ZMLyJ+uG3R8Sm3IwfvCKXtnvtKBf5CQdDXKKLU7t2Q7X6uT3qYX1C7x/EbaffawS4ayj3bYLufy/CLUrs/OmS7hzo10u6bb/dcfx+23eP+/l0+XyYBXIyl/el6AvDCdQaPGfLIH4c/I6ANcDYkaCmda9N47k2/ioN1uZD4Ye4wJ9p/fVh3D1eXB3zlqhJeF9pR3XH2BtsIKO+EM9i2LCB+eA5J1z64fgrvmKX1Fdcz3E+9hzzyxI9Wob6OPFqvuoYfrYd8LEK7ffpEu9nHIjTcyZWBv4fyWCRoxxrG5D6o1OUTD+vCYe61MuHHEqyxTDzgHguIjzH8PsKI8493KsH9DibtOAl/PTLVk6f7p0t3R3JNsMikt/82yrpu2OZq+UZZ2lwBPkHgIAwOi10CUXJ8wtFi1+6syuB41IEqzX7Ts/FvbtFqej3yG0v88De34uiauhiTd8ivbmYHN/AtK9zclxI/3GyuJ354o8oy4oef2C0nfvhJ1w3ED2+2vJH44U2T8K0wamo2eglDHTD0vSn2+7m0nEdGD8+Y0cM5lYG/hzJ64F4VCzt6mOQTD+vCYe5FYfTAxdO/25k4YZqOoddrQx9PBukPV9OpV2/ow4zJDNcE40fbxWQmnclMOhwWfZBYb6Tc7IORFvJ7rE/6rUx8JwALx2lheAc9GKG2qN0Jbh/0/ZSXBjz84+JrN9LVDG4vje4B5zb9Jxg/2ud0hkxHoo5rB31QC8OHxnfqYLWEyAuejdE6DvlsdxqbCb6ZqeOg6xgTX+PPIgs2N6Fw9HN7N6PfMRKey8ctJB80zE0kHxD+XSgfE0g+MCfg00Xig7920E7XEO6Lvd/J5lzodgrpdxKuptrpGsKH6qfBISGuFlSdGI5m269p1GuOx1cG/h7KkPBW5MepgA4JcZ5u9YlHqzy918qEX0Ow1jDxgHssID7GwPFoVaLNDy8o3cykTZvfpwMWlHC6NzuD9UCbYBeTHjTXW0lY7aC53kbytNj7nWzKdefCNldIv5NwNdVcbyN8qH4abK64imH4iwgchMFhsbsIUXJ8wnHFPo2JRx2oMk44/9irftrSf8W7Hu8MrupthA/mEGTxEkx8CMelM6rJdEYx6dAFKe3gUHjuI/BtJN4NKN5KEu9G5Hce8VvB5It+BJ7DXBWAuZrx02V35oRaWn5mDFdxao45Exi2udDDXHD82wjW7XWw6GEuOP7tBOuOOlj0MBcc/w6CtbYOFj3MBcdfS7DW1cGih7ng+OsIVqUOFj3MBcevEKz+Olj0MBccv59gra+DRQ9zwfHXE6wNdbDoYS44/gaCdWcdLHqYC45/J8G6qw4WPcwFx7+LYN1dB2sdwcLx7yZYG+tgLSdYOP5GgnVPHazLCBaOfw/BurcO1lkEC8e/l2BtCsDS17CNcDwTfxPBuq8O1oEEC8eHuF0MVov3H4ZRm9F9wedyoVfzIP1OwlWWT20YtdkZrFesH7o6sYXhmmD8cF+E/XA6W5h0OKw1gli3CWLdLoh1hyDWWkGsdYJYFUGsfkGs9YJYGwSx7hTEuksQ625BrI2CWPcIYt0riEX7sqBxvb6e4V0HjeshHrZndFmDWz7h5gF+8wa8NHJbHc6HEM5DnT/o61kEa6jzB309m2A1M3+4vDIQa6jzB309h/Aa6vxBXx9JsIY6f9DXRxEsHJ/a3Hrzh0plIBaO3+j8oUCwhjp/0NfPcQZiDXX+oK+TBGuo8wd97RKsoc4f9HWKYA11/qCv0wRrqPMHfZ0hWM3MH7oJVtD8YXMdrB6CheNvJlhb6mBlCRaOv4Vgba2DlSNYOP5WgrWtDlYvwcLxtxGs7XWwnkuwcPztBOv+OljPI1g4/v0Ea0cdrOcTLBx/B8F6IABLuzMqA7Fw/AcI1oN1sI4jWDj+gwTrISc4j0c7A7Fw/IcI1s46WC8gWDj+ToK1qw7WMQQLx99FsHbXwVpMsHD83QRrTx2sYwkWjr+HYO2tg/VCgoXj7yVY++pgHUewcPx9BOvhACztrqwMxMLxHyZYj9TBOo1g4fiPEKxHneA8Hu8MxMLxHyVYj9XBOoFg4fiPEazHA7C0W1YZiIXjP06wnqjD60TCC8d/gmC9uA7WSQQLx38xwXpJAJZ2Z1cGYuH4LyFYL63D62TCC8d/KcF6WR2sUwgWjv8ygvXyOlinEiwc/+UE6xV1sE4jWDj+KwjWKwOwtIOT78Yz8V9JsF5Vh9fphBeO/yqC9eo6WGcQLBz/1QTrNXWwziRYOP5rCNZr62CdRbBw/NcSrNfVwTqbYOH4ryNYr6+DdQ7BwvFfT7DeUAfrXIKF47+BYL2xDtZ5BAvHfyPBelMdrPMJFo7/JoL15jpYFxAsHP/NBOstdbAuJFg4/lsI1lvrYF1EsHD8txKst9XBuphg4fhvI1hvr4N1CcHC8d9OsN5RB+tSgoXjv4NgvbMO1mUEC8d/J8F6Vx2sywkWjv8ugvXuOlhXECwc/90E6z11sK4kWDj+ewjWe+tgXUWwcHyI28VgtXj/4fnT+9B9uec9mdDvhUH6nYSrLJ/a86f3OYP1ivVDnz+9n+GaYPzomuP7mXTez6TDYd0uiHWHINZaQax1glgVQax+Qaz1glgbBLHuFMS6SxDrbkGsjYJY9whi3SuItUkQa7Mg1hZBrK2CWNsEsbYLYt0viLVDEOsBQawHBbEeEsTaKYi1SxBrtyDWHkGsvYJY+wSxHhbEekQQ61FBrMcEsR4XxHpCEOvFglgvEcR6qSDWywSxXi6I9QpBrFcKYr1KEOvVglivEcR6rSDW6wSxXi+I9QZBrDcKYr1JEOvNglhvEcR6qyDW2wSx3i6I9Q5BrHcKYr1LEOvdglh0zbHePrmrveugfXIQD6870VcFYyQODo8x/PbhxRDnevvx8oTzUPfj6Wv6pSZuPx733tiqykC/5SgefVfgBuRH30W7EfmtIX74vTG6/rsS+d1G/FYhv9uJ32rkB3nF743FSV7P8e4bfqObPXyI6gPrv8Xnv+MMXpPWjrYZfChVC0lnjWA6WF90HfpWwXRwnab5uU0wHYx1fOXp/1w7pF/34+zQ7QHp4PgQjktneZPpLGfSoVjwKrd28I4mbtdxEr7stRn9KveWWQMxOdu2HN2j72Nytg3a4lrkJ/lcBfArZvDToAtufzPOE6TfxeiukXqM0+p0Btt5E8+kuLxh/rQe4mcnWAd+WOsaxOpg/EyU6dqAfOP0uwK4cvnwa5s4nQ5GJxC+EsALhw/a/w467Ed+gjpMBemwgtKE9PWxBKO962Kpb/WS05fjD1NW42M9gN5mkHBgd1qdwXVwnQ+WQ37PIPdiCA+74bLjXDqdTabTyaTTxcRrxD5x6XCcuRN3oD/SY7iN5N1/qN/4KBL8ng79BAeE/+e0GuYmD5N7j8ivTbag9PCZCfSkIjz+jDFhbvDhtw31r/Qr4jcweZ4ewBkw8bkUmDOcD0E5PEjGxYb6YnZcDGmNJ3z19TLih8e5a4gfHpvSd22598vwPVpfg86NgN9+4yg8zsLhH25wHBX2mCGIy835qB64dIL68VtCpjOmyXTGMOk0O07i0uE40zmvdtgOvYrYIaivuE3iuHAeQJyE/zmyQ68NsEN0zk/HdtQ2UzsE6fnZIVo/IfybAuwQN3c4q+LPGTCxHcKcqR2C8G8ndsjQ+I61Q5AW18/S0ysb7WfHMnow3c/Sg6vXCqaDsaCtcGNNan8aHfvj+HSs7ddePzqBT5Nrr7juxkn4N6D2+gnSXnF9Dxqf0b5tLZMubTOOM3j+qF2QLVvrgxW2j4LwXwjoo4LmQtoFzfX9+LU5fJtaUanl2Q/LYe5BeNw/0vWvdSTs2oCwfnNXfd3nXZtdX8i5UN/7ncEO/NYznMFvAwp/UaUWjroY+Y3zpOvD9lk1XBqO8sF6Wu+DydmE1ZWBYSHPrQxuheDidk71BWeK0Tb+O6++6zb+4wk8Hq0n2l3t4ZmdQ+dStHyxo+VL9UMdV77AW5fvBxoo3wry20D8sF2m59Fhew4YWvf/IP0+xo9CWxpKe2lEn1x74fRJn9Nw/SPWZ5xgzJhYC/MvUt8hDO0TtIP2A20W9NfGxNeOju8g/H9R/zJmNp9+UHtzHN4uYD3QcyTXOzwXLs8QdpqnJ6iPuI3J1cdMtT7eSTjjtO8ylHYLSc9x+LVmSL+L4QO8Oxm/tia4drvZbKonU+wu9/XkurtLLQQfuNJ7dJ2UO18iwYQHXW80out0EWwA/rzc3Uiv2rUhv7uIXxz5AUfdhq6dNZD/3Yb4h9E/Tj/BhL+pUgvXSFkmmHTovKIZrLVDxJroDGwDXF+Ixza0L6wgP3zmaXZi7T5nF4NsXb93Te0+zie1gxli63D/J1iHMtx4lNq6Ow2lHdbWQfpdjn/ZdjJ+zdi6YnfGzZR7u/uK5XSpmC23OIP7hBhzj9o6rt6OZ8IbthVJztZRe9aG/O4kftjWAUfO1pnpF9PJMPrH6SeY8NTWhS3LBJMOtXXNYK0dIhbYOjwOouNUbOvoOLXC5AfbOjovey6xSYa+dMCuA1Kbivlqh+fQFaQnql+Kg+/hcTOOQ9dlIPwL0bj9mIk8P8jDeQw/bl8XztfxE/3DVZhwem0RbMuS0qrzrsmvKBXPKxVWlFbFHJ4ezSLNPp1OOSScdm3k3mrymy7fLCc40AW3OfUdrhIYiys6jE273pM9lWkTNs6b8nDbz7Rb7P1PNum4qSPtas084kuFnlZA+p3O4CpnYgsLt3yJ9UO7RzOPHlJJPQOmy9va3VAZrBvKg24h5D5WE0b/OL/cUjutN5AuZwL9HncWkcm6cGItPLUBYbaN4XYStHWmhQlfIn748VhLAD5dBrkcteMDybc78VAH8mH2q+Epl/tqOLZ/eBjlV/9xeNA5fcSDdRL0eFzrE8o86JE898gTf6eU1mvucTitu+OYdEy3kXEkP7he0i0DjT4u5OpjvcdeN/i0Mb/HXinkj8M/jh57rSTlyQ0f9mMbSDXaBrhywLqGYz0TTPgrKgP9uDbA6YnWheUMB64f4urCcp90tFtaGXo6ND6ECzOOMDM0D//Zbkh/uMYRt4TUK+jndjP6SYaxLZw95KYogMU9Kuf6Ae5xHJ7+0encNs+OBG0fCOqnuMfg2j7dS6YtpsdDQe1hqOlgrFsrT/+Pe79hTrEHjaV2TfSPD5+naUdxuK0HND+4DuE+5WHSp+DHJVxdo0uMEH4J6lMeG+IYgdrRRscIQdsDg/oF7ehnf8JsGx3j8NtU4fvtUMawVPJqVMav9JmOa4fL53WkfLAt5MqHfjvebzngdWhZBnN8E+L4hoC2hzm+xSecvr7eGRyO2iLH4ccvtAwrCIsLT7cHQPh3hBzXQ30wO6Zx2XE9Ln86pqnXH0HdDdpSRcv5c6icP0DaK2cXh9om/caTfrbc8Gt7vWHHHFH4ECs35vBrO9rB+I4LX2HwuXLTaxfUbicQFqQ7Gt2rkHu0zwkao2iHbckXJ/IYOH/cOAeO2McYYWx5o/WZy1MU2k2Yes2lEzQGMvVaKX3Fq4L8BNtWBnTfj3hyY16cvpb1KA8xgsGFp+uIFH89CQ/x2xx+iyy0B9qPTZr09P+ntrKRvjQoj9rBJyVbGE4xJgw9GnGDU0ub43wJ4Qzhf4H6XrrlnJuL9CNMus0ewv8aYa6axfN0nHB2lHs8hh+BAR9u6/OdJB5+DEfLnMOmj8I5nA0Eh+azFd2bwGBzj4K1LPZ+J5t0gAePSvF237sZPnES/p+kHt9DdBqkMy0bmXTxUYkTSLobSbpP1cvZAzGBGx7f43KnZULHnZRnmfhD+P+hMdiTpN+rODWH+8f4JD5tPB+4K4DrnQxX3Gb6KwP9q3XcS/epr33P5rliPpjr/ls/5MfaA9YxKgP1w9kP7vWFRu0H96i+Qvy4cXuLM9iGheljcDlw4em2SAg/AZUzzJWC1ik1PvRL3DqE36t19fopbv6Kn0NMncTj+r2yBZ+Wpc+wLkbrFgdO4tPWDrfBgxpM+2KftBMo7UOJDrm1DMnxH1dWk5yB+Wr0dRUcn76iYOLVJJwm1z/TsX6jrybh+H7HAIC/dobHs6HnrpB+J6MTE3PXijNYr9yrtxC+nwl/e0D49Ux4rtzw3LXi3cNzV0gXz13Xk3vNvJbW06BdwGvBOPxPptYwe4ldwLzoq2fYZkx2eC6OE1xGCSY+3ZNgal44meTn9oD8NPq8FccfrtczJ5N0/OrNyaTeDPX144+henNaQL0Jeq0+6FXHMGvqQWVwS8h07mgynbCvbj6T69RlQnXqLahOXRkwznum63mdYDrcWg/tt6h+sR+kQ+8FjZMqJD9+9eb6SXyaYesNhN+H6s0NIeoNVwZ+xyvhdIdrb85w2cMgLG7sDeG5sW3QGKzChOfWo7nXKaFum32dJPz+EEi/k3CV5VMb73JrBP2M7sY6tbWPfGmlm8odXyqsWHPDKloYAJggSl5PACG8Q37TeJpUGwlzO5OGdviMD1yREiR+hdyn+GE41Qtbz59rhP0++XSccI0Qx2/0PEX63imEvwctooQ5YwFXnjBnLARt3KG6hvudPvHwojH2w3k+PSDPEH5bQJ7X1cnzxSTPfme54d80XIzJw2iH3yQRdA7MFGcg90brE44/XIOVKSQdv859n8/isd8G0iXIH4e/B3Xuj5LOnRt8m86/33lKOF9LUBi/Mz/aGEzt6IsfEP4VXt4NL/yw7zBBWtxCKd4A/6pJ9XUTVOYQ/lZU5q8NUeZB7Yc7JyzIVlg9kHFLyTB1HKdv/UDm+y0DlRx2IEPjBQ1kaFi/Rt3sQIbj5Be20YEMngH0k7CN7hjB8SGc2d1UqUE7lPFTHdyY6IzsDpQHroP22wna4oNPOwCI3+ajO7rDAsJ/EA1ips5++porqwN8+DlOuLLC8Ydrd88BJB0Tq7ja0RWN4R6s+9VBeBum3iDpCw12mHiSgMMvRB3m/5EOM+wusjArtbTOO064Ff6g9ha2/VAdtTGY2vkdSvs7MoAy88Zqd3L/PbXrDt35Q/pBuyo6Gb+mDuHJlt1kT082XU7lc6XuHtpHAld6L8wTvUOZ8GZXjDLsITz9SK/atSG/CvGLIz/8ZJAeTNFviH8Y/eP0E0z41SgPjZQlh3X6ELHgMAlusr6/bJnfIs4tyB+H/0vAggZ3+DF3YC+X1ztIvDsY7tpRm6jdYu9/vZpUruMgPSifUQwX+qYPhP033iE0e2Be/Hb+tPnkN+igzxbHX3c0jVYm7jXOQG7rQnDjFp4wxhofnhpjuHagcOkc3GQ6BzPpmHzyhdOsNx7rmlyLg+2N3xOpdZWaPw4/DY3HEh4m9zYv3XnHLaxyB7dT3cPOOxqG2hsIP8XjxO2UvoXkGeczqJ7h8Rjm7LegdaDHYX8uaNE8tzm13b3YPp5Q4fNc70BkCN+PsLh6RG14BcXv98HyWzT3O/Tn797Kra4rs0g9hw8h+OX/xMpATAi/GGHObRDzJB/MYybXMOeTtoM/2DDV4dPTLsbco/YBx4dwUBdNvfUN+Deawa9+aOgGRhc4T5B+sx+Pw2l1OoPLyMRCIpe3oHLGHwChb0pxWDc0iNXB+Jko0+UB+cbpdwVw5fJBx0BcOlMZnUD4FQG8cHhow7juQ1zQIf5wo6AOU0HljT8kCekP5eNRoLepJBz9eBTW/Y0+WA75PZXcizn8x6O0zez3Ft/GM/lbRHC5ssP3aP3H8SEcl068yXTiTDpBWIsYLNq34/BxJjzkA38gdHjWtmv1cyXDlVujG0r9BL0dRMLBuKXVGdwGV/lgOeT3QeSeX/2MMWnQD9IEtUvtxjMY1K6vDEgT8qod9wYshKMH25bIeNWMrcpl6YdqIQ2c9i2G0g7b5/s9R8C8ubfZm1k/TOXLmUIhnXR73e5yPt0b1L655yEQnlvvOYIJD7o28zHMXCboVAhu/ZCekBVHfsCRWz80Y7NymTD6x+lzpxTS9cNGn20FzY3DYsH6Ibb70LaHy9YEYXFrfS2Ec7vDP9uktgzCL0Xzf3jzLub468Fh7rU6g+3UmZWn/3N9Ke1DVjF5xfeo3nB8CLf/bGWyu1Fb2emjk8UyfAJPFOP0Sp/N4rjcs1b60Y5G182jjoXrNv2QPPhz/yEdeo+mQ8cLOB1Tz+HDtJOhpoOxYAxp+nk/rCWa7ZuzJe5NUnB0rZqrNxXkR8dK/ciPlg9+VknfhNuA/K5F19TFyG86Pjh4dg2XhgPHbbaj/V6jH+VczvDh1p/wevyeyXyaeD0er4H47Y9YgNYpHw5YU/TbO4TXtjFXv70GT5C5wv74AG4Hkz/BNlLkPqgKjjs1ibYR7sOOXPuhbQS3H3riOXZcOwBd6HZwYQPtYBmTD66N0P01a5l8cP3BMuKHbfgdxA+PH+hbS9hWwulrLSQ97bj2Sp9BBOXZ9Hi4g8nr/qy79LSqdYzewtZByJOug1tD1EE6FqHcqA6HMm+gYagdhfAfDnhuuArFAcy1CNPvlDJsW/GYgtpWCP8JYlsNrcmxtjXMifnDsVaI03Mcft4RhVMFufm2XruEj2UvXZ4vHpe/YeXqpaVWokrc9DlTT8PjsA7jFyP3biDhTq0M/A3NgTZhih1D6XJbTLkliqBtSdwSyiomXbjXyoRfQ7DWMPGAe9CSDcbglsUBg4unf1/nE8dPV7iboLoKeoH1jjpY9J2voPd51tbBupBgBX03eV0drEsIlt+HOrRU6mDdTLC4b9sCVn8drFsIFo7fT7DW18FaQ7Bw/PUEa0MdrFsJFo6/gWDdWQeLHsKM49OD3+6qg3U7weK+6wVYd9fBuoNgcd9DBKyNdbDWEiwcf6NPPNxVaxfm0H4z37l002G7Okh/uA7t5/TOHfwIuruH4Zpg/PCjYeyH07mHSYfDWiGIdYsg1u2CWHcIYq0VxFoniFURxOoXxFoviLVBEOtOQay7BLHuFsRaKYi1TBDrRkGs1QSL297H2dyxnmi3ctXyFSVvfuEQFzQf0L/X+KQ/kYnvkLgt5N5EHyzA0ffwGJ9O1/EBmNx4HPDohzIO9pY9RzuDH/MtZ+JrF7Ql0PD2xdBTW0h/uLYc3kj4UP3Q/n4FwzXB+NElkeUh05Go49rBnLeF4UPjOwSrhbmnHbcFjVtKayF+kB69F7RcSF8bgfHAkaje+71Owz1C0I5u6YfwSYRJDwIP+zFICL8uIM+YDzfHhLhmHy1ky9xSJzhumZ4u7/cjP7q8j8cOdHkfjwXochvu27FOqOOWXfE5LWEegdH6Ari0voCtpnYTx8WPsrhtsPNJmpy9wfdom8DxIRyXTrzJdOJMOkFY8xksCM9t/wjalsltSzS8xaO6LZPbcsqthw1lWybobQ4JR7dlctshKZZDfs8h92IOvy2TqyvLfXhCuvXqCve6AcXCjwpgjU7708cPEL7k2WAo9xUkb4u938mmXG86aPuH2UdTvaHXPPy2dmDe3JajprZg5tKum0u6pVIyk8wXk0FtmdtyBOG5LUoLmPBmH6X0JrktmHSbZRvyW0X84sgPOHJbMM3Yp95Q+sfpc1t36BbMRrflYb+Lh4gFWzCxjaevF5i2TfT1xBcxY8jh5tLv/V4eMJ7l+iY89qTPPrjXb7hXOGi+Gn2FY3nIdBY2mc5CJp0uJl6Lz39Ih96j6XCc621fun1KLQ6u335zD1j7j5PwP0Hbl9Z519w2DbrmW29bAG2vEB9vCwjqlyH8nah+0m0BK0iecT65egZ5bmPypR3dFgDh7yVjA0PbbNltAbQvHv5xQ/i1E/p6hqFX7tygPoDbDhRyWwCt4lidGI5mG6sF+9VbIjm5MvD3ULYFcMOdoEfdXNfNPaZbwaQL91qZ8KsI1iomHnCPBcTHGNy0BDC4ePp30SeOn6646TY3LaSPqdbUwaJdI7cFArBur4NFtwUEnTiztg4W3RbAHcsLWOvqYNFtAUFbDPrrYNFtATh+P8FaXwer2W0BGKvZbQEYq9ltARir2W0B3NAgaFsAjYe7V+3CPMrHj6kEH+WHPl8d0h+uR/mc3oMe5W9kuCYYP7rkwW0Z2Mikw2FVBLHuEMRaKYh1iyDWGkGs2wWx1gpirRPE6hfEWi+ItUEQ605BrLsEsZYJYu3vR+arfNJPMPEdEreF3Ev4YAGOvofHv2EemeOxqt8j82+OPDIX6VefqY/MYT7YwvCh8R2C1cLc0w4/Modw3Fs03NwFwtO3LygGfawN4X8R8Fibm4sFPdYOegMA8+HmufT0YW6eyy3X4zeGtGtDfoL1usB92xfrJ14JrwvtqO64OSEex9A3xILeLMPthY6r6tWroMfZEBcvbXLz3ZkkzUbfyMbxg06ljjeZTpxJJwhrJoMF4bk5atDjbG6OCn0F/Vb7Yu93sjmXCqpr3Dx3KI+zQW8zSDj6OJv7njTFcsjvGeRevcfZuExX+PCEdOvVFRw/qE4ubzKd5Uw69HHQIV5fYfiEl3TQ95TNnq6dC/0YHNLnthYB707Gr5nH4OVcKllIl0vJ7nRfXyFZPUmbW/PC98LYjLlMeLN2Icc+Bt+A9KpdG/JbT/xw3wccucfgGwzxD6N/nH6CCU8fg4ctSw7r9CFiwWNw7mTr4bY1sL4wx7M13GNw01zMbnHMudxnmsBx9oS+BY7bb6NvgePtiI28BY51TtdaGn0LHH+6K8aEoY97IXwK1Qn6uJf7jGHQW+CAiR/3Ys70cS+Ez5I+0NB359nHvUGf9Avz3KjR78GazWPj7YBus8B2nW4Dxn0WfUyO19GWET/8HIKebMutjXOv2tFTZu5FfnRr8SbkR+f02HFtGcpFt4eN02u4NJxD0sT1ho5jsM0D/XJbPuaha+wHXOk9Wt9w/GU+8TAf7Qyf1uuaPd2pdqJy0NYErv4MdTsRTquTYEnrLihvQduouO2jQVhhtgRiLMPbX6plujIg35wN4rhy+aDr9Fw7m8foBMLfEcALh+fWxiCu4b4u8BRi7hWUoawPgN4WkXD0lOyhnEK8iNzzWx+A8NxWwzUMpzBb7VbWwaJ7Tfz2zfi1N4xF95pwugqqdxiL7jXh6h1g1ftcKt1rwtUZwOqvg9XsXhOM1exeE4zV7F4TjNXsXhOM1exeE4zV7BEUGKuRIyi4+aR23Ho73mZ7B3l2AnHxsxC8Dk5fG4Tw7zmghllB1/R1RmwHbnUG+uGx422EP34mBjbJ7Kss4Z8PQvqdhKswHzfI9nLb5ENuC6UnZ2B1YjiabawW7EcfA9JHu8tJvKFsC+W6jBsZzKAug8bDunCYe61M+BUEawUTD7jHAuJjDO4jFzT/9C0wfe9mJm36FtgDaPlhKll+4NLC+qBLINyOdxyGcoDwuwKWQCBMm0++bvTBfB0yOXsP4DEdBpPL10qSL8phBeEA4R9F+YLtD44zuL7SNgDLp3R6QLlz9zA2jkv9gtKtF1df34SuqR9Xb28m4WF7jZ9OaV2B8K8IqCs3MBy4reF+HGiYlT4cXsNwwKa1sPyGNT47ItrQNWcKaVHSIriBwfFzoAadPWgOFAd+B1U/bjeJ43OPFgPExR+iL5aWllb5bRmhfcsyn8RaHd7RDzZBPO2iun3I0MeuArcPcR/m4g5HpduHuK0kjaYz1O1DfuMGrr+i8R0St4W5p51uLG8bPTBc0BBYu+srNX8c/v3ITtDtQBCm1QcTpqUQnjv9h1v6hvD3MuHxci6kD+MhvAx8r1M/bWwwqF3d1CDX+5jweAn5HsIV87uvQa4XDzPX5QzXLiZtaqNwvvaHjYL0O5k8mrBRQXrVrsEpDK7qVJ0YjmbbzyxQU0SnBadUBv4eyhRmM/LjVECnMDhPm33i0SZB77Uy4e8jWPcx8YB7LCA+xsDxaFXi4unfL2LihGk6mwn+Yu93sinnhv5GDaQ/XE2nXr2h3fsWhmuC8aPLAFuYdLYw6XBYFUGsjYJYywSxVghirRTEWiWIdYcg1jpBrH5BrPWCWBsEse4UxLpLEOtuQaw1glj3CmItF8S6URCLvqXEvcHhN4ySeEvpPp/0JzPxHRK3hdyb7IMFOPoeHsvQaQf0C+1O8JQnTsKP8T4IzL2ltJGJr10Xcw/y08GkvT+G8JD+cL39W2/qRcch9zJcE4wf7e/DHhgu9ZYSjO1bGD40vkOwWph72I+r49xHLuhTOxyXe2pXYXCDpuz93n28xIExlldq/jj8Qajt0CUO7kly0NR6AxMe98UV75p78ryB+OF4MM7oAuxKzQ/CGX7jqcS98YTzG68M1AX3tBuHp7rjnmjj8QKUfYKEx3pMEH3hNKm9w+Wh61/X5IHhuLccwtgtnLcEgwXfp+QOVG02HYx1I0kH7/zAT8tTU2u4WCe4HeExcwr54/BnTq1hdnvXQTs/6IG6OdQOPzbbPz7okjvBhH5vDdcDOi6rMPnE+qP2AsK/APH8JNmpjdsl/u6edm3IT7Bdlrl2WallY1C75GwUDk/bZVA7xjpLOIPbLJ1rcbuP/L6dhnXYzoTHeHQ3+CnMeIj7ll6FcF/TIHeuP+LsDD749wuTnr4eTzjQ/sCvD8T3aPvvZ/JGsVoZ/rhd03KPMWlz4aFO4MfcnP2Ok/AXorKaMJvHdHw43OHDud0n/AbCAcJfytSXIDuB6/96ggnhr0CY9JDGephLfDCvDhircO20H91rtL+l45EK8ruL+GHutN+8E6VPy/SqysD0MU7FGegoZz++tM+tx5f2R+B3M+rPrvOuOwiesC1PB5Xl4Ux+wpblHQH5p1gQr80ZXF+D2hDW14qpPGa8QczVzJiAG+vAt03bEY8gG8p955SOk3BcPE7ixhZ+3xm+g2mv3FgBH+KvXRvyE6tfbinJjRWwLuIo3TC6ozalnwlfQWHoGB6HX1EZ6Bf0UT6pvvhVkwbirgvA1dfTCY+K95sbQ+rrAvLH4TcH2HFOh0E65+ao/SgMfTutgvzWEz+uTketvmL90PoapAvtGp2v0/rK9U9cfe0n6QTVK+2C6ivE1fV1X8DYEdLn1hboc4p6dYauFW9AHLjwdAwE4Z8IGFdxfRz3oZewfRzdDhKmj8PtFuvkrMrA/ED4V4S0596l4bmf63LtA+uVto8gHWpHdc69GYB1CTpLkPBY/1z7uJP4Bb3NUWE4hG07EFfX2+uJra/3kR46F8XjRFpfOVsP4d8RYOsrDIdm+le6NsLpNch2RK0uR8XW0zUOztZz9Q+vX1wWYqwRdCJUhQm/juHPrYtViB+3Lrbf+nmfsveSesrRsg9qB9o1OkaiZY/rxVrih9eIKiSdejblLJKPejaFrrVC+K82aFOC6lWQLhu1KZh7kE0ZnrXRaNerIJtSIemE7avq2aCTyfgRp0lPhqswaQY9+6pXj6h94upRjOGF7WQHg6vdYu9/skkX9EymwxlcvoJrP6H35kH6nYweTTwT58oV66eV6Ge9GT6ZCc7gtqLdDZXBuqE8Kugax4e1cO0uQTj0ZB/8Bit+dvaXEM/OuLer6XrAv9Da2d8JJndyUti2D3E1bs8knivGDTq5ph9hceErzsC8Qfj/BswBOfvJ1S0IX28MR0/HwvUh6Pn6Wp90uL0EXL9cDT+tlteg+eHwPLNPufv7mX3Fuw7zzJ474SaornInM9D2iuNy7XUNyhfXtrBNwByBh3bLURi6bsKN77jTA+j4bgpTj4J0MRHda7Rfpm2m0bk4Vw5BNoMrm0F7clD+qc3oR3G4MRrVKYQ/NECnnB0K0mk9O1TxroPsUFid0td9IJ2wOoXw8wJ0itfvwugUwh8eoFNOR0E6rbfPoOJdc/ab7iuuMFjciSmUa1idQvhkgE7xCYphdArh0/tRpzjPd5J4FeRHx5zU3nX6xJsQgNnvgwn3cbx1TB6CypKzabQsjw4oSy5f/SHztV4oX+sbzBeEP85Qvtb45GtNg/nqr5Mvv1OPT2HyxfVhfvNabs1FO7r2D+HPCDm2e7asmdF1MW4cHrTnKqi+DGV+cxBZ28D1k9YBfOJP0Dod3Vd2ecg6gE+s1a4N+ZmuA7gu0zrArTkHPXOrMOG5NecEEx7myVwdoPMtqTowddLAcKb21kLeqJ7wPAKvUdB5xHqULtcWafh+736bw4836f4TCL8c1dcJaK8q1S9e07hxGp+2X1uhaxoQ/s5pNcxV3jX3Sjndn9Co7cZ69rPda0Zs9wDbDTrjbDdt00G2m3v3gzthmjvhFr/78fDE+vwrTFwIz435cHi//Qn3BIyNuDUgrKe0D+YWVO/vmzYw/7gcYb+TDvfQNJm0twfMHbi5AHcCO4Svt7ZD9w7heQXEpfmmZfUQsQvc8xGqEzxWxeHpWBX74fTrjcE3MHmkOmz3CY9tJQ7/MFPPwux94PiF7Rf7EVdq04O+LqQdrQtB4wacLvdcidp37n2N/feMMJXibDHOL7XFFUYXQWvWXBlWUBi/PZGcnca2mLYP7mT5sHUF4uq6coNni7m1q1tC5A3faw3gT9sK5OetqK3QffPcemrQuL26ByfALnJ5CHpeHvaZLzeeWR8Qj3vOidNa7P1PJstNOUgP7NYohotff/kBbMdm81xbBvFtznF9ZwvRE7bBgrYh2ULSc5zBcwXaN3H9zWIRPrVnstw6INfuzH4pyC3jZ7K4/uJnsrhsuPEDN/7F85FPkb6LswEVhOsifxz+C2hc9lkfTMdp3Hbi/bkfnTAQV3qPWsW75mzLBuLHzQ+D3tcBDtzeWBy+gPxx+K8j2xD0XuSwPPt0y/t9byzojNsbS/turv7huuD3BSm/cSh9pwnC/yhgHBq0P3dtg9wrDHfazmnb+VSIMWoz+3OnI38c/tcNPmsdrr10OB7+8shT2JWaH4Qb2Z9b88PvC0Ga9fbGvYrYbu4dI+5cC1pf/d6bPxD54/BPBtS/ev1So+u19D3AsHuE9/u7QEk3tb/XzKDsw+wR5vZFceef4HfRNnr1z6Qes7lkdUwLZQj1lbo25I/DJzxD2onyAf/bmuBZzubdcjpfznfni8VMIU+/tKYdlNkYA+mncrme3lRfMpMtFsrFTHq40y/09fRlSn2FHjfTk84ki8Oe/2Kx5GbcbG+ulMkUe7uHO/1Mdz5byGddtzfjljJu3fS1PRjj1UX8XrF2Pd593a5moi+wtRA8uIZ5ErYJgvO2QgtJz3H4eSSk30m4CvOpziNbCZ8WH313IA4G+PS1EHzMJ8boB8pyDOMHWHBuFu6PxxD+kEccHl9DfHzvKDJuHoPCwtk+LYxfjLkHnHU9XUDqaRsKR8/yiTNpgl97gN+oAL/RzkDu2K8DxVtJ4nUymE99EZ48T+HKFtc/ejYwrfsYa0wdLPp1LRx/DMEaWweLfl0Lxx9LsLrqYNGva+H4XQRrXB0s+nUtHH8cwRpfB4t+XQvHH0+wEnWw6Ne1cPwEwZpQB4t+XQvHn0CwJtbBol/XwvEnEqxJdbDo17Vw/EkEa3IdLPp1LRyfnic5pQ4W/boWjj+FYB1QB2sdwcLxDyBYU+tgLSdYOD7E7WKwaP88Dd3fH/0zpN9JuJrqn6c5g/WK9UP7w+kM1wTjR+3WdCad6Uw6HFaXINY4QazxglgJQawJglgTBbEmCWJNFsSaIohF7Va9/vqyytP/g/priIfrLg4XQ2G4Phpj+I0H8Ni83rjgLMKZS5MbY8IZSnSMCeliv3bCDfuNQn5jiB8eY1K734H8xhI/PNeE/OAxJp3b4bzRvGKOHOdO4ofnFXHih3U0mvjh/qOd+GH9Qb5NzKn7ij2FZG/aLebz2WS2J9fInJrOsXA86I9pPV88RJ4DXcFtYXhy/TGk30m4yvKp9cfcXIGbz4F+uszoJxlkv7oY/QCfcUb4JNNQVxJM2sAV+j08H8fhu5AOcXh8DfHxvYdJfeXmGwnipx2dq3NzJHyvdT9hcfMtrDcoU21T7ie6wPW1xec/4NJ7lCMuT2rXxwimg7FgrYFrT1oWe7+TTbl0CvIxjskHpI3rlVzb6c6GtXWQfqdjtC27QXUY64fOPRIM14QzuA7fVamFq1e/cToc1r6IYm0VxHpIEGu3IJakvnYIYu0UxNouiNUviCWZx12CWJK8NgtiSbZHyXLcIogl2Yb2CmJJlqNkXX1EEEuyfu0RxHpMEEuy3kfV5kjm8XFBrA2CWE8IYknqS3JsIlm/ojoulKz3UR3LbRLEelAQ69kwlotqvZccm4z0aY1hRXUsF1VbKDmWk7SFkuUoqa+ojr/uFMSK6vhrmyCWZNuWbEOS+pLshyTbUFR1L2m/JNfloro2JFm/HhTEiuoYM4p9h76mz6wk+o7xPtj4OujZMJdOC8OZe6aM95p0OIPzK/lcGfAnGsKHfHP7UHGeIH36jBn8uf+ARf0grU6CJZw3NyhvQc+i8XN3rAM/rAkNYnUwfibKNBGQb5x+VwBXLh9dgjqJC2K1Eyyu/XPPbyE8t3+aqydB+6ehbPFeQsGyTQWVLbcHW+9ZgH1ZxVLf6iWnL1/iEBcjegC9XUjCwXsArc7gtjHBB8shvy8k92IID7vhsu9dTDwIZ3jPUCqsvYT0OxmdmLCX40LqldtvNI7oHLefmyq1axwW9jMFvZvD9Tdm+96edNjygfSHqz8Lsuva0fIJY9e1u7tSC9eMLdbuUUGs3YJYWwWxNgti7RPEkszjFkGsfkEsyTqxSRBLsk48IIj1bKgTOwWxdgliRbVtS+peUl/bBLEk8/igIJZkOUrW++2CWJL1/n5BLMk68bgglmSdGBl/PTNstGRfe68g1rPBFj4hiCVpc+4TxHpYEEuyDUnqS7JPi+q4MKp9WlTnVpK6l2xDkvqStNEjfcczo++QnFtJ2sI9glgjawr7rw1J6l4yj48JYkV1PiSp+x2CWFFdL5Qc54zYif03nhixE/tP91G1E2HGX6PRPXr2Ire3AbAm1sGiZy/i+GHO2cNY9OxFbo8HxJvskw4+b4Q7W0+7Lmdw3lq8/x0MvvR+JZwe5Anfw+l3Mnk08ZydO7eQ+9Yw6G4KwzXB+NE9ZdyZhlOYdDisCYQDrufDVH6poZbfBDN8AsuPsx+Nlp/fWVbg70RY5+37QeftTepcu9WVp/9z53rSfX8ch8kMhwQTH8Jx6UxsMp2JIdOZ0GQ6E0KmY0Jv9De3twvKEtoILufF3v9kcy4D9esAwguna+js0tBtE9LvJFxNtU3ujFqsH9o2pzFcE4zfFKJXA+WZ3o9n44Yuz2fK2bhQfuMZvdLzQzkO0xgOCSb+tIB0pjaZzlQmnQ4m3mLvf7Ipl85QHUPaON0D0f39UT8h/U5ncJmbqJ8HEj5UP7R+zmC4Jhg/8+WZLHcxeaDlOcOM/kKXJ6Tf6RitX9XynEH4UP3Q8jyI4Zpg/IZQnqlC2U13l7LdyZ58prvYk04VU9lkMdNddt2cm+rN5NLpciGTK+ZS6XIqmyp0MXmg5XmQGf1lwpYnpN/pGK1f1fI8iPCh+qHleTDDNUH8tIPxXQvjF2Putfpg0T6hGSzt4BsiBvuBblr3gTtOF+dvf9gNSL/TMVrv3aAyw/qh9ewQhmuC8ZtG4uHyHB6dp/uGqnNDY9VAnXPjpUZ0rt3GSi0c9Ysx91oDsDYJYu0QxHpQEGurINYWQax+Qax9gli7BLEk87hZEEsyjw8JYu0WxHpYEEuyfkm2R8n6JWkLJXntFMSSrPfPhjpxvyCWZP3aK4glmUdJ3W8TxJKs93sEsUbsRGNYUbUTknl8TBBLcjwRVd0/Log10oYaw7pXEGukDe0/3UvO3SXnyPSsMbyGRJ+DNbouieNDOC6dqU2mMzVkOhObTGdiyHQmNJnOhJDptDeZTnvIdEb0NjCdsHp7prWfZ1p+pjeZzvSQ6RzYZDoHhkxnRpPpzAiZzkFNpnMQk04HE2+x999Np91ksph1y8Vyujvbm+pze9I9PeVMOduTyxTL3Zl8MVtyM/l0qreUTZbdXEk9NU0Xsj3l3mKhp8x9wx6+Oafb8oUHDcwPfEMU7ynG3+xsRf44/FcOqmFe4l3Tb5Y66LqD4LU4ks9JUqG/dw3pdxKusnxqz21aCR+qH/rcJsZwTRA/7ehzmxiTToxJh8PaJYj1sCDWTkGsLYJY/YJYjwhibRLEelAQa4cgVlTLUbKuSrZHSV6bBbG2CmLtFcSSrBPbBLEk68QeQSxJfUnaL0le+wSxJMtRkldU+w7JcpTUvWTblszj44JYGwSxnhDEejb025Jt20RfC3NlPJ+D76mPJ/H09Rji14b8MAb2w/zaAvjh+G0+8Wg+YD5q6v05wB9tBr/6TYBRjK5wniB9mF/GUfgWn/+ARf0grU6CJa27oLxh/rQejEJ86LonhzWqQawOxs9EmbYH5Bun3xXAlctHG9EJ185aGJ3A/dEBvHD48UzaEBd02IH8BHWYCtIhbouQ/lC+pwB6W0TCwZkDrc7gOjjKB8shvxeRezGEh914gsHZUdqe/co34RNfu66AdLqYeJC/MYjjTOQ/mqQx0xnMcWYARxwfwnHptDSZTguTDsXi1ky1u75S88fhv+utk+o8rJo1EHMWw48rK7g/mwk/C4UBPpxuZoeIp10XkxZwgnY8B92XtoU4PeCL7+H0OwlXU33SHMKH6oe2jbkM1wTjR+3CXCaduUw6HBaU53hncPnS769w9W5WQDpdTDpm60IqQ3WJHfgdxuQR/OYhP1w/qIuR3zhPus1+ZnYNl4ajfLDOgVvU9DSL+M1D4eGcGvCbj/zgvauh6PD7DegQlxXwBpsK35r5qbfB46m+9uCBYeDMgvaDa2FaDx6YxiwmX13O4LZOv18zl/HT+D/0+EDbw3WP9n1Y3zHmXlDfN88Hqw1hdSAsOMMoTsLP8fQBdXM+wpWrmz1Z0NsCxIn2JYcbSjtsXwLpdzF8gHcn49fWBNdyIZdMJ3t6iqWeTF93ptxC8IErvUfHAwuZ8Nw3hEDXixwjuk5Vv7NYqeEvRHrVrg35HU784sgPOOp6f+2sgfwXGuIfRv84/QTjh8/AaaQsE4zfxRUZLGwPJLBGDRFrojOwPWGbw9lMuh+rUZuJ488LSGdCk+lMYNIxa1NTOc6mguNsGP3m50Kf/FPH9emQJ902j5hTw6XhKB+sc+A23hmsJ7p+M5/wofeC9q1BOCgPXPcEy6OX6txh8r+QySP4YZuM9UQdVx6QJ10eixsoD6xz4BY1Pc0nfniN5JLKQL8jkF+j41Ssw6VDrNNUh2bGNKk81ZPD8FrE6ILqSV83OieCPGk9vWuIdW0R8cN1DbiNd/xt2FD7sIlMPrh0JjSZzgQmHbNjl1QfV+7guHKn/cGRPvmnjqsTkKdG+wOsc1runK1scQbX+xhzL6g/oG3UzFi4dkYNtkk0/0cyeQS/o5Af1hN1XHngsXMj/QHWOXCLmp4WEr+jUHjaHzwH+TXaH2AdLh1inca8Mfc2hx/bXFp5+n+chF+N1jBWkjUMvKYDaetwbyPhFjK8zZZt+HVcSL/TMWkja+u4iwgfP/vB2U2Im2D88HM6WqdjzL3WAKyg/om+n9Bo/3QAk07U2vkBxA/bQ1w/qKvXlhtZx+XactT0RNetsD2k67hS9rCRdVyuT6H1Nqw9hPA7ybqlIfuVnEjyhdPi5jFRt6tm5iPBdpWzQ43aVTw/aNauQn3kxpn0faxGx5lTmXSiZi+mEj+pceZnmrQJNo0zo2BXub4p7Jgw7Hj0gsrT/+l49N1oPPrOg/15HYbS/tfIeJQ6q8ajUJbjncF1jI5HD2PSOSwgnQOYdEbGo4P5YJ1H1W4eRvxsGo8C97D2EMJ/O0Lj0cOY/Jt9FhXerkL6nc7g+mzCrnLPjTg7xD2DgbgJxo+ORzn7vYhJh8Oi41FcRnQ82uhzsKlMfgw/32no2QTmyPVtuH5QV+8ZTiN2lXs2ETU90edg2B5Tu3ok8mvmOdj3h9g3+c2R640J5zNpmC2HZCms7aJ7gAzZ0qrtWkD4+LV1vYcdzjlaUlp19uq+pdcWTiutWXnssuLZ+RWrrs0vPbZYXFFauRLnBqfQxeSW1hYaBq4TzH2MsbBOLuiX+nApLyRYi+pg0S/14fiLCNYRdbDol/pwfBwX/447g3nC7sDWEDi05XK8LiG8sLWko5mj6mDdTLBw/KMI1nPqYN1CsHB8HBf/jjuDeVJ9BeFocevwWlMZyCuJ4rsEK1UH61aCheOnCFa6DtZtBAvHx3Hx77gzmCfVVxCOlkwdXrdXBvJKo/gZgtVdB+sOgoXjdxOsnjpYawkWjo/j4t9xZzBPqq8gHC3ZOrzWVQby6kHxsz7x/GwZtg1c280if66u4rLHee5i7tHeNYfuC/ZmxbC9K6Tf6QwuFxO9a84ZrD+sHzoz6GW4Jhg/OjPoZdLpZdLhsBYKYs0XxDpCEOtIQaxFglhJQSxXECsriJUWxMoIYoEd48Ze9CS7RmfeOD6d6eEyl7M56erbD7gvAQd+OSaPnO3BdpE6bjYHedKzuQ1za7g0HOWDdQ7cQE+4Pu9PPdFZJq5f0C+D33ORX6MzYsiv1uEbG9Ahrk854reIiWtWv+FX6SD9TmdwXTDRF3NjeK4Ng+5SDNcE40dteNCYCafDYcG4jptH0FMvk0w6yYB0DmQ4G25rKapL7MAvzeQR/LC9x/WDunrtqZFVOqxz4BY1PSWJH55v0VU6PN5sxiY1skqHyyqN8KkOcTj8pjs3f+Z4tTA4SRIW/FqZuPRUVuxHT3/l7Ae+R9vbDIZvFxOP2mVsD/aHXYb0Ox2j/YQbZC85vXLtIEV0zrWRFuKH00kz6XBYdAwQ1K+aGd+F/yIopD9c/SrXD3FfBB2O+u1Xzm4An4wZPtW3PLn1K27cod+GaHcG1yFurY3y7kb4cC/MmIeuize6bomx6Lp4o+uWGIuui3M6oOuUL0dv6e88ZGAYWNPdi8Ls9q65Pgv0oMO9lISj68PadTiDy2d/tH1Iv5NwNdX2uXLE+sF1e5QTXMdwGfs9bziKySut80fW4UTrPJcWVycgHFcnuKeSOtwrA8IdwYSjGFB/8fMvekoFhH2Nh6HHak/O5dMFDO0M7yIJXWfpLjjTuzW4tZyg3Rr7c/ewBFZUd2TQHVzDsdMAEh3qbg39FBx2kqin4Or594X5pdcW86uuXb7s3NKNq0srV7UR2MN86MBvukEVksI4TgBd7VqJ33zijx9HcS7MxghcpfbHtATSH66NEfUe3VMzcSTDNcH44U0qft3VkUw6HBbUFe7lLfpRkUZf3jqI4Ry1TaAHET88PMD1gzrJzbIjL2/Vwgx1sywuKzoEm4XCr6oM9JuD4s0j8fBhdYCPD8+CcPjA0lkE4xDkN4f4HYr85iL8P8x8+no8w5EezgV+2sWYe7RNjmb4UCy/w7mgnOMkfKuXkQ5nsN7k6mztcK6goeg8Q2mH7WNoHcJ8gHcn42ficK6whwNBeG7TbtDhXGaGgfzhXHhTqXZtyG8e8YsjPzx0o4dzGTpELhVG/zj9BONHD+dq9KAn7pDEZrGwPZDAGjVELDicC0/zwOZwNpMextKozcTx5wSkM6HJdCYw6Zi1qaluzqaC42wYPYxlvk/+qeP6eshTo4excH32eGewnuhhLI0eVtvOcIXyMLPEkOqhOneY/HMHkIEftslYT9Rx5QF5avQwFm6cZLY/TmW5+aYToIu5xA/PW+hhLHg+3ej4FfLb6GEsuD4tIH7zmLhRfVHKTHkHvyjF9RFcHaD9LfbD+sd+OJ0FTDoc1iTvmnsBldqkRl9AbWc4R+0AR2qT8FJkowcG4gMch/oCKl17iIqe6PIltjt0Ts0dkjcUHTYyp+YOwYzSoYtYF1RP+no2uqau3jLvu4Zou+lhDNwSMPcKER2jNmp/JjL54NKZ0GQ6E0KmM6fJdOYEpIP9qD1tdMzdznDm0pnbZDrcBxai1Ja4MVLUDjDF5UHb2VwmruEXMkOPkegLmWbmcsEvZHLzHK5PgrjcYdq0TTdzMDcdI5lu0zYdqozrB3X12lMjYySuPUVNT3TNnNviI22TGhkj4bKij9zxejrcw2N7emgchL/TW0/XdWT9oQPTm4XSwM8MPkrCzWF4R9UezjHDJ9AecvajUXsYR9fN2kO6fonrFT20qNF1rAOYdKLWzumhRdgeNrqONVR7yLVlm8ZoUbCHXJ9C621YewjhX0aeLxqyX+yhRXQtbmScaX6cSV8BbsauBs3p6KFFjY4zpzLpRM1e0EOLRsaZz5xxZtgxYVj7Sw+Ng/CfQuPRT/iMMzEPHa5jJs8fwmo3Yjdl7abkeBTKkvs4Jx2PzmLSmRWQzgFMOjaNR4fLbmKdR9VuziJ+Ns3PgXtYewjhfxWh8egsJv9m9yiEt6t0v9ssM3xcruyC7BD3bBjics9z6Xi0mWfDQfN8Oh5tdJ4/lUnH8H6Vhvdh0PEo1+eEtQl4v8pQ5/nALWp6CtqvQu1qM/tVsA6/P8S+idokiTGhIdsV+hBNartMjwk528W19aEfool3G9Dc0tpCw8B1vUM059fJBX1xEpdyGCuLsejLwjj+AoJ1eB0s+rIwjk8/mwK/485gnvTQviAc2nI5XvQQTWwtwxw6irHoIZqNHjqKseghmsN16OhRdXjRQzSPRPHDHBSKseghmtwBn4CVrINFD9HE8elhI/CbvniuHdVXEI4Wtw4veohmoy/vYyx6iGajL+9jLHqI5v48dBTzoodococp0Hh+tgzbBq7t4sMZuLqKyx7nuYu5R3tXQ4dWhj5EE9LvdAaXi4nelTtAgztQC3TXw3BNMH501yh3OGwPkw6HNV8Qa64g1uGCWAsFsRYIYh0piHWUIFZGECspiOUKYoEd48Ze9BDNRmfeOD6d6eEyl7M56QzYENyXgAO/biaPnO3BdpE6bjYHedKzuUYO0cQ6B26gJ1yf96ee6CwT1y96iCY+mLPRGTHkV+uwkUM0cX3qJn4LmLhm9Rt+lQ7S73QG1wUTfTE3hufaMOjuOQzXBONHbXjQmAmnw2HBuI6bR9BDNI9k0jkyIJ0DGc5m60KqTHWJHfhxB4WCH7b3uH5QV689NbJKh3VODxuNip6OJH54vkVX6fB4sxmb1MgqHS6rJMKnOsTh8CGa3PyZ49XC4BxJwoJfKxOXHqKJ/eghmpz9wPdoe5vB8O1i4lG7bOjgs9B2GdLvdIz2E26QveT0yrWD5xCdc22khfjhdIIOHcZYdAwQ1K+aGd+FP5QM0h+ufpXrh4IO0TRZv/3K+agAPoYOia2exsCtX3HjDnyIJq5D3Fob5Z1C+HAvzJiHros3um6Jsei6eKPrlhiLrotzOqDrlG+b+fR/rcOXzRwYBtZ0X4XCvMK75vos0IMO9xYSjq4PaxfVA3QNnXwWeIAud7gfPkTTr47hMvZ73sAddErr/MI6nGid59Li6gT+TDStE7NQuAUo3DsCwh3OhKMY3CGas4gfhH23h6HHavQQzVnOQHztDO8iCV1n6S64WWb4BO6Cw/oZ6i44uibbzC44yZ3IUd2RMYv4DcdOg0YO0eSeowzhEM1ZPnTgNz24EpJq5hDNucQ/7CGaQRsjcJXaH9MSSH+4NkbUe3RPzcRChmuC8ZuDrv26K+7L9hxW0Avq9BDNOUw6QS8ZHMRwjtomUHqI5shLBs+8lwywHaSHaOJDLukBiPUOuYwT/Pisp/9D2c1C8QUfPxRpvYE0cNpzDaUd1tbSTYDcIRKcHW7mMMlUqa/Qk8+X04VyspAvl1qcwTY3yA5DeG5D2zQmvNmDwtJ5qPf4MEm6Fa4N+c0lfnHkhw/3oodJmhnOpfNh9I/TTzDhV1dq4RopywSTDj20MSwWHNqI7bSnQtbG0LZoxg6EH/dA+p2Eq6lxzyxnsF7bGL0GbbrlDtOhLwk1Oh7BWGD3h/slIcxBsD/PcONvcOB3GJNH8KMH+sI1dVyfDXlq5iUheiBcVPRE2zl3OC03bW103IN12Mi4B5cVPZRtFhPXrH7D2yQ6BjBkI90gW8G14aDxCtenzEbXzfZPUJbjncFlS1+waWPSaQtIZyqTTtTaGn3BBtskXD+ok7RJXHuKmp7aiF/UbBJn1yn3OBN2JvGDsC/0Aum5V9m75trIWGeg30zkNwZd43TxlgEIr931FZ7nSd6F1sknZ/OYrT6YuGy0w+N63Ca1a0N+cnWt4GreN8+q8aC2MV4ZmCfOnnFjLAgf9DIQ1lHCGVyvqS3lbNwsdA8ew3D6xOtN2rUhP9P6xBypPmfXyRPVJ6d/rCfQEdefHEKwDmGwsI6D9Akc94c+Mccw+uT6waBxANYn6IibMxxKsDh9zkT3TidcIX47Ex7jxUn4ArI5B04fyG8sik/rwhgGG9vQoHbWyeSji/jhuBr3woNq97UbVRmI+9R/dC+OcJ/KHw5P/DqQX1tlYDqd3u82lA7GAh5xEn4l6kueygOKA/ETTPrtJP0BvJl7uA5SrBhzD8JrnS71OOqy7CQ4oP/F3u9kg67Q3dNXyHTnkyVX/0zRl/YxF50+pydsI7QDXeOyaGfyFifhb0N9/B2o/T8VlklPh9scEK7F5/9TGMy9tsrAe1wZ4boL4SHtzspgjuA3Bvlh+6XdWO831hfGAh5xEv5eUndxfYP4CSb90ST9AbyZe7TujmHCj2HCP3UApMcR6i3Ou/Qc76k0CT6+R7ltNtiuSn2Z3mxfb6E7WUz2ur3peu1K2/Uxnl0PWk8MW5fp3A9jwXoqzGnwgbOSW9cAfxThJ4Tvgp7izmA9QdqjjeStXA5TDjj9TsLVRP3H6QEfqh/63KLDjH5KeqsW1D1sP9oZ3VAeowjHTkMcuTEucOKerQAPHeaMwwZybDXE0WwbLVefI+K5/8rK0/+f2gI5q5YuLhs8Z8b1HvftOPyrUd/+StRvAS7EBzs1BvmPYvzhN5RXKxOWPusZRXTI6RWHhzrZ7pPXdpJXCP9GL3+a24TpPCbWH+bV6oP5FoS5ipQJHqcHtXkIP4YJj9sY8BnvDG6bY0g8zL3DGejwPa58WkhY2gfj536jSNhRPulQfXAcRjM4tJ+kmDRNWh+0o3OkGJMOblO4z+9g0hfsH7q5vhIc+NGD67Efznu+UgtHHbeGCHnS+d0+q4ZLw1E+XFuTHBvB/Ti6T9ONkbDtJCx9Hok5xgU4Jph02gnuqAD+LQSnjYnX5fDtkfsflm8Lw5fra5pNB2P1VQamg8sZ92nfnFXDpXY8xsStVGr+OPz3UJ/2nZB9GrUlOA+FSu0etdl0HEvbJF1non0XDYP7cRz+x8g2TSDzkXYmPX3vp0Sf3BiBG/fRMUJ8dg3zF0Sf3BhgvDNYN7QOd5C08PgY+heqgz+gcv3tLP+0QK9dAXnU9/40iw+HOeBwFIPrOwGDa9cQbzzDi7Y9ajvaA9Lg+jMujTjxa7Z8uH4bjzW4MQznj/tznA6918qErzf+6PTB5nDbGRzOzo8mfi2MH7VhOL/YhtGxCTcnw7aRa3d+ZRc09ua4hxlXtQdw5/SH7ZD0Wk4yl3SThWx3uewWe/J9mXprOdLpp7p7c/nevqSbKqdS6VzPcKffk+lxc7l8rtBTKPdmCn3DnX6ht6fcm073ueneYqnXHfb8lzLpvrJbVut56XIynXOHO321Op8qZdy+vm63lO/tLTeylsjZZ9xX4DaE7+P2B3sGaH89x+uvza618QcJh+njuPxx9uVCn/y9AI1H5s+un16QzeT6wlbih+0iLaPq+nnIPED4ozzeeN2AW/fCa27atVUG5m+xdz/ZnMtwz3bxfD1eGZjvoLUK7eg4eSwTHj8DpWMa/OyUzuXiDBbXL9F61u7w417Ao/WsF5URfbaL63wn4Y7zTscKMSbdoDUOzfMC0p4NPRfIcmsK4LocfnyD/XA7oXv26Fox9sP1oNH9raALzevCEPugODtBbQG37sfZCbzX6yl+lcG89ke7xWNs2m65NUkcHtpOwhlcbrS+cmNHrg3QMWcsID1uvoTbgN8zOWwT8JrCJWQfGLemgONSew3hb0B9zuWkz8H2idYXzs5QLo7D27Ewa03c3BXKhXvOJ7l22ULSg3zgezj9Tseo/XKpvcd6DXrWZmh8lAE+3JyXK2f9bG6cM7jMuPk1Xmelxzlza5+cbaPjI862cW2d2gFuzhq0NhHU1vHzpTBjR64d03aOw69C7fi+gLGj3zqf4wSXYVCZY/3StZhRyK+D+HF9bpA9Hx3Aq94zJsqLe8bkMGnXywP2iwWkEYE+tZvrU3HeaZ8aNLbVjpZBFxOeG+8mSHis86C1J65djiF+YdslHofe59OX4nxgO0vXh7j2ifto3K+3EC44Dbx+Bkd6t5A02pnwGC9Owj/AjPUpJtga7dZVBmNSzvg+1gudt0O4XYjD1Yc9fR3mHUZDe1dCv09c3bvJ6MNE/87N/7h9xYbnS4WgdsCN++j8ipYdbsN++xDoc07cN2C7T9ftX+bVrQTB1A7OD2lh/LhnWniv3mOzB+bN1LNV+l6N376YVxMbhds7tzcA7Adti29A44TXkXECV/fHOME2i9uLQ+uP334WarMg/FsCbBY3z8G81lV4zLcz61JB9YIrP1qXcfhRTL648RddR+Rs6f57VydZ5MYIWD90jBCkC+0aHT9C/UiQ8FiPXDsaRdIJqqvaBe2dwe8XQLsTX+N3Xbfck+nL9RRSyXKxMNxr/JlyNt9Tzia7U8VMKVXMN7LGH6TjFkbH4wN0HHY8RLFaArDidbDokY9+bZDGG6bxSegj6Oj4xMye0ODxCdYPXRvlxgoJxo/OgRtdP+LWPCWwaN+Msf3aBjdnxzpyHH68g3V7ZuXp/2b3Iyf7uDmgQ/I8luHcwoTn1rDx/uUCGvfTcDRNrLuxxA/b+S7ih/uRccQP9yPjiR+3xhimDWoXVH/iPvmSSIfr+7j+utl0sL5Hk3RGC6bDrQVy6yi0fQftu+HSaWHS4eaieOz95Gw+Tb8xKF1rh/DT5tQw4SVPCAM6akVhurzrDoa7oB3o5Z6vOEQ32AbRNXr8nIvWeWw/aD3F6z+0bo1DHPC+bOo4uwPhNGZ/CLvD6dpQXxopXYfVJ+hCx3t3A3Yc11fIE55PBrUjnC5tRzNQGzl8Ti08Tsdxws3l6q0b07kct24c1X6aK3taZ8YhP1pnxiM/2j7x0c5YJ9TVGxeEbZ+0nDm773euAK1XeO33yQbXaFuYNMLMb+J1sMLMSYKwws6VRuY3g5xV85s2QawWkh+s+3pz/3r1mdbBoDk2jjdMdTD0M35aB1vM8HHD6nWodVCy3kQdy+T77Fy78Vuzv4D0WRDPb82ezhsg/KVovHOxdx32vR+aT5om3VNYb18/HT9xa+dBe1W5eWsje4ax7nDeYK8I3RfR5+mr3n7U/fkMfjjX10Fn3Pp60L5NOjaMMZi4zo+siY2siY2sifH/w6YT5TWxTT7zMb81MWqfIfzLUN+2xWdNbBsKs3dkTewpNxxrYntH1sSecjasib0StZG3j6yJ+fbTz6Q1sbf72GBIg9rgsGtim5gxHISj7xThcRzst6Lzl1vm1rDfR2w84H0Y1d8PzBnIE+f70spAP25vs7632kuTs11aFnu/k025bD5oHGP2PYVMIcy4Aqc/XGeCcXNC7j0FboxK9+zi8dQ9lVo46hdj7rUGYO0SxNoniLVVEKtfEOt+QaxNglh7BbEk9SWZRylenB2MSl3dI4gl2bYl68ROQawR+zViv0zmUVL3mwWxJOv9w4JYkm07qu1R0kZHta+VLMctgljPhn7o2ZBHSV6SdjWq/fZ6QSxJXpL6elQQa4cgluTYJKp92kh73H95jGq//WyYp0nWifsEsaJa73cLYkV1reMRQSyTNhrC4mcbcPaAdqu8a/qMYgV5JmBoXb4YtBfA7HcwMqHPNqDP+bmzajsZv2beOe1zy+lSsq8vk+ordvf09LQQfOBK79E1y7DfHwBdjzGj6z5uH1kn0qt2bcivg/jFkR9w1Lqn30o38ww10xdG/zj9BBOenrEQtizh++ajUTr0WSuuwysqA/3aGQ74uV/QPjXu+Sc+q6Ayt8YVx6P1LEbiYv8WlD53H1+3kPs4XZzeBZWB8egzR8qF5jfG8OR00crogtu/ECMYuJ3ivai6jJ9h+8dLYe1sVPePGz5DpkjrI+YTtTNkHvTqOLe/z28fssNwgLQdj8tW0nb29370PXMHxoF4Yc+QgfCPov0cD3vXI/vRB+aNnkMD4V/u6UvXvQjsRy9pHs/k/eh7kL5H9qMPzuPIfnQ+XxLpjOxH97cB0vvRPz+XT9NvPzq1zxD+l6hv+9LcgWFAR19GYb5H1hQwd0E7MLIf3Rms65H96LUwUduP/hvURv5F2ubIfvRn5n70f/nYYEiD2mAY69fbjw62XfoMvGyq0J1Pd/cmC6XubL4n28gZeCNjyFqYkTEkny+JdEbGkP62RHoMechhfJp+Y0i/c756D6thzjpsYBjQ0RwU5ijvemQMWQtHndQYkup6ZAxZCxO1MeTzURs5lbTNkTHkM3MMeaqPDYY0qA0OO4Y8BLX7p+5VauEEyzAF+YlXapxBN22VGu92xFu70cgPwgHXDjNck8C108OH9onTxHlpJeHpdZzcuwqVJc4j5APfw/gQfgzyg/AxdA84Qv1tR35jKo1hjSZYo5rAAl4JJvyoIfLisNoJVgeDhe/hZ1PneGVj4mzxfLbUm+lJpwrpcm8+l8w1Mq+iz5IH5M8ZWHeE20Poc+ng3nCdSxcjfKh+4JqzgRCXPkPRju7d4M475L4/MlxY3PNMWhcMfZMl9PlwkH6nY7RuukF6jTF65ebY9NtneJ5Ky4/bR8DtsbIFC+Jrx80DYf8gN6alOqXtHftxz96H8xvJG8n8ZjThutj7nWzS7a9vJL8YzQnuO6x+elH8RvIOj3e9PQDA2fAegJFvJDuD69kjqIz25zeS30Xas6H9WtZ/I/nLIeaXI99IrjluDRXaTsIZXG60vuI20EH8cBug57nEAtLD5Q+6xm3Arx/lxjjAEcqC2z+qHe1HIfwHSbsz864A349iu0/zJ5h2D/dcBBz3HIa2ea7f5OwBbfPculvYNg+6aLTNc+PAoO/jBn3flWsDtH3gNkD7N9wP+H2jVDt4j6WFYDpOcN/H7cWsN9/GbQI/E/kaWY+D9PCYB8f1+874b9G47Ztk3MY9Qx35znjtPz2/y9AYYOQ74059WxH0vWdufDActgKnbfo7439E7Xj0vIH55+xoC+HnOMFlGFTmWL/AdeQ74/wcdT+OS0e+M4788FwO2ktQ/4XtLH22xbVP3Ef3evcgTVPr0vQ5oCR+LpnJ0WfmwvzThteOM4bH7Umob8dXavjc/CZGwtE42p+ud+IwJvdIqHLuNqynlOHxWzpMO8bpc+vOLT7/AYv6QVrD9U16Lm9Bz3Ekx+sc1v4sU7/3j54KU6n5tRK/NuTXTvxwX4jntjNRONoG6Xdu8Dz5pEoNYxHCO8K7NrnHDGy3KZuh3SSGP903gJ/dc8/UQefc3osY8cPPz9sqA9OBfQ7wDINiAQ+6L2Kh95vbt0Cf9+P06fP+AbyZe1QvjewPmONdj3FqawZphOfXRrjn0ty8Co9FDbbnFHDlnpti+wLpj1UyxbteuWr5itIpy064pVRYvera5cuOyxeuKTnE0YfTLSjzfh0zziiHEUPxOacLxOQgPpurbQ6CBhF3Bi/I4fTjJHzO+y29uaSczbvldL6c784Xi5lC3Q/Xz/CuRwbFgS5teDCWMfwAix0UcwYH6vCJlZouT6wM5ARhTkJhTkJhtAsaOHObmE4gfrgtnUj8sLHCHfoEp3YN9f6Z3KFDxwMGWRvnmd71suWrri2vOWHZjatLq0vFs1f3Lb22cOLqZYWnDfXSpQ5xdNDdQn63kt/UJrcxONTheC0oD1G31Qd6v/e3rV7i/bDbVncXhstWm9QPrcsmbDU8LOLyoh1nYyEOtYeHoTjaXYSwW4jfxUy64HdJheeh3aXIjy60Xob86GTVRJ+n6lnW9AOqSY7/QBnq+HEVI2lX2+jxHr4jh50E7BMQ9xYD3E80g58C/JPM6D4N+Cebwa/yP8UMfgbwTzWj/6p+TkP4jiNfP083w7+Kf4YZ/tX6f6YR/qkq/7OM4PdU+Z9tBr9aP88xg98N+Oeawe8F/PPM4JcA/3wz+GXAv8AIfjYD85Y+r2EFvchA/zvO4DmEdjBOidqLBtwBjXSzQaMvg+D4Jj7qPlwPT+Ih880tkFIdNvriA7fZ2PSDScNrPN2gC26DElc3IfzoBsN3NBie20TSFhB+TIP4YxsM39Vg+HENhh8fMjx9iRgwtIO6MgHdl174x+k5Dv9AFdLvJFylbUIXSY/TxUQzafeE1cVEogtDZeMazm/V/k4i+aXlC+knSHiadxyWw9IO6rxuq2BvlpRWnbl8VWllqw8WLg+cJg1Pr8HFfXBizuA2R+P6vShD44z2ud/hc7/T5/4Yn/tjfe53+dwf53N/vMM7WJ+AsHHif0IlODzekOn4pE31a/q3M4xpSXCFOsldtwSE6fLB187wGmVomwn3huuA7xjhQ/VD+96wL4MfX6mFo35hxuw2YJ1ugJfk3I4bu0O4oLYw1HRwPHpgTCvjp21hgXADneCN5DjuBOSPwx/SUsMsk7S5OZ7hte5s2PZOX8YwPYfk5jpcHeVeygr6mDpeu6R+MeZeawDW8c8CrNMN8DJ9kB891IrrC4JekgjzEnyjB/Nxm+MNb8juqWfT1vvkyc+m4Q9R4PDfRph3OQN1yNmQsH06jEnHM1zCrBNhrJMJFrdOFGR7MNZJBIvb9BzUXjDWKQTL7wUuvzqH9Qtjdq5udzSIRdtQO4PF7cHRstj7nWzKZXq49iGH31Po8NGNEH6WO1SC9utmPtLlhn7JEtLvJFyFbVG1Xw97iAZ38B99GQn70TrIrR2OZdJJMH70+VozWOcKYXHtoBle5wjx0u5sQawzBbEuEMQ6XxBLKo+c7YpKnZDUvWSdkGzbkrzOE8SSrKuS5Qj1C8aPEPar3n+Te3pVF9QTZp7dYSjtFpIe6M8h+aWHdnNzEOkPlPb2lkrdqXLeTXane9KlwAMIuDlOo3076HqsGV1nuJfTxiC9ateG/DqIXxz5AUc9lr6mZSB/Q2O3UPrnxkM4/PGVWrhGyhI+UErHGqAfrn1iP1yn/V4A1df0wGVujhr0Ajg+8IE7dAf8Opl8gB8uP9qPcnWZezk/4fiXC9W937waH6iHw//Y+6/zPKNlIPeweab54p7Zd4bMV6cPVptPvughcxD+V95/XQdWtgzE5PSO6yldE8CcqN7H1sGiawI4Pp1bdNXBomsCOH4XwRpXB4uuCeD44wjW+AAs3F7GM/HHEz8cL+hFXzz/164N+UmuTev6cVNLjQfNL7bTWhKMLnB4qDsJJjzsCeXyO34/5rejwfxy9ZvmF7ebqJVv0AGcXF3H4U8i+cUH/I8JyG/nfsxvUPnWs4WnkPxy9sum8q13yBA9JArntysgvzaWLx4vcfkdR/y4Q5TwuIGORXCarege2EhuXIZx4dkBfb4500tP62IzSRu/SxhmvADh5yBMOl7g1uoTTH64Z0Fh1ur/v72r+ZHjqOLd07O79q4db7LO58bOhgAJCND0fPTMoEgYsNexohCTBAyIr56ZHsfCOFLiIIQ4DDckDhwQEv8IF7hw4ciJGxLigMR/wB3X0m/2N799XdOTrZrpSbak0XTXq3716lXVq1cf71XdgmvRtXrExbqHba1+3jlL1j00nY11WE6HaTSdCuFFOiHSvDOHZtZxFtXjNAfhNj1O5myoSzmcszWlv+B5OQkCw3N2PM+/DLBFLzCaOvR49PstyB9Ox/QgD/cIhvqr0Ka1VZ57cNvF5+ncO9DbEvd/SX8N+v+odkynCSjnhS7Pcj5ZVM7PmzuwXqo5blvhOK6W95ylvPOcC7JeqvX9darfeQ6mb1rKW4F5llreLUt5tXES07NeWtaB+JIc/6vlrS9YXm380cp7gWCRwgs+l2ZCkR6GMDyXVnVfC3dzBKv2tSDxW5NjeES0HtGfP6/KWdb7OYIqO8v6Sf6Rj8u0hp1kMGx30kYWm9fmvHrV+ISyxQThNdbFplK2DUr/i/C4zL8EuXGUVsnv6JIWS7qw4P8IhxJXn8zGaXWEbVfSS97bCo0Cw4vVUO6ZcCF/R34hLqFjg9L/mtoutjf5XrvYDS/K47y0/LntapfK7SjpTf38iuQRlt31uZejPAk/xjFtv/HYr7JBu98d9IedxqjRj/utMpfUDQCo6ek4Nl2fzMLk0+/Wjsv3u3A2jeD7A/Sz39P4jPSJfwN2Yo+0mLhv5y+a3xjzu5a/N04V2plmX+oOf9LTzoC7w9+d+tU55wd/6vecXXfq8HbbD/9b2n6vQ/o72n64O/zNkbb24ZD+aft8zA//p/V7yQ/9U/vtXT/4k9XZwLaHZXQMzN+3DWxI+Qk9zB8+B7qn0KrZr7KM12xh95R8dhUYn6M6Da5vOcT1TYe4vuEIlzb+nYauNx3SteWQLlf8cllGl3RpekAV2qqmP1Slb7tsE287xHUmv87kl88yuuT9tkO6XLV787zjkC6XfbuK/dG1jK7qWOuyHm87xPVJGIc+CWV0RZdruVrVcZvXTarSvlzKVV67OQ1dbzmky+Xcqqo65ll/XF0ZqzpufxLmaS7bBK8NfxzbPa9PV0WPdjkf2nVIl08ZLWnxXI/4/jFB7D14D/Nt2jP04zO2PbL5wNH241zmHVJ+QaDvCbCNnuZjaVuBnWZ/ehCPW1ljMGg3B6NOkiQh4RdaOY7X/bXz19r+grZ36JDXA9u5Ps0W9RzBNgAmNGq2qH7sltuDMvzH/HeV9Ncnx+kWqUuxRUUdk21DsQ3zxcGbCg14LkCzWQ0Jv3bOz/yntWNa8TukEctnuyA0KojH55DiMV/M73Ay+x3fvce0cHkjhU6NFzWFF2Xsg7GfCj4f51za426ajLuNTnPUzpqjuecCvwP9KSA6Xe5/nlfK6Qp/D+4oCPzQ7/sSad/38U3vYMI7UmyXSItMwWehqczZpBrAXidYFJzEzRfYtoLjb0x4A2gICYa6bI1gbxLtCMM1SD6fjTraBsFwHYEv+EV9jM+4oz7K4x3OX3icxHuz2C7iDsDYhgDvvWK7SLz3im0I8d6rxwiG915dItj3AbZLsB8A7HGC/RBgTxDsRwDbI9iPJ8FRMDCx1RFYCrAnCTYA2FMEGwLsaYKNAPYMwTKAPUuwMcCeI9hdgO0T7F2APZ/HiZy4EhzD3MnR9vTM1FUP+B8NA8M9hf6rUDYTPi53jLkeH0w49IPf9x1j0zuQ/NwxFncF/y0/9A/kTPAfc3ya/YyMS37H8rgXUn5BoM9jp7YVgVfdZeH7b8xYJGOVuXQ7vZu9laUjVv0F3dNK0bDomOY0176aIM1zkWtfzbPm9pVdCXF1cRwv82iuiLQj3Q6rssOuhzBox875uiZc1kExzoH5jmUy3ezPgJfTMT3IczaJ1qZdYXCyLURKnK0+eBnFU30MPU8LEm3JgPmruZjWlsaQBxy0+pYyLVrf2Pd4G26eCLK5Vt6g75DnXL+MuyhvxFGnZ6lbP0eOFzfN14YVLA8GpNvU338BL6fjPFF+7BEM6/MywbCtPUkwXF54imC4xPI0wfCY0zMEw+31ZwmG29LPEQy3fPYJhlslzxMMtxhEPT5PeFyr4xeJFgwXiRbJW545aG1E6F60jYQKL9icwDxfJRgud71AMGzrBwRDNxQvEuxJgH2KYE8B7CWCod7yaYI9A7DPEOxZgH2WYM8B7OXgOHDdFI19PF6ZcC3/b446WaPfG/Sag7TVHbRbg34/jVtxEse98ajZGLWb406cJMN+1h/HrfGgk6VJJ+0nozhrpMmI86opdEm+Ih/3FRpZxuL3+8FsYBwankDJo6Z8y7Q9X0BbEf3YhzQc+4RDnq9Y6JdvePnRhGv5f6vRamVps51knUaS9fq9rN8dd7qNYToej7qN9nBg9pWSRsvUWbfZGDT7WdzqZ53hkYlxLHldJd5cUcov5XoBYLxUECnfvxDMBsbBeK5QWqYNv62VpA3T1Apoiyz4ud4OLPTX5tCP3zJvDwroL9I7DoKT9F9V8MuzhoNlBcuQGsTXFfo0nFcK8sX4/YJ895V8be1R6/MSr41jvMWj8YvnQuZ5m2CoW1wiGI71rOfgWMQ6CY4bPPZp16loOtBjBEOd5AmC4ZjJuhOOb6zn4FjEugzKPR6jsX5sW+0XCYY61+MEQ52AdUMcv1mPw7G2RjDsE+zSF/XUCwTjY5kICwG2STDUi3cIhnrqLsFQb2SdGfUa1m9RBxF5Z/KpukuVP+Xvq3apgsuBIeQvQVtTwOVJlC2bgT424XVrmP4v+b+hoR/qOJGvuOzKuiDrNtfy/8Ypg9Aj7VqbK2tllPR/hTK+mhO3umXXRmmT4qouu54PTsoZl0vkXN9Ij3YMRJOlfBQEr96KlPSbUEYeP2ZctVHc3/N/diNqwvXJLA2aq02MwyMhf6Oy8TEU7V/wchyvP2p9xvOxBPWK98Ad/ljTCerAz39APMsKnh+aIPKVXan+C3D+M3/W1uyFxzuBXaZrc1puL5sF6VneSfp/5/+aTN9Syq25VWWc/wGcXyGc865oK3O0UHNxp7mJPU8wbSwQ/Q6PDGI7N6EOMJey3ZTjazTG2Fw92nhhAvPO5ioR24fNVaImB9hk3dZWTWD3evP6nabjREoeoZJHmesL63NwHRIujV5trZ2P85Vdr9fwS1rbeIs035jM0lyk96BcLcJ1k3BpV4Jo4+JGoJcf5bg2rmn4Jd6z/tApI5cwf5s7ak0+bZXgic3F5wp4ktjkjY0n2hFlTe6cK8GTeXJ/yTzp2mSqjSc29+BFV8cU8WSePF8yT3pS9p0FeaK5II7ondMV8aTsNQZL4klfyn5hQZ5obtQjeud0RTzR8t5ZHU9SKfvFBXmiXesT0TunqxfwRMv7QgFPcE3YRrMJovtfsuSp0cxmARo/tLw1cwKkleNt64sRwTQ9RFsDtl0ZZluztK0d29YebWuWtrVc27q51L0Xc4hO2h2m3Tjut+OsHXfmrek5X1NsN7Os02sPBo+e4lG87Pyr5E74MEdg2sxr+bP0qw0lP5PujiVdWPB/hEOJq09m485PTqavkjvhd3IEVXYn/Eb+URXdCUvbMe36y3n8eps5dVvLMnOK/OBv+l6vlDHu+mQWf0D5RpRO+4bHcEzDY7gJN3KYGfdkb9Q8s1nHIeQTEuwmwNiUiY/OIwz3ldiUCU2+eP1BWwPANQneO/Bhmt1rtAd+zXmbPW1tkc2z6gCzmSMLjSbN54g/W374k/jkv3GVvKfQL3nJXmcbeIJwSY988FSP/TJjPea/7ZVvx3twZdeDja4re/J3s4e3Pxzcvze8nj5M79x7+CD74INN4mlE77zvyftL/D2fjxY6X8n/tXPfRUHoYZmI+PjcU0jvtYJ0WE5t7mSbHy0yB9L21rV5VZl5zjpdqyLmtFW+VuUL+fM6nEHp5++rPoMi55fWW69td8/0Wnsoq9eeRmeVM4LmmU27NZ3Vp+0T6jye6izeK6DfBNF50NXSzJwzODlG8fpeWIC36rJNzgWuWraxWfiZbFNDy7MNYuy5H6qyzbY2rsm2efLrBuDmOfehkq/PMj9qEx3P40VzLygeI0S2ST/Xzj5gX8C9La1eAiUuDIrl4/ngZD1ey//jVuvRQvWoG49H41an228O4qSVJOP2uJv02qNxp52OulncTlvNftZtjONelnU7rWE3GfdHw2TMZa1ZyrboHg3yr+oyXOwGVi3DX8yfz2S4NZzpp8GZfkqhlH6K9pDIZ76GEPHw2Vix8TE67V4BvjL6blTwHc5RGUfgkF8aHaFCx7rr5wf5+6pl+/fy5zWX7cNlyXZf5yZ97j2YIHhRh9bOkUobFlmMz0KTpHkN0rxWkOYWpMH9LRO0cUTo08aRQ4Jhf7tJMO1cvWbPITQZOSw2hqhXa/tvIcFeB9iS5h7pKucey3bx5rpsMu6+CvWI/UHyxHr01C9bPI4Ggb4Xxi6rPcmh6V5Y2T1lsxcm+sYwvX//9vv3fpY+zA4/fDB8eO+9B1gERFtTiogswDSaF2B8t21DsSjA7q+5x+LvOc4musKC/0D5PghOmobhd7x1VXOQj+8loN2gWNX1LK4WdnnG9Yjdm9tmoPA3gDRSpiPzI8DL6ZgerAc2Aykyg4kgzUc1gzHxVXNJxvXhyiXZIvWBPOItZ22ase7LS1/N36tggi9DsWYiFhKsyOUJy3buJyZcn/z/37dJLJv638r/TVnfIZo187FI4VWZoRnLq5mbbZXIW3O1x3lvBrocEnxswno7/zflv5M/a+NeRLCaglvrk2jyu+rj16s+/v6l/HnNp/TJ2ZabPbjachP13TyjqxnEFwTH/X3ZuuUSttpi7WgpLo2aUJ/M5o2wDYChPsguID0tY3eqsIz9CvCE205IfPC1RRJSfkGgT6clbttjvTRgOh0RPcwfnE7LUv7999LR4fvv/fTGz7Phh2Yy/fV0+G6GpQgLSodwDBp3woJ4E2ybq+t0cPLl/L3KBycP8ud1mDl8MX9f9cxBDnCuuaaz7vcedTyvJqiajrb6EVE6/sbAbdrQskZpT3xqLWOxumjWaDuwrzl6KztSS17LcsQ2b0bMq7a2u/FsTtTK4lplnRatiB2lmRzDbJoy362FmjKu1B1AOu6DfPAExyrZ3OO7x8QQQTuw4Fp2e9QgG3tBsQ62LvrX5/P3KutfL+XPO8HxjKYF+Ir6iKbF2xw9ee7PTaFVc8qlbfibGYdsfJt7fLJbD2YnHAEF3l4LofBFAzMWVMMRwfdaWAeluJe/r1opFj7JP3pO9qEUX/aDv4HL3AGVBfNl5T9wSIPgk3agbS/yNvVUMBF9oXv6YqZF2/6VIMt8lyFO+Pk40epLkRf8vk4vCH5fypLWJjGO2wDWAysg3E8d05pOlQOgIaI8mUZMUw9Ohhq91yk+KpFWa5sCmyoBlu/YSpvjWOEMlPRThSL/3yjAhR5bMf0WpfVVh3sKTUw7Wsl7oGF6qeSOH/yqnEfPfDsEk3altc+w4L1G/7a0oQWv1qYEp9QV0ivl+B8cBSY66nYLAA==",
      "debug_symbols": "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bUe2HXnnYNs52HYOtp2Dbedg2znYdg62nYNt52DbOdh2Dradg23nYNs52HYOtp2Dbedg2znYdg62nYNt52DbOdh2Dradg33nYN852HcO9p2Dfedg3znYdw72nYN952DfOdh3Dvadg33nYN852HcO9p2Dfedg3znYdw72nYN952DfOdh3Dvadg33nYN852HcO9p2Dfedg3znYdw72nYN952DfOdh3Dvadg33nYN852HcO9p2Dfedg3znYRw7aNaBu4A2yQTfYhrahLxg5OKFs2JFlR5YdWXbkkYNWBtiGtqEvGDk4oWygDXUDb5ANO7LuyLoj645sO7LtyLYj245sO7LtyLYj245sO7LtyG1Hbjty25Hbjtx25LYjtx257chtR247ct+R+47cd+S+I/cdue/IfUfuO3LfkfuKXK7rCipBFFSDOEiCNMiCWlBolNAooVFCo4RGCY2RkyZOGmRBQ6M59U0jMReVIAqqQRwkQRpkQaFBoVFDo4ZGDY0aGjU0amjU0KihUUOjhgaHBocGhwaHBocGhwaHBocGhwaHhoSGhIaEhoSGhIaEhoSGhIaEhoSGhoaGhoaGhoaGhoaGhoaGhoaGhoaFhoWGhYaFhoWGhYaFhoWGhYaFRguNFhotNFpotNBoodFCo4VGC40WGj00emj00Oih0UOjh0YPjR4aPTT61ijXFVSCKKgGcZAEaZAFtaDQKKFRQqOERgmNEholNEpolNCIPC+R5yXyvESel8jzEnleIs9L5HmJPC+R5yXyvESel8jzEnleIs9L5HmJPC+R5yXyvESel8jzEnleIs9L5HmJPC+R5yXyvESel8jzEnleIs9L5HmJPC+R5yXyvESel8jzEnleIs9L5HmJPC+R5yXyvESel8jzEnleIs9L5HmJPC+R5yXyvESel8jzEnleIs9L5HmJPC+R5yXyvESel8jzEnleIs9L5HmJPC+R5yXyvESel8jzEnleIs9L5HmJPC+R5yXyvESel8jzEnleIs9L5HmJPC+R5xR5TpHnFHlOkecUeU6R5xR5TpHnFHlOkecUeU6R5xR5TpHnFHlOkecUeU6R5xR5TpHnFHlOkecUeU6R5xR5TpHnFHlOkecUeU6R5xR5TpHnFHlOkecUeU6R5xR5TpHnFHlOkecUeU6R5xR5TpHnFHlOkecUeU6R5xR5TpHnFHlOkecUeU6R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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "notify_enqueued_public_function_call_wrapper",
        "get_note_internal",
        "storage_read",
        "get_public_data_witness",
        "field_less_than",
        "decompose_hint",
        "lte_hint",
        "call_private_function_internal",
        "load",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert",
        "directive_to_radix",
        "directive_integer_quotient"
      ],
      "verification_key": "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\nPa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "refund_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "Id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3564161243949231814": {
            "error_kind": "string",
            "string": "Function refund_public can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6144404149669079610": {
            "error_kind": "string",
            "string": "AlreadyClaimed"
          },
          "9323748002447105156": {
            "error_kind": "string",
            "string": "NotPassedTimelock"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17595253152434889169": {
            "error_kind": "string",
            "string": "offset too large"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBPJwAABAMnAgIEAScCAwQAHwoAAgADgE4uCIBOAAElAAAARSUAAACTKAIAAQSATycCAgQAOw4AAgABKACAQwQAAygAgEQBAAAoAIBFBAAAKACARgAAACgAgEcBAAEoAIBIBAABKACASQAAASgAgEoEAAIoAIBLBAAEKACATAQACygAgE0EABcmJQAAD74eAgADAB4CAAQAMyoAAwAEAAUkAgAFAAAAtyUAAA/nHgIAAwEeAgAEAAoqAwQFJAIABQAAANMlAAAP+ScCAwACLQgBBCcCBQQDAAgBBQEnAwQEAQAiBAIFLQoFBi0OAwYAIgYCBi0OAQYnAgYEBy0IAActCgQILgiASgAJLgiARAAKAAgABgAlAAAQCy0CAAAtCggFCyIABYBGAAYLIgAGgEQAByQCAAcAAAFJJQAAEdkeAgAGBicCCAQJLQgACS4IgEQACi4IgEYACy0KAwwtCgUNAAgACAAlAAAR6y0CAAAtCgoHLQgBBQAAAQIBLQ4HBS0IAQcAAAECAS4MgEUABy0IAQgnAgkEGAAIAQkBJwMIBAEAIggCCScCCgQXACoKCQotCgkLDCoLCgwWCgwMJAIADAAAAeAuDIBGAAsAIgsCCyMAAAG/JwIJADYnAgsEDC0IAAwtCgUNLQoHDi0KCQ8tCggQAAgACwAlAAASuC0CAAAtCg0KLQsKBQAiBQIFLQ4FCicCBwQLLQgACy0KCgwuCIBIAA0ACAAHACUAABN7LQIAAC0KDAUtCwoHACIHAgctDgcKJwIHBAwnAgwEDS0IAA0tCgoOLQoHDwAIAAwAJQAAE3stAgAALQoOCwEiAAqASAANLQsNDBwKDA0EHAoNCgAcCgoMBScCFwQYLQgAGC0KBRkACAAXACUAABSpLQIAAC0KGQotChoNLQobDi0KHA8tCh0QLQoeES0KHxItCiATLQohFC0KIhUtCiMWJwIhBCItCAAiLQoLIwAIACEAJQAAFKktAgAALQojBS0KJBctCiUYLQomGS0KJxotCigbLQopHC0KKh0tCiseLQosHy0KLSAMKgYMCxYKCwYcCgsMABwKBiEABCoMCiIEKiEFCgAqIgoFHAoLCgYcCgYiBgQqCg0jBCoiFw0AKiMNFwQqDA4NBCohGAwAKg0MDgQqCg8MBCoiGQ0AKgwNDwQqChAMBCoiGg0AKgwNEAQqChEMBCoiGw0AKgwNEQQqChIMBCoiHA0AKgwNEgQqChMMBCoiHQ0AKgwNEwQqChQMBCoiHgoAKgwKDRwKCwoFHAoGDAUEKgoVFAQqDB8KACoUCgwcCgsKAhwKBgsCBCoKFgYEKgsgCgAqBgoLJwIGAgEKKgsGCiQCAAoAAAQNJQAAFfIeAgAGBgwqDAYKJAIACgAABCQlAAAWBC0LBAYAIgYCBi0OBgQnAgoEGC0IABgtCgQZLgiASgAaLgiARAAbAAgACgAlAAAQCy0CAAAtChkGCyIABoBGAAQLIgAEgEQACiQCAAoAAAR5JQAAEdknAgoEGC0IABguCIBEABkuCIBGABotCgMbLQoGHAAIAAoAJQAAEestAgAALQoZBC0IAQoAAAECAS0OBAotCAEEAAABAgEuDIBFAAQtCwgLACILAgstDgsIJwIUBBgtCAAYLQoKGS0KBBotCgkbLQoIHAAIABQAJQAAErgtAgAALQoZCy0LCwQAIgQCBC0OBAsnAggEGC0IABgtCgsZLgiASAAaAAgACAAlAAATey0CAAAtChkELQsLCAAiCAIILQ4ICycCCQQYLQgAGC0KCxktCgcaAAgACQAlAAATey0CAAAtChkIASIAC4BIAAktCwkHHAoHCgQcCgoJABwKCQcFJwIdBB4tCAAeLQoEHwAIAB0AJQAAFKktAgAALQofCS0KIAotCiELLQoiFC0KIxUtCiQWLQolGC0KJhktCicaLQooGy0KKRwnAicEKC0IACgtCggpAAgAJwAlAAAUqS0CAAAtCikELQoqHS0KKx4tCiwfLQotIC0KLiEtCi8iLQowIy0KMSQtCjIlLQozJi8KAAYACBwKCCgEHAooJwACKggnKCwCAAgALV4Ji4K6N7Q7maExYRj9INQvUWbJ6fE/teplqW0eCm0EKigIJxwKJykEHAopKAACKicoKQQqKQgnHAonKgEcCiopABwKKSoBAionKSssAgAnADAz6iRuUG6Jjpf1cMr/1wTLC7RgMT+3ILKeE55cEAABBCorJywcCiwtBBwKLSsAAiosKy0EKi0ILBwKLC0BHAotCAAcCggtAQIqLAguBCouJywcCiwuBBwKLicAHAonLAUWCi0nHAoILQUcCicuBQQqLSwnHAorLAUWCiorHAopKgUcCistBQQqKiwrHAooKgUeAgAsBgwqLCovJwIqBbQkAgAvAAAHPSMAAAcgHAopLgUEKi4rLwQqLSouACovLiotCioCIwAAB1ocCggtBQQqLScvBCouKi0AKi8tKi0KKgIjAAAHWgAqLAItDiosLS4kAgAuAAAHcSUAABYWDCosBwIWCgIHHAoCLAAcCgcuAAQqLAkvBCouBAkAKi8JBBwKAgkGHAoHLwYEKgkKMAQqLx0KACowCh0EKiwLCgQqLh4LACoKCx4EKgkUCgQqLx8LACoKCxQEKgkVCgQqLyALACoKCxUEKgkWCgQqLyELACoKCxYEKgkYCgQqLyILACoKCxgEKgkZCgQqLyMLACoKCxkEKgkaCgQqLyQJACoKCQscCgIJBRwKBwoFBCoJGxoEKgolCQAqGgkKHAoCCQIcCgcCAgQqCRwHBCoCJgkAKgcJAi0IAQcAAAECARwKLQkAJwIaACAnAhwELC0IACwtCgMtLQoaLgAIABwAJQAAFigtAgAALQotGwQqKBsaACoJGhsnAgkAQCcCHAQsLQgALC0KAy0tCgkuAAgAHAAlAAAWKC0CAAAtCi0aBCopGgkAKhsJGhwKKwkAJwIbAEgnAh8EKy0IACstCgMsLQobLQAIAB8AJQAAFigtAgAALQosHAQqCRwbACoaGwknAhoAaCcCHAQrLQgAKy0KAywtChotAAgAHAAlAAAWKC0CAAAtCiwbBCoIGxoAKgkaCBwKJwkAJwIaAHAnAhwEKy0IACstCgMsLQoaLQAIABwAJQAAFigtAgAALQosGwQqCRsaACoIGgktCAEIJwIaBBgACAEaAScDCAQBACIIAhotChobLQ4JGwAiGwIbLgyARgAbACIbAhsuDIBGABsAIhsCGy4MgEYAGwAiGwIbLgyARgAbACIbAhsuDIBGABsAIhsCGy4MgEYAGwAiGwIbLgyARgAbACIbAhsuDIBGABsAIhsCGy4MgEYAGwAiGwIbLgyARgAbACIbAhsuDIBGABsAIhsCGy4MgEYAGwAiGwIbLgyARgAbACIbAhsuDIBGABsAIhsCGy4MgEYAGwAiGwIbLgyARgAbACIbAhsuDIBGABsAIhsCGy4MgEYAGwAiGwIbLgyARgAbACIbAhsuDIBGABsAIhsCGy4MgEYAGwAiGwIbLgyARgAbLQ4IBxwKHQgAHAoUCQAcChUUABwKFhUAHAoYFgAcChkYABwKCxkAHAoKCwAcCgIKAC0IAQInAhoEDAAIARoBJwMCBAEAIgICGi0KGhstDgQbACIbAhstDggbACIbAhstDh4bACIbAhstDgkbACIbAhstDhQbACIbAhstDhUbACIbAhstDhYbACIbAhstDhgbACIbAhstDhkbACIbAhstDgsbACIbAhstDgobHAoXBAAcCg8IABwKEAkAHAoRCgAcChILABwKEw8AHAoNEAAcCgwNAC0IAQwnAhEEDAAIAREBJwMMBAEAIgwCES0KERItDgUSACISAhItDgQSACISAhItDg4SACISAhItDggSACISAhItDgkSACISAhItDgoSACISAhItDgsSACISAhItDg8SACISAhItDhASACISAhItDg0SACISAhItDgMSLgiARQAqIwAAC8MNIgAqgEwAAyQCAAMAAA75IwAAC9gtCwcDLQsDBAAiBAIELQ4EAy0IAQQnAgUEBAAIAQUBJwMEBAEAIgQCBS0KBQcuDIBGAAcAIgcCBy4MgEYABwAiBwIHLgyARgAHKwIABQAAAAAAAAAAFwAAAAAAAAAALQgBBycCCAQFAAgBCAEnAwcEAQAiBwIILQoICS4MgEYACQAiCQIJLgyARgAJACIJAgkuDIBGAAkAIgkCCS0OBQktCAEFAAABAgEtDgQFLQgBBAAAAQIBLQ4HBC0IAQcAAAECAS4MgEUABy0IAQgAAAECAS4MgEQACC0LAwkAIgkCCS0OCQMuCIBFAAIjAAAMxw0iAAKATQAJJAIACQAADq8jAAAM3CcCCgQLLQgACy0KBQwtCgQNLQoHDi0KCA8ACAAKACUAABcoLQIAAC0KDAktCAEEJwIFBBkACAEFAScDBAQBACIEAgUnAgcEGAAqBwUHLQoFCAwqCAcKFgoKCiQCAAoAAA1OLgyARgAIACIIAggjAAANLS0IAQUAAAECAS0OBAUuCIBFAAIjAAANZg0iAAKATQAEJAIABAAADmIjAAANey0LBQMnAgQEGC4CAAOAAygAgAQEABklAAAXnC4IgAUABwAqBwQILQ4JCC0OBwUuCIBFAAIjAAANtAwqAgQDJAIAAwAADjMjAAANxikCAAIALRfGuCcCBAQCJwIGBAMAKgQGBS0IAQMACAEFAScDAwQBACIDAgUtDgQFACIFAgUtDgQFJwIFBAMAKgMFBC0KBAUtDgIFACIFAgUtDgEFACIDAgQtCwQCJwIFBAIAKgQFATcLAAEAAiYcCgIDAAAqBgMFACIHAggAKggCCS0LCQMwCgADAAUBIgACgEgAAy0KAwIjAAANtAAiAwIHACoHAggtCwgELQsFBy4CAAeAAygAgAQEABklAAAXnC4IgAUACAAiCAIKACoKAgstDgQLLQ4IBQEiAAKASAAELQoEAiMAAA1mACIDAgoAKgoCCy0LCwknAgoECy0IAAstCgUMLQoEDS0KBw4tCggPLQoJEAAIAAoAJQAAGCotAgAAASIAAoBIAAktCgkCIwAADMcBIgAqgEgAAwAiAgIFACoFKggtCwgELQsHBQ0iAAOATQAIJAIACAAADyglAAAZTi4CAAWAAygAgAQEABglAAAXnC4IgAUACAAiCAIJACoJAwotDgQKASIAA4BMAAQOKgMEBSQCAAUAAA9oJQAAFhYAIgwCCQAqCSoKLQsKBQ0iAASATQAJJAIACQAAD4slAAAZTi4CAAiAAygAgAQEABglAAAXnC4IgAUACQAiCQIKACoKBAstDgULLQ4JBy0KAyojAAALwygAgAQEeAANAAAAgASAAyQAgAMAAA/mKgEAAQX3ofOvpa3UyjwEAgEmKgEAAQW+Hj//PqT2+jwEAgEmKgEAAQUxdnHEg87uxjwEAgEmJQAAD74cCgIFACsCAAYAAAAAAAAAAAEAAAAAAAAAAAQqBQYHLQgBBScCBgQEAAgBBgEnAwUEAQAiBQIGLQoGCC4MgEYACAAiCAIILgyARgAIACIIAgguDIBGAAgtCAEGJwIIBAUACAEIAScDBgQBACIGAggtCggJLgyARgAJACIJAgkuDIBGAAkAIgkCCS4MgEYACQAiCQIJLQ4HCS0IAQcAAAECAS0OBQctCAEFAAABAgEtDgYFLQgBBgAAAQIBLgyARQAGLQgBCAAAAQIBLgyARAAILQsBCQAiCQIJLQ4JAS4IgEUABCMAABD4DSIABIBKAAkkAgAJAAAReCMAABENJAIAAwAAERojAAARTCcCAQQJLQgACS0KBwotCgULLQoGDC0KCA0uCIBJAA4ACAABACUAABgqLQIAACMAABFMJwICBAktCAAJLQoHCi0KBQstCgYMLQoIDQAIAAIAJQAAFygtAgAALQoKASYMKgQCCSQCAAkAABGKIwAAEcgAIgECCgAqCgQLLQsLCScCCgQLLQgACy0KBwwtCgUNLQoGDi0KCA8tCgkQAAgACgAlAAAYKi0CAAAjAAARyAEiAASASAAJLQoJBCMAABD4KgEAAQUC3G4ngHYSnTwEAgEmJQAAD74tCAEGJwIHBBgACAEHAScDBgQBACIGAgcnAggEFwAqCAcILQoHCQwqCQgKFgoKCiQCAAoAABI3LgyARgAJACIJAgkjAAASFi0IAQcAAAECAS0OBgcuCIBFAAUjAAASTw0iAAWATQABJAIAAQAAEmkjAAASZC0LBwEmHAoFAQAAKgQBAi8KAAIAAS0LBwIuAgACgAMoAIAEBAAYJQAAF5wuCIAFAAMAIgMCBgAqBgUILQ4BCC0OAwcBIgAFgEgAAS0KAQUjAAASTyUAAA++LQgBBgAAAQIBLQ4EBi4IgEUABSMAABLVDSIABYBNAAMkAgADAAAS7yMAABLqLQsGASYtCwEDLQsCBA0iAASATQAHJAIABwAAEwwlAAAZTgAiAwIIACoIBAktCwkHASIABIBIAAgOKgQICSQCAAkAABM0JQAAFhYtDgMBLQ4IAi0LBgMuAgADgAMoAIAEBAAYJQAAF5wuCIAFAAQAIgQCCAAqCAUJLQ4HCS0OBAYBIgAFgEgAAy0KAwUjAAAS1SUAAA++ASIAAoBMAAQOKgIEBSQCAAUAABOaJQAAFhYNKIBNAAQABQsiAAWARAAEJAIABAAAE7clAAAZYC0IAQQnAgUEDAAIAQUBJwMEBAEAIgQCBScCBgQLACoGBQYtCgUHDCoHBggWCggIJAIACAAAE/4uDIBGAAcAIgcCByMAABPdLQgBBQAAAQIBLQ4EBS4IgEUAAyMAABQWDSIAA4BMAAQkAgAEAAAUMCMAABQrLQsFASYAKgMCBA4qAwQGJAIABgAAFEclAAAWFg0iAASATQAGJAIABgAAFFwlAAAZTgAiAQIHACoHBAgtCwgGLQsFBC4CAASAAygAgAQEAAwlAAAXnC4IgAUABwAiBwIIACoIAwktDgYJLQ4HBQEiAAOASAAELQoEAyMAABQWJQAAD74BIgABgEgAAy0LAwIBIgABgEoABC0LBAMcCgMFBhwKBQQAHAoEAwYBIgABgEMABS0LBQQBIgABgEsABi0LBgUcCgUHBhwKBwYAHAoGBQYnAgYEBQAqAQYILQsIBxwKBwgGHAoIBgAcCgYHBicCBgQGACoBBgktCwkIHAoICQYcCgkGABwKBggGJwIGBAcAKgEGCi0LCgkcCgkKBhwKCgYAHAoGCQYnAgYECAAqAQYLLQsLChwKCgsGHAoLBgAcCgYKBicCBgQJACoBBgwtCwwLHAoLDAYcCgwGABwKBgsGJwIGBAoAKgEGDS0LDQwcCgwNBRwKDQYAHAoGDAUBIgABgEwADS0LDQYcCgYNAhwKDQEAHAoBBgItCgIBLQoDAi0KBAMtCgUELQoHBS0KCQctCgsJLQoGCy0KCAYtCgoILQoMCiYqAQABBVVFTwUJdio6PAQCASYqAQABBYFkm2itHhyEPAQCASYqAQABBUWnynEZQeQVPAQCASYlAAAPvi0IAQQAAAECAS4MgEkABCcCBgQCJwIHAQEtCAEFJwIIBCEACAEIAScDBQQBACIFAggnAgkEIEMDqgACAAYACQAHAAgnAgoEIC4CAAiAAy4CAAqABCUAABlyJwICBCEnAgYEIC4IgEgAAyMAABabDCoDAgckAgAHAAAWsiMAABatLQsEASYtCwQHBCoHBwgCKgYDBw4qAwYJJAIACQAAFtIlAAAZ8gwqBwYJJAIACQAAFuQlAAAZTgAiBQIKACoKBwstCwsJHAoJBwAEKggBCQQqBwkKAyiASQAHAAkEKgkIBwAqCgcILQ4IBAEiAAOASAAHLQoHAyMAABabJQAAD74tCwQFCyIABYBEAAYkAgAGAAAXSicCBwQAPAYHAScCBQQGLQgABi0KAQctCgIILQoDCS0KBAoACAAFACUAABoELQIAAC0LAQUtCwIGLQsDBy0OBQEtDgYCLQ4HAy4MgEcABAEiAAaASAACLQsCASYuAYADgAYLAIAGAAKAByQAgAcAABe3IwAAF8IuAIADgAUjAAAYKS4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAABgVLgGACoAILgSACIALAQCACgACgAoBAIALAAKACyMAABfkKAGABQQAAQMAgAYAAoAGIwAAGCkmJQAAD74tCwQGCyIABoBEAAckAgAHAAAYTCcCCAQAPAYIAS0LAwYLIgAGgEMAByQCAAcAABjfIwAAGGUtCwMGLQsBBy0LAggtCwQJDSIABoBDAAokAgAKAAAYiiUAABlOLgIAB4ADKACABAQABCUAABecLgiABQAKACIKAgsAKgsGDC0OBQwBIgAGgEgABQ4qBgUHJAIABwAAGMolAAAWFi0OCgEtDggCLQ4FAy0OCQQjAAAZTScCBgQHLQgABy0KAQgtCgIJLQoDCi0KBAsACAAGACUAABoELQIAAC0LAQYtCwIHLQsECC4CAAaAAygAgAQEAAQlAAAXnC4IgAUACQEiAAmASAAKLQ4FCi0OCQEtDgcCLgyASAADLQ4IBCMAABlNJioBAAEFxWvEWg4QAAI8BAIBJioBAAEF9C7lhLv0IdE8BAIBJigAgAYEAAIHAIAEgAaABS4AgASACCgAgAkEAAANAIAJgAWAChcAgAqACiQAgAoAABnxAwCACAACgAgBAIADgAmACy4BgAuABgEAgAOACIALLgGAC4AHAQCAA4AJgAsuBIAHgAsBAIADgAiACy4EgAaACwEAgAkAAoAJIwAAGY4mKgEAAQUohpKwR9z9QzwEAgEmJQAAD74uCIBFAAUjAAAaFA0iAAWAQwAGJAIABgAAGn8jAAAaKS0LAgUtCwUGACIGAgYtDgYFLQgBBicCBwQFAAgBBwEnAwYEAQAiBQIHJwIIBAQAIgYCCT8PAAcACS0LAQUtCwMHLQsECC0OBQEtDgYCLQ4HAy0OCAQmLQsDBgwqBQYHJAIABwAAGpUjAAAbAS0LAgYAIgYCCAAqCAUJLQsJBy0LAQgAIggCCgAqCgULLQsLCQAqBwkKLQsDBy0LBAkuAgAGgAMoAIAEBAAFJQAAF5wuCIAFAAsAIgsCDAAqDAUNLQ4KDS0OCAEtDgsCLQ4HAy0OCQQjAAAbAQEiAAWASAAGLQoGBSMAABoU",
      "debug_symbols": "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",
      "brillig_names": [
        "refund_public"
      ]
    },
    {
      "name": "sync_private_state",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2896122431943215824": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3095323350861740601": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6336853191198150230": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "11418088424205762236": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "17879506016437779469": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "sync_private_state"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000001"
            },
            {
              "kind": "string",
              "value": "HTLC_Private"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Train"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "contracts_private",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "contracts_public",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "hashlock_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::add_lock_private_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::add_lock_private_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::add_lock_public_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::add_lock_public_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "src_asset",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 90
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::commit_private_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::commit_private_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "src_asset",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 90
                    }
                  },
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::commit_public_user_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::commit_public_user_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "Train::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "key",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::get_htlc_public_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "src_receiver",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "hashlock_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "hashlock_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "secret_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "secret_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "ownership_hash_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "ownership_hash_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "claimed",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 8
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::HTLC_Public"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::get_htlc_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::is_contract_initialized_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "boolean"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::is_contract_initialized_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "hashlock_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "ownership_hash_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "ownership_hash_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "randomness",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "src_asset",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 90
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::lock_private_solver_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::lock_private_solver_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "hashlock",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "ownership_hash",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timelock",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "src_asset",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_chain",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_asset",
                    "type": {
                      "kind": "string",
                      "length": 30
                    }
                  },
                  {
                    "name": "dst_address",
                    "type": {
                      "kind": "string",
                      "length": 90
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::lock_public_solver_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::lock_public_solver_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "message_ciphertext",
                    "type": {
                      "fields": [
                        {
                          "name": "storage",
                          "type": {
                            "kind": "array",
                            "length": 17,
                            "type": {
                              "kind": "field"
                            }
                          }
                        },
                        {
                          "name": "len",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::collections::bounded_vec::BoundedVec"
                    }
                  },
                  {
                    "name": "message_context",
                    "type": {
                      "fields": [
                        {
                          "name": "tx_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "unique_note_hashes_in_tx",
                          "type": {
                            "fields": [
                              {
                                "name": "storage",
                                "type": {
                                  "kind": "array",
                                  "length": 64,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              },
                              {
                                "name": "len",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "std::collections::bounded_vec::BoundedVec"
                          }
                        },
                        {
                          "name": "first_nullifier_in_tx",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "recipient",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::messages::processing::message_context::MessageContext"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::process_message_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::process_message_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "secret_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "ownership_key_high",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "ownership_key_low",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::redeem_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::redeem_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  },
                  {
                    "name": "ownership_key",
                    "type": {
                      "kind": "array",
                      "length": 32,
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 8
                      }
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::redeem_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::redeem_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::refund_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::refund_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "Id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Train::refund_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::refund_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "Train::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Train::sync_private_state_abi"
        }
      ]
    }
  },
  "file_map": {
    "101": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    macros::{\n        authwits::AUTHWIT_TYPES,\n        dispatch::generate_public_dispatch,\n        functions::{stub_registry, utils::check_each_fn_macroified},\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n    messages::discovery::private_notes::MAX_NOTE_PACKED_LEN,\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_private_state = generate_sync_private_state();\n    let process_message = generate_process_message();\n    generate_authwit_exports();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n        $process_message\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_authwit_exports() {\n    let authwits = AUTHWIT_TYPES.values();\n    authwits.for_each(|(s): TypeDefinition| { s.add_attribute(\"abi(authwits)\"); });\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$utility]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // TODO(#15012): Here we use PRIVATE_LOG_CIPHERTEXT_LEN for message ciphertext length. Fix message vs log naming.\n    quote {\n        #[$utility]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            aztec::messages::discovery::process_message::do_process_message(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n"
    },
    "102": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::{compute_fn_selector, size_in_fields};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it's possible to have collisions. With the following check, we ensure it doesn't happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f\"Public function selector collision detected between functions '{fn_name}' and '{existing_fn}'\",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "105": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_array, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_public, is_fn_view,\n    size_in_fields,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else if is_fn_public(f) {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    } else {\n        if is_void {\n            create_utility_void_stub(f)\n        } else {\n            create_utility_stub(f)\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n    let params_num_fields =\n        fn_parameters.fold(0, |acc, (_, typ)| acc + crate::macros::utils::size_in_fields(typ));\n\n    let serialized_args_index_name = quote { serialized_args_index };\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args = [0;2];\n    // let mut serialized_args_index = 0;\n    // let target_address_serialized = aztec::protocol_types::traits::Serialize::serialize(target_address)\n    // for i in 0..target_address_serialized.len() {\n    //    serialized_args[serialized_args_index] = target_address_serialized[i];\n    //    serialized_args_index += 1;\n    // }\n    // serialized_args[serialized_args_index] = fee_juice_limit_per_tx as Field\n    // serialized_args_index += 1;\n    // ```\n    let serialized_args_array_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_NAME = [0; $params_num_fields];\n            let mut $serialized_args_index_name: u32 = 0;\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append =\n                add_to_field_array(SERIALIZED_ARGS_NAME, serialized_args_index_name, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_array_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n    let size = size_in_fields(fn_return_type);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type, $size> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n    let size = size_in_fields(fn_return_type);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type, $size> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len, (), 0> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len, (), 0> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n    let size = size_in_fields(fn_return_type);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type, $size> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n    let size = size_in_fields(fn_return_type);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type, $size> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len, (), 0> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len, (), 0> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_utility_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n    let size = size_in_fields(fn_return_type);\n\n    // This is here because utility function call interfaces can only be used within TXe tests.\n    let modified_fn_name = f\"_experimental_{fn_name}\".quoted_contents();\n\n    quote {\n        pub fn $modified_fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityCallInterface<$fn_name_len, $fn_return_type, $size> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::UtilityCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_utility_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    // This is here because utility function call interfaces can only be used within TXe tests.\n    let modified_fn_name = f\"_experimental_{fn_name}\".quoted_contents();\n\n    quote {\n        pub fn $modified_fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityVoidCallInterface<$fn_name_len, (), 0> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::UtilityVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n"
    },
    "106": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "109": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any. Note that the message\n    // discovery call syncs private events as well. We do not sync those here if there are no notes because we don't\n    // have an API that would access events from private functions.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process or they may be used to sync private events from TypeScript\n    // (`sync_private_state` function gets invoked by PXE::getPrivateEvents function).\n    let message_discovery_call = create_message_discovery_call();\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n\n    fn_abi\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "111": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _, _)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ, _) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "112": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract should have this macro (or `storage_no_init`) applied to it, and the\n/// struct has to be called 'Storage'.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    let struct_name = s.name();\n    if struct_name != quote { Storage } {\n        panic(\n            f\"The #[storage] macro can only be applied to a struct with name 'Storage', got '{struct_name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage_no_init\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ, _) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot });\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract can have this macro (or storage_no_init) applied to it, and the struct\n/// has to be called 'Storage'.\npub comptime fn storage_no_init(s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n\n    // We do need to make sure that the type is called Storage, since we'll do `Storage::init` later on.\n\n    if s.name() != quote { Storage } {\n        let name = s.name();\n        panic(\n            f\"The #[storage_no_init] macro can only be applied to a struct with name 'Storage', got '{name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(typ: Type, slot: Quoted) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    let constructor = if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot });\n\n        quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }\n    } else {\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        quote { $struct_name::new(context, $slot)}\n    };\n\n    (constructor, get_storage_size(typ))\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "114": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{private_notes::MAX_NOTE_PACKED_LEN, process_message::do_process_message},\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, note_nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        do_process_message(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n"
    },
    "115": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "116": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "117": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/discovery/private_events.nr",
      "source": "use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    prelude::AztecAddress,\n    utils::array,\n};\nuse protocol_types::{\n    constants::GENERATOR_INDEX__EVENT_COMMITMENT, hash::poseidon2_hash_with_separator_bounded_vec,\n    traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private_log` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n"
    },
    "118": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            storage_slot,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "119": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/discovery/process_message.nr",
      "source": "use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::decode_message,\n    encryption::{aes128::AES128, log_encryption::LogEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    constants::PRIVATE_LOG_CIPHERTEXT_LEN,\n    debug_log::{debug_log, debug_log_format},\n};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn do_process_message<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    let message = AES128::decrypt_log(message_ciphertext, message_context.recipient);\n\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            let body = if type1 == type2 {\n                quote { self }\n            } else if type1 == quote { bool } {\n                quote { self != 0 }\n            } else {\n                quote { self as $type1 }\n            };\n\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "120": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\npub global MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "121": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{\n        GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2,\n        PRIVATE_LOG_CIPHERTEXT_LEN,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign, point_to_bytes},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "128": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/logs/note.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    messages::{\n        encoding::encode_message,\n        encryption::{aes128::AES128, log_encryption::LogEncryption},\n        logs::utils::prefix_with_tag,\n        msg_type::{PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID},\n        offchain_messages::emit_offchain_message,\n    },\n    note::{note_emission::NoteEmission, note_interface::NoteType},\n    utils::{array::subarray::subarray, remove_constraints::remove_constraints},\n};\nuse protocol_types::{\n    abis::note_hash::NoteHash,\n    address::AztecAddress,\n    constants::{PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_SIZE_IN_FIELDS},\n    traits::Packable,\n};\n\n// TODO: it feels like this existence check is in the wrong place. In fact, why is it needed at all? Under what circumstances have we found a non-existent note being emitted accidentally?\nfn assert_note_exists(context: PrivateContext, note_hash_counter: u32) {\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n}\n\npub fn compute_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PRIVATE_NOTE_MSG_TYPE_ID,\n    )\n}\n\npub fn compute_partial_note_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    compute_log(\n        note,\n        storage_slot,\n        recipient,\n        sender,\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID,\n    )\n}\n\nfn compute_log<Note, let N: u32>(\n    note: Note,\n    storage_slot: Field,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    msg_type: u64,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let packed_note = note.pack();\n\n    // A note message's content is the storage slot followed by the packed note representation\n    let mut msg_content: [Field; N + 1] = std::mem::zeroed();\n    msg_content[0] = storage_slot;\n    for i in 0..packed_note.len() {\n        msg_content[1 + i] = packed_note[i];\n    }\n\n    // Notes use the note type id for metadata\n    let plaintext = encode_message(msg_type, Note::get_id() as u64, msg_content);\n\n    let ciphertext = AES128::encrypt_log(plaintext, recipient);\n\n    let log = prefix_with_tag(ciphertext, sender, recipient);\n\n    log\n}\n\n/// Sends an encrypted message to `recipient` with the content of the note, which they will discover when processing\n/// private logs.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n        assert_note_exists(*context, note_hash_counter);\n\n        let encrypted_log = compute_note_log(note, storage_slot, recipient, sender);\n        // Regardless of the original note size `N, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_raw_note_log(encrypted_log, length, note_hash_counter);\n    }\n}\n\n/// Same as `encode_and_encrypt_note`, except encryption is unconstrained. This means that the sender is free to make\n/// the log contents be whatever they wish, potentially resulting in scenarios in which the recipient is unable to\n/// decrypt and process the payload, **leading to the note being lost**.\n///\n/// Only use this function in scenarios where the recipient not receiving the note is an acceptable outcome.\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n\n        assert_note_exists(*context, note_hash_counter);\n\n        // Safety: this function does not constrain the encryption of the log, as explained on its description.\n        let encrypted_log = unsafe {\n            remove_constraints(|| compute_note_log(note, storage_slot, recipient, sender))\n        };\n        // Regardless of the original note size `N`, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_raw_note_log(encrypted_log, length, note_hash_counter);\n    }\n}\n\n/// Same as `encode_and_encrypt_note_unconstrained`, except the note is emitted as an offchain message instead of a\n/// private log.\n///\n/// Like `encode_and_encrypt_note_unconstrained`, this function uses unconstrained encryption. The sender can set any\n/// message contents, potentially preventing recipient decryption and resulting in note loss. Since offchain messages\n/// inherently lack delivery guarantees, constrained encryption provides no benefit and is not offered.\n///\n/// While delivery is not guaranteed, message integrity is still protected via cryptographic commitments in the note\n/// hash tree. For guaranteed delivery, use `encode_and_encrypt_note` with private logs instead. See\n/// `messages::offchain_message::emit_offchain_message` for more details on delivery guarantees.\npub fn encode_and_encrypt_note_and_emit_as_offchain_message<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteType + Packable<N>,\n{\n    |e: NoteEmission<Note>| {\n        let note = e.note;\n        let storage_slot = e.storage_slot;\n        let note_hash_counter = e.note_hash_counter;\n\n        assert_note_exists(*context, note_hash_counter);\n\n        // Safety: this function does not constrain the encryption of the log, as explained on its description.\n        let encrypted_log = unsafe {\n            remove_constraints(|| compute_note_log(note, storage_slot, recipient, sender))\n        };\n\n        // Remove the tag from the log\n        // TODO: This is a tech debt. We should refactor this file such that the log is by default computed without\n        // the tag.\n        let message_ciphertext: [_; PRIVATE_LOG_CIPHERTEXT_LEN] = subarray(encrypted_log, 1);\n\n        emit_offchain_message(message_ciphertext, recipient);\n    }\n}\n"
    },
    "129": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/logs/utils.nr",
      "source": "use crate::{\n    oracle::notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n    prelude::AztecAddress,\n};\n\npub(crate) fn prefix_with_tag<let L: u32>(\n    log_without_tag: [Field; L],\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> [Field; L + 1] {\n    // Safety: we assume that the sender wants for the recipient to find the tagged note, and therefore that they will\n    // cooperate and use the correct tag. Usage of a bad tag will result in the recipient not being able to find the\n    // note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    let mut log_with_tag = [0; L + 1];\n\n    log_with_tag[0] = tag;\n    for i in 0..log_without_tag.len() {\n        log_with_tag[i + 1] = log_without_tag[i];\n    }\n\n    log_with_tag\n}\n\nmod test {\n    use super::prefix_with_tag;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn prefixing_with_tag() {\n        let sender = AztecAddress::from_field(1);\n        let recipient = AztecAddress::from_field(2);\n\n        let app_tagging_secret = 42;\n        let index = 5;\n\n        // I am using the deserialize trait instead of directly instantiating the IndexedTaggingSecret struct because\n        // direct instantiation functionality is not exposed.\n        let indexed_tagging_secret = IndexedTaggingSecret::deserialize([app_tagging_secret, index]);\n\n        // Mock the tagging oracles\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(indexed_tagging_secret);\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        let log_without_tag = [1, 2, 3];\n        let log_with_tag = prefix_with_tag(log_without_tag, sender, recipient);\n\n        let expected_result = [indexed_tagging_secret.compute_tag(recipient), 1, 2, 3];\n\n        // Check tag was prefixed correctly\n        assert_eq(log_with_tag, expected_result, \"Tag was not prefixed correctly\");\n    }\n}\n"
    },
    "137": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/messages/processing/mod.nr",
      "source": "pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            storage_slot,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n"
    },
    "142": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_interface::{NoteHash, NoteType},\n    retrieved_note::RetrievedNote,\n    utils::{compute_note_hash_for_nullify_from_read_request, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::notify_created_note;\nuse protocol_types::traits::Packable;\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    let note_hash_counter = context.side_effect_counter;\n\n    let note_hash = note.compute_note_hash(storage_slot);\n\n    let packed_note = Note::pack(note);\n    notify_created_note(\n        storage_slot,\n        Note::get_id(),\n        packed_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(note, storage_slot, note_hash_counter)\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n\n    destroy_note_unsafe(context, retrieved_note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_from_read_request(retrieved_note, note_hash_for_read_request);\n    let nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash = if retrieved_note.metadata.is_settled() {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifying so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, note_hash)\n}\n"
    },
    "144": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n    pub storage_slot: Field,\n    pub note_hash_counter: u32, // a note_hash_counter of 0 means settled\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note, storage_slot: Field, note_hash_counter: u32) -> Self {\n        Self { note, storage_slot, note_hash_counter }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "147": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/note/note_getter.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{\n        note_getter_options::{\n            NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder,\n        },\n        note_interface::{NoteHash, NoteType},\n        note_viewer_options::NoteViewerOptions,\n        retrieved_note::RetrievedNote,\n        utils::compute_note_hash_for_read_request,\n    },\n    oracle,\n    utils::{array, comparison::compare},\n};\n\nuse protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, traits::{Packable, ToField}};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    packed_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the packed note.\n    // This allows easier packing and custom (un)packing schemas. A note property is located\n    // inside the packed note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = packed_note[selector.index as u32].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[(31 + offset - i) as u32] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_packed_note<let N: u32>(packed_note: [Field; N], selects: BoundedVec<Option<Select>, N>) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(packed_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (RetrievedNote<Note>, Field)\nwhere\n    Note: NoteType + NoteHash + Packable<N>,\n{\n    // Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\n    // is check that the metadata is correct, and that the note exists.\n    let retrieved_note = unsafe { get_note_internal::<Note, N>(storage_slot) };\n\n    // For settled notes, the contract address is implicitly checked since the hash returned from\n    // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n    // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the contract\n    // address returned from the oracle matches. Since branching in circuits is expensive, we perform this check on all\n    // note types.\n    assert(\n        retrieved_note.contract_address.eq(context.this_address()),\n        \"Note contract address mismatch.\",\n    );\n\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (retrieved_note, note_hash_for_read_request)\n}\n\n/// Returns a BoundedVec of notes that have been proven to have been created by this contract, either in the current or\n/// past transactions (i.e. pending or settled notes). A second BoundedVec contains the note hashes used for the read\n/// requests, which can save constraints when computing the note's nullifiers.\n///\n/// WARNING: recall that notes are never destroyed! Note existence therefore does not imply that the note is _current_\n/// or _valid_ - this typically requires also emitting the note's nullifier to prove that it had not been emitted\n/// before. Because of this, calling this function directly from end-user applications should be discouraged, and safe\n/// abstractions such as aztec-nr's state variables should be used instead.\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // Safety: The notes are constrained below.\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteType + NoteHash + Eq + Packable<N>,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the notes (as opposed to simply removing some), the private\n    // kernel will later validate that these note actually exist, so transformations would cause for that check\n    // to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = array::collapse(filtered_notes);\n    let mut note_hashes = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_packed_note = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let retrieved_note = notes.get_unchecked(i);\n\n            // For settled notes, the contract address is implicitly checked since the hash returned from\n            // `compute_note_hash_for_read_request` is siloed and kernels verify the siloing during note read request\n            // validation. Pending notes however are read with the unsiloed note hash, so we need to check that the\n            // contract address returned from the oracle matches. Since branching in circuits is expensive, we perform\n            // this check on all note types.\n            assert(\n                retrieved_note.contract_address.eq(context.this_address()),\n                \"Note contract address mismatch.\",\n            );\n\n            let packed_note = retrieved_note.note.pack();\n            check_packed_note(packed_note, options.selects);\n            if i != 0 {\n                check_notes_order(prev_packed_note, packed_note, options.sorts);\n            }\n            prev_packed_note = packed_note;\n\n            let note_hash_for_read_request =\n                compute_note_hash_for_read_request(retrieved_note, storage_slot);\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> RetrievedNote<Note>\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let opt_notes: [_; 1] = oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n    );\n\n    opt_notes[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\n/// Unconstrained variant of `get_notes`, meant to be used in unconstrained execution contexts. Notably only the note\n/// content is returned, and not any of the information used when proving its existence (e.g. note nonce, note hash,\n/// etc.).\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteType + Packable<N> + Eq,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n\n    // We fetch the notes from the same oracle we use in the constrained case, except we don't bother inspecting the\n    // metadata in order to prove existence.\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n    );\n\n    // Even though we don't expect for the opt_notes array to be sparse, collapse is still useful in this case to\n    // convert it into a BoundedVec.\n    array::collapse(opt_notes).map(\n        // view_notes just returns the actual note, so we drop the metadata\n        |retrieved_note| retrieved_note.note,\n    )\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects as u32] =\n                select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects as u32] = select.unwrap_unchecked().value;\n            select_comparators[num_selects as u32] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "150": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, note_nonce: Field },\n//   Settled{ note_nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_note_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_note_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_note_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_note_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_note_nonce }\n            }\n        } else if maybe_note_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_note_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_note_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_note_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.note_nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.note_nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    note_nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    note_nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n"
    },
    "152": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/note/retrieved_note.nr",
      "source": "use crate::{note::note_metadata::NoteMetadata, utils::array::subarray::subarray};\nuse protocol_types::{\n    address::AztecAddress,\n    traits::{FromField, Packable, Serialize, ToField},\n    utils::arrays::array_concat,\n};\n\n// Number of fields a RetrievedNote adds to the packed or serialized representation of a note\n// +1 for the contract address\n// +2 for the note metadata\npub global RETRIEVED_NOTE_OVERHEAD: u32 = 1 + 2;\n\n/// A container of a note and the metadata required to prove its existence, regardless of whether the note is\n/// pending (created in the current transaction) or settled (created in a previous transaction).\n#[derive(Eq)]\npub struct RetrievedNote<NOTE> {\n    pub note: NOTE,\n    pub contract_address: AztecAddress,\n    pub metadata: NoteMetadata,\n}\n\nimpl<NOTE, let N: u32> Serialize<N + RETRIEVED_NOTE_OVERHEAD> for RetrievedNote<NOTE>\nwhere\n    NOTE: Serialize<N>,\n{\n    fn serialize(self) -> [Field; N + RETRIEVED_NOTE_OVERHEAD] {\n        array_concat(\n            array_concat(self.note.serialize(), [self.contract_address.to_field()]),\n            self.metadata.serialize(),\n        )\n    }\n}\n\n// This function is not part of the Packable trait implementation because in the case of the retrieved note, the pack\n// functionality resides in TS (oracle.ts and txe_service.ts).\npub fn unpack_retrieved_note<NOTE, let N: u32>(\n    packed_retrieved_note: [Field; N + RETRIEVED_NOTE_OVERHEAD],\n) -> RetrievedNote<NOTE>\nwhere\n    NOTE: Packable<N>,\n{\n    let contract_address = AztecAddress::from_field(packed_retrieved_note[0]);\n    let note_nonce = packed_retrieved_note[1];\n    let nonzero_note_hash_counter = (packed_retrieved_note[2] as u1) != 0;\n\n    let packed_note = subarray(packed_retrieved_note, RETRIEVED_NOTE_OVERHEAD);\n    let note = NOTE::unpack(packed_note);\n\n    RetrievedNote {\n        note,\n        contract_address,\n        metadata: NoteMetadata::from_raw_data(nonzero_note_hash_counter, note_nonce),\n    }\n}\n"
    },
    "153": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().note_nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let note_nonce = retrieved_note.metadata.to_pending_previous_phase().note_nonce();\n\n        compute_unique_note_hash(note_nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "157": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "158": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "159": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(notifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(notifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: false,\n        };\n        let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2_1);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    // Ensure is_infinite is comptime\n    let point1_1 = EmbeddedCurvePoint { x: point1.x, y: point1.y, is_infinite: false };\n    let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n    embedded_curve_add_unsafe(point1_1, point2_1)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2)[0]\n}\n"
    },
    "160": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getTimestamp)]\nunconstrained fn get_timestamp_oracle() -> u64 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_timestamp() -> u64 {\n    get_timestamp_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "161": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "162": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "166": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "167": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "168": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] != 0 } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] != 0 } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] != 0 } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] != 0 } },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "170": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/message_processing.nr",
      "source": "use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(fetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(validateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(bulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n"
    },
    "172": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{\n    note_interface::NoteType,\n    retrieved_note::{RETRIEVED_NOTE_OVERHEAD, RetrievedNote, unpack_retrieved_note},\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress, indexed_tagging_secret::IndexedTaggingSecret, traits::Packable,\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; M],\n    _select_by_offsets: [u8; M],\n    _select_by_lengths: [u8; M],\n    _select_values: [Field; M],\n    _select_comparators: [u8; M],\n    _sort_by_indexes: [u8; M],\n    _sort_by_offsets: [u8; M],\n    _sort_by_lengths: [u8; M],\n    _sort_order: [u8; M],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec\n    _max_notes: u32,\n    // This is always set to NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD. We need to pass it to TS in order to be able to\n    // correctly construct the BoundedVec there.\n    _packed_retrieved_note_length: u32,\n) -> BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> {}\n\npub unconstrained fn get_notes<Note, let NOTE_PCKD_LEN: u32, let M: u32, let MAX_NOTES: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<NOTE_PCKD_LEN>,\n{\n    // N + 3 because of the contract address, note nonce, and note_hash_counter that are stored out of the packed note.\n    let packed_retrieved_notes: BoundedVec<[Field; NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD], MAX_NOTES> = get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        MAX_NOTES,\n        NOTE_PCKD_LEN + RETRIEVED_NOTE_OVERHEAD,\n    );\n\n    let mut notes = BoundedVec::<_, MAX_NOTES>::new();\n    for i in 0..packed_retrieved_notes.len() {\n        let retrieved_note = unpack_retrieved_note(packed_retrieved_notes.get(i));\n        notes.push(retrieved_note);\n    }\n\n    // At last we convert the bounded vector to an array of options. We do this because that is what the filter\n    // function needs to have on the output and we've decided to have the same type on the input and output of\n    // the filter and preprocessor functions.\n    //\n    // We have decided to have the same type on the input and output of the filter and preprocessor functions because\n    // it allows us to chain multiple filters and preprocessors together.\n    //\n    // So why do we want the array of options on the output of the filter function?\n    //\n    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options\n    // allows setting values at known indices in the output array which is much more efficient than pushing to a\n    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted\n    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic\n    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor\n    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in\n    // an unconstrained context. We, however, use the same return value type to be able to use the same function as\n    // both a preprocessor and a filter.\n    let mut notes_array = [Option::none(); MAX_NOTES];\n    for i in 0..notes.len() {\n        if i < notes.len() {\n            notes_array[i] = Option::some(notes.get_unchecked(i));\n        }\n    }\n\n    notes_array\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "174": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "175": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "177": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: u32,\n    length: u32,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(address.to_field(), storage_slot, block_number, N)\n}\n\npub unconstrained fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable<N>,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "179": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\n// Map reserves a single storage slot regardless of what it stores because nothing is stored at said slot: it is only\n// used to derive the storage slots of nested state variables, which is expected to never result in collisions or slots\n// being close to one another due to these being hashes. This mirrors the strategy adopted by Solidity mappings.\nimpl<K, T, Context> Storage<1> for Map<K, T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "181": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/state_vars/private_immutable.nr",
      "source": "use dep::protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\nuse crate::context::{PrivateContext, UtilityContext};\nuse crate::note::{\n    lifecycle::create_note,\n    note_emission::NoteEmission,\n    note_getter::{get_note, view_notes},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateImmutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\n// Private storage slots are not really 'slots' but rather a value in the note hash preimage, so there is no notion of a\n// value spilling over multiple slots. For this reason PrivateImmutable (and all other private state variables) needs\n// just one slot to be reserved, regardless of what it stores.\nimpl<T, Context> Storage<1> for PrivateImmutable<T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateImmutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateImmutable>` type (for example), because the storage slot often also identifies an actor.\n    // e.g. the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<Note> PrivateImmutable<Note, &mut PrivateContext> {\n    // docs:start:initialize\n    pub fn initialize<let N: u32>(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: NoteType + NoteHash + Packable<N>,\n    {\n        // We emit an initialization nullifier to indicate that the struct is initialized. This also prevents\n        // the value from being initialized again as a nullifier can be included only once.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:get_note\n    pub fn get_note<let N: u32>(self) -> Note\n    where\n        Note: NoteType + NoteHash + Packable<N>,\n    {\n        let storage_slot = self.storage_slot;\n        let retrieved_note = get_note(self.context, storage_slot).0;\n\n        // Because the notes obtained from PrivateImmutable are not meant to be nullified and get_note(...) function\n        // has already constrained the note (by pushing a read request to the context), we can return just the note\n        // and skip the additional data in RetrievedNote.\n        retrieved_note.note\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateImmutable<Note, UtilityContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    // docs:start:is_initialized\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // view_note does not actually use the context, but it calls oracles that are only available in private\n    // docs:start:view_note\n    pub unconstrained fn view_note<let N: u32>(self) -> Note\n    where\n        Note: Packable<N>,\n    {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"
    },
    "190": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable.nr",
      "source": "use dep::protocol_types::{\n    shared_mutable::{\n        ScheduledDelayChange,\n        ScheduledValueChange,\n        shared_mutable_values::{unpack_delay_change, unpack_value_change},\n        SharedMutableValues,\n    },\n    traits::Packable,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\n\nmod test;\n\npub struct SharedMutable<T, let INITIAL_DELAY: u64, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// This will make the Aztec macros require that T implements the Packable and Eq traits, and allocate `M` storage\n// slots to this state variable.\nimpl<T, let INITIAL_DELAY: u64, Context, let M: u32> Storage<M> for SharedMutable<T, INITIAL_DELAY, Context>\nwhere\n    WithHash<SharedMutableValues<T, INITIAL_DELAY>, _>: Packable<M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in seconds. Reads in private are only valid as long as they are included in a block with a timestamp not\n// too far into the future, so that they can guarantee the value will not have possibly changed by then (because of the\n// delay). The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, let INITIAL_DELAY: u64, Context> SharedMutable<T, INITIAL_DELAY, Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u64> SharedMutable<T, INITIAL_DELAY, &mut PublicContext>\nwhere\n    T: Eq,\n{\n\n    pub fn schedule_value_change<let N: u32>(self, new_value: T)\n    where\n        T: Packable<N>,\n    {\n        let _value_change = self.schedule_and_return_value_change(new_value);\n    }\n\n    pub fn schedule_and_return_value_change<let N: u32>(\n        self,\n        new_value: T,\n    ) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let current_timestamp = self.context.timestamp();\n        let current_delay = delay_change.get_current(current_timestamp);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let timestamp_of_change = current_timestamp + current_delay;\n        value_change.schedule_change(\n            new_value,\n            current_timestamp,\n            current_delay,\n            timestamp_of_change,\n        );\n\n        self.write(value_change, delay_change);\n\n        value_change\n    }\n\n    pub fn schedule_delay_change<let N: u32>(self, new_delay: u64)\n    where\n        T: Packable<N>,\n    {\n        let mut delay_change = self.read_delay_change();\n\n        let current_timestamp = self.context.timestamp();\n\n        delay_change.schedule_change(new_delay, current_timestamp);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let current_timestamp = self.context.timestamp();\n        let value_change = self.read_value_change();\n\n        value_change.get_current_at(current_timestamp)\n    }\n\n    pub fn get_current_delay<let N: u32>(self) -> u64\n    where\n        T: Packable<N>,\n    {\n        let current_timestamp = self.context.timestamp();\n        self.read_delay_change().get_current(current_timestamp)\n    }\n\n    pub fn get_scheduled_value<let N: u32>(self) -> (T, u64)\n    where\n        T: Packable<N>,\n    {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay<let N: u32>(self) -> (u64, u64)\n    where\n        T: Packable<N>,\n    {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change<let N: u32>(self) -> ScheduledValueChange<T>\n    where\n        T: Packable<N>,\n    {\n        // We don't read ScheduledValueChange directly by having it implement Packable because ScheduledValueChange\n        // and ScheduledDelayChange are packed together (sdc and svc.timestamp_of_change are stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_value_change::<T, N>(packed)\n    }\n\n    fn read_delay_change<let N: u32>(self) -> ScheduledDelayChange<INITIAL_DELAY>\n    where\n        T: Packable<N>,\n    {\n        // Since all ScheduledDelayChange member are packed into a single field, we can read a single storage slot\n        // here and skip the ones that correspond to ScheduledValueChange members. We are abusing the fact that\n        // the field containing the ScheduledDelayChange data is the first one in the storage layout - otherwise we'd\n        // need to offset the storage slot to get the position where it'd land.\n        // We don't read ScheduledDelayChange directly by having it implement Packable because ScheduledValueChange\n        // and ScheduledDelayChange are packed together (sdc and svc.timestamp_of_change are stored in the same slot).\n        let packed = self.context.storage_read(self.storage_slot);\n        unpack_delay_change::<INITIAL_DELAY>(packed)\n    }\n\n    fn write<let N: u32>(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>,\n    )\n    where\n        T: Packable<N>,\n    {\n        // Whenever we write to public storage, we write both the value change and delay change to storage at once.\n        // We do so by wrapping them in a single struct (`SharedMutableValues`). Then we wrap the resulting struct in\n        // `WithHash`.\n        // Wrapping in `WithHash` makes for more costly writes but it also makes private proofs much simpler because\n        // they only need to produce a historical proof for the hash, which results in a single inclusion proof (as\n        // opposed to 4 in the best case scenario in which T is a single field). Private shared mutable reads are\n        // assumed to be much more frequent than public writes, so this tradeoff makes sense.\n        let values = WithHash::new(SharedMutableValues::new(value_change, delay_change));\n\n        self.context.storage_write(self.storage_slot, values);\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u64> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext>\nwhere\n    T: Eq,\n{\n    pub fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction timestamp as this proof\n        // will only be valid for the time we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n        let (value_change, delay_change, historical_timestamp) =\n            self.historical_read_from_public_storage();\n\n        // We use the effective minimum delay as opposed to the current delay at the historical timestamp (timestamp of\n        // the historical block against which we are executing the private part of the tx) as this one also takes into\n        // consideration any scheduled delay changes.\n        // For example, consider a scenario in which at timestamp `x` the current delay was 86400 seconds (1 day). We\n        // may naively think that the earliest we could change the value would be at timestamp `x + 86400` by scheduling\n        // immediately after the historical timestamp, i.e. at timestamp `x + 1`. But if there was a delay change scheduled\n        // for timestamp `y` to reduce the delay to 43200 seconds (12 hours), then if a value change was scheduled at\n        // timestamp `y` it would go into effect at timestamp `y + 43200`, which is earlier than what we'd expect if we\n        // only considered the current delay.\n        let effective_minimum_delay =\n            delay_change.get_effective_minimum_delay_at(historical_timestamp);\n        let timestamp_horizon =\n            value_change.get_timestamp_horizon(historical_timestamp, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any timestamp after the timestamp horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_include_by_timestamp(timestamp_horizon);\n\n        value_change.get_current_at(historical_timestamp)\n    }\n\n    fn historical_read_from_public_storage<let N: u32>(\n        self,\n    ) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u64)\n    where\n        T: Packable<N>,\n    {\n        let header = self.context.get_block_header();\n        let address = self.context.this_address();\n\n        let historical_timestamp = header.global_variables.timestamp;\n\n        let values: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::historical_public_storage_read(header, address, self.storage_slot);\n\n        (values.svc, values.sdc, historical_timestamp)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u64> SharedMutable<T, INITIAL_DELAY, UtilityContext>\nwhere\n    T: Eq,\n{\n    pub unconstrained fn get_current_value<let N: u32>(self) -> T\n    where\n        T: Packable<N>,\n    {\n        let smv: SharedMutableValues<T, INITIAL_DELAY> =\n            WithHash::utility_public_storage_read(self.context, self.storage_slot);\n\n        let current_timestamp = self.context.timestamp();\n        smv.svc.get_current_at(current_timestamp)\n    }\n}\n"
    },
    "202": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "205": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "206": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "208": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "209": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "211": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "213": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "214": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/random.nr",
      "source": "use crate::oracle::random::random;\n\n/// Returns as many random bytes as specified through N.\npub unconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n"
    },
    "218": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "225": {
      "path": "/home/nerses/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "243": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "286": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "301": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "303": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "304": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{arrays::array_concat, field::{field_from_bytes, field_from_bytes_32_trunc}},\n};\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, private_log.inner.log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n"
    },
    "305": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr",
      "source": "use crate::traits::{Deserialize, Serialize, ToField};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    app_tagging_secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash(\n            [self.app_tagging_secret, recipient.to_field(), self.index as Field],\n        )\n    }\n}\n"
    },
    "314": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "318": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] != 0 };\n        consumed_counter = 1;\n    } else if typ.is_field() | typ.as_integer().is_some() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type, _) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint =\n        quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_pack & typ.implements(packable_constraint)) {\n        // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n        let name_at_one_token = collapse_to_one_token(name);\n        let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n        // We add the individual fields to the fields array\n        let pack_method = get_trait_impl_method(\n            typ,\n            quote { crate::traits::Packable<$packed_len> },\n            quote { pack },\n        );\n        let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n        for i in 0..packed_len {\n            fields = fields.push_back(quote { $packed_struct_name[$i] });\n        }\n\n        // We add the new auxiliary variable to the aux_vars array\n        aux_vars = aux_vars.push_back(packed_struct);\n    } else if typ.is_field() {\n        // For field we just add the value to fields\n        fields = fields.push_back(name);\n    } else if typ.as_integer().is_some() | typ.is_bool() {\n        // For integer and bool we just cast to Field and add the value to fields\n        fields = fields.push_back(quote { $name as Field });\n    } else if typ.as_data_type().is_some() {\n        // For struct we pref\n        let nested_struct = typ.as_data_type().unwrap();\n        let params = nested_struct.0.fields(nested_struct.1);\n        let struct_flattened = params.map(|(param_name, param_type, _)| {\n            let maybe_prefixed_name = if name == quote {} {\n                // Triggered when the param name is of a value available in the current scope (e.g. a function\n                // argument) --> then we don't prefix the name with anything.\n                param_name\n            } else {\n                // Triggered when we want to prefix the param name with the `name` from function input. This\n                // can typically be `self` when implementing a method on a struct.\n                quote { $name.$param_name }\n            };\n            generate_serialize_to_fields(quote {$maybe_prefixed_name}, param_type, should_pack)\n        });\n        let struct_flattened_fields = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n        );\n        let struct_flattened_aux_vars = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n        );\n        fields = fields.append(struct_flattened_fields);\n        aux_vars = aux_vars.append(struct_flattened_aux_vars);\n    } else if typ.as_array().is_some() {\n        // For array we recursively call `generate_serialize_to_fields(...)` for each element\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        for i in 0..array_len {\n            let (element_fields, element_aux_vars) =\n                generate_serialize_to_fields(quote { $name[$i] }, element_type, should_pack);\n            fields = fields.append(element_fields);\n            aux_vars = aux_vars.append(element_aux_vars);\n        }\n    } else if typ.as_str().is_some() {\n        // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n        // then we add each byte to fields as a Field\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let as_member = name.as_expr().unwrap().as_member_access();\n        let var_name = if as_member.is_some() {\n            as_member.unwrap().1\n        } else {\n            name\n        };\n        let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n        let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n        for i in 0..str_len {\n            fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n        }\n        aux_vars = aux_vars.push_back(as_bytes);\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    let serialize_trait: TraitConstraint =\n        quote { Serialize<$serialized_len> }.as_trait_constraint();\n    quote {\n        impl $serialize_trait for $typ {\n            #[inline_always]\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            #[inline_always]\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "320": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] != 0 }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "321": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "331": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] != 0,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] != 0,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] != 0,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] != 0,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "335": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_delay_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initially equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation\n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the\n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a\n// reduced delay, invalidating prior private reads.\npub struct ScheduledDelayChange<let INITIAL_DELAY: u64> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option,\n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pub(crate) pre: Option<u64>,\n    pub(crate) post: Option<u64>,\n    // Timestamp at which `post` value is used instead of `pre`\n    pub(crate) timestamp_of_change: u64,\n}\n\nimpl<let INITIAL_DELAY: u64> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u64>, post: Option<u64>, timestamp_of_change: u64) -> Self {\n        Self { pre, post, timestamp_of_change }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current timestamp - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_timestamp: u64) -> u64 {\n        // The post value becomes the current one at the timestamp of change, so any transaction that is included at or after\n        // the timestamp of change will use the post value.\n        if current_timestamp < self.timestamp_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the timestamp at which it will become the current\n    /// delay. Note that this timestamp may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u64, u64) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.timestamp_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current timestamp. This function is only meaningful\n    /// when called in public with the current timestamp.\n    /// The timestamp at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u64, current_timestamp: u64) {\n        let current = self.get_current(current_timestamp);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let time_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior constraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value timestamp of change\n            //      timestamp             timestamp of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   time until change               new delay              |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.timestamp_of_change = current_timestamp + time_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical timestamp (timestamp of a historical block). It only returns a meaningful value when called in\n    /// private with historical timestamps. This function can be used alongside\n    /// `ScheduledValueChange.get_timestamp_horizon` to properly constrain the `include_by_timestamp` transaction\n    /// property when reading mutable shared state.\n    /// This value typically equals the current delay at the timestamp following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is\n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_timestamp: u64) -> u64 {\n        if self.timestamp_of_change <= historical_timestamp {\n            // If no delay changes were scheduled, then the delay value at the historical timestamp (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // timestamp of change the current delay will be the scheduled one, with an overall delay from the historical\n            // timestamp equal to the time until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //        timestamp                delay                  actual earliest value\n            //           v              timestamp of change           timestamp of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest timestamp in        |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |          time                  new delay                       |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest timestamp in\n            //                             which to scheduled value change\n            let time_until_change = self.timestamp_of_change - (historical_timestamp + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                time_until_change + self.post.unwrap_or(INITIAL_DELAY),\n            )\n        }\n    }\n}\n\nimpl<let INITIAL_DELAY: u64> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.timestamp_of_change == other.timestamp_of_change)\n    }\n}\n\nimpl<let INITIAL_DELAY: u64> Empty for ScheduledDelayChange<INITIAL_DELAY> {\n    fn empty() -> Self {\n        Self { pre: Option::none(), post: Option::none(), timestamp_of_change: 0 }\n    }\n}\n"
    },
    "337": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/scheduled_value_change.nr",
      "source": "use crate::traits::Empty;\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some timestamp\n// called the `timestamp_of_change`. The value can only be made to change by scheduling a change event at some future\n// timestamp after some minimum delay measured in seconds has elapsed. This means that at any given timestamp we know\n// both the current value and the smallest timestamp at which the value might change - this is called the\n// 'timestamp horizon'.\npub struct ScheduledValueChange<T> {\n    pub(crate) pre: T,\n    pub(crate) post: T,\n    // Timestamp at which `post` value is used instead of `pre`\n    pub(crate) timestamp_of_change: u64,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, timestamp_of_change: u64) -> Self {\n        Self { pre, post, timestamp_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given timestamp. This function can be called both in public\n    /// (where `timestamp` is simply the current timestamp, i.e. the timestamp at which the current transaction will be\n    /// included) and in private (where `timestamp` is the historical timestamp that is used to construct the proof).\n    /// Reading in private is only safe if the transaction's `include_by_timestamp` property is set to a value lower or\n    /// equal to the timestamp horizon (see `get_timestamp_horizon()`).\n    pub fn get_current_at(self, timestamp: u64) -> T {\n        // The post value becomes the current one at the timestamp of change. This means different things in each realm:\n        // - in public, any transaction that is included at the timestamp of change will use the post value\n        // - in private, any transaction that includes the timestamp of change as part of the historical state will use\n        //   the post value (barring any follow-up changes)\n        if timestamp < self.timestamp_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the timestamp at which it will become the current\n    /// value. Note that this timestamp may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u64) {\n        (self.post, self.timestamp_of_change)\n    }\n\n    // Returns the previous value. This is the value that is current up until the timestamp of change. Note that this\n    // value might not be the current anymore since timestamp of change might have already passed.\n    pub fn get_previous(self) -> (T, u64) {\n        (self.pre, self.timestamp_of_change)\n    }\n\n    /// Returns the largest timestamp at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_timestamp`\n    /// (timestamp of a historical block at which we are constructing a proof), since due to its asynchronous nature\n    /// private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum time in seconds that needs to\n    /// elapse from the next block's timestamp until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical timestamp is only safe to use\n    /// if the transaction's `include_by_timestamp` property is set to a value lower or equal to the timestamp horizon\n    /// computed using the same historical timestamp.\n    pub fn get_timestamp_horizon(self, historical_timestamp: u64, minimum_delay: u64) -> u64 {\n        // The timestamp horizon is the very last timestamp in which the current value is known. Any timestamp past the\n        // horizon (i.e. with a timestamp larger than the timestamp horizon) may have a different current value.\n        // Reading the current value in private typically requires constraining the maximum valid timestamp to be equal\n        // to the timestamp horizon.\n        if historical_timestamp >= self.timestamp_of_change {\n            // Once the timestamp of change has passed (block with timestamp >= timestamp_of_change was mined),\n            // the current value (post) will not change unless a new value change is scheduled. This did not happen at\n            // the historical timestamp (or else it would not be greater or equal to the timestamp of change), and\n            // therefore could only happen after the historical timestamp. The earliest would be the immediate next\n            // timestamp, and so the smallest possible next timestamp of change equals `historical_timestamp + 1 +\n            // minimum_delay`. Our timestamp horizon is simply the previous timestamp to that one.\n            //\n            //   timestamp of    historical\n            //      change       timestamp          timestamp horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n            historical_timestamp + minimum_delay\n        } else {\n            // If the timestamp of change has not yet been reached however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the timestamp horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the timestamp of change is in the past: the time horizon is\n            //      the timestamp prior to the earliest one in which a new timestamp of change might land.\n            //\n            //         historical\n            //         timestamp                      timestamp horizon    timestamp of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` seconds away from the historical timestamp, in which case\n            //      the timestamp of change would become the limiting factor for the time horizon, which would equal\n            //      the timestamp right before the timestamp of change (since by definition the value changes at the\n            //      timestamp of change).\n            //\n            //           historical                         timestamp horizon\n            //           timestamp   timestamp of change    if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the timestamp of change to an\n            // arbitrary value, and therefore scenario a) is not currently possible. However implementing #5501 would\n            // allow for this to happen.\n            // Because historical_timestamp < self.timestamp_of_change, then timestamp_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.timestamp_of_change - 1,\n                historical_timestamp + minimum_delay,\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current timestamp. This function is only meaningful when\n    /// called in public with the current timestamp.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_timestamp: u64,\n        minimum_delay: u64,\n        timestamp_of_change: u64,\n    ) {\n        assert(timestamp_of_change >= current_timestamp + minimum_delay);\n\n        self.pre = self.get_current_at(current_timestamp);\n        self.post = new_value;\n        self.timestamp_of_change = timestamp_of_change;\n    }\n}\n\nimpl<T> Eq for ScheduledValueChange<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.timestamp_of_change == other.timestamp_of_change)\n    }\n}\n\nimpl<T> Empty for ScheduledValueChange<T>\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        Self { pre: T::empty(), post: T::empty(), timestamp_of_change: 0 }\n    }\n}\n"
    },
    "339": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/shared_mutable/shared_mutable_values.nr",
      "source": "use crate::{\n    hash::poseidon2_hash,\n    shared_mutable::{\n        scheduled_delay_change::ScheduledDelayChange, scheduled_value_change::ScheduledValueChange,\n    },\n    traits::{Hash, Packable},\n    utils::arrays,\n};\nuse std::meta::derive;\n\nmod test;\n\n/// SharedMutableValues is just a wrapper around ScheduledValueChange and ScheduledDelayChange that then allows us\n/// to wrap both of these values in WithHash. WithHash allows for efficient read of values in private.\n///\n/// Note that the WithHash optimization does not work in public (due to there being no unconstrained). But we also want\n/// to be able to read the values efficiently in public and we want to be able to read each value separately. Reading\n/// the values separately is tricky because ScheduledValueChange and ScheduledDelayChange are packed together (sdc and\n/// svc.timestamp_of_change are stored in the same slot). For that reason we expose `unpack_value_change` and\n/// `unpack_delay_change` functions that can be used to extract the values from the packed representation. This\n/// is \"hacky\" but there is no way around it.\n#[derive(Eq)]\npub struct SharedMutableValues<T, let INITIAL_DELAY: u64> {\n    pub svc: ScheduledValueChange<T>,\n    pub sdc: ScheduledDelayChange<INITIAL_DELAY>,\n}\n\nimpl<T, let INITIAL_DELAY: u64> SharedMutableValues<T, INITIAL_DELAY> {\n    pub fn new(svc: ScheduledValueChange<T>, sdc: ScheduledDelayChange<INITIAL_DELAY>) -> Self {\n        SharedMutableValues { svc, sdc }\n    }\n}\n\npub fn unpack_value_change<T, let N: u32>(packed: [Field; 2 * N + 1]) -> ScheduledValueChange<T>\nwhere\n    T: Packable<N>,\n{\n    let svc_pre_packed = arrays::subarray(packed, 1);\n    let svc_post_packed = arrays::subarray(packed, N + 1);\n\n    // We first cast to u32 as the timestamp_of_change is packed into the same field as the delay change and it\n    // occupies the first 32 bits of the field.\n    let timestamp_of_change = (packed[0] as u32) as u64;\n    ScheduledValueChange::new(\n        T::unpack(svc_pre_packed),\n        T::unpack(svc_post_packed),\n        timestamp_of_change,\n    )\n}\n\npub fn unpack_delay_change<let INITIAL_DELAY: u64>(\n    packed: Field,\n) -> ScheduledDelayChange<INITIAL_DELAY> {\n    // This function expects to be called with just the first field of the packed representation, which contains sdc\n    // and svc timestamp_of_change. We'll discard the svc component.\n    let svc_timestamp_of_change = packed as u32;\n\n    let mut tmp = (packed - svc_timestamp_of_change as Field) / TWO_POW_32;\n    let sdc_timestamp_of_change = tmp as u32;\n\n    tmp = (tmp - sdc_timestamp_of_change as Field) / TWO_POW_32;\n    let sdc_post_is_some = (tmp as u1) != 0;\n\n    tmp = (tmp - sdc_post_is_some as Field) / TWO_POW_8;\n    let sdc_post_inner = tmp as u32;\n\n    tmp = (tmp - sdc_post_inner as Field) / TWO_POW_32;\n    let sdc_pre_is_some = (tmp as u1) != 0;\n\n    tmp = (tmp - sdc_pre_is_some as Field) / TWO_POW_8;\n    let sdc_pre_inner = tmp as u32;\n\n    // Note that below we cast the values to u64 as that is the default type of timestamp in the system. Us packing\n    // the values as u32 is a tech debt that is not worth tackling.\n    ScheduledDelayChange {\n        pre: if sdc_pre_is_some {\n            Option::some(sdc_pre_inner as u64)\n        } else {\n            Option::none()\n        },\n        post: if sdc_post_is_some {\n            Option::some(sdc_post_inner as u64)\n        } else {\n            Option::none()\n        },\n        timestamp_of_change: sdc_timestamp_of_change as u64,\n    }\n}\n\nglobal TWO_POW_32: Field = 2.pow_32(32);\nglobal TWO_POW_8: Field = 2.pow_32(8);\n\n// We pack to `2 * N + 1` fields because ScheduledValueChange contains T twice (hence `2 * N`) and we need one extra\n// field to store ScheduledDelayChange and the timestamp_of_change of ScheduledValueChange.\nimpl<T, let INITIAL_DELAY: u64, let N: u32> Packable<2 * N + 1> for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; 2 * N + 1] {\n        let mut result = [0; 2 * N + 1];\n\n        // We pack sdc.pre, sdc.post, sdc.timestamp_of_change and svc.timestamp_of_change into a single field as follows:\n        // [ sdc.pre_inner: u32 | sdc.pre_is_some: u8 | sdc.post_inner: u32 | sdc.post_is_some: u8 | sdc.timestamp_of_change: u32 | svc.timestamp_of_change: u32 ]\n        // Note that the code below no longer works after 2106 as by that time the timestamp will overflow u32. This is a tech debt that is not worth tackling.\n        result[0] = self.svc.timestamp_of_change as Field\n            + ((self.sdc.timestamp_of_change as Field) * 2.pow_32(32))\n            + ((self.sdc.post.is_some() as Field) * 2.pow_32(64))\n            + ((self.sdc.post.unwrap_unchecked() as Field) * 2.pow_32(72))\n            + ((self.sdc.pre.is_some() as Field) * 2.pow_32(104))\n            + ((self.sdc.pre.unwrap_unchecked() as Field) * 2.pow_32(112));\n\n        // Pack the pre and post values from ScheduledValueChange\n        let svc_pre_packed = self.svc.pre.pack();\n        let svc_post_packed = self.svc.post.pack();\n        for i in 0..N {\n            result[i + 1] = svc_pre_packed[i];\n            result[i + 1 + N] = svc_post_packed[i];\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; 2 * N + 1]) -> Self {\n        let svc = unpack_value_change::<T, N>(fields);\n        let sdc = unpack_delay_change::<INITIAL_DELAY>(fields[0]);\n        Self::new(svc, sdc)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u64, let N: u32> Hash for SharedMutableValues<T, INITIAL_DELAY>\nwhere\n    T: Packable<N>,\n{\n    fn hash(self) -> Field {\n        poseidon2_hash(self.pack())\n    }\n}\n"
    },
    "342": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "356": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    #[inline_always]\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// T = type of item in BoundedVec\n// M = max length of BoundedVec\n// O = field length of T\n// O * M + 1 = total serialized length of BoundedVec<T, M> (the +1 is for length of the BoundedVec)\nimpl<T, let M: u32, let O: u32> Deserialize<O * M + 1> for BoundedVec<T, M>\nwhere\n    T: Deserialize<O>,\n{\n    #[inline_always]\n    fn deserialize(fields: [Field; O * M + 1]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[O * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; O];\n            for j in 0..O {\n                nested_fields[j] = fields[i * O + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl<let N: u32> Deserialize<0> for () {\n    fn deserialize(_fields: [Field; 0]) -> Self {\n        ()\n    }\n}\n\nimpl<T, let M: u32, let O: u32> Serialize<O * M + 1> for BoundedVec<T, M>\nwhere\n    T: Serialize<O>,\n{\n    #[inline_always]\n    fn serialize(self) -> [Field; O * M + 1] {\n        let mut fields = [0; O * M + 1];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..O {\n                fields[i * O + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[O * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    #[inline_always]\n    fn deserialize(fields: [Field; N]) -> Self {\n        str::<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n"
    },
    "361": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as u8 as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as u16 as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as u32 as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as u64 as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "362": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T, let N: u32> Serialize<N + 1> for Option<T>\nwhere\n    T: Serialize<N>,\n{\n    fn serialize(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T, let N: u32> Deserialize<N + 1> for Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    fn deserialize(fields: [Field; N + 1]) -> Self {\n        if fields[0] == 1 {\n            let mut value_serialized: [Field; N] = std::mem::zeroed();\n            for i in 0..N {\n                value_serialized[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_serialized))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n"
    },
    "380": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_padded_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_padded_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_padded_array::{\n    assert_sorted_transformed_i_padded_array_capped_size,\n    assert_sorted_transformed_padded_array_capped_size, validate_padded_items,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    get_split_order_hints::{get_split_order_hints_asc, SplitOrderHints},\n};\npub use assert_split_transformed_padded_arrays::assert_split_transformed_padded_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::sort_by_counter_asc;\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\n// Returns the number of consecutive elements at the start of the array for which the predicate returns false.\n// This function ensures that any element after the first matching element (predicate returns true) also matches the predicate.\npub fn array_length_until<T, let N: u32, Env>(array: [T; N], predicate: fn[Env](T) -> bool) -> u32 {\n    let mut length = 0;\n    let mut stop = false;\n    for i in 0..N {\n        if predicate(array[i]) {\n            stop = true;\n        } else {\n            assert(\n                stop == false,\n                \"matching element found after already encountering a non-matching element\",\n            );\n            length += 1;\n        }\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n// Helper function to check if an array is padded with a given value from a given index.\n// Different to padded_array_length in that it allows the elements before the given index to be the same as the padded value.\npub fn array_padded_with<T, let N: u32>(array: [T; N], from_index: u32, padded_with: T) -> bool\nwhere\n    T: Eq,\n{\n    let mut is_valid = true;\n    let mut should_check = false;\n    for i in 0..N {\n        should_check |= i == from_index;\n        is_valid &= !should_check | (array[i] == padded_with);\n    }\n    is_valid\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nfn test_array_length_until() {\n    let array = [11, 22, 33, 44, 55];\n    assert_eq(array_length_until(array, |x| x == 55), 4);\n    assert_eq(array_length_until(array, |x| x == 56), 5);\n    assert_eq(array_length_until(array, |x| x > 40), 3);\n    assert_eq(array_length_until(array, |x| x > 10), 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_non_consecutive_fails() {\n    let array = [1, 1, 0, 1, 0];\n    let _ = array_length_until(array, |x| x == 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_first_non_matching_fails() {\n    let array = [1, 0, 0, 0, 0];\n    let _ = array_length_until(array, |x| x == 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test]\nfn test_array_padded_with() {\n    let array = [11, 22, 33, 44, 44];\n    assert_eq(array_padded_with(array, 0, 44), false);\n    assert_eq(array_padded_with(array, 1, 44), false);\n    assert_eq(array_padded_with(array, 2, 44), false);\n    assert_eq(array_padded_with(array, 3, 44), true);\n    assert_eq(array_padded_with(array, 4, 44), true);\n    assert_eq(array_padded_with(array, 4, 33), false);\n    assert_eq(array_padded_with(array, 5, 44), true); // Index out of bounds.\n    assert_eq(array_padded_with(array, 0, 11), false);\n}\n"
    },
    "381": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO: This currently only exists to aid point compression in compress_to_blob_commitment().\n// Once compression is part of BigCurve it can either be removed or optimised to be used elsewhere.\npub fn byte_to_bits_be(byte: u8) -> [u1; 8] {\n    let mut mut_byte = byte;\n    let mut bits: [u1; 8] = [0; 8];\n    for i in 0..8 {\n        bits[7 - i] = (mut_byte & 1) as u1;\n        mut_byte >>= 1;\n    }\n    bits\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "383": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "393": {
      "path": "/home/nerses/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "414": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    history::nullifier_inclusion::ProveNullifierInclusion,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{\n            GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER,\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT, PRIVATE_LOG_SIZE_IN_FIELDS,\n        },\n        hash::{compute_siloed_nullifier, poseidon2_hash_with_separator},\n        traits::{Deserialize, FromField, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// This function inserts a partial note validity commitment into the nullifier tree to be later on able to verify\n    /// that the partial note and completer are legitimate. See function docs of `compute_validity_commitment` for more\n    /// details.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n        completer: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient, sender);\n        // Regardless of the original content size, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_private_log(encrypted_log, length);\n\n        let partial_note = PartialUintNote { commitment };\n\n        // Now we compute the validity commitment and push it to the nullifier tree. It can be safely pushed to\n        // the nullifier tree since it uses its own separator, making collisions with actual note nullifiers\n        // practically impossible.\n        let validity_commitment = partial_note.compute_validity_commitment(completer);\n        context.push_nullifier(validity_commitment);\n\n        partial_note\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nglobal NOTE_COMPLETION_LOG_LENGTH: u32 = 2;\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, context: &mut PublicContext, completer: AztecAddress, value: u128) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        assert(\n            context.nullifier_exists(validity_commitment, context.this_address()),\n            \"Invalid partial note or completer\",\n        );\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Completes the partial note, creating a new note that can be used like any other UintNote. Same as `complete`\n    /// function but works from private context.\n    pub fn complete_from_private(\n        self,\n        context: &mut PrivateContext,\n        completer: AztecAddress,\n        value: u128,\n    ) {\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        // `prove_nullifier_inclusion` function expects the nullifier to be siloed (hashed with the address of\n        // the contract that emitted the nullifier) as it checks the value directly against the nullifier tree and all\n        // the nullifiers in the tree are siloed by the protocol.\n        let siloed_validity_commitment =\n            compute_siloed_nullifier(context.this_address(), validity_commitment);\n        context.get_block_header().prove_nullifier_inclusion(siloed_validity_commitment);\n\n        // We need to do two things:\n        //  - emit an unencrypted log containing the public fields (the value) via the private log channel. The\n        //  contract will later find it by searching for the expected tag (which is simply the partial note\n        //  commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_private_log(\n            self.compute_note_completion_log_padded_for_private_log(value),\n            NOTE_COMPLETION_LOG_LENGTH,\n        );\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Computes a validity commitment for this partial note. The commitment cryptographically binds the note's private\n    /// data with the designated completer address. When the note is later completed in public execution, we can load\n    /// this commitment from the nullifier tree and verify that both the partial note (e.g. that the storage slot\n    /// corresponds to the correct owner, and that we're using the correct state variable) and completer are\n    /// legitimate.\n    pub fn compute_validity_commitment(self, completer: AztecAddress) -> Field {\n        poseidon2_hash_with_separator(\n            [self.commitment, completer.to_field()],\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT,\n        )\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; NOTE_COMPLETION_LOG_LENGTH] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_note_completion_log_padded_for_private_log(\n        self,\n        value: u128,\n    ) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n        let note_completion_log = self.compute_note_completion_log(value);\n        let padding = [0; PRIVATE_LOG_SIZE_IN_FIELDS - NOTE_COMPLETION_LOG_LENGTH];\n        array_concat(note_completion_log, padding)\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nimpl ToField for PartialUintNote {\n    fn to_field(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl FromField for PartialUintNote {\n    fn from_field(field: Field) -> Self {\n        Self { commitment: field }\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n}\n"
    },
    "50": {
      "path": "/home/nerses/contracts/chains/aztec/contracts/train/src/lib.nr",
      "source": "pub fn bytes_to_u128_limbs(bytes: [u8; 32]) -> (u128, u128) {\n    let mut high: u128 = 0;\n    let mut low: u128 = 0;\n    for i in 0..16 {\n        high = (high << 8) + (bytes[i] as u128);\n    }\n    for i in 16..32 {\n        low = (low << 8) + (bytes[i] as u128);\n    }\n    (high, low)\n}\n\npub fn u128_limbs_to_bytes(high: u128, low: u128) -> [u8; 32] {\n    let mut bytes: [u8; 32] = [0; 32];\n\n    let mut temp = high;\n    for i in 0..16 {\n        bytes[15 - i] = (temp & 0xff) as u8;\n        temp >>= 8;\n    }\n\n    temp = low;\n    for i in 0..16 {\n        bytes[31 - i] = (temp & 0xff) as u8;\n        temp >>= 8;\n    }\n\n    bytes\n}\n"
    },
    "51": {
      "path": "/home/nerses/contracts/chains/aztec/contracts/train/src/main.nr",
      "source": "//     @@                                    @@@\n//    @@@\n//    @@@        @@   @@@@      @@@@@         @     @    @@@@@\n//  @@@@@@@@@   @@@@@@      @@@@    @@@@@    @@@   @@@@@@    @@@@\n//    @@@       @@@       @@@           @@@  @@@   @@@          @@@\n//    @@@       @@@       @@@           @@@  @@@   @@@          @@@\n//    @@@       @@@       @@@           @@@  @@@   @@@          @@@\n//     @@@      @@@        @@@@       @@@@@  @@@   @@@          @@@\n//       @@@@@  @@@           @@@@@@@@@ @@@  @@@   @@@          @@@\n\nmod lib;\nmod types;\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract Train {\n    use crate::lib::{bytes_to_u128_limbs, u128_limbs_to_bytes};\n    use crate::types::events::{\n        TokenCommitted, TokenLockAdded, TokenLockedFirst, TokenLockedSecond, TokenRedeemed,\n        TokenRefunded,\n    };\n    use dep::aztec::messages::logs::note::encode_and_encrypt_note;\n    use dep::aztec::protocol_types::traits::{Deserialize, Packable, Serialize};\n    use dep::aztec::state_vars::{private_immutable::PrivateImmutable, SharedMutable};\n    use dep::sha256;\n    use dep::token::Token;\n    use aztec::macros::{\n        functions::{initializer, internal, private, public, utility, view},\n        notes::note,\n        storage::storage,\n    };\n    use aztec::prelude::{AztecAddress, Map};\n    use std::meta::derive;\n\n    #[note]\n    #[derive(Eq)]\n    struct HTLC_Private {\n        owner: AztecAddress,\n        randomness: Field,\n    }\n    #[derive(Eq, Packable, Serialize, Deserialize)]\n    pub struct HTLC_Public {\n        src_receiver: AztecAddress,\n        amount: u128,\n        token: AztecAddress,\n        hashlock_high: u128,\n        hashlock_low: u128,\n        secret_high: u128,\n        secret_low: u128,\n        ownership_hash_high: u128,\n        ownership_hash_low: u128,\n        timelock: u64,\n        claimed: u8,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor() {}\n\n    #[storage]\n    struct Storage<Context> {\n        contracts_private: Map<Field, PrivateImmutable<HTLC_Private, Context>, Context>,\n        contracts_public: Map<Field, SharedMutable<HTLC_Public, 180, Context>, Context>,\n    }\n\n    #[private]\n    fn commit_private_user(\n        Id: Field,\n        src_receiver: AztecAddress,\n        timelock: u64,\n        token: AztecAddress,\n        amount: u128,\n        src_asset: str<30>,\n        dst_chain: str<30>,\n        dst_asset: str<30>,\n        dst_address: str<90>,\n        randomness: Field,\n    ) {\n        assert(amount > 0, \"FundsNotSent\");\n\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address())\n            .commit_public_user(\n                src_asset,\n                dst_chain,\n                dst_asset,\n                dst_address,\n                Id,\n                src_receiver,\n                timelock,\n                token,\n                amount,\n            )\n            .enqueue(&mut context);\n\n        let htlc_note = HTLC_Private { owner: context.msg_sender(), randomness: randomness };\n        storage.contracts_private.at(Id).initialize(htlc_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n\n        Token::at(token)\n            .transfer_to_public(context.msg_sender(), context.this_address(), amount, randomness)\n            .call(&mut context);\n    }\n\n    #[internal]\n    #[public]\n    fn commit_public_user(\n        src_asset: str<30>,\n        dst_chain: str<30>,\n        dst_asset: str<30>,\n        dst_address: str<90>,\n        Id: Field,\n        src_receiver: AztecAddress,\n        timelock: u64,\n        token: AztecAddress,\n        amount: u128,\n    ) {\n        let htlc_public_current = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public_current.amount == 0, \"HTLCAlreadyExists\");\n        assert(context.timestamp() + 900 < timelock, \"InvalidTimelock\");\n        let htlc_public = HTLC_Public {\n            src_receiver: src_receiver,\n            amount: amount,\n            token: token,\n            hashlock_high: 0 as u128,\n            hashlock_low: 0 as u128,\n            secret_high: 0 as u128,\n            secret_low: 0 as u128,\n            ownership_hash_high: 0 as u128,\n            ownership_hash_low: 0 as u128,\n            timelock: timelock,\n            claimed: 1 as u8,\n        };\n        storage.contracts_public.at(Id).schedule_value_change(htlc_public);\n        let log_msg = TokenCommitted {\n            Id: Id,\n            amount: amount,\n            token: token,\n            timelock: timelock,\n            src_receiver: src_receiver,\n            src_asset: src_asset,\n            dst_chain: dst_chain,\n            dst_asset: dst_asset,\n            dst_address: dst_address,\n        };\n        context.emit_public_log(log_msg.pack());\n    }\n\n    #[private]\n    fn add_lock_private_user(Id: Field, hashlock_high: u128, hashlock_low: u128, timelock: u64) {\n        let hashlock = u128_limbs_to_bytes(hashlock_high, hashlock_low);\n        let htlc_private = storage.contracts_private.at(Id).get_note();\n        assert(htlc_private.owner == context.msg_sender(), \"NoAllowance\");\n\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address()).add_lock_public_user(Id, hashlock, timelock).enqueue(\n            &mut context,\n        );\n    }\n\n    #[internal]\n    #[public]\n    fn add_lock_public_user(Id: Field, hashlock: [u8; 32], timelock: u64) {\n        assert(context.timestamp() + 900 < timelock, \"InvalidTimelock\");\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n        assert(htlc_public.hashlock_high == (0 as u128), \"HashlockAlreadySet\");\n        assert(htlc_public.hashlock_low == (0 as u128), \"HashlockAlreadySet\");\n\n        let hashlock_tuple = bytes_to_u128_limbs(hashlock);\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: hashlock_tuple.0,\n            hashlock_low: hashlock_tuple.1,\n            secret_high: htlc_public.secret_high,\n            secret_low: htlc_public.secret_low,\n            ownership_hash_high: htlc_public.ownership_hash_high,\n            ownership_hash_low: htlc_public.ownership_hash_low,\n            timelock: timelock,\n            claimed: htlc_public.claimed,\n        };\n        storage.contracts_public.at(Id).schedule_value_change(modified_htlc_public);\n        let log_msg = TokenLockAdded { Id, hashlock, timelock };\n        context.emit_public_log(log_msg.pack());\n    }\n\n    #[private]\n    fn refund_private(Id: Field) {\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address()).refund_public(Id).enqueue(&mut context);\n\n        let htlc_private = storage.contracts_private.at(Id).get_note();\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n\n        let partial_note = Token::at(htlc_public.token)\n            .prepare_private_balance_increase(htlc_private.owner, htlc_private.owner)\n            .call(&mut context);\n        Token::at(htlc_public.token)\n            .finalize_transfer_to_private(htlc_public.amount, partial_note)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn refund_public(Id: Field) {\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n        assert(htlc_public.timelock < context.timestamp(), \"NotPassedTimelock\");\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: htlc_public.hashlock_high,\n            hashlock_low: htlc_public.hashlock_low,\n            secret_high: htlc_public.secret_high,\n            secret_low: htlc_public.secret_low,\n            ownership_hash_high: htlc_public.ownership_hash_high,\n            ownership_hash_low: htlc_public.ownership_hash_low,\n            timelock: htlc_public.timelock,\n            claimed: 2 as u8,\n        };\n\n        storage.contracts_public.at(Id).schedule_value_change(modified_htlc_public);\n        let log_msg = TokenRefunded { Id };\n        context.emit_public_log(log_msg.pack());\n    }\n\n    #[private]\n    fn lock_private_solver(\n        Id: Field,\n        hashlock_high: u128,\n        hashlock_low: u128,\n        amount: u128,\n        ownership_hash_high: u128,\n        ownership_hash_low: u128,\n        timelock: u64,\n        token: AztecAddress,\n        randomness: Field,\n        src_asset: str<30>,\n        dst_chain: str<30>,\n        dst_asset: str<30>,\n        dst_address: str<90>,\n    ) {\n        assert(amount > 0, \"FundsNotSent\");\n        let hashlock = u128_limbs_to_bytes(hashlock_high, hashlock_low);\n        let ownership_hash = u128_limbs_to_bytes(ownership_hash_high, ownership_hash_low);\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address())\n            .lock_public_solver(\n                Id,\n                hashlock,\n                ownership_hash,\n                amount,\n                token,\n                timelock,\n                src_asset,\n                dst_chain,\n                dst_asset,\n                dst_address,\n            )\n            .enqueue(&mut context);\n\n        let htlc_note = HTLC_Private { owner: context.msg_sender(), randomness: randomness };\n        storage.contracts_private.at(Id).initialize(htlc_note).emit(encode_and_encrypt_note(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n\n        Token::at(token)\n            .transfer_to_public(context.msg_sender(), context.this_address(), amount, randomness)\n            .call(&mut context);\n    }\n\n    #[internal]\n    #[public]\n    fn lock_public_solver(\n        Id: Field,\n        hashlock: [u8; 32],\n        ownership_hash: [u8; 32],\n        amount: u128,\n        token: AztecAddress,\n        timelock: u64,\n        src_asset: str<30>,\n        dst_chain: str<30>,\n        dst_asset: str<30>,\n        dst_address: str<90>,\n    ) {\n        let htlc_public_current = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public_current.amount == 0, \"HTLCAlreadyExists\");\n        assert(context.timestamp() + 1800 < timelock, \"InvalidTimelock\");\n        let hashlock_tuple = bytes_to_u128_limbs(hashlock);\n        let ownership_hash_tuple = bytes_to_u128_limbs(ownership_hash);\n        let htlc_public = HTLC_Public {\n            src_receiver: AztecAddress::zero(),\n            amount: amount,\n            token: token,\n            hashlock_high: hashlock_tuple.0,\n            hashlock_low: hashlock_tuple.1,\n            secret_high: 0 as u128,\n            secret_low: 0 as u128,\n            ownership_hash_high: ownership_hash_tuple.0,\n            ownership_hash_low: ownership_hash_tuple.1,\n            timelock: timelock,\n            claimed: 1 as u8,\n        };\n        storage.contracts_public.at(Id).schedule_value_change(htlc_public);\n\n        let log_msg_1 = TokenLockedFirst {\n            Id: Id,\n            amount: amount,\n            token: token,\n            timelock: timelock,\n            src_receiver: AztecAddress::zero(),\n            src_asset: src_asset,\n            dst_chain: dst_chain,\n            dst_asset: dst_asset,\n            dst_address: dst_address,\n        };\n\n        let log_msg_2 =\n            TokenLockedSecond { Id: Id, hashlock: hashlock, ownership_hash: ownership_hash };\n\n        context.emit_public_log(log_msg_1.pack());\n        context.emit_public_log(log_msg_2.pack());\n    }\n\n    #[private]\n    fn redeem_private(\n        Id: Field,\n        secret_high: u128,\n        secret_low: u128,\n        ownership_key_high: u128,\n        ownership_key_low: u128,\n    ) {\n        let secret = u128_limbs_to_bytes(secret_high, secret_low);\n        let ownership_key = u128_limbs_to_bytes(ownership_key_high, ownership_key_low);\n\n        // Safety: The contract intentionally exposes these parameters as public.\n        Train::at(context.this_address()).redeem_public(Id, secret, ownership_key).enqueue(\n            &mut context,\n        );\n        let htlc_public = storage.contracts_public.at(Id).get_current_value();\n        if (htlc_public.ownership_hash_high == 0 as u128) {\n            if htlc_public.ownership_hash_low == 0 as u128 {\n                let partial_note = Token::at(htlc_public.token)\n                    .prepare_private_balance_increase(\n                        htlc_public.src_receiver,\n                        htlc_public.src_receiver,\n                    )\n                    .call(&mut context);\n                Token::at(htlc_public.token)\n                    .finalize_transfer_to_private(htlc_public.amount, partial_note)\n                    .enqueue(&mut context);\n            }\n        } else {\n            let partial_note = Token::at(htlc_public.token)\n                .prepare_private_balance_increase(context.msg_sender(), context.msg_sender())\n                .call(&mut context);\n            Token::at(htlc_public.token)\n                .finalize_transfer_to_private(htlc_public.amount, partial_note)\n                .enqueue(&mut context);\n        }\n    }\n\n    #[public]\n    #[internal]\n    fn redeem_public(Id: Field, secret: [u8; 32], ownership_key: [u8; 32]) {\n        let mut htlc_public = storage.contracts_public.at(Id).get_current_value();\n        assert(htlc_public.amount > 0, \"HTLCNotExists\"); // If it doesn't exist, all parameters will default to zero values.\n        let hashed_secret = sha256::sha256_var(secret, secret.len() as u64);\n        let hashed_secret_tuple = bytes_to_u128_limbs(hashed_secret);\n        assert(htlc_public.hashlock_high == hashed_secret_tuple.0, \"HashlockNotMatch\");\n        assert(htlc_public.hashlock_low == hashed_secret_tuple.1, \"HashlockNotMatch\");\n        assert(htlc_public.claimed == 1, \"AlreadyClaimed\");\n\n        if (htlc_public.ownership_hash_high != 0 as u128) {\n            if htlc_public.ownership_hash_low != 0 as u128 {\n                let ownership_key_hashed =\n                    sha256::sha256_var(ownership_key, ownership_key.len() as u64);\n                let ownership_key_tuple = bytes_to_u128_limbs(ownership_key_hashed);\n                assert(htlc_public.ownership_hash_high == ownership_key_tuple.0, \"NotAnOwner\");\n                assert(htlc_public.ownership_hash_low == ownership_key_tuple.1, \"NotAnOwner\");\n            }\n        }\n\n        let secret_limbs = bytes_to_u128_limbs(secret);\n\n        let modified_htlc_public = HTLC_Public {\n            src_receiver: htlc_public.src_receiver,\n            amount: htlc_public.amount,\n            token: htlc_public.token,\n            hashlock_high: htlc_public.hashlock_high,\n            hashlock_low: htlc_public.hashlock_low,\n            secret_high: secret_limbs.0,\n            secret_low: secret_limbs.1,\n            ownership_hash_high: htlc_public.ownership_hash_high,\n            ownership_hash_low: htlc_public.ownership_hash_low,\n            timelock: htlc_public.timelock,\n            claimed: 3 as u8,\n        };\n\n        storage.contracts_public.at(Id).schedule_value_change(modified_htlc_public);\n\n        let log_msg = TokenRedeemed {\n            Id: Id,\n            hashlock: u128_limbs_to_bytes(htlc_public.hashlock_high, htlc_public.hashlock_low),\n            secret: secret,\n        };\n\n        context.emit_public_log(log_msg.pack());\n    }\n\n    // This utility function should be invoked by the frontend before each function call\n    // where the existence or non-existence of an HTLC is a critical security check.\n    #[utility]\n    unconstrained fn is_contract_initialized(Id: Field) -> bool {\n        storage.contracts_private.at(Id).is_initialized()\n    }\n\n    #[view]\n    #[utility]\n    unconstrained fn get_htlc_public(key: Field) -> pub HTLC_Public {\n        storage.contracts_public.at(key).get_current_value()\n    }\n}\n"
    },
    "52": {
      "path": "/home/nerses/contracts/chains/aztec/contracts/train/src/types/events.nr",
      "source": "use crate::lib::{bytes_to_u128_limbs, u128_limbs_to_bytes};\nuse dep::aztec::prelude::AztecAddress;\nuse dep::aztec::protocol_types::traits::{Packable, Serialize};\n\n#[derive(Serialize)]\npub struct TokenCommitted {\n    pub Id: Field,\n    pub amount: u128,\n    pub token: AztecAddress,\n    pub timelock: u64,\n    pub src_receiver: AztecAddress,\n    pub src_asset: str<30>,\n    pub dst_chain: str<30>,\n    pub dst_asset: str<30>,\n    pub dst_address: str<90>,\n}\n\nimpl Packable<12> for TokenCommitted {\n    fn pack(self) -> [Field; 12] {\n        let zero: Field = 0;\n        let mut out = [zero; 12];\n        out[0] = 0x7A3F2B1C;\n        out[1] = self.Id;\n        out[2] = self.amount as Field;\n        out[3] = self.token.inner;\n        out[4] = self.timelock as Field;\n        out[5] = self.src_receiver.inner;\n\n        let src_asset_byte_array = self.src_asset.as_bytes();\n        let mut src_asset_byte_array_filled = [0 as u8; 30];\n        for i in 0..src_asset_byte_array.len() {\n            src_asset_byte_array_filled[i] = src_asset_byte_array[i];\n        }\n        out[6] = Field::from_be_bytes::<30>(src_asset_byte_array_filled);\n\n        let dst_chain_byte_array = self.dst_chain.as_bytes();\n        let mut dst_chain_byte_array_filled = [0 as u8; 30];\n        for i in 0..dst_chain_byte_array.len() {\n            dst_chain_byte_array_filled[i] = dst_chain_byte_array[i];\n        }\n        out[7] = Field::from_be_bytes::<30>(dst_chain_byte_array_filled);\n\n        let dst_asset_byte_array = self.dst_asset.as_bytes();\n        let mut dst_asset_byte_array_filled = [0 as u8; 30];\n        for i in 0..dst_asset_byte_array.len() {\n            dst_asset_byte_array_filled[i] = dst_asset_byte_array[i];\n        }\n        out[8] = Field::from_be_bytes::<30>(dst_asset_byte_array_filled);\n\n        let dst_address_byte_array = self.dst_address.as_bytes();\n        let mut dst_address_byte_array_filled_1 = [0 as u8; 30];\n        let mut dst_address_byte_array_filled_2 = [0 as u8; 30];\n        let mut dst_address_byte_array_filled_3 = [0 as u8; 30];\n\n        for i in 0..30 {\n            dst_address_byte_array_filled_1[i] = dst_address_byte_array[i];\n            dst_address_byte_array_filled_2[i] = dst_address_byte_array[i + 30];\n            dst_address_byte_array_filled_3[i] = dst_address_byte_array[i + 60];\n        }\n\n        out[9] = Field::from_be_bytes::<30>(dst_address_byte_array_filled_1);\n        out[10] = Field::from_be_bytes::<30>(dst_address_byte_array_filled_2);\n        out[11] = Field::from_be_bytes::<30>(dst_address_byte_array_filled_3);\n        out\n    }\n\n    fn unpack(fields: [Field; 12]) -> Self {\n        assert(false, \"unpack not implemented\");\n        TokenCommitted {\n            Id: fields[1] as Field,\n            amount: 0 as u128,\n            token: AztecAddress::zero(),\n            timelock: 0 as u64,\n            src_receiver: AztecAddress::zero(),\n            src_asset: \"000000000000000000000000000000\",\n            dst_chain: \"000000000000000000000000000000\",\n            dst_asset: \"000000000000000000000000000000\",\n            dst_address: \"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n        }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenLockAdded {\n    pub Id: Field,\n    pub hashlock: [u8; 32],\n    pub timelock: u64,\n}\n\nimpl Packable<5> for TokenLockAdded {\n    fn pack(self) -> [Field; 5] {\n        let mut out = [0 as Field; 5];\n        out[0] = 0xC1D4E792;\n        out[1] = self.Id;\n\n        let (hashlock_high, hashlock_low) = bytes_to_u128_limbs(self.hashlock);\n        out[2] = hashlock_high as Field;\n        out[3] = hashlock_low as Field;\n        out[4] = self.timelock as Field;\n        out\n    }\n\n    fn unpack(fields: [Field; 5]) -> Self {\n        let Id = fields[1];\n        let hashlock = u128_limbs_to_bytes(fields[2] as u128, fields[3] as u128);\n        let timelock = fields[4] as u64;\n        TokenLockAdded { Id, hashlock, timelock }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenRefunded {\n    pub Id: Field,\n}\n\nimpl Packable<2> for TokenRefunded {\n    fn pack(self) -> [Field; 2] {\n        let mut out = [0 as Field; 2];\n        out[0] = 0x2D17C6B8;\n        out[1] = self.Id;\n        out\n    }\n\n    fn unpack(fields: [Field; 2]) -> Self {\n        let Id = fields[1];\n        TokenRefunded { Id }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenRedeemed {\n    pub Id: Field,\n    pub hashlock: [u8; 32],\n    pub secret: [u8; 32],\n}\n\nimpl Packable<6> for TokenRedeemed {\n    fn pack(self) -> [Field; 6] {\n        let mut out = [0 as Field; 6];\n        out[0] = 0x4F8B9A3E;\n        out[1] = self.Id;\n\n        let (hashlock_high, hashlock_low) = bytes_to_u128_limbs(self.hashlock);\n        out[2] = hashlock_high as Field;\n        out[3] = hashlock_low as Field;\n\n        let (secret_high, secret_low) = bytes_to_u128_limbs(self.secret);\n        out[4] = secret_high as Field;\n        out[5] = secret_low as Field;\n\n        out\n    }\n\n    fn unpack(fields: [Field; 6]) -> Self {\n        let Id = fields[1];\n        let hashlock = u128_limbs_to_bytes(fields[2] as u128, fields[3] as u128);\n        let secret = u128_limbs_to_bytes(fields[4] as u128, fields[5] as u128);\n\n        TokenRedeemed { Id, hashlock, secret }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenLockedFirst {\n    pub Id: Field,\n    pub amount: u128,\n    pub token: AztecAddress,\n    pub timelock: u64,\n    pub src_receiver: AztecAddress,\n    pub src_asset: str<30>,\n    pub dst_chain: str<30>,\n    pub dst_asset: str<30>,\n    pub dst_address: str<90>,\n}\n\nimpl Packable<12> for TokenLockedFirst {\n    fn pack(self) -> [Field; 12] {\n        let zero: Field = 0;\n        let mut out = [zero; 12];\n        out[0] = 0x9E5A4F03;\n        out[1] = self.Id;\n        out[2] = self.amount as Field;\n        out[3] = self.token.inner;\n        out[4] = self.timelock as Field;\n        out[5] = self.src_receiver.inner;\n\n        let src_asset_byte_array = self.src_asset.as_bytes();\n        let mut src_asset_byte_array_filled = [0 as u8; 30];\n        for i in 0..src_asset_byte_array.len() {\n            src_asset_byte_array_filled[i] = src_asset_byte_array[i];\n        }\n        out[6] = Field::from_be_bytes::<30>(src_asset_byte_array_filled);\n\n        let dst_chain_byte_array = self.dst_chain.as_bytes();\n        let mut dst_chain_byte_array_filled = [0 as u8; 30];\n        for i in 0..dst_chain_byte_array.len() {\n            dst_chain_byte_array_filled[i] = dst_chain_byte_array[i];\n        }\n        out[7] = Field::from_be_bytes::<30>(dst_chain_byte_array_filled);\n\n        let dst_asset_byte_array = self.dst_asset.as_bytes();\n        let mut dst_asset_byte_array_filled = [0 as u8; 30];\n        for i in 0..dst_asset_byte_array.len() {\n            dst_asset_byte_array_filled[i] = dst_asset_byte_array[i];\n        }\n        out[8] = Field::from_be_bytes::<30>(dst_asset_byte_array_filled);\n\n        let dst_address_byte_array = self.dst_address.as_bytes();\n        let mut dst_address_byte_array_filled_1 = [0 as u8; 30];\n        let mut dst_address_byte_array_filled_2 = [0 as u8; 30];\n        let mut dst_address_byte_array_filled_3 = [0 as u8; 30];\n\n        for i in 0..30 {\n            dst_address_byte_array_filled_1[i] = dst_address_byte_array[i];\n            dst_address_byte_array_filled_2[i] = dst_address_byte_array[i + 30];\n            dst_address_byte_array_filled_3[i] = dst_address_byte_array[i + 60];\n        }\n\n        out[9] = Field::from_be_bytes::<30>(dst_address_byte_array_filled_1);\n        out[10] = Field::from_be_bytes::<30>(dst_address_byte_array_filled_2);\n        out[11] = Field::from_be_bytes::<30>(dst_address_byte_array_filled_3);\n        out\n    }\n\n    fn unpack(fields: [Field; 12]) -> Self {\n        assert(false, \"unpack not implemented\");\n        TokenLockedFirst {\n            Id: fields[1] as Field,\n            amount: 0 as u128,\n            token: AztecAddress::zero(),\n            timelock: 0 as u64,\n            src_receiver: AztecAddress::zero(),\n            src_asset: \"000000000000000000000000000000\",\n            dst_chain: \"000000000000000000000000000000\",\n            dst_asset: \"000000000000000000000000000000\",\n            dst_address: \"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n        }\n    }\n}\n\n#[derive(Serialize)]\npub struct TokenLockedSecond {\n    pub Id: Field,\n    pub hashlock: [u8; 32],\n    pub ownership_hash: [u8; 32],\n}\n\nimpl Packable<6> for TokenLockedSecond {\n    fn pack(self) -> [Field; 6] {\n        let mut out = [0 as Field; 6];\n        out[0] = 0x9E5A4F03;\n        out[1] = self.Id;\n\n        let (hashlock_high, hashlock_low) = bytes_to_u128_limbs(self.hashlock);\n        out[2] = hashlock_high as Field;\n        out[3] = hashlock_low as Field;\n\n        let (ownership_hash_high, ownership_hash_low) = bytes_to_u128_limbs(self.ownership_hash);\n        out[4] = ownership_hash_high as Field;\n        out[5] = ownership_hash_low as Field;\n\n        out\n    }\n\n    fn unpack(fields: [Field; 6]) -> Self {\n        assert(false, \"unpack not implemented\");\n        TokenLockedSecond {\n            Id: fields[1] as Field,\n            hashlock: [0 as u8; 32],\n            ownership_hash: [0 as u8; 32],\n        }\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "63": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env, let N: u32>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize<N>,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n        // we do not care about the order in which each tuple was passed to the closure.\n        let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n        array.for_each(|index, value| { called_with.push((index, value)); });\n\n        assert_eq(called_with.len(), 3);\n        assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n        assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n        assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| {\n            if index == 1 {\n                array.remove(index);\n            }\n        });\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 4);\n        assert_eq(array.get(1), 6);\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let contract_address = setup();\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(4);\n        array.push(5);\n        array.push(6);\n\n        array.for_each(|index, _| { array.remove(index); });\n\n        assert_eq(array.len(), 0);\n    }\n\n    // TODO: uncomment this test once OracleMock::count is implemented in the stdlib.\n    // #[test]\n    // unconstrained fn for_each_remove_all_no_copy() {\n    //     let contract_address = setup();\n    //     let array = CapsuleArray::at(contract_address, SLOT);\n\n    //     array.push(4);\n    //     array.push(5);\n    //     array.push(6);\n\n    //     // We test that the copyCapsule was never called, which is the expensive operation we want to avoid.\n    //     let mock = OracleMock::mock(\"copyCapsule\");\n\n    //     array.for_each(|index, _| {\n    //         array.remove(index);\n    //     });\n\n    //     assert_eq(mock.count(), 0);\n    // }\n}\n"
    },
    "64": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{\n    gas::GasOpts, private_context::PrivateContext, public_context::PublicContext,\n    returns_hash::ReturnsHash,\n};\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\nuse crate::test::helpers::cheatcodes;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T, let N: u32> PrivateCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PrivateCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let M: u32, T, let N: u32> PrivateVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PrivateVoidCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T, let N: u32> PrivateStaticCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<N>,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PrivateStaticCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let M: u32, T, let N: u32> PrivateStaticVoidCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args, self.args_hash);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PrivateStaticVoidCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T, let N: u32> PublicCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) -> T {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<N>())\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<N>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PublicCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T, let N: u32> PublicVoidCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PublicVoidCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T, let N: u32> PublicStaticCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<N>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PublicStaticCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T, let N: u32> PublicStaticVoidCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for PublicStaticVoidCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// UtilityCallInterface\n\npub struct UtilityCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for UtilityCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        false\n    }\n}\n\nimpl<let M: u32, T, let N: u32> UtilityCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n\n// UtilityVoidCallInterface\n\npub struct UtilityVoidCallInterface<let M: u32, T, let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let M: u32, T, let N: u32> CallInterface<M> for UtilityVoidCallInterface<M, T, N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        false\n    }\n}\n\nimpl<let M: u32, T, let N: u32> UtilityVoidCallInterface<M, T, N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n\npub trait TXEPublicCallInterface<T, let N: u32> {\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field);\n}\n\nimpl<let M: u32, T, let N: u32> TXEPublicCallInterface<T, N> for PublicCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let (returns_hash, tx_hash) = cheatcodes::public_call_new_flow(\n            from,\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.is_static,\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPublicCallInterface<T, N> for PublicVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let (returns_hash, tx_hash) = cheatcodes::public_call_new_flow(\n            from,\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.is_static,\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage_and_assert_empty();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPublicCallInterface<T, N> for PublicStaticCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let (returns_hash, tx_hash) = cheatcodes::public_call_new_flow(\n            from,\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.is_static,\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPublicCallInterface<T, N> for PublicStaticVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let (returns_hash, tx_hash) = cheatcodes::public_call_new_flow(\n            from,\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.is_static,\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage_and_assert_empty();\n\n        (returns, tx_hash)\n    }\n}\n\npub trait TXEPrivateCallInterface<T, let N: u32> {\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field);\n}\n\nimpl<let M: u32, T, let N: u32> TXEPrivateCallInterface<T, N> for PrivateCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n\n        let (_end_side_effect_counter, returns_hash, tx_hash) = cheatcodes::private_call_new_flow(\n            from,\n            self.get_contract_address(),\n            self.get_selector(),\n            args,\n            args_hash,\n            self.get_is_static(),\n        );\n\n        let returns: T = ReturnsHash::new(returns_hash).get_preimage();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPrivateCallInterface<T, N> for PrivateVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n\n        let (_end_side_effect_counter, returns_hash, tx_hash) = cheatcodes::private_call_new_flow(\n            from,\n            self.get_contract_address(),\n            self.get_selector(),\n            args,\n            args_hash,\n            self.get_is_static(),\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage_and_assert_empty();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPrivateCallInterface<T, N> for PrivateStaticCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n\n        let (_, returns_hash, tx_hash) = cheatcodes::private_call_new_flow(\n            from,\n            self.get_contract_address(),\n            self.get_selector(),\n            args,\n            args_hash,\n            self.get_is_static(),\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage();\n\n        (returns, tx_hash)\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEPrivateCallInterface<T, N> for PrivateStaticVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self, from: AztecAddress) -> (T, Field) {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n\n        let (_, returns_hash, tx_hash) = cheatcodes::private_call_new_flow(\n            from,\n            self.get_contract_address(),\n            self.get_selector(),\n            args,\n            args_hash,\n            self.get_is_static(),\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage_and_assert_empty();\n\n        (returns, tx_hash)\n    }\n}\n\npub trait TXEUtilityCallInterface<T, let N: u32> {\n    unconstrained fn call_with_txe(self) -> T;\n}\n\nimpl<let M: u32, T, let N: u32> TXEUtilityCallInterface<T, N> for UtilityCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self) -> T {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n\n        let returns_hash = crate::oracle::simulate_utility_function::simulate_utility_function(\n            self.get_contract_address(),\n            self.get_selector(),\n            args_hash,\n        );\n\n        let returns: T = ReturnsHash::new(returns_hash).get_preimage();\n        returns\n    }\n}\n\nimpl<let M: u32, T, let N: u32> TXEUtilityCallInterface<T, N> for UtilityVoidCallInterface<M, T, N>\nwhere\n    T: Deserialize<N>,\n{\n    unconstrained fn call_with_txe(self) -> T {\n        let args = self.get_args();\n        let args_hash = hash_args(args);\n        execution_cache::store(args, args_hash);\n\n        let returns_hash = crate::oracle::simulate_utility_function::simulate_utility_function(\n            self.get_contract_address(),\n            self.get_selector(),\n            args_hash,\n        );\n\n        let returns = ReturnsHash::new(returns_hash).get_preimage_and_assert_empty();\n        returns\n    }\n}\n"
    },
    "71": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        include_by_timestamp::IncludeByTimestamp,\n        log_hash::LogHash,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub include_by_timestamp: IncludeByTimestamp,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<Counted<L2ToL1Message>, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            include_by_timestamp: IncludeByTimestamp::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            include_by_timestamp: self.include_by_timestamp,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:include-by-timestamp\n    pub fn set_include_by_timestamp(&mut self, include_by_timestamp: u64) {\n        // docs:end:include-by-timestamp\n        self.include_by_timestamp =\n            IncludeByTimestamp::min_with_u64(self.include_by_timestamp, include_by_timestamp);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content };\n        self.l2_to_l1_msgs.push(message.count(self.next_counter()));\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            include_by_timestamp: IncludeByTimestamp::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "72": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_U32_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> u128 {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> u128 {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "73": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n\n    pub fn get_preimage_and_assert_empty<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n        assert_eq(self.hash, 0);\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "74": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_timestamp, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let timestamp = get_timestamp();\n        let contract_address = get_contract_address();\n        let version = get_version();\n        let chain_id = get_chain_id();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let timestamp = get_timestamp();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let timestamp = get_timestamp();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "77": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/event/event_selector.nr",
      "source": "use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    // TODO(#2707): Consider making this a u64 as we already cast this to that when encoding the message. This would decrease\n    // the likelihood of collisions without any extra cost.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "79": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{\n        poseidon2_hash_subarray, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice,\n        sha256_to_field,\n    },\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n    // +1 to length to account for the separator\n    let nonzero_length = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, nonzero_length)\n    // NOTE: we use poseidon2_hash_subarray here because we want to hash the bytecode only up to\n    // its nonzero length. We do NOT want to include a `1` at the end to indicate \"variable length\",\n    // and we want to enforce that all trailing elements are zero.\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "91": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n    hash::poseidon2_hash_with_separator, utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(self.global_variables.block_number, public_data_tree_index)\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "94": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/keys/ecdh_shared_secret.nr",
      "source": "use dep::protocol_types::{\n    address::aztec_address::AztecAddress, point::Point, scalar::Scalar, traits::FromField,\n};\nuse std::{embedded_curve_ops::multi_scalar_mul, ops::Neg};\n\n/// Computes a standard ecdh shared secret: [secret] * public_key = shared_secret.\n/// The input secret is known only to one party. The output shared secret is derivable\n/// by both parties, through this function.\n/// E.g.:\n/// Epk = esk * G // ephemeral keypair\n/// Pk = sk * G // recipient keypair\n/// Shared secret S = esk * Pk = sk * Epk // see how this function can be called with two different sets of inputs, depending on which secret the caller knows (either esk or sk)?\n// See also: https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman\npub fn derive_ecdh_shared_secret(secret: Scalar, public_key: Point) -> Point {\n    let shared_secret = multi_scalar_mul([public_key], [secret]);\n    shared_secret\n}\n\n/// Computes a standard ecdh shared secret using the address public key of the given address:\n/// [ephemeral_secret] * recipient_address_public_key = shared_secret.\n/// The intention is that the _creator_ of a shared secret would call this function,\n/// given the address of their intended recipient.\npub fn derive_ecdh_shared_secret_using_aztec_address(\n    ephemeral_secret: Scalar,\n    recipient_address: AztecAddress,\n) -> Point {\n    derive_ecdh_shared_secret(ephemeral_secret, recipient_address.to_address_point().inner)\n}\n\n#[test]\nunconstrained fn test_consistency_with_typescript() {\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let shared_secret = derive_ecdh_shared_secret(secret, point);\n\n    // This is just pasted from a test run.\n    // The original typescript code from which this could be generated seems to have been deleted by someone, and soon the typescript code for encryption and decryption won't be needed, so this will have to do.\n    let hard_coded_shared_secret = Point {\n        x: 0x15d55a5b3b2caa6a6207f313f05c5113deba5da9927d6421bcaa164822b911bc,\n        y: 0x0974c3d0825031ae933243d653ebb1a0b08b90ee7f228f94c5c74739ea3c871e,\n        is_infinite: false,\n    };\n    assert_eq(shared_secret, hard_coded_shared_secret);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let shared_secret = derive_ecdh_shared_secret(secret_a, pk_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n\n#[test]\nunconstrained fn test_shared_secret_computation_from_address_in_both_directions() {\n    let secret_a = Scalar { lo: 0x1234, hi: 0x2345 };\n    let secret_b = Scalar { lo: 0x3456, hi: 0x4567 };\n\n    let mut pk_a = std::embedded_curve_ops::fixed_base_scalar_mul(secret_a);\n    let mut pk_b = std::embedded_curve_ops::fixed_base_scalar_mul(secret_b);\n\n    let address_b = AztecAddress::from_field(pk_b.x);\n\n    // We were lazy in deriving the secret keys, and didn't check the resulting y-coordinates\n    // of the pk_a or pk_b to be less than half the field modulus.\n    // If needed, we negate the pk's so that they yield valid address points.\n    // (We could also have negated the secrets, but there's no negate method for\n    // EmbeddedCurvesScalar).\n    pk_a = if (AztecAddress::from_field(pk_a.x).to_address_point().inner == pk_a) {\n        pk_a\n    } else {\n        pk_a.neg()\n    };\n    pk_b = if (address_b.to_address_point().inner == pk_b) {\n        pk_b\n    } else {\n        pk_b.neg()\n    };\n\n    let shared_secret = derive_ecdh_shared_secret_using_aztec_address(secret_a, address_b);\n    let shared_secret_alt = derive_ecdh_shared_secret(secret_b, pk_a);\n\n    assert_eq(shared_secret, shared_secret_alt);\n}\n"
    },
    "95": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/keys/ephemeral.nr",
      "source": "use std::embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul};\n\nuse dep::protocol_types::{point::Point, scalar::Scalar};\n\nuse crate::oracle::random::random;\n\npub fn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    // Safety: we use the randomness to preserve the privacy of both the sender and recipient via encryption, so a\n    // malicious sender could use non-random values to reveal the plaintext. But they already know it themselves anyway,\n    // and so the recipient already trusts them to not disclose this information. We can therefore assume that the\n    // sender will cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // TODO(#12757): compute the key pair without constraining eph_sk twice (once in from_field, once in the black box\n    // called by fixed_base_scalar_mul).\n    let eph_sk = EmbeddedCurveScalar::from_field(randomness);\n    let eph_pk = fixed_base_scalar_mul(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n"
    },
    "96": {
      "path": "/home/nerses/nargo/github.com/AztecProtocol/aztec-packages/v1.1.2/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    }
  }
}